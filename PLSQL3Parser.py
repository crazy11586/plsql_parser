# $ANTLR 3.4 ./output/PLSQL3.g 2011-12-29 17:19:46

import sys
from antlr3 import *
from antlr3.compat import set, frozenset

from antlr3.tree import *




# for convenience in actions
HIDDEN = BaseRecognizer.HIDDEN

# token types
EOF=-1
T__50=50
T__51=51
T__52=52
T__53=53
T__54=54
T__55=55
T__56=56
T__57=57
T__58=58
T__59=59
T__60=60
T__61=61
T__62=62
T__63=63
T__64=64
T__65=65
T__66=66
T__67=67
T__68=68
T__69=69
T__70=70
T__71=71
T__72=72
T__73=73
T__74=74
T__75=75
T__76=76
T__77=77
T__78=78
T__79=79
T__80=80
T__81=81
T__82=82
T__83=83
T__84=84
T__85=85
T__86=86
T__87=87
T__88=88
T__89=89
T__90=90
T__91=91
T__92=92
T__93=93
T__94=94
T__95=95
T__96=96
T__97=97
T__98=98
T__99=99
T__100=100
T__101=101
T__102=102
T__103=103
T__104=104
T__105=105
T__106=106
T__107=107
T__108=108
T__109=109
T__110=110
T__111=111
T__112=112
T__113=113
T__114=114
T__115=115
T__116=116
T__117=117
T__118=118
T__119=119
T__120=120
T__121=121
T__122=122
T__123=123
T__124=124
T__125=125
T__126=126
T__127=127
T__128=128
T__129=129
T__130=130
T__131=131
T__132=132
T__133=133
T__134=134
T__135=135
T__136=136
T__137=137
T__138=138
T__139=139
T__140=140
T__141=141
T__142=142
T__143=143
T__144=144
T__145=145
T__146=146
T__147=147
T__148=148
T__149=149
T__150=150
T__151=151
T__152=152
T__153=153
T__154=154
T__155=155
T__156=156
T__157=157
T__158=158
T__159=159
T__160=160
T__161=161
T__162=162
T__163=163
T__164=164
T__165=165
T__166=166
T__167=167
ARROW=4
ASSIGN=5
ASTERISK=6
AT_SIGN=7
BULK_ROWCOUNT_ATTR=8
CHARSET_ATTR=9
COLON=10
COMMA=11
DIVIDE=12
DOT=13
DOUBLEDOT=14
DOUBLEQUOTED_STRING=15
DOUBLEVERTBAR=16
EQ=17
EXPONENT=18
FOUND_ATTR=19
GEQ=20
GTH=21
ID=22
ISOPEN_ATTR=23
LBRACK=24
LEQ=25
LLABEL=26
LPAREN=27
LTH=28
MINUS=29
ML_COMMENT=30
N=31
NOTFOUND_ATTR=32
NOT_EQ=33
NUMBER=34
PERCENTAGE=35
PLUS=36
POINT=37
QUOTE=38
QUOTED_STRING=39
RBRACK=40
RLABEL=41
ROWCOUNT_ATTR=42
ROWTYPE_ATTR=43
RPAREN=44
SEMI=45
SL_COMMENT=46
TYPE_ATTR=47
VERTBAR=48
WS=49

# token names
tokenNames = [
    "<invalid>", "<EOR>", "<DOWN>", "<UP>",
    "ARROW", "ASSIGN", "ASTERISK", "AT_SIGN", "BULK_ROWCOUNT_ATTR", "CHARSET_ATTR",
    "COLON", "COMMA", "DIVIDE", "DOT", "DOUBLEDOT", "DOUBLEQUOTED_STRING",
    "DOUBLEVERTBAR", "EQ", "EXPONENT", "FOUND_ATTR", "GEQ", "GTH", "ID",
    "ISOPEN_ATTR", "LBRACK", "LEQ", "LLABEL", "LPAREN", "LTH", "MINUS",
    "ML_COMMENT", "N", "NOTFOUND_ATTR", "NOT_EQ", "NUMBER", "PERCENTAGE",
    "PLUS", "POINT", "QUOTE", "QUOTED_STRING", "RBRACK", "RLABEL", "ROWCOUNT_ATTR",
    "ROWTYPE_ATTR", "RPAREN", "SEMI", "SL_COMMENT", "TYPE_ATTR", "VERTBAR",
    "WS", "'ALL'", "'AND'", "'ANY'", "'AS'", "'ASC'", "'AT'", "'BEGIN'",
    "'BETWEEN'", "'BFILE'", "'BINARY_DOUBLE'", "'BINARY_FLOAT'", "'BINARY_INTEGER'",
    "'BLOB'", "'BOOLEAN'", "'BY'", "'CASE'", "'CHAR'", "'CHARACTER'", "'CLOB'",
    "'COMMENT'", "'COMMIT'", "'CONNECT'", "'CONSTANT'", "'CREATE'", "'DATE'",
    "'DEC'", "'DECIMAL'", "'DECLARE'", "'DEFAULT'", "'DELETE'", "'DESC'",
    "'DISTINCT'", "'DOUBLE'", "'ELSE'", "'ELSIF'", "'END'", "'EXCEPTION'",
    "'EXCLUSIVE'", "'EXISTS'", "'FALSE'", "'FETCH'", "'FLOAT'", "'FOR'",
    "'FROM'", "'FUNCTION'", "'GOTO'", "'GROUP'", "'HAVING'", "'IF'", "'IN'",
    "'INDEX'", "'INSERT'", "'INT'", "'INTEGER'", "'INTERSECT'", "'INTO'",
    "'IS'", "'LIKE'", "'LOCK'", "'LONG'", "'LOOP'", "'MINUS'", "'MLSLABEL'",
    "'MODE'", "'NATIONAL'", "'NATURAL'", "'NCHAR'", "'NCLOB'", "'NOT'",
    "'NOWAIT'", "'NULL'", "'NUMBER'", "'NUMERIC'", "'NVARCHAR'", "'NVARCHAR2'",
    "'OF'", "'ON'", "'OR'", "'ORDER'", "'OUT'", "'PACKAGE'", "'PLS_INTEGER'",
    "'POSITIVE'", "'PRAGMA'", "'PRIOR'", "'PROCEDURE'", "'RAISE'", "'RAW'",
    "'REAL'", "'RECORD'", "'RETURN'", "'RETURNING'", "'ROLLBACK'", "'ROW'",
    "'ROWID'", "'ROWS'", "'SAVEPOINT'", "'SELECT'", "'SET'", "'SHARE'",
    "'SMALLINT'", "'SQL'", "'START'", "'TABLE'", "'THEN'", "'TO'", "'TRUE'",
    "'UNION'", "'UNIQUE'", "'UPDATE'", "'UROWID'", "'VALUES'", "'VARCHAR'",
    "'VARCHAR2'", "'WHEN'", "'WHERE'", "'WHILE'", "'WITH'"
]




class PLSQL3Parser(Parser):
    grammarFileName = "./output/PLSQL3.g"
    api_version = 1
    tokenNames = tokenNames

    antlr_version = (3, 1, 3, 0)
    antlr_version_str = "3.1.3"

    def __init__(self, input, state=None, *args, **kwargs):
        if state is None:
            state = RecognizerSharedState()

        super(PLSQL3Parser, self).__init__(input, state, *args, **kwargs)

        self._state.ruleMemo = {}

        self.dfa10 = self.DFA10(
            self, 10,
            eot = self.DFA10_eot,
            eof = self.DFA10_eof,
            min = self.DFA10_min,
            max = self.DFA10_max,
            accept = self.DFA10_accept,
            special = self.DFA10_special,
            transition = self.DFA10_transition
            )

        self.dfa19 = self.DFA19(
            self, 19,
            eot = self.DFA19_eot,
            eof = self.DFA19_eof,
            min = self.DFA19_min,
            max = self.DFA19_max,
            accept = self.DFA19_accept,
            special = self.DFA19_special,
            transition = self.DFA19_transition
            )

        self.dfa29 = self.DFA29(
            self, 29,
            eot = self.DFA29_eot,
            eof = self.DFA29_eof,
            min = self.DFA29_min,
            max = self.DFA29_max,
            accept = self.DFA29_accept,
            special = self.DFA29_special,
            transition = self.DFA29_transition
            )

        self.dfa32 = self.DFA32(
            self, 32,
            eot = self.DFA32_eot,
            eof = self.DFA32_eof,
            min = self.DFA32_min,
            max = self.DFA32_max,
            accept = self.DFA32_accept,
            special = self.DFA32_special,
            transition = self.DFA32_transition
            )

        self.dfa125 = self.DFA125(
            self, 125,
            eot = self.DFA125_eot,
            eof = self.DFA125_eof,
            min = self.DFA125_min,
            max = self.DFA125_max,
            accept = self.DFA125_accept,
            special = self.DFA125_special,
            transition = self.DFA125_transition
            )

        self.dfa157 = self.DFA157(
            self, 157,
            eot = self.DFA157_eot,
            eof = self.DFA157_eof,
            min = self.DFA157_min,
            max = self.DFA157_max,
            accept = self.DFA157_accept,
            special = self.DFA157_special,
            transition = self.DFA157_transition
            )

        self.dfa166 = self.DFA166(
            self, 166,
            eot = self.DFA166_eot,
            eof = self.DFA166_eof,
            min = self.DFA166_min,
            max = self.DFA166_max,
            accept = self.DFA166_accept,
            special = self.DFA166_special,
            transition = self.DFA166_transition
            )




        self.delegates = []

	self._adaptor = None
	self.adaptor = CommonTreeAdaptor()



    def getTreeAdaptor(self):
        return self._adaptor

    def setTreeAdaptor(self, adaptor):
        self._adaptor = adaptor

    adaptor = property(getTreeAdaptor, setTreeAdaptor)


    is_sql = False


    class start_rule_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.start_rule_return, self).__init__()

            self.tree = None





    # $ANTLR start "start_rule"
    # ./output/PLSQL3.g:47:1: start_rule : ( create_package )* EOF ;
    def start_rule(self, ):
        retval = self.start_rule_return()
        retval.start = self.input.LT(1)

        start_rule_StartIndex = self.input.index()

        root_0 = None

        EOF2 = None
        create_package1 = None


        EOF2_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 1):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:48:2: ( ( create_package )* EOF )
                # ./output/PLSQL3.g:48:4: ( create_package )* EOF
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:48:4: ( create_package )*
                while True: #loop1
                    alt1 = 2
                    LA1_0 = self.input.LA(1)

                    if (LA1_0 == 73) :
                        alt1 = 1


                    if alt1 == 1:
                        # ./output/PLSQL3.g:48:5: create_package
                        pass
                        self._state.following.append(self.FOLLOW_create_package_in_start_rule50)
                        create_package1 = self.create_package()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, create_package1.tree)



                    else:
                        break #loop1


                EOF2 = self.match(self.input, EOF, self.FOLLOW_EOF_in_start_rule54)
                if self._state.backtracking == 0:
                    EOF2_tree = self._adaptor.createWithPayload(EOF2)
                    self._adaptor.addChild(root_0, EOF2_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 1, start_rule_StartIndex, success)


            pass
        return retval

    # $ANTLR end "start_rule"


    class create_package_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.create_package_return, self).__init__()

            self.tree = None





    # $ANTLR start "create_package"
    # ./output/PLSQL3.g:51:1: create_package : 'CREATE' ( 'OR' keyREPLACE )? ( package_spec | package_body ) ;
    def create_package(self, ):
        retval = self.create_package_return()
        retval.start = self.input.LT(1)

        create_package_StartIndex = self.input.index()

        root_0 = None

        string_literal3 = None
        string_literal4 = None
        keyREPLACE5 = None

        package_spec6 = None

        package_body7 = None


        string_literal3_tree = None
        string_literal4_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 2):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:52:2: ( 'CREATE' ( 'OR' keyREPLACE )? ( package_spec | package_body ) )
                # ./output/PLSQL3.g:52:4: 'CREATE' ( 'OR' keyREPLACE )? ( package_spec | package_body )
                pass
                root_0 = self._adaptor.nil()


                string_literal3 = self.match(self.input, 73, self.FOLLOW_73_in_create_package65)
                if self._state.backtracking == 0:
                    string_literal3_tree = self._adaptor.createWithPayload(string_literal3)
                    self._adaptor.addChild(root_0, string_literal3_tree)



                # ./output/PLSQL3.g:52:13: ( 'OR' keyREPLACE )?
                alt2 = 2
                LA2_0 = self.input.LA(1)

                if (LA2_0 == 127) :
                    alt2 = 1
                if alt2 == 1:
                    # ./output/PLSQL3.g:52:15: 'OR' keyREPLACE
                    pass
                    string_literal4 = self.match(self.input, 127, self.FOLLOW_127_in_create_package69)
                    if self._state.backtracking == 0:
                        string_literal4_tree = self._adaptor.createWithPayload(string_literal4)
                        self._adaptor.addChild(root_0, string_literal4_tree)



                    self._state.following.append(self.FOLLOW_keyREPLACE_in_create_package71)
                    keyREPLACE5 = self.keyREPLACE()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyREPLACE5.tree)





                # ./output/PLSQL3.g:53:3: ( package_spec | package_body )
                alt3 = 2
                LA3_0 = self.input.LA(1)

                if (LA3_0 == 130) :
                    LA3_1 = self.input.LA(2)

                    if (LA3_1 == ID) :
                        LA3_2 = self.input.LA(3)

                        if (LA3_2 == DOT or LA3_2 == 53 or LA3_2 == 106) :
                            alt3 = 1
                        elif (LA3_2 == DOUBLEQUOTED_STRING or LA3_2 == ID or LA3_2 == 144) :
                            alt3 = 2
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 3, 2, self.input)

                            raise nvae


                    elif (LA3_1 == DOUBLEQUOTED_STRING or LA3_1 == 144) :
                        alt3 = 1
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 3, 1, self.input)

                        raise nvae


                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 3, 0, self.input)

                    raise nvae


                if alt3 == 1:
                    # ./output/PLSQL3.g:53:5: package_spec
                    pass
                    self._state.following.append(self.FOLLOW_package_spec_in_create_package80)
                    package_spec6 = self.package_spec()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, package_spec6.tree)



                elif alt3 == 2:
                    # ./output/PLSQL3.g:53:20: package_body
                    pass
                    self._state.following.append(self.FOLLOW_package_body_in_create_package84)
                    package_body7 = self.package_body()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, package_body7.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 2, create_package_StartIndex, success)


            pass
        return retval

    # $ANTLR end "create_package"


    class package_spec_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.package_spec_return, self).__init__()

            self.tree = None





    # $ANTLR start "package_spec"
    # ./output/PLSQL3.g:56:1: package_spec : keyPACKAGE package_name ( 'IS' | 'AS' ) ( package_obj_spec )* 'END' ( package_name )? SEMI ;
    def package_spec(self, ):
        retval = self.package_spec_return()
        retval.start = self.input.LT(1)

        package_spec_StartIndex = self.input.index()

        root_0 = None

        set10 = None
        string_literal12 = None
        SEMI14 = None
        keyPACKAGE8 = None

        package_name9 = None

        package_obj_spec11 = None

        package_name13 = None


        set10_tree = None
        string_literal12_tree = None
        SEMI14_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 3):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:57:2: ( keyPACKAGE package_name ( 'IS' | 'AS' ) ( package_obj_spec )* 'END' ( package_name )? SEMI )
                # ./output/PLSQL3.g:57:4: keyPACKAGE package_name ( 'IS' | 'AS' ) ( package_obj_spec )* 'END' ( package_name )? SEMI
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyPACKAGE_in_package_spec98)
                keyPACKAGE8 = self.keyPACKAGE()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyPACKAGE8.tree)


                self._state.following.append(self.FOLLOW_package_name_in_package_spec100)
                package_name9 = self.package_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, package_name9.tree)


                set10 = self.input.LT(1)

                if self.input.LA(1) == 53 or self.input.LA(1) == 106:
                    self.input.consume()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set10))

                    self._state.errorRecovery = False


                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    mse = MismatchedSetException(None, self.input)
                    raise mse



                # ./output/PLSQL3.g:58:3: ( package_obj_spec )*
                while True: #loop4
                    alt4 = 2
                    LA4_0 = self.input.LA(1)

                    if (LA4_0 == DOUBLEQUOTED_STRING or LA4_0 == ID or LA4_0 == 94 or LA4_0 == 133 or LA4_0 == 135) :
                        alt4 = 1


                    if alt4 == 1:
                        # ./output/PLSQL3.g:58:5: package_obj_spec
                        pass
                        self._state.following.append(self.FOLLOW_package_obj_spec_in_package_spec117)
                        package_obj_spec11 = self.package_obj_spec()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, package_obj_spec11.tree)



                    else:
                        break #loop4


                string_literal12 = self.match(self.input, 85, self.FOLLOW_85_in_package_spec124)
                if self._state.backtracking == 0:
                    string_literal12_tree = self._adaptor.createWithPayload(string_literal12)
                    self._adaptor.addChild(root_0, string_literal12_tree)



                # ./output/PLSQL3.g:59:9: ( package_name )?
                alt5 = 2
                LA5_0 = self.input.LA(1)

                if (LA5_0 == DOUBLEQUOTED_STRING or LA5_0 == ID or LA5_0 == 144) :
                    alt5 = 1
                if alt5 == 1:
                    # ./output/PLSQL3.g:59:10: package_name
                    pass
                    self._state.following.append(self.FOLLOW_package_name_in_package_spec127)
                    package_name13 = self.package_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, package_name13.tree)





                SEMI14 = self.match(self.input, SEMI, self.FOLLOW_SEMI_in_package_spec131)
                if self._state.backtracking == 0:
                    SEMI14_tree = self._adaptor.createWithPayload(SEMI14)
                    self._adaptor.addChild(root_0, SEMI14_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 3, package_spec_StartIndex, success)


            pass
        return retval

    # $ANTLR end "package_spec"


    class package_body_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.package_body_return, self).__init__()

            self.tree = None





    # $ANTLR start "package_body"
    # ./output/PLSQL3.g:62:1: package_body : keyPACKAGE ( keyBODY ) package_name ( 'IS' | 'AS' ) ( package_obj_body )* ( 'BEGIN' seq_of_statements )? 'END' ( package_name )? SEMI ;
    def package_body(self, ):
        retval = self.package_body_return()
        retval.start = self.input.LT(1)

        package_body_StartIndex = self.input.index()

        root_0 = None

        set18 = None
        string_literal20 = None
        string_literal22 = None
        SEMI24 = None
        keyPACKAGE15 = None

        keyBODY16 = None

        package_name17 = None

        package_obj_body19 = None

        seq_of_statements21 = None

        package_name23 = None


        set18_tree = None
        string_literal20_tree = None
        string_literal22_tree = None
        SEMI24_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 4):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:63:2: ( keyPACKAGE ( keyBODY ) package_name ( 'IS' | 'AS' ) ( package_obj_body )* ( 'BEGIN' seq_of_statements )? 'END' ( package_name )? SEMI )
                # ./output/PLSQL3.g:63:4: keyPACKAGE ( keyBODY ) package_name ( 'IS' | 'AS' ) ( package_obj_body )* ( 'BEGIN' seq_of_statements )? 'END' ( package_name )? SEMI
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyPACKAGE_in_package_body143)
                keyPACKAGE15 = self.keyPACKAGE()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyPACKAGE15.tree)


                # ./output/PLSQL3.g:63:15: ( keyBODY )
                # ./output/PLSQL3.g:63:17: keyBODY
                pass
                self._state.following.append(self.FOLLOW_keyBODY_in_package_body147)
                keyBODY16 = self.keyBODY()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyBODY16.tree)





                self._state.following.append(self.FOLLOW_package_name_in_package_body151)
                package_name17 = self.package_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, package_name17.tree)


                set18 = self.input.LT(1)

                if self.input.LA(1) == 53 or self.input.LA(1) == 106:
                    self.input.consume()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set18))

                    self._state.errorRecovery = False


                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    mse = MismatchedSetException(None, self.input)
                    raise mse



                # ./output/PLSQL3.g:64:3: ( package_obj_body )*
                while True: #loop6
                    alt6 = 2
                    LA6_0 = self.input.LA(1)

                    if (LA6_0 == DOUBLEQUOTED_STRING or LA6_0 == ID or LA6_0 == 73 or LA6_0 == 94 or LA6_0 == 133 or LA6_0 == 135) :
                        alt6 = 1


                    if alt6 == 1:
                        # ./output/PLSQL3.g:64:5: package_obj_body
                        pass
                        self._state.following.append(self.FOLLOW_package_obj_body_in_package_body167)
                        package_obj_body19 = self.package_obj_body()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, package_obj_body19.tree)



                    else:
                        break #loop6


                # ./output/PLSQL3.g:65:3: ( 'BEGIN' seq_of_statements )?
                alt7 = 2
                LA7_0 = self.input.LA(1)

                if (LA7_0 == 56) :
                    alt7 = 1
                if alt7 == 1:
                    # ./output/PLSQL3.g:65:5: 'BEGIN' seq_of_statements
                    pass
                    string_literal20 = self.match(self.input, 56, self.FOLLOW_56_in_package_body176)
                    if self._state.backtracking == 0:
                        string_literal20_tree = self._adaptor.createWithPayload(string_literal20)
                        self._adaptor.addChild(root_0, string_literal20_tree)



                    self._state.following.append(self.FOLLOW_seq_of_statements_in_package_body178)
                    seq_of_statements21 = self.seq_of_statements()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, seq_of_statements21.tree)





                string_literal22 = self.match(self.input, 85, self.FOLLOW_85_in_package_body187)
                if self._state.backtracking == 0:
                    string_literal22_tree = self._adaptor.createWithPayload(string_literal22)
                    self._adaptor.addChild(root_0, string_literal22_tree)



                # ./output/PLSQL3.g:66:9: ( package_name )?
                alt8 = 2
                LA8_0 = self.input.LA(1)

                if (LA8_0 == DOUBLEQUOTED_STRING or LA8_0 == ID or LA8_0 == 144) :
                    alt8 = 1
                if alt8 == 1:
                    # ./output/PLSQL3.g:66:11: package_name
                    pass
                    self._state.following.append(self.FOLLOW_package_name_in_package_body191)
                    package_name23 = self.package_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, package_name23.tree)





                SEMI24 = self.match(self.input, SEMI, self.FOLLOW_SEMI_in_package_body196)
                if self._state.backtracking == 0:
                    SEMI24_tree = self._adaptor.createWithPayload(SEMI24)
                    self._adaptor.addChild(root_0, SEMI24_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 4, package_body_StartIndex, success)


            pass
        return retval

    # $ANTLR end "package_body"


    class package_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.package_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "package_name"
    # ./output/PLSQL3.g:69:1: package_name : ( schema_name DOT )? identifier ;
    def package_name(self, ):
        retval = self.package_name_return()
        retval.start = self.input.LT(1)

        package_name_StartIndex = self.input.index()

        root_0 = None

        DOT26 = None
        schema_name25 = None

        identifier27 = None


        DOT26_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 5):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:70:2: ( ( schema_name DOT )? identifier )
                # ./output/PLSQL3.g:70:4: ( schema_name DOT )? identifier
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:70:4: ( schema_name DOT )?
                alt9 = 2
                LA9_0 = self.input.LA(1)

                if (LA9_0 == DOUBLEQUOTED_STRING or LA9_0 == ID) :
                    LA9_1 = self.input.LA(2)

                    if (LA9_1 == DOT) :
                        alt9 = 1
                elif (LA9_0 == 144) :
                    alt9 = 1
                if alt9 == 1:
                    # ./output/PLSQL3.g:70:6: schema_name DOT
                    pass
                    self._state.following.append(self.FOLLOW_schema_name_in_package_name209)
                    schema_name25 = self.schema_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, schema_name25.tree)


                    DOT26 = self.match(self.input, DOT, self.FOLLOW_DOT_in_package_name211)
                    if self._state.backtracking == 0:
                        DOT26_tree = self._adaptor.createWithPayload(DOT26)
                        self._adaptor.addChild(root_0, DOT26_tree)






                self._state.following.append(self.FOLLOW_identifier_in_package_name216)
                identifier27 = self.identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, identifier27.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 5, package_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "package_name"


    class package_obj_spec_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.package_obj_spec_return, self).__init__()

            self.tree = None





    # $ANTLR start "package_obj_spec"
    # ./output/PLSQL3.g:73:1: package_obj_spec : ( variable_declaration | type_declaration | subtype_declaration | record_declaration | plsql_table_declaration | varray_declaration | cursor_declaration | cursor_spec | procedure_spec | function_spec | exception_declaration | pragma_declaration );
    def package_obj_spec(self, ):
        retval = self.package_obj_spec_return()
        retval.start = self.input.LT(1)

        package_obj_spec_StartIndex = self.input.index()

        root_0 = None

        variable_declaration28 = None

        type_declaration29 = None

        subtype_declaration30 = None

        record_declaration31 = None

        plsql_table_declaration32 = None

        varray_declaration33 = None

        cursor_declaration34 = None

        cursor_spec35 = None

        procedure_spec36 = None

        function_spec37 = None

        exception_declaration38 = None

        pragma_declaration39 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 6):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:74:2: ( variable_declaration | type_declaration | subtype_declaration | record_declaration | plsql_table_declaration | varray_declaration | cursor_declaration | cursor_spec | procedure_spec | function_spec | exception_declaration | pragma_declaration )
                alt10 = 12
                alt10 = self.dfa10.predict(self.input)
                if alt10 == 1:
                    # ./output/PLSQL3.g:74:4: variable_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_variable_declaration_in_package_obj_spec228)
                    variable_declaration28 = self.variable_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, variable_declaration28.tree)



                elif alt10 == 2:
                    # ./output/PLSQL3.g:75:4: type_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_type_declaration_in_package_obj_spec234)
                    type_declaration29 = self.type_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, type_declaration29.tree)



                elif alt10 == 3:
                    # ./output/PLSQL3.g:76:4: subtype_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_subtype_declaration_in_package_obj_spec239)
                    subtype_declaration30 = self.subtype_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, subtype_declaration30.tree)



                elif alt10 == 4:
                    # ./output/PLSQL3.g:77:4: record_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_record_declaration_in_package_obj_spec245)
                    record_declaration31 = self.record_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, record_declaration31.tree)



                elif alt10 == 5:
                    # ./output/PLSQL3.g:78:4: plsql_table_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_plsql_table_declaration_in_package_obj_spec251)
                    plsql_table_declaration32 = self.plsql_table_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, plsql_table_declaration32.tree)



                elif alt10 == 6:
                    # ./output/PLSQL3.g:79:4: varray_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_varray_declaration_in_package_obj_spec257)
                    varray_declaration33 = self.varray_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, varray_declaration33.tree)



                elif alt10 == 7:
                    # ./output/PLSQL3.g:80:4: cursor_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_cursor_declaration_in_package_obj_spec262)
                    cursor_declaration34 = self.cursor_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, cursor_declaration34.tree)



                elif alt10 == 8:
                    # ./output/PLSQL3.g:81:4: cursor_spec
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_cursor_spec_in_package_obj_spec268)
                    cursor_spec35 = self.cursor_spec()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, cursor_spec35.tree)



                elif alt10 == 9:
                    # ./output/PLSQL3.g:82:4: procedure_spec
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_procedure_spec_in_package_obj_spec274)
                    procedure_spec36 = self.procedure_spec()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, procedure_spec36.tree)



                elif alt10 == 10:
                    # ./output/PLSQL3.g:83:4: function_spec
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_function_spec_in_package_obj_spec280)
                    function_spec37 = self.function_spec()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, function_spec37.tree)



                elif alt10 == 11:
                    # ./output/PLSQL3.g:84:4: exception_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_exception_declaration_in_package_obj_spec286)
                    exception_declaration38 = self.exception_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, exception_declaration38.tree)



                elif alt10 == 12:
                    # ./output/PLSQL3.g:85:4: pragma_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_pragma_declaration_in_package_obj_spec292)
                    pragma_declaration39 = self.pragma_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, pragma_declaration39.tree)



                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 6, package_obj_spec_StartIndex, success)


            pass
        return retval

    # $ANTLR end "package_obj_spec"


    class variable_declaration_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.variable_declaration_return, self).__init__()

            self.tree = None





    # $ANTLR start "variable_declaration"
    # ./output/PLSQL3.g:88:1: variable_declaration : variable_name ( 'CONSTANT' )? type_spec ( 'NOT' 'NULL' )? ( ( ASSIGN | 'DEFAULT' ) plsql_expression )? SEMI ;
    def variable_declaration(self, ):
        retval = self.variable_declaration_return()
        retval.start = self.input.LT(1)

        variable_declaration_StartIndex = self.input.index()

        root_0 = None

        string_literal41 = None
        string_literal43 = None
        string_literal44 = None
        set45 = None
        SEMI47 = None
        variable_name40 = None

        type_spec42 = None

        plsql_expression46 = None


        string_literal41_tree = None
        string_literal43_tree = None
        string_literal44_tree = None
        set45_tree = None
        SEMI47_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 7):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:89:2: ( variable_name ( 'CONSTANT' )? type_spec ( 'NOT' 'NULL' )? ( ( ASSIGN | 'DEFAULT' ) plsql_expression )? SEMI )
                # ./output/PLSQL3.g:89:4: variable_name ( 'CONSTANT' )? type_spec ( 'NOT' 'NULL' )? ( ( ASSIGN | 'DEFAULT' ) plsql_expression )? SEMI
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_variable_name_in_variable_declaration303)
                variable_name40 = self.variable_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, variable_name40.tree)


                # ./output/PLSQL3.g:89:18: ( 'CONSTANT' )?
                alt11 = 2
                LA11_0 = self.input.LA(1)

                if (LA11_0 == 72) :
                    alt11 = 1
                if alt11 == 1:
                    # ./output/PLSQL3.g:89:19: 'CONSTANT'
                    pass
                    string_literal41 = self.match(self.input, 72, self.FOLLOW_72_in_variable_declaration306)
                    if self._state.backtracking == 0:
                        string_literal41_tree = self._adaptor.createWithPayload(string_literal41)
                        self._adaptor.addChild(root_0, string_literal41_tree)






                self._state.following.append(self.FOLLOW_type_spec_in_variable_declaration312)
                type_spec42 = self.type_spec()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, type_spec42.tree)


                # ./output/PLSQL3.g:90:13: ( 'NOT' 'NULL' )?
                alt12 = 2
                LA12_0 = self.input.LA(1)

                if (LA12_0 == 118) :
                    alt12 = 1
                if alt12 == 1:
                    # ./output/PLSQL3.g:90:14: 'NOT' 'NULL'
                    pass
                    string_literal43 = self.match(self.input, 118, self.FOLLOW_118_in_variable_declaration315)
                    if self._state.backtracking == 0:
                        string_literal43_tree = self._adaptor.createWithPayload(string_literal43)
                        self._adaptor.addChild(root_0, string_literal43_tree)



                    string_literal44 = self.match(self.input, 120, self.FOLLOW_120_in_variable_declaration317)
                    if self._state.backtracking == 0:
                        string_literal44_tree = self._adaptor.createWithPayload(string_literal44)
                        self._adaptor.addChild(root_0, string_literal44_tree)






                # ./output/PLSQL3.g:91:3: ( ( ASSIGN | 'DEFAULT' ) plsql_expression )?
                alt13 = 2
                LA13_0 = self.input.LA(1)

                if (LA13_0 == ASSIGN or LA13_0 == 78) :
                    alt13 = 1
                if alt13 == 1:
                    # ./output/PLSQL3.g:91:5: ( ASSIGN | 'DEFAULT' ) plsql_expression
                    pass
                    set45 = self.input.LT(1)

                    if self.input.LA(1) == ASSIGN or self.input.LA(1) == 78:
                        self.input.consume()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set45))

                        self._state.errorRecovery = False


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        mse = MismatchedSetException(None, self.input)
                        raise mse



                    self._state.following.append(self.FOLLOW_plsql_expression_in_variable_declaration336)
                    plsql_expression46 = self.plsql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, plsql_expression46.tree)





                SEMI47 = self.match(self.input, SEMI, self.FOLLOW_SEMI_in_variable_declaration340)
                if self._state.backtracking == 0:
                    SEMI47_tree = self._adaptor.createWithPayload(SEMI47)
                    self._adaptor.addChild(root_0, SEMI47_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 7, variable_declaration_StartIndex, success)


            pass
        return retval

    # $ANTLR end "variable_declaration"


    class type_declaration_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.type_declaration_return, self).__init__()

            self.tree = None





    # $ANTLR start "type_declaration"
    # ./output/PLSQL3.g:94:1: type_declaration : keyTYPE type_spec 'IS' ( keyNEW )? ( type_spec ( 'NOT' 'NULL' )? | LPAREN plsql_expressions RPAREN ) SEMI ;
    def type_declaration(self, ):
        retval = self.type_declaration_return()
        retval.start = self.input.LT(1)

        type_declaration_StartIndex = self.input.index()

        root_0 = None

        string_literal50 = None
        string_literal53 = None
        string_literal54 = None
        LPAREN55 = None
        RPAREN57 = None
        SEMI58 = None
        keyTYPE48 = None

        type_spec49 = None

        keyNEW51 = None

        type_spec52 = None

        plsql_expressions56 = None


        string_literal50_tree = None
        string_literal53_tree = None
        string_literal54_tree = None
        LPAREN55_tree = None
        RPAREN57_tree = None
        SEMI58_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 8):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:95:2: ( keyTYPE type_spec 'IS' ( keyNEW )? ( type_spec ( 'NOT' 'NULL' )? | LPAREN plsql_expressions RPAREN ) SEMI )
                # ./output/PLSQL3.g:95:4: keyTYPE type_spec 'IS' ( keyNEW )? ( type_spec ( 'NOT' 'NULL' )? | LPAREN plsql_expressions RPAREN ) SEMI
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyTYPE_in_type_declaration353)
                keyTYPE48 = self.keyTYPE()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyTYPE48.tree)


                self._state.following.append(self.FOLLOW_type_spec_in_type_declaration355)
                type_spec49 = self.type_spec()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, type_spec49.tree)


                string_literal50 = self.match(self.input, 106, self.FOLLOW_106_in_type_declaration357)
                if self._state.backtracking == 0:
                    string_literal50_tree = self._adaptor.createWithPayload(string_literal50)
                    self._adaptor.addChild(root_0, string_literal50_tree)



                # ./output/PLSQL3.g:95:27: ( keyNEW )?
                alt14 = 2
                LA14_0 = self.input.LA(1)

                if (LA14_0 == ID) :
                    LA14 = self.input.LA(2)
                    if LA14 == DOUBLEQUOTED_STRING or LA14 == 58 or LA14 == 59 or LA14 == 60 or LA14 == 61 or LA14 == 62 or LA14 == 63 or LA14 == 66 or LA14 == 67 or LA14 == 68 or LA14 == 74 or LA14 == 75 or LA14 == 76 or LA14 == 82 or LA14 == 91 or LA14 == 102 or LA14 == 103 or LA14 == 109 or LA14 == 112 or LA14 == 114 or LA14 == 115 or LA14 == 116 or LA14 == 117 or LA14 == 121 or LA14 == 122 or LA14 == 123 or LA14 == 124 or LA14 == 131 or LA14 == 132 or LA14 == 137 or LA14 == 138 or LA14 == 144 or LA14 == 150 or LA14 == 160 or LA14 == 162 or LA14 == 163:
                        alt14 = 1
                    elif LA14 == ID:
                        LA14_4 = self.input.LA(3)

                        if (LA14_4 == AT_SIGN or LA14_4 == DOT or LA14_4 == ID or LA14_4 == ROWTYPE_ATTR or LA14_4 == SEMI or LA14_4 == TYPE_ATTR or LA14_4 == 118 or LA14_4 == 167) :
                            alt14 = 1
                        elif (LA14_4 == LPAREN) :
                            LA14_6 = self.input.LA(4)

                            if (LA14_6 == NUMBER) :
                                LA14_8 = self.input.LA(5)

                                if (LA14_8 == RPAREN) :
                                    LA14_10 = self.input.LA(6)

                                    if (LA14_10 == SEMI or LA14_10 == 118 or LA14_10 == 167) :
                                        alt14 = 1
                    elif LA14 == LPAREN:
                        LA14_5 = self.input.LA(3)

                        if (LA14_5 == NUMBER) :
                            LA14_7 = self.input.LA(4)

                            if (LA14_7 == RPAREN) :
                                LA14_9 = self.input.LA(5)

                                if (((((self.synpred27_PLSQL3()) and (self.synpred27_PLSQL3()))) and (((self.input).LT(1).text.upper() == "NEW")))) :
                                    alt14 = 1
                            elif (LA14_7 == ASTERISK or LA14_7 == BULK_ROWCOUNT_ATTR or (COMMA <= LA14_7 <= DIVIDE) or (DOUBLEVERTBAR <= LA14_7 <= GTH) or LA14_7 == ISOPEN_ATTR or LA14_7 == LEQ or (LTH <= LA14_7 <= MINUS) or (NOTFOUND_ATTR <= LA14_7 <= NOT_EQ) or LA14_7 == PLUS or LA14_7 == ROWCOUNT_ATTR or LA14_7 == 51 or LA14_7 == 57 or LA14_7 == 99 or (106 <= LA14_7 <= 107) or LA14_7 == 118 or LA14_7 == 127) :
                                alt14 = 1
                        elif (LA14_5 == DOUBLEQUOTED_STRING or LA14_5 == ID or LA14_5 == LPAREN or LA14_5 == MINUS or LA14_5 == PLUS or LA14_5 == QUOTED_STRING or LA14_5 == 65 or LA14_5 == 81 or LA14_5 == 89 or LA14_5 == 118 or LA14_5 == 120 or LA14_5 == 144 or LA14_5 == 147 or LA14_5 == 151 or LA14_5 == 156) :
                            alt14 = 1
                if alt14 == 1:
                    # ./output/PLSQL3.g:95:29: keyNEW
                    pass
                    self._state.following.append(self.FOLLOW_keyNEW_in_type_declaration361)
                    keyNEW51 = self.keyNEW()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyNEW51.tree)





                # ./output/PLSQL3.g:95:39: ( type_spec ( 'NOT' 'NULL' )? | LPAREN plsql_expressions RPAREN )
                alt16 = 2
                LA16_0 = self.input.LA(1)

                if (LA16_0 == DOUBLEQUOTED_STRING or LA16_0 == ID or (58 <= LA16_0 <= 63) or (66 <= LA16_0 <= 68) or (74 <= LA16_0 <= 76) or LA16_0 == 82 or LA16_0 == 91 or (102 <= LA16_0 <= 103) or LA16_0 == 109 or LA16_0 == 112 or (114 <= LA16_0 <= 117) or (121 <= LA16_0 <= 124) or (131 <= LA16_0 <= 132) or (137 <= LA16_0 <= 138) or LA16_0 == 144 or LA16_0 == 150 or LA16_0 == 160 or (162 <= LA16_0 <= 163)) :
                    alt16 = 1
                elif (LA16_0 == LPAREN) :
                    alt16 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 16, 0, self.input)

                    raise nvae


                if alt16 == 1:
                    # ./output/PLSQL3.g:95:41: type_spec ( 'NOT' 'NULL' )?
                    pass
                    self._state.following.append(self.FOLLOW_type_spec_in_type_declaration368)
                    type_spec52 = self.type_spec()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, type_spec52.tree)


                    # ./output/PLSQL3.g:95:51: ( 'NOT' 'NULL' )?
                    alt15 = 2
                    LA15_0 = self.input.LA(1)

                    if (LA15_0 == 118) :
                        alt15 = 1
                    if alt15 == 1:
                        # ./output/PLSQL3.g:95:53: 'NOT' 'NULL'
                        pass
                        string_literal53 = self.match(self.input, 118, self.FOLLOW_118_in_type_declaration372)
                        if self._state.backtracking == 0:
                            string_literal53_tree = self._adaptor.createWithPayload(string_literal53)
                            self._adaptor.addChild(root_0, string_literal53_tree)



                        string_literal54 = self.match(self.input, 120, self.FOLLOW_120_in_type_declaration374)
                        if self._state.backtracking == 0:
                            string_literal54_tree = self._adaptor.createWithPayload(string_literal54)
                            self._adaptor.addChild(root_0, string_literal54_tree)







                elif alt16 == 2:
                    # ./output/PLSQL3.g:95:71: LPAREN plsql_expressions RPAREN
                    pass
                    LPAREN55 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_type_declaration381)
                    if self._state.backtracking == 0:
                        LPAREN55_tree = self._adaptor.createWithPayload(LPAREN55)
                        self._adaptor.addChild(root_0, LPAREN55_tree)



                    self._state.following.append(self.FOLLOW_plsql_expressions_in_type_declaration383)
                    plsql_expressions56 = self.plsql_expressions()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, plsql_expressions56.tree)


                    RPAREN57 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_type_declaration385)
                    if self._state.backtracking == 0:
                        RPAREN57_tree = self._adaptor.createWithPayload(RPAREN57)
                        self._adaptor.addChild(root_0, RPAREN57_tree)






                SEMI58 = self.match(self.input, SEMI, self.FOLLOW_SEMI_in_type_declaration389)
                if self._state.backtracking == 0:
                    SEMI58_tree = self._adaptor.createWithPayload(SEMI58)
                    self._adaptor.addChild(root_0, SEMI58_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 8, type_declaration_StartIndex, success)


            pass
        return retval

    # $ANTLR end "type_declaration"


    class subtype_declaration_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.subtype_declaration_return, self).__init__()

            self.tree = None





    # $ANTLR start "subtype_declaration"
    # ./output/PLSQL3.g:98:1: subtype_declaration : keySUBTYPE type_spec 'IS' type_spec ( 'NOT' 'NULL' | keyRANGE literal DOUBLEDOT literal )? SEMI ;
    def subtype_declaration(self, ):
        retval = self.subtype_declaration_return()
        retval.start = self.input.LT(1)

        subtype_declaration_StartIndex = self.input.index()

        root_0 = None

        string_literal61 = None
        string_literal63 = None
        string_literal64 = None
        DOUBLEDOT67 = None
        SEMI69 = None
        keySUBTYPE59 = None

        type_spec60 = None

        type_spec62 = None

        keyRANGE65 = None

        literal66 = None

        literal68 = None


        string_literal61_tree = None
        string_literal63_tree = None
        string_literal64_tree = None
        DOUBLEDOT67_tree = None
        SEMI69_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 9):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:99:2: ( keySUBTYPE type_spec 'IS' type_spec ( 'NOT' 'NULL' | keyRANGE literal DOUBLEDOT literal )? SEMI )
                # ./output/PLSQL3.g:99:4: keySUBTYPE type_spec 'IS' type_spec ( 'NOT' 'NULL' | keyRANGE literal DOUBLEDOT literal )? SEMI
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keySUBTYPE_in_subtype_declaration402)
                keySUBTYPE59 = self.keySUBTYPE()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keySUBTYPE59.tree)


                self._state.following.append(self.FOLLOW_type_spec_in_subtype_declaration404)
                type_spec60 = self.type_spec()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, type_spec60.tree)


                string_literal61 = self.match(self.input, 106, self.FOLLOW_106_in_subtype_declaration406)
                if self._state.backtracking == 0:
                    string_literal61_tree = self._adaptor.createWithPayload(string_literal61)
                    self._adaptor.addChild(root_0, string_literal61_tree)



                self._state.following.append(self.FOLLOW_type_spec_in_subtype_declaration408)
                type_spec62 = self.type_spec()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, type_spec62.tree)


                # ./output/PLSQL3.g:99:40: ( 'NOT' 'NULL' | keyRANGE literal DOUBLEDOT literal )?
                alt17 = 3
                LA17_0 = self.input.LA(1)

                if (LA17_0 == 118) :
                    alt17 = 1
                elif (LA17_0 == ID) :
                    alt17 = 2
                if alt17 == 1:
                    # ./output/PLSQL3.g:99:42: 'NOT' 'NULL'
                    pass
                    string_literal63 = self.match(self.input, 118, self.FOLLOW_118_in_subtype_declaration412)
                    if self._state.backtracking == 0:
                        string_literal63_tree = self._adaptor.createWithPayload(string_literal63)
                        self._adaptor.addChild(root_0, string_literal63_tree)



                    string_literal64 = self.match(self.input, 120, self.FOLLOW_120_in_subtype_declaration414)
                    if self._state.backtracking == 0:
                        string_literal64_tree = self._adaptor.createWithPayload(string_literal64)
                        self._adaptor.addChild(root_0, string_literal64_tree)




                elif alt17 == 2:
                    # ./output/PLSQL3.g:99:57: keyRANGE literal DOUBLEDOT literal
                    pass
                    self._state.following.append(self.FOLLOW_keyRANGE_in_subtype_declaration418)
                    keyRANGE65 = self.keyRANGE()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyRANGE65.tree)


                    self._state.following.append(self.FOLLOW_literal_in_subtype_declaration420)
                    literal66 = self.literal()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, literal66.tree)


                    DOUBLEDOT67 = self.match(self.input, DOUBLEDOT, self.FOLLOW_DOUBLEDOT_in_subtype_declaration422)
                    if self._state.backtracking == 0:
                        DOUBLEDOT67_tree = self._adaptor.createWithPayload(DOUBLEDOT67)
                        self._adaptor.addChild(root_0, DOUBLEDOT67_tree)



                    self._state.following.append(self.FOLLOW_literal_in_subtype_declaration424)
                    literal68 = self.literal()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, literal68.tree)





                SEMI69 = self.match(self.input, SEMI, self.FOLLOW_SEMI_in_subtype_declaration429)
                if self._state.backtracking == 0:
                    SEMI69_tree = self._adaptor.createWithPayload(SEMI69)
                    self._adaptor.addChild(root_0, SEMI69_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 9, subtype_declaration_StartIndex, success)


            pass
        return retval

    # $ANTLR end "subtype_declaration"


    class cursor_declaration_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.cursor_declaration_return, self).__init__()

            self.tree = None





    # $ANTLR start "cursor_declaration"
    # ./output/PLSQL3.g:102:1: cursor_declaration : keyCURSOR cursor_name ( LPAREN parameter_specs RPAREN )? 'IS' select_command SEMI ;
    def cursor_declaration(self, ):
        retval = self.cursor_declaration_return()
        retval.start = self.input.LT(1)

        cursor_declaration_StartIndex = self.input.index()

        root_0 = None

        LPAREN72 = None
        RPAREN74 = None
        string_literal75 = None
        SEMI77 = None
        keyCURSOR70 = None

        cursor_name71 = None

        parameter_specs73 = None

        select_command76 = None


        LPAREN72_tree = None
        RPAREN74_tree = None
        string_literal75_tree = None
        SEMI77_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 10):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:103:2: ( keyCURSOR cursor_name ( LPAREN parameter_specs RPAREN )? 'IS' select_command SEMI )
                # ./output/PLSQL3.g:103:4: keyCURSOR cursor_name ( LPAREN parameter_specs RPAREN )? 'IS' select_command SEMI
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyCURSOR_in_cursor_declaration442)
                keyCURSOR70 = self.keyCURSOR()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyCURSOR70.tree)


                self._state.following.append(self.FOLLOW_cursor_name_in_cursor_declaration444)
                cursor_name71 = self.cursor_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, cursor_name71.tree)


                # ./output/PLSQL3.g:104:3: ( LPAREN parameter_specs RPAREN )?
                alt18 = 2
                LA18_0 = self.input.LA(1)

                if (LA18_0 == LPAREN) :
                    alt18 = 1
                if alt18 == 1:
                    # ./output/PLSQL3.g:104:5: LPAREN parameter_specs RPAREN
                    pass
                    LPAREN72 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_cursor_declaration450)
                    if self._state.backtracking == 0:
                        LPAREN72_tree = self._adaptor.createWithPayload(LPAREN72)
                        self._adaptor.addChild(root_0, LPAREN72_tree)



                    self._state.following.append(self.FOLLOW_parameter_specs_in_cursor_declaration452)
                    parameter_specs73 = self.parameter_specs()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, parameter_specs73.tree)


                    RPAREN74 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_cursor_declaration454)
                    if self._state.backtracking == 0:
                        RPAREN74_tree = self._adaptor.createWithPayload(RPAREN74)
                        self._adaptor.addChild(root_0, RPAREN74_tree)






                string_literal75 = self.match(self.input, 106, self.FOLLOW_106_in_cursor_declaration461)
                if self._state.backtracking == 0:
                    string_literal75_tree = self._adaptor.createWithPayload(string_literal75)
                    self._adaptor.addChild(root_0, string_literal75_tree)



                self._state.following.append(self.FOLLOW_select_command_in_cursor_declaration463)
                select_command76 = self.select_command()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, select_command76.tree)


                SEMI77 = self.match(self.input, SEMI, self.FOLLOW_SEMI_in_cursor_declaration465)
                if self._state.backtracking == 0:
                    SEMI77_tree = self._adaptor.createWithPayload(SEMI77)
                    self._adaptor.addChild(root_0, SEMI77_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 10, cursor_declaration_StartIndex, success)


            pass
        return retval

    # $ANTLR end "cursor_declaration"


    class package_obj_body_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.package_obj_body_return, self).__init__()

            self.tree = None





    # $ANTLR start "package_obj_body"
    # ./output/PLSQL3.g:107:1: package_obj_body : ( variable_declaration | subtype_declaration | cursor_declaration | exception_declaration | record_declaration | plsql_table_declaration | varray_declaration | procedure_body | function_body | pragma_declaration );
    def package_obj_body(self, ):
        retval = self.package_obj_body_return()
        retval.start = self.input.LT(1)

        package_obj_body_StartIndex = self.input.index()

        root_0 = None

        variable_declaration78 = None

        subtype_declaration79 = None

        cursor_declaration80 = None

        exception_declaration81 = None

        record_declaration82 = None

        plsql_table_declaration83 = None

        varray_declaration84 = None

        procedure_body85 = None

        function_body86 = None

        pragma_declaration87 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 11):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:108:2: ( variable_declaration | subtype_declaration | cursor_declaration | exception_declaration | record_declaration | plsql_table_declaration | varray_declaration | procedure_body | function_body | pragma_declaration )
                alt19 = 10
                alt19 = self.dfa19.predict(self.input)
                if alt19 == 1:
                    # ./output/PLSQL3.g:108:4: variable_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_variable_declaration_in_package_obj_body475)
                    variable_declaration78 = self.variable_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, variable_declaration78.tree)



                elif alt19 == 2:
                    # ./output/PLSQL3.g:109:4: subtype_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_subtype_declaration_in_package_obj_body481)
                    subtype_declaration79 = self.subtype_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, subtype_declaration79.tree)



                elif alt19 == 3:
                    # ./output/PLSQL3.g:110:4: cursor_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_cursor_declaration_in_package_obj_body487)
                    cursor_declaration80 = self.cursor_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, cursor_declaration80.tree)



                elif alt19 == 4:
                    # ./output/PLSQL3.g:111:4: exception_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_exception_declaration_in_package_obj_body493)
                    exception_declaration81 = self.exception_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, exception_declaration81.tree)



                elif alt19 == 5:
                    # ./output/PLSQL3.g:112:4: record_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_record_declaration_in_package_obj_body499)
                    record_declaration82 = self.record_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, record_declaration82.tree)



                elif alt19 == 6:
                    # ./output/PLSQL3.g:113:4: plsql_table_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_plsql_table_declaration_in_package_obj_body505)
                    plsql_table_declaration83 = self.plsql_table_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, plsql_table_declaration83.tree)



                elif alt19 == 7:
                    # ./output/PLSQL3.g:114:4: varray_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_varray_declaration_in_package_obj_body511)
                    varray_declaration84 = self.varray_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, varray_declaration84.tree)



                elif alt19 == 8:
                    # ./output/PLSQL3.g:115:4: procedure_body
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_procedure_body_in_package_obj_body516)
                    procedure_body85 = self.procedure_body()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, procedure_body85.tree)



                elif alt19 == 9:
                    # ./output/PLSQL3.g:116:4: function_body
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_function_body_in_package_obj_body522)
                    function_body86 = self.function_body()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, function_body86.tree)



                elif alt19 == 10:
                    # ./output/PLSQL3.g:117:4: pragma_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_pragma_declaration_in_package_obj_body528)
                    pragma_declaration87 = self.pragma_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, pragma_declaration87.tree)



                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 11, package_obj_body_StartIndex, success)


            pass
        return retval

    # $ANTLR end "package_obj_body"


    class seq_of_statements_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.seq_of_statements_return, self).__init__()

            self.tree = None





    # $ANTLR start "seq_of_statements"
    # ./output/PLSQL3.g:120:1: seq_of_statements : statement SEMI ( statement SEMI )* ;
    def seq_of_statements(self, ):
        retval = self.seq_of_statements_return()
        retval.start = self.input.LT(1)

        seq_of_statements_StartIndex = self.input.index()

        root_0 = None

        SEMI89 = None
        SEMI91 = None
        statement88 = None

        statement90 = None


        SEMI89_tree = None
        SEMI91_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 12):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:121:2: ( statement SEMI ( statement SEMI )* )
                # ./output/PLSQL3.g:121:4: statement SEMI ( statement SEMI )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_statement_in_seq_of_statements539)
                statement88 = self.statement()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, statement88.tree)


                SEMI89 = self.match(self.input, SEMI, self.FOLLOW_SEMI_in_seq_of_statements541)
                if self._state.backtracking == 0:
                    SEMI89_tree = self._adaptor.createWithPayload(SEMI89)
                    self._adaptor.addChild(root_0, SEMI89_tree)



                # ./output/PLSQL3.g:121:19: ( statement SEMI )*
                while True: #loop20
                    alt20 = 2
                    LA20_0 = self.input.LA(1)

                    if (LA20_0 == COLON or LA20_0 == DOUBLEQUOTED_STRING or LA20_0 == ID or LA20_0 == LLABEL or LA20_0 == 56 or LA20_0 == 65 or LA20_0 == 70 or LA20_0 == 73 or LA20_0 == 77 or LA20_0 == 79 or LA20_0 == 90 or LA20_0 == 92 or (94 <= LA20_0 <= 95) or LA20_0 == 98 or LA20_0 == 101 or LA20_0 == 108 or LA20_0 == 110 or LA20_0 == 120 or LA20_0 == 133 or (135 <= LA20_0 <= 136) or LA20_0 == 140 or LA20_0 == 142 or LA20_0 == 144 or (146 <= LA20_0 <= 148) or LA20_0 == 159 or LA20_0 == 166) :
                        alt20 = 1


                    if alt20 == 1:
                        # ./output/PLSQL3.g:121:21: statement SEMI
                        pass
                        self._state.following.append(self.FOLLOW_statement_in_seq_of_statements545)
                        statement90 = self.statement()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, statement90.tree)


                        SEMI91 = self.match(self.input, SEMI, self.FOLLOW_SEMI_in_seq_of_statements547)
                        if self._state.backtracking == 0:
                            SEMI91_tree = self._adaptor.createWithPayload(SEMI91)
                            self._adaptor.addChild(root_0, SEMI91_tree)




                    else:
                        break #loop20




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 12, seq_of_statements_StartIndex, success)


            pass
        return retval

    # $ANTLR end "seq_of_statements"


    class statement_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.statement_return, self).__init__()

            self.tree = None





    # $ANTLR start "statement"
    # ./output/PLSQL3.g:124:1: statement : ( assignment_statement | exit_statement | goto_statement | case_statement | if_statement | loop_statement | null_statement | raise_statement | return_statement | sql_statement | plsql_block | function_call );
    def statement(self, ):
        retval = self.statement_return()
        retval.start = self.input.LT(1)

        statement_StartIndex = self.input.index()

        root_0 = None

        assignment_statement92 = None

        exit_statement93 = None

        goto_statement94 = None

        case_statement95 = None

        if_statement96 = None

        loop_statement97 = None

        null_statement98 = None

        raise_statement99 = None

        return_statement100 = None

        sql_statement101 = None

        plsql_block102 = None

        function_call103 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 13):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:125:2: ( assignment_statement | exit_statement | goto_statement | case_statement | if_statement | loop_statement | null_statement | raise_statement | return_statement | sql_statement | plsql_block | function_call )
                alt21 = 12
                LA21 = self.input.LA(1)
                if LA21 == ID:
                    LA21_1 = self.input.LA(2)

                    if (self.synpred43_PLSQL3()) :
                        alt21 = 1
                    elif (((((((self.input).LT(1).text.upper() == "EXIT")) and (((this.input).LT(1).text.upper() == "EXIT")))) and (self.synpred44_PLSQL3()))) :
                        alt21 = 2
                    elif (self.synpred46_PLSQL3()) :
                        alt21 = 4
                    elif (((((self.synpred52_PLSQL3()) and (self.synpred52_PLSQL3()))) and ((((self.input).LT(1).text.upper() == "OPEN") or ((this.input).LT(1).text.upper() == "CLOSE"))))) :
                        alt21 = 10
                    elif (self.synpred53_PLSQL3()) :
                        alt21 = 11
                    elif (True) :
                        alt21 = 12
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 21, 1, self.input)

                        raise nvae


                elif LA21 == COLON:
                    alt21 = 1
                elif LA21 == DOUBLEQUOTED_STRING:
                    LA21_3 = self.input.LA(2)

                    if (self.synpred43_PLSQL3()) :
                        alt21 = 1
                    elif (self.synpred46_PLSQL3()) :
                        alt21 = 4
                    elif (self.synpred53_PLSQL3()) :
                        alt21 = 11
                    elif (True) :
                        alt21 = 12
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 21, 3, self.input)

                        raise nvae


                elif LA21 == 95:
                    alt21 = 3
                elif LA21 == 65:
                    alt21 = 4
                elif LA21 == 98:
                    alt21 = 5
                elif LA21 == LLABEL:
                    LA21_7 = self.input.LA(2)

                    if (self.synpred48_PLSQL3()) :
                        alt21 = 6
                    elif (self.synpred53_PLSQL3()) :
                        alt21 = 11
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 21, 7, self.input)

                        raise nvae


                elif LA21 == 92 or LA21 == 110 or LA21 == 166:
                    alt21 = 6
                elif LA21 == 120:
                    alt21 = 7
                elif LA21 == 136:
                    alt21 = 8
                elif LA21 == 140:
                    alt21 = 9
                elif LA21 == 70 or LA21 == 79 or LA21 == 90 or LA21 == 101 or LA21 == 108 or LA21 == 142 or LA21 == 146 or LA21 == 147 or LA21 == 148 or LA21 == 159:
                    alt21 = 10
                elif LA21 == 56 or LA21 == 73 or LA21 == 77 or LA21 == 94 or LA21 == 133 or LA21 == 135:
                    alt21 = 11
                elif LA21 == 144:
                    alt21 = 12
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 21, 0, self.input)

                    raise nvae


                if alt21 == 1:
                    # ./output/PLSQL3.g:125:4: assignment_statement
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_assignment_statement_in_statement562)
                    assignment_statement92 = self.assignment_statement()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, assignment_statement92.tree)



                elif alt21 == 2:
                    # ./output/PLSQL3.g:126:4: exit_statement
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_exit_statement_in_statement567)
                    exit_statement93 = self.exit_statement()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, exit_statement93.tree)



                elif alt21 == 3:
                    # ./output/PLSQL3.g:127:4: goto_statement
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_goto_statement_in_statement572)
                    goto_statement94 = self.goto_statement()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, goto_statement94.tree)



                elif alt21 == 4:
                    # ./output/PLSQL3.g:128:4: case_statement
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_case_statement_in_statement577)
                    case_statement95 = self.case_statement()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, case_statement95.tree)



                elif alt21 == 5:
                    # ./output/PLSQL3.g:129:4: if_statement
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_if_statement_in_statement582)
                    if_statement96 = self.if_statement()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, if_statement96.tree)



                elif alt21 == 6:
                    # ./output/PLSQL3.g:130:4: loop_statement
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_loop_statement_in_statement588)
                    loop_statement97 = self.loop_statement()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, loop_statement97.tree)



                elif alt21 == 7:
                    # ./output/PLSQL3.g:131:4: null_statement
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_null_statement_in_statement594)
                    null_statement98 = self.null_statement()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, null_statement98.tree)



                elif alt21 == 8:
                    # ./output/PLSQL3.g:132:4: raise_statement
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_raise_statement_in_statement599)
                    raise_statement99 = self.raise_statement()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, raise_statement99.tree)



                elif alt21 == 9:
                    # ./output/PLSQL3.g:133:4: return_statement
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_return_statement_in_statement604)
                    return_statement100 = self.return_statement()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, return_statement100.tree)



                elif alt21 == 10:
                    # ./output/PLSQL3.g:134:4: sql_statement
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_sql_statement_in_statement609)
                    sql_statement101 = self.sql_statement()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_statement101.tree)



                elif alt21 == 11:
                    # ./output/PLSQL3.g:135:4: plsql_block
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_plsql_block_in_statement614)
                    plsql_block102 = self.plsql_block()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, plsql_block102.tree)



                elif alt21 == 12:
                    # ./output/PLSQL3.g:137:4: function_call
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_function_call_in_statement620)
                    function_call103 = self.function_call()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, function_call103.tree)



                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 13, statement_StartIndex, success)


            pass
        return retval

    # $ANTLR end "statement"


    class plsql_block_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.plsql_block_return, self).__init__()

            self.tree = None





    # $ANTLR start "plsql_block"
    # ./output/PLSQL3.g:140:1: plsql_block : ( LLABEL label_name RLABEL )? ( ( 'DECLARE' )? ( declare_spec )+ )? ( 'BEGIN' ) seq_of_statements ( 'EXCEPTION' ( exception_handler )+ )? ( 'END' ( label_name )? ) ;
    def plsql_block(self, ):
        retval = self.plsql_block_return()
        retval.start = self.input.LT(1)

        plsql_block_StartIndex = self.input.index()

        root_0 = None

        LLABEL104 = None
        RLABEL106 = None
        string_literal107 = None
        string_literal109 = None
        string_literal111 = None
        string_literal113 = None
        label_name105 = None

        declare_spec108 = None

        seq_of_statements110 = None

        exception_handler112 = None

        label_name114 = None


        LLABEL104_tree = None
        RLABEL106_tree = None
        string_literal107_tree = None
        string_literal109_tree = None
        string_literal111_tree = None
        string_literal113_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 14):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:141:2: ( ( LLABEL label_name RLABEL )? ( ( 'DECLARE' )? ( declare_spec )+ )? ( 'BEGIN' ) seq_of_statements ( 'EXCEPTION' ( exception_handler )+ )? ( 'END' ( label_name )? ) )
                # ./output/PLSQL3.g:141:4: ( LLABEL label_name RLABEL )? ( ( 'DECLARE' )? ( declare_spec )+ )? ( 'BEGIN' ) seq_of_statements ( 'EXCEPTION' ( exception_handler )+ )? ( 'END' ( label_name )? )
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:141:4: ( LLABEL label_name RLABEL )?
                alt22 = 2
                LA22_0 = self.input.LA(1)

                if (LA22_0 == LLABEL) :
                    alt22 = 1
                if alt22 == 1:
                    # ./output/PLSQL3.g:141:6: LLABEL label_name RLABEL
                    pass
                    LLABEL104 = self.match(self.input, LLABEL, self.FOLLOW_LLABEL_in_plsql_block635)
                    if self._state.backtracking == 0:
                        LLABEL104_tree = self._adaptor.createWithPayload(LLABEL104)
                        self._adaptor.addChild(root_0, LLABEL104_tree)



                    self._state.following.append(self.FOLLOW_label_name_in_plsql_block637)
                    label_name105 = self.label_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, label_name105.tree)


                    RLABEL106 = self.match(self.input, RLABEL, self.FOLLOW_RLABEL_in_plsql_block639)
                    if self._state.backtracking == 0:
                        RLABEL106_tree = self._adaptor.createWithPayload(RLABEL106)
                        self._adaptor.addChild(root_0, RLABEL106_tree)






                # ./output/PLSQL3.g:142:3: ( ( 'DECLARE' )? ( declare_spec )+ )?
                alt25 = 2
                LA25_0 = self.input.LA(1)

                if (LA25_0 == DOUBLEQUOTED_STRING or LA25_0 == ID or LA25_0 == 73 or LA25_0 == 77 or LA25_0 == 94 or LA25_0 == 133 or LA25_0 == 135) :
                    alt25 = 1
                if alt25 == 1:
                    # ./output/PLSQL3.g:142:5: ( 'DECLARE' )? ( declare_spec )+
                    pass
                    # ./output/PLSQL3.g:142:5: ( 'DECLARE' )?
                    alt23 = 2
                    LA23_0 = self.input.LA(1)

                    if (LA23_0 == 77) :
                        alt23 = 1
                    if alt23 == 1:
                        # ./output/PLSQL3.g:142:7: 'DECLARE'
                        pass
                        string_literal107 = self.match(self.input, 77, self.FOLLOW_77_in_plsql_block650)
                        if self._state.backtracking == 0:
                            string_literal107_tree = self._adaptor.createWithPayload(string_literal107)
                            self._adaptor.addChild(root_0, string_literal107_tree)






                    # ./output/PLSQL3.g:142:20: ( declare_spec )+
                    cnt24 = 0
                    while True: #loop24
                        alt24 = 2
                        LA24_0 = self.input.LA(1)

                        if (LA24_0 == DOUBLEQUOTED_STRING or LA24_0 == ID or LA24_0 == 73 or LA24_0 == 94 or LA24_0 == 133 or LA24_0 == 135) :
                            alt24 = 1


                        if alt24 == 1:
                            # ./output/PLSQL3.g:142:21: declare_spec
                            pass
                            self._state.following.append(self.FOLLOW_declare_spec_in_plsql_block656)
                            declare_spec108 = self.declare_spec()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, declare_spec108.tree)



                        else:
                            if cnt24 >= 1:
                                break #loop24

                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            eee = EarlyExitException(24, self.input)
                            raise eee

                        cnt24 += 1





                # ./output/PLSQL3.g:143:3: ( 'BEGIN' )
                # ./output/PLSQL3.g:143:5: 'BEGIN'
                pass
                string_literal109 = self.match(self.input, 56, self.FOLLOW_56_in_plsql_block668)
                if self._state.backtracking == 0:
                    string_literal109_tree = self._adaptor.createWithPayload(string_literal109)
                    self._adaptor.addChild(root_0, string_literal109_tree)






                self._state.following.append(self.FOLLOW_seq_of_statements_in_plsql_block674)
                seq_of_statements110 = self.seq_of_statements()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, seq_of_statements110.tree)


                # ./output/PLSQL3.g:145:3: ( 'EXCEPTION' ( exception_handler )+ )?
                alt27 = 2
                LA27_0 = self.input.LA(1)

                if (LA27_0 == 86) :
                    alt27 = 1
                if alt27 == 1:
                    # ./output/PLSQL3.g:145:5: 'EXCEPTION' ( exception_handler )+
                    pass
                    string_literal111 = self.match(self.input, 86, self.FOLLOW_86_in_plsql_block680)
                    if self._state.backtracking == 0:
                        string_literal111_tree = self._adaptor.createWithPayload(string_literal111)
                        self._adaptor.addChild(root_0, string_literal111_tree)



                    # ./output/PLSQL3.g:145:17: ( exception_handler )+
                    cnt26 = 0
                    while True: #loop26
                        alt26 = 2
                        LA26_0 = self.input.LA(1)

                        if (LA26_0 == 164) :
                            alt26 = 1


                        if alt26 == 1:
                            # ./output/PLSQL3.g:145:19: exception_handler
                            pass
                            self._state.following.append(self.FOLLOW_exception_handler_in_plsql_block684)
                            exception_handler112 = self.exception_handler()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, exception_handler112.tree)



                        else:
                            if cnt26 >= 1:
                                break #loop26

                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            eee = EarlyExitException(26, self.input)
                            raise eee

                        cnt26 += 1





                # ./output/PLSQL3.g:146:3: ( 'END' ( label_name )? )
                # ./output/PLSQL3.g:146:5: 'END' ( label_name )?
                pass
                string_literal113 = self.match(self.input, 85, self.FOLLOW_85_in_plsql_block697)
                if self._state.backtracking == 0:
                    string_literal113_tree = self._adaptor.createWithPayload(string_literal113)
                    self._adaptor.addChild(root_0, string_literal113_tree)



                # ./output/PLSQL3.g:146:11: ( label_name )?
                alt28 = 2
                LA28_0 = self.input.LA(1)

                if (LA28_0 == DOUBLEQUOTED_STRING or LA28_0 == ID) :
                    alt28 = 1
                if alt28 == 1:
                    # ./output/PLSQL3.g:146:13: label_name
                    pass
                    self._state.following.append(self.FOLLOW_label_name_in_plsql_block701)
                    label_name114 = self.label_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, label_name114.tree)










                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 14, plsql_block_StartIndex, success)


            pass
        return retval

    # $ANTLR end "plsql_block"


    class declare_spec_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.declare_spec_return, self).__init__()

            self.tree = None





    # $ANTLR start "declare_spec"
    # ./output/PLSQL3.g:149:1: declare_spec : ( variable_declaration | subtype_declaration | cursor_declaration | exception_declaration | record_declaration | plsql_table_declaration | varray_declaration | procedure_declaration | function_declaration | type_declaration | pragma_declaration );
    def declare_spec(self, ):
        retval = self.declare_spec_return()
        retval.start = self.input.LT(1)

        declare_spec_StartIndex = self.input.index()

        root_0 = None

        variable_declaration115 = None

        subtype_declaration116 = None

        cursor_declaration117 = None

        exception_declaration118 = None

        record_declaration119 = None

        plsql_table_declaration120 = None

        varray_declaration121 = None

        procedure_declaration122 = None

        function_declaration123 = None

        type_declaration124 = None

        pragma_declaration125 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 15):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:150:2: ( variable_declaration | subtype_declaration | cursor_declaration | exception_declaration | record_declaration | plsql_table_declaration | varray_declaration | procedure_declaration | function_declaration | type_declaration | pragma_declaration )
                alt29 = 11
                alt29 = self.dfa29.predict(self.input)
                if alt29 == 1:
                    # ./output/PLSQL3.g:150:4: variable_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_variable_declaration_in_declare_spec717)
                    variable_declaration115 = self.variable_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, variable_declaration115.tree)



                elif alt29 == 2:
                    # ./output/PLSQL3.g:151:4: subtype_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_subtype_declaration_in_declare_spec723)
                    subtype_declaration116 = self.subtype_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, subtype_declaration116.tree)



                elif alt29 == 3:
                    # ./output/PLSQL3.g:152:4: cursor_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_cursor_declaration_in_declare_spec729)
                    cursor_declaration117 = self.cursor_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, cursor_declaration117.tree)



                elif alt29 == 4:
                    # ./output/PLSQL3.g:153:4: exception_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_exception_declaration_in_declare_spec735)
                    exception_declaration118 = self.exception_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, exception_declaration118.tree)



                elif alt29 == 5:
                    # ./output/PLSQL3.g:154:4: record_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_record_declaration_in_declare_spec741)
                    record_declaration119 = self.record_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, record_declaration119.tree)



                elif alt29 == 6:
                    # ./output/PLSQL3.g:155:4: plsql_table_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_plsql_table_declaration_in_declare_spec747)
                    plsql_table_declaration120 = self.plsql_table_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, plsql_table_declaration120.tree)



                elif alt29 == 7:
                    # ./output/PLSQL3.g:156:4: varray_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_varray_declaration_in_declare_spec753)
                    varray_declaration121 = self.varray_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, varray_declaration121.tree)



                elif alt29 == 8:
                    # ./output/PLSQL3.g:157:4: procedure_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_procedure_declaration_in_declare_spec758)
                    procedure_declaration122 = self.procedure_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, procedure_declaration122.tree)



                elif alt29 == 9:
                    # ./output/PLSQL3.g:158:4: function_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_function_declaration_in_declare_spec764)
                    function_declaration123 = self.function_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, function_declaration123.tree)



                elif alt29 == 10:
                    # ./output/PLSQL3.g:159:4: type_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_type_declaration_in_declare_spec769)
                    type_declaration124 = self.type_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, type_declaration124.tree)



                elif alt29 == 11:
                    # ./output/PLSQL3.g:160:4: pragma_declaration
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_pragma_declaration_in_declare_spec775)
                    pragma_declaration125 = self.pragma_declaration()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, pragma_declaration125.tree)



                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 15, declare_spec_StartIndex, success)


            pass
        return retval

    # $ANTLR end "declare_spec"


    class pragma_declaration_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.pragma_declaration_return, self).__init__()

            self.tree = None





    # $ANTLR start "pragma_declaration"
    # ./output/PLSQL3.g:163:1: pragma_declaration : keyPRAGMA ( keyRESTRICT_REFERENCES LPAREN ( 'DEFAULT' | function_name ) ( COMMA pragma_param )+ RPAREN | keyEXCEPTION_INIT LPAREN exception_name COMMA literal RPAREN | keyAUTONOMOUS_TRANSACTION | keySERIALLY_REUSABLE | keyBUILTIN LPAREN pragma_params RPAREN | keyFIPSFLAG LPAREN pragma_params RPAREN | keyINTERFACE LPAREN pragma_params RPAREN | keyNEW_NAMES LPAREN pragma_params RPAREN | keyTIMESTAMP LPAREN pragma_params RPAREN ) SEMI ;
    def pragma_declaration(self, ):
        retval = self.pragma_declaration_return()
        retval.start = self.input.LT(1)

        pragma_declaration_StartIndex = self.input.index()

        root_0 = None

        LPAREN128 = None
        string_literal129 = None
        COMMA131 = None
        RPAREN133 = None
        LPAREN135 = None
        COMMA137 = None
        RPAREN139 = None
        LPAREN143 = None
        RPAREN145 = None
        LPAREN147 = None
        RPAREN149 = None
        LPAREN151 = None
        RPAREN153 = None
        LPAREN155 = None
        RPAREN157 = None
        LPAREN159 = None
        RPAREN161 = None
        SEMI162 = None
        keyPRAGMA126 = None

        keyRESTRICT_REFERENCES127 = None

        function_name130 = None

        pragma_param132 = None

        keyEXCEPTION_INIT134 = None

        exception_name136 = None

        literal138 = None

        keyAUTONOMOUS_TRANSACTION140 = None

        keySERIALLY_REUSABLE141 = None

        keyBUILTIN142 = None

        pragma_params144 = None

        keyFIPSFLAG146 = None

        pragma_params148 = None

        keyINTERFACE150 = None

        pragma_params152 = None

        keyNEW_NAMES154 = None

        pragma_params156 = None

        keyTIMESTAMP158 = None

        pragma_params160 = None


        LPAREN128_tree = None
        string_literal129_tree = None
        COMMA131_tree = None
        RPAREN133_tree = None
        LPAREN135_tree = None
        COMMA137_tree = None
        RPAREN139_tree = None
        LPAREN143_tree = None
        RPAREN145_tree = None
        LPAREN147_tree = None
        RPAREN149_tree = None
        LPAREN151_tree = None
        RPAREN153_tree = None
        LPAREN155_tree = None
        RPAREN157_tree = None
        LPAREN159_tree = None
        RPAREN161_tree = None
        SEMI162_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 16):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:164:2: ( keyPRAGMA ( keyRESTRICT_REFERENCES LPAREN ( 'DEFAULT' | function_name ) ( COMMA pragma_param )+ RPAREN | keyEXCEPTION_INIT LPAREN exception_name COMMA literal RPAREN | keyAUTONOMOUS_TRANSACTION | keySERIALLY_REUSABLE | keyBUILTIN LPAREN pragma_params RPAREN | keyFIPSFLAG LPAREN pragma_params RPAREN | keyINTERFACE LPAREN pragma_params RPAREN | keyNEW_NAMES LPAREN pragma_params RPAREN | keyTIMESTAMP LPAREN pragma_params RPAREN ) SEMI )
                # ./output/PLSQL3.g:164:4: keyPRAGMA ( keyRESTRICT_REFERENCES LPAREN ( 'DEFAULT' | function_name ) ( COMMA pragma_param )+ RPAREN | keyEXCEPTION_INIT LPAREN exception_name COMMA literal RPAREN | keyAUTONOMOUS_TRANSACTION | keySERIALLY_REUSABLE | keyBUILTIN LPAREN pragma_params RPAREN | keyFIPSFLAG LPAREN pragma_params RPAREN | keyINTERFACE LPAREN pragma_params RPAREN | keyNEW_NAMES LPAREN pragma_params RPAREN | keyTIMESTAMP LPAREN pragma_params RPAREN ) SEMI
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyPRAGMA_in_pragma_declaration786)
                keyPRAGMA126 = self.keyPRAGMA()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyPRAGMA126.tree)


                # ./output/PLSQL3.g:165:3: ( keyRESTRICT_REFERENCES LPAREN ( 'DEFAULT' | function_name ) ( COMMA pragma_param )+ RPAREN | keyEXCEPTION_INIT LPAREN exception_name COMMA literal RPAREN | keyAUTONOMOUS_TRANSACTION | keySERIALLY_REUSABLE | keyBUILTIN LPAREN pragma_params RPAREN | keyFIPSFLAG LPAREN pragma_params RPAREN | keyINTERFACE LPAREN pragma_params RPAREN | keyNEW_NAMES LPAREN pragma_params RPAREN | keyTIMESTAMP LPAREN pragma_params RPAREN )
                alt32 = 9
                alt32 = self.dfa32.predict(self.input)
                if alt32 == 1:
                    # ./output/PLSQL3.g:165:5: keyRESTRICT_REFERENCES LPAREN ( 'DEFAULT' | function_name ) ( COMMA pragma_param )+ RPAREN
                    pass
                    self._state.following.append(self.FOLLOW_keyRESTRICT_REFERENCES_in_pragma_declaration793)
                    keyRESTRICT_REFERENCES127 = self.keyRESTRICT_REFERENCES()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyRESTRICT_REFERENCES127.tree)


                    LPAREN128 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_pragma_declaration795)
                    if self._state.backtracking == 0:
                        LPAREN128_tree = self._adaptor.createWithPayload(LPAREN128)
                        self._adaptor.addChild(root_0, LPAREN128_tree)



                    # ./output/PLSQL3.g:165:35: ( 'DEFAULT' | function_name )
                    alt30 = 2
                    LA30_0 = self.input.LA(1)

                    if (LA30_0 == 78) :
                        alt30 = 1
                    elif (LA30_0 == DOUBLEQUOTED_STRING or LA30_0 == ID or LA30_0 == QUOTED_STRING) :
                        alt30 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 30, 0, self.input)

                        raise nvae


                    if alt30 == 1:
                        # ./output/PLSQL3.g:165:37: 'DEFAULT'
                        pass
                        string_literal129 = self.match(self.input, 78, self.FOLLOW_78_in_pragma_declaration799)
                        if self._state.backtracking == 0:
                            string_literal129_tree = self._adaptor.createWithPayload(string_literal129)
                            self._adaptor.addChild(root_0, string_literal129_tree)




                    elif alt30 == 2:
                        # ./output/PLSQL3.g:165:49: function_name
                        pass
                        self._state.following.append(self.FOLLOW_function_name_in_pragma_declaration803)
                        function_name130 = self.function_name()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, function_name130.tree)





                    # ./output/PLSQL3.g:165:65: ( COMMA pragma_param )+
                    cnt31 = 0
                    while True: #loop31
                        alt31 = 2
                        LA31_0 = self.input.LA(1)

                        if (LA31_0 == COMMA) :
                            alt31 = 1


                        if alt31 == 1:
                            # ./output/PLSQL3.g:165:67: COMMA pragma_param
                            pass
                            COMMA131 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_pragma_declaration809)
                            if self._state.backtracking == 0:
                                COMMA131_tree = self._adaptor.createWithPayload(COMMA131)
                                self._adaptor.addChild(root_0, COMMA131_tree)



                            self._state.following.append(self.FOLLOW_pragma_param_in_pragma_declaration811)
                            pragma_param132 = self.pragma_param()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, pragma_param132.tree)



                        else:
                            if cnt31 >= 1:
                                break #loop31

                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            eee = EarlyExitException(31, self.input)
                            raise eee

                        cnt31 += 1


                    RPAREN133 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_pragma_declaration816)
                    if self._state.backtracking == 0:
                        RPAREN133_tree = self._adaptor.createWithPayload(RPAREN133)
                        self._adaptor.addChild(root_0, RPAREN133_tree)




                elif alt32 == 2:
                    # ./output/PLSQL3.g:166:5: keyEXCEPTION_INIT LPAREN exception_name COMMA literal RPAREN
                    pass
                    self._state.following.append(self.FOLLOW_keyEXCEPTION_INIT_in_pragma_declaration823)
                    keyEXCEPTION_INIT134 = self.keyEXCEPTION_INIT()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyEXCEPTION_INIT134.tree)


                    LPAREN135 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_pragma_declaration825)
                    if self._state.backtracking == 0:
                        LPAREN135_tree = self._adaptor.createWithPayload(LPAREN135)
                        self._adaptor.addChild(root_0, LPAREN135_tree)



                    self._state.following.append(self.FOLLOW_exception_name_in_pragma_declaration827)
                    exception_name136 = self.exception_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, exception_name136.tree)


                    COMMA137 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_pragma_declaration829)
                    if self._state.backtracking == 0:
                        COMMA137_tree = self._adaptor.createWithPayload(COMMA137)
                        self._adaptor.addChild(root_0, COMMA137_tree)



                    self._state.following.append(self.FOLLOW_literal_in_pragma_declaration831)
                    literal138 = self.literal()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, literal138.tree)


                    RPAREN139 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_pragma_declaration833)
                    if self._state.backtracking == 0:
                        RPAREN139_tree = self._adaptor.createWithPayload(RPAREN139)
                        self._adaptor.addChild(root_0, RPAREN139_tree)




                elif alt32 == 3:
                    # ./output/PLSQL3.g:167:5: keyAUTONOMOUS_TRANSACTION
                    pass
                    self._state.following.append(self.FOLLOW_keyAUTONOMOUS_TRANSACTION_in_pragma_declaration839)
                    keyAUTONOMOUS_TRANSACTION140 = self.keyAUTONOMOUS_TRANSACTION()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyAUTONOMOUS_TRANSACTION140.tree)



                elif alt32 == 4:
                    # ./output/PLSQL3.g:168:5: keySERIALLY_REUSABLE
                    pass
                    self._state.following.append(self.FOLLOW_keySERIALLY_REUSABLE_in_pragma_declaration845)
                    keySERIALLY_REUSABLE141 = self.keySERIALLY_REUSABLE()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keySERIALLY_REUSABLE141.tree)



                elif alt32 == 5:
                    # ./output/PLSQL3.g:169:5: keyBUILTIN LPAREN pragma_params RPAREN
                    pass
                    self._state.following.append(self.FOLLOW_keyBUILTIN_in_pragma_declaration851)
                    keyBUILTIN142 = self.keyBUILTIN()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyBUILTIN142.tree)


                    LPAREN143 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_pragma_declaration853)
                    if self._state.backtracking == 0:
                        LPAREN143_tree = self._adaptor.createWithPayload(LPAREN143)
                        self._adaptor.addChild(root_0, LPAREN143_tree)



                    self._state.following.append(self.FOLLOW_pragma_params_in_pragma_declaration855)
                    pragma_params144 = self.pragma_params()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, pragma_params144.tree)


                    RPAREN145 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_pragma_declaration857)
                    if self._state.backtracking == 0:
                        RPAREN145_tree = self._adaptor.createWithPayload(RPAREN145)
                        self._adaptor.addChild(root_0, RPAREN145_tree)




                elif alt32 == 6:
                    # ./output/PLSQL3.g:170:5: keyFIPSFLAG LPAREN pragma_params RPAREN
                    pass
                    self._state.following.append(self.FOLLOW_keyFIPSFLAG_in_pragma_declaration863)
                    keyFIPSFLAG146 = self.keyFIPSFLAG()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyFIPSFLAG146.tree)


                    LPAREN147 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_pragma_declaration865)
                    if self._state.backtracking == 0:
                        LPAREN147_tree = self._adaptor.createWithPayload(LPAREN147)
                        self._adaptor.addChild(root_0, LPAREN147_tree)



                    self._state.following.append(self.FOLLOW_pragma_params_in_pragma_declaration867)
                    pragma_params148 = self.pragma_params()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, pragma_params148.tree)


                    RPAREN149 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_pragma_declaration869)
                    if self._state.backtracking == 0:
                        RPAREN149_tree = self._adaptor.createWithPayload(RPAREN149)
                        self._adaptor.addChild(root_0, RPAREN149_tree)




                elif alt32 == 7:
                    # ./output/PLSQL3.g:171:5: keyINTERFACE LPAREN pragma_params RPAREN
                    pass
                    self._state.following.append(self.FOLLOW_keyINTERFACE_in_pragma_declaration875)
                    keyINTERFACE150 = self.keyINTERFACE()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyINTERFACE150.tree)


                    LPAREN151 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_pragma_declaration877)
                    if self._state.backtracking == 0:
                        LPAREN151_tree = self._adaptor.createWithPayload(LPAREN151)
                        self._adaptor.addChild(root_0, LPAREN151_tree)



                    self._state.following.append(self.FOLLOW_pragma_params_in_pragma_declaration879)
                    pragma_params152 = self.pragma_params()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, pragma_params152.tree)


                    RPAREN153 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_pragma_declaration881)
                    if self._state.backtracking == 0:
                        RPAREN153_tree = self._adaptor.createWithPayload(RPAREN153)
                        self._adaptor.addChild(root_0, RPAREN153_tree)




                elif alt32 == 8:
                    # ./output/PLSQL3.g:172:5: keyNEW_NAMES LPAREN pragma_params RPAREN
                    pass
                    self._state.following.append(self.FOLLOW_keyNEW_NAMES_in_pragma_declaration887)
                    keyNEW_NAMES154 = self.keyNEW_NAMES()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyNEW_NAMES154.tree)


                    LPAREN155 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_pragma_declaration889)
                    if self._state.backtracking == 0:
                        LPAREN155_tree = self._adaptor.createWithPayload(LPAREN155)
                        self._adaptor.addChild(root_0, LPAREN155_tree)



                    self._state.following.append(self.FOLLOW_pragma_params_in_pragma_declaration891)
                    pragma_params156 = self.pragma_params()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, pragma_params156.tree)


                    RPAREN157 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_pragma_declaration893)
                    if self._state.backtracking == 0:
                        RPAREN157_tree = self._adaptor.createWithPayload(RPAREN157)
                        self._adaptor.addChild(root_0, RPAREN157_tree)




                elif alt32 == 9:
                    # ./output/PLSQL3.g:173:5: keyTIMESTAMP LPAREN pragma_params RPAREN
                    pass
                    self._state.following.append(self.FOLLOW_keyTIMESTAMP_in_pragma_declaration899)
                    keyTIMESTAMP158 = self.keyTIMESTAMP()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyTIMESTAMP158.tree)


                    LPAREN159 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_pragma_declaration901)
                    if self._state.backtracking == 0:
                        LPAREN159_tree = self._adaptor.createWithPayload(LPAREN159)
                        self._adaptor.addChild(root_0, LPAREN159_tree)



                    self._state.following.append(self.FOLLOW_pragma_params_in_pragma_declaration903)
                    pragma_params160 = self.pragma_params()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, pragma_params160.tree)


                    RPAREN161 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_pragma_declaration905)
                    if self._state.backtracking == 0:
                        RPAREN161_tree = self._adaptor.createWithPayload(RPAREN161)
                        self._adaptor.addChild(root_0, RPAREN161_tree)






                SEMI162 = self.match(self.input, SEMI, self.FOLLOW_SEMI_in_pragma_declaration913)
                if self._state.backtracking == 0:
                    SEMI162_tree = self._adaptor.createWithPayload(SEMI162)
                    self._adaptor.addChild(root_0, SEMI162_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 16, pragma_declaration_StartIndex, success)


            pass
        return retval

    # $ANTLR end "pragma_declaration"


    class pragma_params_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.pragma_params_return, self).__init__()

            self.tree = None





    # $ANTLR start "pragma_params"
    # ./output/PLSQL3.g:178:1: pragma_params : pragma_param ( COMMA pragma_param )* ;
    def pragma_params(self, ):
        retval = self.pragma_params_return()
        retval.start = self.input.LT(1)

        pragma_params_StartIndex = self.input.index()

        root_0 = None

        COMMA164 = None
        pragma_param163 = None

        pragma_param165 = None


        COMMA164_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 17):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:179:2: ( pragma_param ( COMMA pragma_param )* )
                # ./output/PLSQL3.g:179:4: pragma_param ( COMMA pragma_param )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_pragma_param_in_pragma_params924)
                pragma_param163 = self.pragma_param()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, pragma_param163.tree)


                # ./output/PLSQL3.g:179:17: ( COMMA pragma_param )*
                while True: #loop33
                    alt33 = 2
                    LA33_0 = self.input.LA(1)

                    if (LA33_0 == COMMA) :
                        alt33 = 1


                    if alt33 == 1:
                        # ./output/PLSQL3.g:179:19: COMMA pragma_param
                        pass
                        COMMA164 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_pragma_params928)
                        if self._state.backtracking == 0:
                            COMMA164_tree = self._adaptor.createWithPayload(COMMA164)
                            self._adaptor.addChild(root_0, COMMA164_tree)



                        self._state.following.append(self.FOLLOW_pragma_param_in_pragma_params930)
                        pragma_param165 = self.pragma_param()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, pragma_param165.tree)



                    else:
                        break #loop33




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 17, pragma_params_StartIndex, success)


            pass
        return retval

    # $ANTLR end "pragma_params"


    class pragma_param_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.pragma_param_return, self).__init__()

            self.tree = None





    # $ANTLR start "pragma_param"
    # ./output/PLSQL3.g:182:1: pragma_param : ( ( PLUS | MINUS )? NUMBER | QUOTED_STRING | identifier );
    def pragma_param(self, ):
        retval = self.pragma_param_return()
        retval.start = self.input.LT(1)

        pragma_param_StartIndex = self.input.index()

        root_0 = None

        set166 = None
        NUMBER167 = None
        QUOTED_STRING168 = None
        identifier169 = None


        set166_tree = None
        NUMBER167_tree = None
        QUOTED_STRING168_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 18):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:183:2: ( ( PLUS | MINUS )? NUMBER | QUOTED_STRING | identifier )
                alt35 = 3
                LA35 = self.input.LA(1)
                if LA35 == MINUS or LA35 == NUMBER or LA35 == PLUS:
                    alt35 = 1
                elif LA35 == QUOTED_STRING:
                    alt35 = 2
                elif LA35 == DOUBLEQUOTED_STRING or LA35 == ID:
                    alt35 = 3
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 35, 0, self.input)

                    raise nvae


                if alt35 == 1:
                    # ./output/PLSQL3.g:183:4: ( PLUS | MINUS )? NUMBER
                    pass
                    root_0 = self._adaptor.nil()


                    # ./output/PLSQL3.g:183:4: ( PLUS | MINUS )?
                    alt34 = 2
                    LA34_0 = self.input.LA(1)

                    if (LA34_0 == MINUS or LA34_0 == PLUS) :
                        alt34 = 1
                    if alt34 == 1:
                        # ./output/PLSQL3.g:
                        pass
                        set166 = self.input.LT(1)

                        if self.input.LA(1) == MINUS or self.input.LA(1) == PLUS:
                            self.input.consume()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set166))

                            self._state.errorRecovery = False


                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            mse = MismatchedSetException(None, self.input)
                            raise mse






                    NUMBER167 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_pragma_param955)
                    if self._state.backtracking == 0:
                        NUMBER167_tree = self._adaptor.createWithPayload(NUMBER167)
                        self._adaptor.addChild(root_0, NUMBER167_tree)




                elif alt35 == 2:
                    # ./output/PLSQL3.g:184:4: QUOTED_STRING
                    pass
                    root_0 = self._adaptor.nil()


                    QUOTED_STRING168 = self.match(self.input, QUOTED_STRING, self.FOLLOW_QUOTED_STRING_in_pragma_param960)
                    if self._state.backtracking == 0:
                        QUOTED_STRING168_tree = self._adaptor.createWithPayload(QUOTED_STRING168)
                        self._adaptor.addChild(root_0, QUOTED_STRING168_tree)




                elif alt35 == 3:
                    # ./output/PLSQL3.g:185:4: identifier
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_identifier_in_pragma_param965)
                    identifier169 = self.identifier()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, identifier169.tree)



                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 18, pragma_param_StartIndex, success)


            pass
        return retval

    # $ANTLR end "pragma_param"


    class assignment_statement_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.assignment_statement_return, self).__init__()

            self.tree = None





    # $ANTLR start "assignment_statement"
    # ./output/PLSQL3.g:188:1: assignment_statement : ( lvalue ASSIGN plsql_expression ) ;
    def assignment_statement(self, ):
        retval = self.assignment_statement_return()
        retval.start = self.input.LT(1)

        assignment_statement_StartIndex = self.input.index()

        root_0 = None

        ASSIGN171 = None
        lvalue170 = None

        plsql_expression172 = None


        ASSIGN171_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 19):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:189:2: ( ( lvalue ASSIGN plsql_expression ) )
                # ./output/PLSQL3.g:191:3: ( lvalue ASSIGN plsql_expression )
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:191:3: ( lvalue ASSIGN plsql_expression )
                # ./output/PLSQL3.g:191:4: lvalue ASSIGN plsql_expression
                pass
                self._state.following.append(self.FOLLOW_lvalue_in_assignment_statement981)
                lvalue170 = self.lvalue()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, lvalue170.tree)


                ASSIGN171 = self.match(self.input, ASSIGN, self.FOLLOW_ASSIGN_in_assignment_statement983)
                if self._state.backtracking == 0:
                    ASSIGN171_tree = self._adaptor.createWithPayload(ASSIGN171)
                    self._adaptor.addChild(root_0, ASSIGN171_tree)



                self._state.following.append(self.FOLLOW_plsql_expression_in_assignment_statement985)
                plsql_expression172 = self.plsql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, plsql_expression172.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 19, assignment_statement_StartIndex, success)


            pass
        return retval

    # $ANTLR end "assignment_statement"


    class lvalues_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.lvalues_return, self).__init__()

            self.tree = None





    # $ANTLR start "lvalues"
    # ./output/PLSQL3.g:194:1: lvalues : lvalue ( COMMA lvalue )* ;
    def lvalues(self, ):
        retval = self.lvalues_return()
        retval.start = self.input.LT(1)

        lvalues_StartIndex = self.input.index()

        root_0 = None

        COMMA174 = None
        lvalue173 = None

        lvalue175 = None


        COMMA174_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 20):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:195:2: ( lvalue ( COMMA lvalue )* )
                # ./output/PLSQL3.g:195:4: lvalue ( COMMA lvalue )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_lvalue_in_lvalues997)
                lvalue173 = self.lvalue()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, lvalue173.tree)


                # ./output/PLSQL3.g:195:11: ( COMMA lvalue )*
                while True: #loop36
                    alt36 = 2
                    LA36_0 = self.input.LA(1)

                    if (LA36_0 == COMMA) :
                        alt36 = 1


                    if alt36 == 1:
                        # ./output/PLSQL3.g:195:13: COMMA lvalue
                        pass
                        COMMA174 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_lvalues1001)
                        if self._state.backtracking == 0:
                            COMMA174_tree = self._adaptor.createWithPayload(COMMA174)
                            self._adaptor.addChild(root_0, COMMA174_tree)



                        self._state.following.append(self.FOLLOW_lvalue_in_lvalues1003)
                        lvalue175 = self.lvalue()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, lvalue175.tree)



                    else:
                        break #loop36




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 20, lvalues_StartIndex, success)


            pass
        return retval

    # $ANTLR end "lvalues"


    class lvalue_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.lvalue_return, self).__init__()

            self.tree = None





    # $ANTLR start "lvalue"
    # ./output/PLSQL3.g:197:1: lvalue : ( variable_name | record_name DOT field_name | plsql_table_name LPAREN subscript RPAREN ( DOT field_name )* | COLON host_variable ( COLON host_variable )? );
    def lvalue(self, ):
        retval = self.lvalue_return()
        retval.start = self.input.LT(1)

        lvalue_StartIndex = self.input.index()

        root_0 = None

        DOT178 = None
        LPAREN181 = None
        RPAREN183 = None
        DOT184 = None
        COLON186 = None
        COLON188 = None
        variable_name176 = None

        record_name177 = None

        field_name179 = None

        plsql_table_name180 = None

        subscript182 = None

        field_name185 = None

        host_variable187 = None

        host_variable189 = None


        DOT178_tree = None
        LPAREN181_tree = None
        RPAREN183_tree = None
        DOT184_tree = None
        COLON186_tree = None
        COLON188_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 21):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:198:2: ( variable_name | record_name DOT field_name | plsql_table_name LPAREN subscript RPAREN ( DOT field_name )* | COLON host_variable ( COLON host_variable )? )
                alt39 = 4
                LA39_0 = self.input.LA(1)

                if (LA39_0 == DOUBLEQUOTED_STRING or LA39_0 == ID) :
                    LA39 = self.input.LA(2)
                    if LA39 == EOF or LA39 == ASSIGN or LA39 == COMMA or LA39 == SEMI or LA39 == 93:
                        alt39 = 1
                    elif LA39 == DOT:
                        LA39_4 = self.input.LA(3)

                        if (LA39_4 == DOUBLEQUOTED_STRING or LA39_4 == ID) :
                            LA39_6 = self.input.LA(4)

                            if (LA39_6 == EOF or LA39_6 == ASSIGN or LA39_6 == COMMA or LA39_6 == SEMI or LA39_6 == 93) :
                                alt39 = 2
                            elif (LA39_6 == DOT or LA39_6 == LPAREN) :
                                alt39 = 3
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 39, 6, self.input)

                                raise nvae


                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 39, 4, self.input)

                            raise nvae


                    elif LA39 == LPAREN:
                        alt39 = 3
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 39, 1, self.input)

                        raise nvae


                elif (LA39_0 == COLON) :
                    alt39 = 4
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 39, 0, self.input)

                    raise nvae


                if alt39 == 1:
                    # ./output/PLSQL3.g:198:4: variable_name
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_variable_name_in_lvalue1016)
                    variable_name176 = self.variable_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, variable_name176.tree)



                elif alt39 == 2:
                    # ./output/PLSQL3.g:199:4: record_name DOT field_name
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_record_name_in_lvalue1021)
                    record_name177 = self.record_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, record_name177.tree)


                    DOT178 = self.match(self.input, DOT, self.FOLLOW_DOT_in_lvalue1023)
                    if self._state.backtracking == 0:
                        DOT178_tree = self._adaptor.createWithPayload(DOT178)
                        self._adaptor.addChild(root_0, DOT178_tree)



                    self._state.following.append(self.FOLLOW_field_name_in_lvalue1025)
                    field_name179 = self.field_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, field_name179.tree)



                elif alt39 == 3:
                    # ./output/PLSQL3.g:200:4: plsql_table_name LPAREN subscript RPAREN ( DOT field_name )*
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_plsql_table_name_in_lvalue1030)
                    plsql_table_name180 = self.plsql_table_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, plsql_table_name180.tree)


                    LPAREN181 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_lvalue1032)
                    if self._state.backtracking == 0:
                        LPAREN181_tree = self._adaptor.createWithPayload(LPAREN181)
                        self._adaptor.addChild(root_0, LPAREN181_tree)



                    self._state.following.append(self.FOLLOW_subscript_in_lvalue1034)
                    subscript182 = self.subscript()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, subscript182.tree)


                    RPAREN183 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_lvalue1036)
                    if self._state.backtracking == 0:
                        RPAREN183_tree = self._adaptor.createWithPayload(RPAREN183)
                        self._adaptor.addChild(root_0, RPAREN183_tree)



                    # ./output/PLSQL3.g:200:45: ( DOT field_name )*
                    while True: #loop37
                        alt37 = 2
                        LA37_0 = self.input.LA(1)

                        if (LA37_0 == DOT) :
                            alt37 = 1


                        if alt37 == 1:
                            # ./output/PLSQL3.g:200:47: DOT field_name
                            pass
                            DOT184 = self.match(self.input, DOT, self.FOLLOW_DOT_in_lvalue1040)
                            if self._state.backtracking == 0:
                                DOT184_tree = self._adaptor.createWithPayload(DOT184)
                                self._adaptor.addChild(root_0, DOT184_tree)



                            self._state.following.append(self.FOLLOW_field_name_in_lvalue1042)
                            field_name185 = self.field_name()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, field_name185.tree)



                        else:
                            break #loop37



                elif alt39 == 4:
                    # ./output/PLSQL3.g:201:4: COLON host_variable ( COLON host_variable )?
                    pass
                    root_0 = self._adaptor.nil()


                    COLON186 = self.match(self.input, COLON, self.FOLLOW_COLON_in_lvalue1050)
                    if self._state.backtracking == 0:
                        COLON186_tree = self._adaptor.createWithPayload(COLON186)
                        self._adaptor.addChild(root_0, COLON186_tree)



                    self._state.following.append(self.FOLLOW_host_variable_in_lvalue1052)
                    host_variable187 = self.host_variable()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, host_variable187.tree)


                    # ./output/PLSQL3.g:201:24: ( COLON host_variable )?
                    alt38 = 2
                    LA38_0 = self.input.LA(1)

                    if (LA38_0 == COLON) :
                        alt38 = 1
                    if alt38 == 1:
                        # ./output/PLSQL3.g:201:26: COLON host_variable
                        pass
                        COLON188 = self.match(self.input, COLON, self.FOLLOW_COLON_in_lvalue1056)
                        if self._state.backtracking == 0:
                            COLON188_tree = self._adaptor.createWithPayload(COLON188)
                            self._adaptor.addChild(root_0, COLON188_tree)



                        self._state.following.append(self.FOLLOW_host_variable_in_lvalue1058)
                        host_variable189 = self.host_variable()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, host_variable189.tree)






                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 21, lvalue_StartIndex, success)


            pass
        return retval

    # $ANTLR end "lvalue"


    class field_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.field_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "field_name"
    # ./output/PLSQL3.g:204:1: field_name : identifier ;
    def field_name(self, ):
        retval = self.field_name_return()
        retval.start = self.input.LT(1)

        field_name_StartIndex = self.input.index()

        root_0 = None

        identifier190 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 22):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:205:2: ( identifier )
                # ./output/PLSQL3.g:205:4: identifier
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_identifier_in_field_name1072)
                identifier190 = self.identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, identifier190.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 22, field_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "field_name"


    class subscript_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.subscript_return, self).__init__()

            self.tree = None





    # $ANTLR start "subscript"
    # ./output/PLSQL3.g:208:1: subscript : plsql_expression ;
    def subscript(self, ):
        retval = self.subscript_return()
        retval.start = self.input.LT(1)

        subscript_StartIndex = self.input.index()

        root_0 = None

        plsql_expression191 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 23):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:209:2: ( plsql_expression )
                # ./output/PLSQL3.g:209:4: plsql_expression
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_plsql_expression_in_subscript1084)
                plsql_expression191 = self.plsql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, plsql_expression191.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 23, subscript_StartIndex, success)


            pass
        return retval

    # $ANTLR end "subscript"


    class host_variable_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.host_variable_return, self).__init__()

            self.tree = None





    # $ANTLR start "host_variable"
    # ./output/PLSQL3.g:212:1: host_variable : identifier ;
    def host_variable(self, ):
        retval = self.host_variable_return()
        retval.start = self.input.LT(1)

        host_variable_StartIndex = self.input.index()

        root_0 = None

        identifier192 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 24):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:213:2: ( identifier )
                # ./output/PLSQL3.g:213:4: identifier
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_identifier_in_host_variable1097)
                identifier192 = self.identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, identifier192.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 24, host_variable_StartIndex, success)


            pass
        return retval

    # $ANTLR end "host_variable"


    class goto_statement_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.goto_statement_return, self).__init__()

            self.tree = None





    # $ANTLR start "goto_statement"
    # ./output/PLSQL3.g:216:1: goto_statement : 'GOTO' label_name ;
    def goto_statement(self, ):
        retval = self.goto_statement_return()
        retval.start = self.input.LT(1)

        goto_statement_StartIndex = self.input.index()

        root_0 = None

        string_literal193 = None
        label_name194 = None


        string_literal193_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 25):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:217:2: ( 'GOTO' label_name )
                # ./output/PLSQL3.g:217:4: 'GOTO' label_name
                pass
                root_0 = self._adaptor.nil()


                string_literal193 = self.match(self.input, 95, self.FOLLOW_95_in_goto_statement1109)
                if self._state.backtracking == 0:
                    string_literal193_tree = self._adaptor.createWithPayload(string_literal193)
                    self._adaptor.addChild(root_0, string_literal193_tree)



                self._state.following.append(self.FOLLOW_label_name_in_goto_statement1111)
                label_name194 = self.label_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, label_name194.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 25, goto_statement_StartIndex, success)


            pass
        return retval

    # $ANTLR end "goto_statement"


    class label_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.label_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "label_name"
    # ./output/PLSQL3.g:220:1: label_name : identifier ;
    def label_name(self, ):
        retval = self.label_name_return()
        retval.start = self.input.LT(1)

        label_name_StartIndex = self.input.index()

        root_0 = None

        identifier195 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 26):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:221:2: ( identifier )
                # ./output/PLSQL3.g:221:4: identifier
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_identifier_in_label_name1123)
                identifier195 = self.identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, identifier195.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 26, label_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "label_name"


    class exit_statement_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.exit_statement_return, self).__init__()

            self.tree = None





    # $ANTLR start "exit_statement"
    # ./output/PLSQL3.g:224:1: exit_statement : keyEXIT ( label_name )? ( 'WHEN' plsql_condition )? ;
    def exit_statement(self, ):
        retval = self.exit_statement_return()
        retval.start = self.input.LT(1)

        exit_statement_StartIndex = self.input.index()

        root_0 = None

        string_literal198 = None
        keyEXIT196 = None

        label_name197 = None

        plsql_condition199 = None


        string_literal198_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 27):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:225:2: ( keyEXIT ( label_name )? ( 'WHEN' plsql_condition )? )
                # ./output/PLSQL3.g:225:4: keyEXIT ( label_name )? ( 'WHEN' plsql_condition )?
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyEXIT_in_exit_statement1135)
                keyEXIT196 = self.keyEXIT()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyEXIT196.tree)


                # ./output/PLSQL3.g:225:12: ( label_name )?
                alt40 = 2
                LA40_0 = self.input.LA(1)

                if (LA40_0 == DOUBLEQUOTED_STRING or LA40_0 == ID) :
                    alt40 = 1
                if alt40 == 1:
                    # ./output/PLSQL3.g:225:14: label_name
                    pass
                    self._state.following.append(self.FOLLOW_label_name_in_exit_statement1139)
                    label_name197 = self.label_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, label_name197.tree)





                # ./output/PLSQL3.g:225:28: ( 'WHEN' plsql_condition )?
                alt41 = 2
                LA41_0 = self.input.LA(1)

                if (LA41_0 == 164) :
                    alt41 = 1
                if alt41 == 1:
                    # ./output/PLSQL3.g:225:30: 'WHEN' plsql_condition
                    pass
                    string_literal198 = self.match(self.input, 164, self.FOLLOW_164_in_exit_statement1146)
                    if self._state.backtracking == 0:
                        string_literal198_tree = self._adaptor.createWithPayload(string_literal198)
                        self._adaptor.addChild(root_0, string_literal198_tree)



                    self._state.following.append(self.FOLLOW_plsql_condition_in_exit_statement1148)
                    plsql_condition199 = self.plsql_condition()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, plsql_condition199.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 27, exit_statement_StartIndex, success)


            pass
        return retval

    # $ANTLR end "exit_statement"


    class datatype_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.datatype_return, self).__init__()

            self.tree = None





    # $ANTLR start "datatype"
    # ./output/PLSQL3.g:228:1: datatype : ( 'BINARY_INTEGER' | 'BINARY_FLOAT' | 'BINARY_DOUBLE' | 'NATURAL' | 'POSITIVE' | ( 'NUMBER' | 'NUMERIC' | 'DECIMAL' | 'DEC' ) ( LPAREN NUMBER ( COMMA NUMBER )? RPAREN )? | 'LONG' ( 'RAW' )? ( LPAREN NUMBER RPAREN )? | 'RAW' ( LPAREN NUMBER RPAREN )? | 'BOOLEAN' | 'DATE' | keyINTERVAL keyDAY ( LPAREN NUMBER RPAREN )? 'TO' keySECOND ( LPAREN NUMBER RPAREN )? | keyINTERVAL keyYEAR ( LPAREN NUMBER RPAREN )? 'TO' keyMONTH | ( keyTIME | keyTIMESTAMP ) ( LPAREN NUMBER RPAREN )? ( 'WITH' ( keyLOCAL )? keyTIME keyZONE )? | 'INTEGER' | 'INT' | 'SMALLINT' | 'FLOAT' ( LPAREN NUMBER RPAREN )? | 'REAL' | 'DOUBLE' keyPRECISION | 'CHAR' ( keyVARYING )? ( LPAREN NUMBER ( keyBYTE | 'CHAR' )? RPAREN )? ( 'CHARACTER' 'SET' ( identifier | column_spec CHARSET_ATTR ) )? | 'VARCHAR' ( LPAREN NUMBER ( keyBYTE | 'CHAR' )? RPAREN )? ( 'CHARACTER' 'SET' ( identifier | column_spec CHARSET_ATTR ) )? | 'VARCHAR2' ( LPAREN NUMBER ( keyBYTE | 'CHAR' )? RPAREN )? ( 'CHARACTER' 'SET' ( identifier | column_spec CHARSET_ATTR ) )? | 'CHARACTER' ( keyVARYING )? ( LPAREN NUMBER RPAREN )? | 'NCHAR' ( keyVARYING )? ( LPAREN NUMBER RPAREN )? | 'NVARCHAR' ( LPAREN NUMBER RPAREN )? | 'NVARCHAR2' ( LPAREN NUMBER RPAREN )? | 'NATIONAL' ( 'CHARACTER' | 'CHAR' ) ( keyVARYING )? ( LPAREN NUMBER RPAREN )? | 'MLSLABEL' | 'PLS_INTEGER' | 'BLOB' | 'CLOB' ( 'CHARACTER' 'SET' ( identifier | column_spec CHARSET_ATTR ) )? | 'NCLOB' | 'BFILE' | 'ROWID' | 'UROWID' ( LPAREN NUMBER RPAREN )? );
    def datatype(self, ):
        retval = self.datatype_return()
        retval.start = self.input.LT(1)

        datatype_StartIndex = self.input.index()

        root_0 = None

        string_literal200 = None
        string_literal201 = None
        string_literal202 = None
        string_literal203 = None
        string_literal204 = None
        set205 = None
        LPAREN206 = None
        NUMBER207 = None
        COMMA208 = None
        NUMBER209 = None
        RPAREN210 = None
        string_literal211 = None
        string_literal212 = None
        LPAREN213 = None
        NUMBER214 = None
        RPAREN215 = None
        string_literal216 = None
        LPAREN217 = None
        NUMBER218 = None
        RPAREN219 = None
        string_literal220 = None
        string_literal221 = None
        LPAREN224 = None
        NUMBER225 = None
        RPAREN226 = None
        string_literal227 = None
        LPAREN229 = None
        NUMBER230 = None
        RPAREN231 = None
        LPAREN234 = None
        NUMBER235 = None
        RPAREN236 = None
        string_literal237 = None
        LPAREN241 = None
        NUMBER242 = None
        RPAREN243 = None
        string_literal244 = None
        string_literal248 = None
        string_literal249 = None
        string_literal250 = None
        string_literal251 = None
        LPAREN252 = None
        NUMBER253 = None
        RPAREN254 = None
        string_literal255 = None
        string_literal256 = None
        string_literal258 = None
        LPAREN260 = None
        NUMBER261 = None
        string_literal263 = None
        RPAREN264 = None
        string_literal265 = None
        string_literal266 = None
        CHARSET_ATTR269 = None
        string_literal270 = None
        LPAREN271 = None
        NUMBER272 = None
        string_literal274 = None
        RPAREN275 = None
        string_literal276 = None
        string_literal277 = None
        CHARSET_ATTR280 = None
        string_literal281 = None
        LPAREN282 = None
        NUMBER283 = None
        string_literal285 = None
        RPAREN286 = None
        string_literal287 = None
        string_literal288 = None
        CHARSET_ATTR291 = None
        string_literal292 = None
        LPAREN294 = None
        NUMBER295 = None
        RPAREN296 = None
        string_literal297 = None
        LPAREN299 = None
        NUMBER300 = None
        RPAREN301 = None
        string_literal302 = None
        LPAREN303 = None
        NUMBER304 = None
        RPAREN305 = None
        string_literal306 = None
        LPAREN307 = None
        NUMBER308 = None
        RPAREN309 = None
        string_literal310 = None
        set311 = None
        LPAREN313 = None
        NUMBER314 = None
        RPAREN315 = None
        string_literal316 = None
        string_literal317 = None
        string_literal318 = None
        string_literal319 = None
        string_literal320 = None
        string_literal321 = None
        CHARSET_ATTR324 = None
        string_literal325 = None
        string_literal326 = None
        string_literal327 = None
        string_literal328 = None
        LPAREN329 = None
        NUMBER330 = None
        RPAREN331 = None
        keyINTERVAL222 = None

        keyDAY223 = None

        keySECOND228 = None

        keyINTERVAL232 = None

        keyYEAR233 = None

        keyMONTH238 = None

        keyTIME239 = None

        keyTIMESTAMP240 = None

        keyLOCAL245 = None

        keyTIME246 = None

        keyZONE247 = None

        keyPRECISION257 = None

        keyVARYING259 = None

        keyBYTE262 = None

        identifier267 = None

        column_spec268 = None

        keyBYTE273 = None

        identifier278 = None

        column_spec279 = None

        keyBYTE284 = None

        identifier289 = None

        column_spec290 = None

        keyVARYING293 = None

        keyVARYING298 = None

        keyVARYING312 = None

        identifier322 = None

        column_spec323 = None


        string_literal200_tree = None
        string_literal201_tree = None
        string_literal202_tree = None
        string_literal203_tree = None
        string_literal204_tree = None
        set205_tree = None
        LPAREN206_tree = None
        NUMBER207_tree = None
        COMMA208_tree = None
        NUMBER209_tree = None
        RPAREN210_tree = None
        string_literal211_tree = None
        string_literal212_tree = None
        LPAREN213_tree = None
        NUMBER214_tree = None
        RPAREN215_tree = None
        string_literal216_tree = None
        LPAREN217_tree = None
        NUMBER218_tree = None
        RPAREN219_tree = None
        string_literal220_tree = None
        string_literal221_tree = None
        LPAREN224_tree = None
        NUMBER225_tree = None
        RPAREN226_tree = None
        string_literal227_tree = None
        LPAREN229_tree = None
        NUMBER230_tree = None
        RPAREN231_tree = None
        LPAREN234_tree = None
        NUMBER235_tree = None
        RPAREN236_tree = None
        string_literal237_tree = None
        LPAREN241_tree = None
        NUMBER242_tree = None
        RPAREN243_tree = None
        string_literal244_tree = None
        string_literal248_tree = None
        string_literal249_tree = None
        string_literal250_tree = None
        string_literal251_tree = None
        LPAREN252_tree = None
        NUMBER253_tree = None
        RPAREN254_tree = None
        string_literal255_tree = None
        string_literal256_tree = None
        string_literal258_tree = None
        LPAREN260_tree = None
        NUMBER261_tree = None
        string_literal263_tree = None
        RPAREN264_tree = None
        string_literal265_tree = None
        string_literal266_tree = None
        CHARSET_ATTR269_tree = None
        string_literal270_tree = None
        LPAREN271_tree = None
        NUMBER272_tree = None
        string_literal274_tree = None
        RPAREN275_tree = None
        string_literal276_tree = None
        string_literal277_tree = None
        CHARSET_ATTR280_tree = None
        string_literal281_tree = None
        LPAREN282_tree = None
        NUMBER283_tree = None
        string_literal285_tree = None
        RPAREN286_tree = None
        string_literal287_tree = None
        string_literal288_tree = None
        CHARSET_ATTR291_tree = None
        string_literal292_tree = None
        LPAREN294_tree = None
        NUMBER295_tree = None
        RPAREN296_tree = None
        string_literal297_tree = None
        LPAREN299_tree = None
        NUMBER300_tree = None
        RPAREN301_tree = None
        string_literal302_tree = None
        LPAREN303_tree = None
        NUMBER304_tree = None
        RPAREN305_tree = None
        string_literal306_tree = None
        LPAREN307_tree = None
        NUMBER308_tree = None
        RPAREN309_tree = None
        string_literal310_tree = None
        set311_tree = None
        LPAREN313_tree = None
        NUMBER314_tree = None
        RPAREN315_tree = None
        string_literal316_tree = None
        string_literal317_tree = None
        string_literal318_tree = None
        string_literal319_tree = None
        string_literal320_tree = None
        string_literal321_tree = None
        CHARSET_ATTR324_tree = None
        string_literal325_tree = None
        string_literal326_tree = None
        string_literal327_tree = None
        string_literal328_tree = None
        LPAREN329_tree = None
        NUMBER330_tree = None
        RPAREN331_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 28):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:229:2: ( 'BINARY_INTEGER' | 'BINARY_FLOAT' | 'BINARY_DOUBLE' | 'NATURAL' | 'POSITIVE' | ( 'NUMBER' | 'NUMERIC' | 'DECIMAL' | 'DEC' ) ( LPAREN NUMBER ( COMMA NUMBER )? RPAREN )? | 'LONG' ( 'RAW' )? ( LPAREN NUMBER RPAREN )? | 'RAW' ( LPAREN NUMBER RPAREN )? | 'BOOLEAN' | 'DATE' | keyINTERVAL keyDAY ( LPAREN NUMBER RPAREN )? 'TO' keySECOND ( LPAREN NUMBER RPAREN )? | keyINTERVAL keyYEAR ( LPAREN NUMBER RPAREN )? 'TO' keyMONTH | ( keyTIME | keyTIMESTAMP ) ( LPAREN NUMBER RPAREN )? ( 'WITH' ( keyLOCAL )? keyTIME keyZONE )? | 'INTEGER' | 'INT' | 'SMALLINT' | 'FLOAT' ( LPAREN NUMBER RPAREN )? | 'REAL' | 'DOUBLE' keyPRECISION | 'CHAR' ( keyVARYING )? ( LPAREN NUMBER ( keyBYTE | 'CHAR' )? RPAREN )? ( 'CHARACTER' 'SET' ( identifier | column_spec CHARSET_ATTR ) )? | 'VARCHAR' ( LPAREN NUMBER ( keyBYTE | 'CHAR' )? RPAREN )? ( 'CHARACTER' 'SET' ( identifier | column_spec CHARSET_ATTR ) )? | 'VARCHAR2' ( LPAREN NUMBER ( keyBYTE | 'CHAR' )? RPAREN )? ( 'CHARACTER' 'SET' ( identifier | column_spec CHARSET_ATTR ) )? | 'CHARACTER' ( keyVARYING )? ( LPAREN NUMBER RPAREN )? | 'NCHAR' ( keyVARYING )? ( LPAREN NUMBER RPAREN )? | 'NVARCHAR' ( LPAREN NUMBER RPAREN )? | 'NVARCHAR2' ( LPAREN NUMBER RPAREN )? | 'NATIONAL' ( 'CHARACTER' | 'CHAR' ) ( keyVARYING )? ( LPAREN NUMBER RPAREN )? | 'MLSLABEL' | 'PLS_INTEGER' | 'BLOB' | 'CLOB' ( 'CHARACTER' 'SET' ( identifier | column_spec CHARSET_ATTR ) )? | 'NCLOB' | 'BFILE' | 'ROWID' | 'UROWID' ( LPAREN NUMBER RPAREN )? )
                alt79 = 35
                LA79 = self.input.LA(1)
                if LA79 == 61:
                    alt79 = 1
                elif LA79 == 60:
                    alt79 = 2
                elif LA79 == 59:
                    alt79 = 3
                elif LA79 == 115:
                    alt79 = 4
                elif LA79 == 132:
                    alt79 = 5
                elif LA79 == 75 or LA79 == 76 or LA79 == 121 or LA79 == 122:
                    alt79 = 6
                elif LA79 == 109:
                    alt79 = 7
                elif LA79 == 137:
                    alt79 = 8
                elif LA79 == 63:
                    alt79 = 9
                elif LA79 == 74:
                    alt79 = 10
                elif LA79 == ID:
                    LA79_11 = self.input.LA(2)

                    if (LA79_11 == ID) :
                        LA79 = self.input.LA(3)
                        if LA79 == LPAREN:
                            LA79_36 = self.input.LA(4)

                            if (LA79_36 == NUMBER) :
                                LA79_38 = self.input.LA(5)

                                if (LA79_38 == RPAREN) :
                                    LA79_40 = self.input.LA(6)

                                    if (LA79_40 == 155) :
                                        LA79_37 = self.input.LA(7)

                                        if (LA79_37 == ID) :
                                            LA79_39 = self.input.LA(8)

                                            if (((((self.synpred114_PLSQL3()) and (self.synpred114_PLSQL3()))) and (((self.input).LT(1).text.upper() == "INTERVAL")))) :
                                                alt79 = 11
                                            elif (((((self.synpred116_PLSQL3()) and (self.synpred116_PLSQL3()))) and (((self.input).LT(1).text.upper() == "INTERVAL")))) :
                                                alt79 = 12
                                            else:
                                                if self._state.backtracking > 0:
                                                    raise BacktrackingFailed


                                                nvae = NoViableAltException("", 79, 39, self.input)

                                                raise nvae


                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 79, 37, self.input)

                                            raise nvae


                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 79, 40, self.input)

                                        raise nvae


                                else:
                                    if self._state.backtracking > 0:
                                        raise BacktrackingFailed


                                    nvae = NoViableAltException("", 79, 38, self.input)

                                    raise nvae


                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 79, 36, self.input)

                                raise nvae


                        elif LA79 == 155:
                            LA79_37 = self.input.LA(4)

                            if (LA79_37 == ID) :
                                LA79_39 = self.input.LA(5)

                                if (((((self.synpred114_PLSQL3()) and (self.synpred114_PLSQL3()))) and (((self.input).LT(1).text.upper() == "INTERVAL")))) :
                                    alt79 = 11
                                elif (((((self.synpred116_PLSQL3()) and (self.synpred116_PLSQL3()))) and (((self.input).LT(1).text.upper() == "INTERVAL")))) :
                                    alt79 = 12
                                else:
                                    if self._state.backtracking > 0:
                                        raise BacktrackingFailed


                                    nvae = NoViableAltException("", 79, 39, self.input)

                                    raise nvae


                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 79, 37, self.input)

                                raise nvae


                        elif LA79 == DOT or LA79 == DOUBLEQUOTED_STRING or LA79 == ID or LA79 == MINUS or LA79 == NUMBER or LA79 == PLUS or LA79 == QUOTED_STRING or LA79 == 58 or LA79 == 59 or LA79 == 60 or LA79 == 61 or LA79 == 62 or LA79 == 63 or LA79 == 66 or LA79 == 67 or LA79 == 68 or LA79 == 72 or LA79 == 74 or LA79 == 75 or LA79 == 76 or LA79 == 82 or LA79 == 86 or LA79 == 91 or LA79 == 102 or LA79 == 103 or LA79 == 109 or LA79 == 112 or LA79 == 114 or LA79 == 115 or LA79 == 116 or LA79 == 117 or LA79 == 121 or LA79 == 122 or LA79 == 123 or LA79 == 124 or LA79 == 131 or LA79 == 132 or LA79 == 137 or LA79 == 138 or LA79 == 144 or LA79 == 150 or LA79 == 160 or LA79 == 162 or LA79 == 163:
                            alt79 = 13
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 79, 34, self.input)

                            raise nvae


                    elif (LA79_11 == EOF or LA79_11 == ASSIGN or LA79_11 == COMMA or LA79_11 == DOUBLEQUOTED_STRING or LA79_11 == LPAREN or (RPAREN <= LA79_11 <= SEMI) or LA79_11 == 53 or LA79_11 == 56 or LA79_11 == 73 or LA79_11 == 78 or LA79_11 == 85 or LA79_11 == 94 or LA79_11 == 100 or LA79_11 == 106 or LA79_11 == 118 or LA79_11 == 133 or LA79_11 == 135 or LA79_11 == 167) :
                        alt79 = 13
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 79, 11, self.input)

                        raise nvae


                elif LA79 == 103:
                    alt79 = 14
                elif LA79 == 102:
                    alt79 = 15
                elif LA79 == 150:
                    alt79 = 16
                elif LA79 == 91:
                    alt79 = 17
                elif LA79 == 138:
                    alt79 = 18
                elif LA79 == 82:
                    alt79 = 19
                elif LA79 == 66:
                    alt79 = 20
                elif LA79 == 162:
                    alt79 = 21
                elif LA79 == 163:
                    alt79 = 22
                elif LA79 == 67:
                    alt79 = 23
                elif LA79 == 116:
                    alt79 = 24
                elif LA79 == 123:
                    alt79 = 25
                elif LA79 == 124:
                    alt79 = 26
                elif LA79 == 114:
                    alt79 = 27
                elif LA79 == 112:
                    alt79 = 28
                elif LA79 == 131:
                    alt79 = 29
                elif LA79 == 62:
                    alt79 = 30
                elif LA79 == 68:
                    alt79 = 31
                elif LA79 == 117:
                    alt79 = 32
                elif LA79 == 58:
                    alt79 = 33
                elif LA79 == 144:
                    alt79 = 34
                elif LA79 == 160:
                    alt79 = 35
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 79, 0, self.input)

                    raise nvae


                if alt79 == 1:
                    # ./output/PLSQL3.g:229:4: 'BINARY_INTEGER'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal200 = self.match(self.input, 61, self.FOLLOW_61_in_datatype1163)
                    if self._state.backtracking == 0:
                        string_literal200_tree = self._adaptor.createWithPayload(string_literal200)
                        self._adaptor.addChild(root_0, string_literal200_tree)




                elif alt79 == 2:
                    # ./output/PLSQL3.g:230:4: 'BINARY_FLOAT'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal201 = self.match(self.input, 60, self.FOLLOW_60_in_datatype1169)
                    if self._state.backtracking == 0:
                        string_literal201_tree = self._adaptor.createWithPayload(string_literal201)
                        self._adaptor.addChild(root_0, string_literal201_tree)




                elif alt79 == 3:
                    # ./output/PLSQL3.g:231:4: 'BINARY_DOUBLE'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal202 = self.match(self.input, 59, self.FOLLOW_59_in_datatype1174)
                    if self._state.backtracking == 0:
                        string_literal202_tree = self._adaptor.createWithPayload(string_literal202)
                        self._adaptor.addChild(root_0, string_literal202_tree)




                elif alt79 == 4:
                    # ./output/PLSQL3.g:232:4: 'NATURAL'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal203 = self.match(self.input, 115, self.FOLLOW_115_in_datatype1179)
                    if self._state.backtracking == 0:
                        string_literal203_tree = self._adaptor.createWithPayload(string_literal203)
                        self._adaptor.addChild(root_0, string_literal203_tree)




                elif alt79 == 5:
                    # ./output/PLSQL3.g:233:4: 'POSITIVE'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal204 = self.match(self.input, 132, self.FOLLOW_132_in_datatype1185)
                    if self._state.backtracking == 0:
                        string_literal204_tree = self._adaptor.createWithPayload(string_literal204)
                        self._adaptor.addChild(root_0, string_literal204_tree)




                elif alt79 == 6:
                    # ./output/PLSQL3.g:234:4: ( 'NUMBER' | 'NUMERIC' | 'DECIMAL' | 'DEC' ) ( LPAREN NUMBER ( COMMA NUMBER )? RPAREN )?
                    pass
                    root_0 = self._adaptor.nil()


                    set205 = self.input.LT(1)

                    if (75 <= self.input.LA(1) <= 76) or (121 <= self.input.LA(1) <= 122):
                        self.input.consume()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set205))

                        self._state.errorRecovery = False


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        mse = MismatchedSetException(None, self.input)
                        raise mse



                    # ./output/PLSQL3.g:234:49: ( LPAREN NUMBER ( COMMA NUMBER )? RPAREN )?
                    alt43 = 2
                    LA43_0 = self.input.LA(1)

                    if (LA43_0 == LPAREN) :
                        alt43 = 1
                    if alt43 == 1:
                        # ./output/PLSQL3.g:234:51: LPAREN NUMBER ( COMMA NUMBER )? RPAREN
                        pass
                        LPAREN206 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1211)
                        if self._state.backtracking == 0:
                            LPAREN206_tree = self._adaptor.createWithPayload(LPAREN206)
                            self._adaptor.addChild(root_0, LPAREN206_tree)



                        NUMBER207 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1213)
                        if self._state.backtracking == 0:
                            NUMBER207_tree = self._adaptor.createWithPayload(NUMBER207)
                            self._adaptor.addChild(root_0, NUMBER207_tree)



                        # ./output/PLSQL3.g:234:65: ( COMMA NUMBER )?
                        alt42 = 2
                        LA42_0 = self.input.LA(1)

                        if (LA42_0 == COMMA) :
                            alt42 = 1
                        if alt42 == 1:
                            # ./output/PLSQL3.g:234:67: COMMA NUMBER
                            pass
                            COMMA208 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_datatype1217)
                            if self._state.backtracking == 0:
                                COMMA208_tree = self._adaptor.createWithPayload(COMMA208)
                                self._adaptor.addChild(root_0, COMMA208_tree)



                            NUMBER209 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1219)
                            if self._state.backtracking == 0:
                                NUMBER209_tree = self._adaptor.createWithPayload(NUMBER209)
                                self._adaptor.addChild(root_0, NUMBER209_tree)






                        RPAREN210 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1224)
                        if self._state.backtracking == 0:
                            RPAREN210_tree = self._adaptor.createWithPayload(RPAREN210)
                            self._adaptor.addChild(root_0, RPAREN210_tree)







                elif alt79 == 7:
                    # ./output/PLSQL3.g:235:4: 'LONG' ( 'RAW' )? ( LPAREN NUMBER RPAREN )?
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal211 = self.match(self.input, 109, self.FOLLOW_109_in_datatype1232)
                    if self._state.backtracking == 0:
                        string_literal211_tree = self._adaptor.createWithPayload(string_literal211)
                        self._adaptor.addChild(root_0, string_literal211_tree)



                    # ./output/PLSQL3.g:235:11: ( 'RAW' )?
                    alt44 = 2
                    LA44_0 = self.input.LA(1)

                    if (LA44_0 == 137) :
                        alt44 = 1
                    if alt44 == 1:
                        # ./output/PLSQL3.g:235:13: 'RAW'
                        pass
                        string_literal212 = self.match(self.input, 137, self.FOLLOW_137_in_datatype1236)
                        if self._state.backtracking == 0:
                            string_literal212_tree = self._adaptor.createWithPayload(string_literal212)
                            self._adaptor.addChild(root_0, string_literal212_tree)






                    # ./output/PLSQL3.g:235:21: ( LPAREN NUMBER RPAREN )?
                    alt45 = 2
                    LA45_0 = self.input.LA(1)

                    if (LA45_0 == LPAREN) :
                        alt45 = 1
                    if alt45 == 1:
                        # ./output/PLSQL3.g:235:23: LPAREN NUMBER RPAREN
                        pass
                        LPAREN213 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1242)
                        if self._state.backtracking == 0:
                            LPAREN213_tree = self._adaptor.createWithPayload(LPAREN213)
                            self._adaptor.addChild(root_0, LPAREN213_tree)



                        NUMBER214 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1244)
                        if self._state.backtracking == 0:
                            NUMBER214_tree = self._adaptor.createWithPayload(NUMBER214)
                            self._adaptor.addChild(root_0, NUMBER214_tree)



                        RPAREN215 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1246)
                        if self._state.backtracking == 0:
                            RPAREN215_tree = self._adaptor.createWithPayload(RPAREN215)
                            self._adaptor.addChild(root_0, RPAREN215_tree)







                elif alt79 == 8:
                    # ./output/PLSQL3.g:236:4: 'RAW' ( LPAREN NUMBER RPAREN )?
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal216 = self.match(self.input, 137, self.FOLLOW_137_in_datatype1254)
                    if self._state.backtracking == 0:
                        string_literal216_tree = self._adaptor.createWithPayload(string_literal216)
                        self._adaptor.addChild(root_0, string_literal216_tree)



                    # ./output/PLSQL3.g:236:10: ( LPAREN NUMBER RPAREN )?
                    alt46 = 2
                    LA46_0 = self.input.LA(1)

                    if (LA46_0 == LPAREN) :
                        alt46 = 1
                    if alt46 == 1:
                        # ./output/PLSQL3.g:236:12: LPAREN NUMBER RPAREN
                        pass
                        LPAREN217 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1258)
                        if self._state.backtracking == 0:
                            LPAREN217_tree = self._adaptor.createWithPayload(LPAREN217)
                            self._adaptor.addChild(root_0, LPAREN217_tree)



                        NUMBER218 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1260)
                        if self._state.backtracking == 0:
                            NUMBER218_tree = self._adaptor.createWithPayload(NUMBER218)
                            self._adaptor.addChild(root_0, NUMBER218_tree)



                        RPAREN219 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1262)
                        if self._state.backtracking == 0:
                            RPAREN219_tree = self._adaptor.createWithPayload(RPAREN219)
                            self._adaptor.addChild(root_0, RPAREN219_tree)







                elif alt79 == 9:
                    # ./output/PLSQL3.g:237:4: 'BOOLEAN'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal220 = self.match(self.input, 63, self.FOLLOW_63_in_datatype1270)
                    if self._state.backtracking == 0:
                        string_literal220_tree = self._adaptor.createWithPayload(string_literal220)
                        self._adaptor.addChild(root_0, string_literal220_tree)




                elif alt79 == 10:
                    # ./output/PLSQL3.g:238:4: 'DATE'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal221 = self.match(self.input, 74, self.FOLLOW_74_in_datatype1275)
                    if self._state.backtracking == 0:
                        string_literal221_tree = self._adaptor.createWithPayload(string_literal221)
                        self._adaptor.addChild(root_0, string_literal221_tree)




                elif alt79 == 11:
                    # ./output/PLSQL3.g:239:4: keyINTERVAL keyDAY ( LPAREN NUMBER RPAREN )? 'TO' keySECOND ( LPAREN NUMBER RPAREN )?
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_keyINTERVAL_in_datatype1280)
                    keyINTERVAL222 = self.keyINTERVAL()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyINTERVAL222.tree)


                    self._state.following.append(self.FOLLOW_keyDAY_in_datatype1282)
                    keyDAY223 = self.keyDAY()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyDAY223.tree)


                    # ./output/PLSQL3.g:239:23: ( LPAREN NUMBER RPAREN )?
                    alt47 = 2
                    LA47_0 = self.input.LA(1)

                    if (LA47_0 == LPAREN) :
                        alt47 = 1
                    if alt47 == 1:
                        # ./output/PLSQL3.g:239:25: LPAREN NUMBER RPAREN
                        pass
                        LPAREN224 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1286)
                        if self._state.backtracking == 0:
                            LPAREN224_tree = self._adaptor.createWithPayload(LPAREN224)
                            self._adaptor.addChild(root_0, LPAREN224_tree)



                        NUMBER225 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1288)
                        if self._state.backtracking == 0:
                            NUMBER225_tree = self._adaptor.createWithPayload(NUMBER225)
                            self._adaptor.addChild(root_0, NUMBER225_tree)



                        RPAREN226 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1290)
                        if self._state.backtracking == 0:
                            RPAREN226_tree = self._adaptor.createWithPayload(RPAREN226)
                            self._adaptor.addChild(root_0, RPAREN226_tree)






                    string_literal227 = self.match(self.input, 155, self.FOLLOW_155_in_datatype1295)
                    if self._state.backtracking == 0:
                        string_literal227_tree = self._adaptor.createWithPayload(string_literal227)
                        self._adaptor.addChild(root_0, string_literal227_tree)



                    self._state.following.append(self.FOLLOW_keySECOND_in_datatype1297)
                    keySECOND228 = self.keySECOND()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keySECOND228.tree)


                    # ./output/PLSQL3.g:239:64: ( LPAREN NUMBER RPAREN )?
                    alt48 = 2
                    LA48_0 = self.input.LA(1)

                    if (LA48_0 == LPAREN) :
                        alt48 = 1
                    if alt48 == 1:
                        # ./output/PLSQL3.g:239:66: LPAREN NUMBER RPAREN
                        pass
                        LPAREN229 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1301)
                        if self._state.backtracking == 0:
                            LPAREN229_tree = self._adaptor.createWithPayload(LPAREN229)
                            self._adaptor.addChild(root_0, LPAREN229_tree)



                        NUMBER230 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1303)
                        if self._state.backtracking == 0:
                            NUMBER230_tree = self._adaptor.createWithPayload(NUMBER230)
                            self._adaptor.addChild(root_0, NUMBER230_tree)



                        RPAREN231 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1305)
                        if self._state.backtracking == 0:
                            RPAREN231_tree = self._adaptor.createWithPayload(RPAREN231)
                            self._adaptor.addChild(root_0, RPAREN231_tree)







                elif alt79 == 12:
                    # ./output/PLSQL3.g:240:4: keyINTERVAL keyYEAR ( LPAREN NUMBER RPAREN )? 'TO' keyMONTH
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_keyINTERVAL_in_datatype1313)
                    keyINTERVAL232 = self.keyINTERVAL()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyINTERVAL232.tree)


                    self._state.following.append(self.FOLLOW_keyYEAR_in_datatype1315)
                    keyYEAR233 = self.keyYEAR()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyYEAR233.tree)


                    # ./output/PLSQL3.g:240:24: ( LPAREN NUMBER RPAREN )?
                    alt49 = 2
                    LA49_0 = self.input.LA(1)

                    if (LA49_0 == LPAREN) :
                        alt49 = 1
                    if alt49 == 1:
                        # ./output/PLSQL3.g:240:26: LPAREN NUMBER RPAREN
                        pass
                        LPAREN234 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1319)
                        if self._state.backtracking == 0:
                            LPAREN234_tree = self._adaptor.createWithPayload(LPAREN234)
                            self._adaptor.addChild(root_0, LPAREN234_tree)



                        NUMBER235 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1321)
                        if self._state.backtracking == 0:
                            NUMBER235_tree = self._adaptor.createWithPayload(NUMBER235)
                            self._adaptor.addChild(root_0, NUMBER235_tree)



                        RPAREN236 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1323)
                        if self._state.backtracking == 0:
                            RPAREN236_tree = self._adaptor.createWithPayload(RPAREN236)
                            self._adaptor.addChild(root_0, RPAREN236_tree)






                    string_literal237 = self.match(self.input, 155, self.FOLLOW_155_in_datatype1328)
                    if self._state.backtracking == 0:
                        string_literal237_tree = self._adaptor.createWithPayload(string_literal237)
                        self._adaptor.addChild(root_0, string_literal237_tree)



                    self._state.following.append(self.FOLLOW_keyMONTH_in_datatype1330)
                    keyMONTH238 = self.keyMONTH()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyMONTH238.tree)



                elif alt79 == 13:
                    # ./output/PLSQL3.g:241:4: ( keyTIME | keyTIMESTAMP ) ( LPAREN NUMBER RPAREN )? ( 'WITH' ( keyLOCAL )? keyTIME keyZONE )?
                    pass
                    root_0 = self._adaptor.nil()


                    # ./output/PLSQL3.g:241:4: ( keyTIME | keyTIMESTAMP )
                    alt50 = 2
                    LA50_0 = self.input.LA(1)

                    if (LA50_0 == ID) :
                        LA50_1 = self.input.LA(2)

                        if (((((((self.input).LT(1).text.upper() == "TIME")) and (((this.input).LT(1).text.upper() == "TIME")))) and (self.synpred117_PLSQL3()))) :
                            alt50 = 1
                        elif (((self.input).LT(1).text.upper() == "TIMESTAMP")) :
                            alt50 = 2
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 50, 1, self.input)

                            raise nvae


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 50, 0, self.input)

                        raise nvae


                    if alt50 == 1:
                        # ./output/PLSQL3.g:241:6: keyTIME
                        pass
                        self._state.following.append(self.FOLLOW_keyTIME_in_datatype1337)
                        keyTIME239 = self.keyTIME()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyTIME239.tree)



                    elif alt50 == 2:
                        # ./output/PLSQL3.g:241:16: keyTIMESTAMP
                        pass
                        self._state.following.append(self.FOLLOW_keyTIMESTAMP_in_datatype1341)
                        keyTIMESTAMP240 = self.keyTIMESTAMP()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyTIMESTAMP240.tree)





                    # ./output/PLSQL3.g:241:31: ( LPAREN NUMBER RPAREN )?
                    alt51 = 2
                    LA51_0 = self.input.LA(1)

                    if (LA51_0 == LPAREN) :
                        alt51 = 1
                    if alt51 == 1:
                        # ./output/PLSQL3.g:241:33: LPAREN NUMBER RPAREN
                        pass
                        LPAREN241 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1347)
                        if self._state.backtracking == 0:
                            LPAREN241_tree = self._adaptor.createWithPayload(LPAREN241)
                            self._adaptor.addChild(root_0, LPAREN241_tree)



                        NUMBER242 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1349)
                        if self._state.backtracking == 0:
                            NUMBER242_tree = self._adaptor.createWithPayload(NUMBER242)
                            self._adaptor.addChild(root_0, NUMBER242_tree)



                        RPAREN243 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1351)
                        if self._state.backtracking == 0:
                            RPAREN243_tree = self._adaptor.createWithPayload(RPAREN243)
                            self._adaptor.addChild(root_0, RPAREN243_tree)






                    # ./output/PLSQL3.g:241:57: ( 'WITH' ( keyLOCAL )? keyTIME keyZONE )?
                    alt53 = 2
                    LA53_0 = self.input.LA(1)

                    if (LA53_0 == 167) :
                        alt53 = 1
                    if alt53 == 1:
                        # ./output/PLSQL3.g:241:59: 'WITH' ( keyLOCAL )? keyTIME keyZONE
                        pass
                        string_literal244 = self.match(self.input, 167, self.FOLLOW_167_in_datatype1358)
                        if self._state.backtracking == 0:
                            string_literal244_tree = self._adaptor.createWithPayload(string_literal244)
                            self._adaptor.addChild(root_0, string_literal244_tree)



                        # ./output/PLSQL3.g:241:66: ( keyLOCAL )?
                        alt52 = 2
                        LA52_0 = self.input.LA(1)

                        if (LA52_0 == ID) :
                            LA52_1 = self.input.LA(2)

                            if (LA52_1 == ID) :
                                LA52_2 = self.input.LA(3)

                                if (LA52_2 == ID) :
                                    LA52 = self.input.LA(4)
                                    if LA52 == EOF or LA52 == ASSIGN or LA52 == COMMA or LA52 == RPAREN or LA52 == SEMI or LA52 == 53 or LA52 == 56 or LA52 == 73 or LA52 == 78 or LA52 == 85 or LA52 == 94 or LA52 == 100 or LA52 == 106 or LA52 == 118 or LA52 == 133 or LA52 == 135:
                                        alt52 = 1
                                    elif LA52 == ID:
                                        LA52 = self.input.LA(5)
                                        if LA52 == DOUBLEQUOTED_STRING or LA52 == MINUS or LA52 == NUMBER or LA52 == PLUS or LA52 == QUOTED_STRING or LA52 == 58 or LA52 == 59 or LA52 == 60 or LA52 == 61 or LA52 == 62 or LA52 == 63 or LA52 == 66 or LA52 == 67 or LA52 == 68 or LA52 == 72 or LA52 == 74 or LA52 == 75 or LA52 == 76 or LA52 == 82 or LA52 == 86 or LA52 == 91 or LA52 == 102 or LA52 == 103 or LA52 == 109 or LA52 == 112 or LA52 == 114 or LA52 == 115 or LA52 == 116 or LA52 == 117 or LA52 == 121 or LA52 == 122 or LA52 == 123 or LA52 == 124 or LA52 == 131 or LA52 == 132 or LA52 == 137 or LA52 == 138 or LA52 == 144 or LA52 == 150 or LA52 == 160 or LA52 == 162 or LA52 == 163:
                                            alt52 = 1
                                        elif LA52 == ID:
                                            LA52_8 = self.input.LA(6)

                                            if (LA52_8 == ASSIGN or LA52_8 == AT_SIGN or LA52_8 == DOT or LA52_8 == ID or LA52_8 == ROWTYPE_ATTR or LA52_8 == SEMI or LA52_8 == TYPE_ATTR or LA52_8 == 78 or LA52_8 == 106 or LA52_8 == 118 or LA52_8 == 140 or LA52_8 == 167) :
                                                alt52 = 1
                                            elif (LA52_8 == LPAREN) :
                                                LA52_10 = self.input.LA(7)

                                                if (LA52_10 == NUMBER) :
                                                    LA52_12 = self.input.LA(8)

                                                    if (LA52_12 == RPAREN) :
                                                        LA52_13 = self.input.LA(9)

                                                        if (LA52_13 == ASSIGN or LA52_13 == SEMI or LA52_13 == 78 or LA52_13 == 106 or LA52_13 == 118 or LA52_13 == 167) :
                                                            alt52 = 1
                                                elif (LA52_10 == DOUBLEQUOTED_STRING or LA52_10 == ID) :
                                                    alt52 = 1
                                        elif LA52 == DOT:
                                            LA52_9 = self.input.LA(6)

                                            if (LA52_9 == DOUBLEQUOTED_STRING or LA52_9 == ID) :
                                                LA52_11 = self.input.LA(7)

                                                if (LA52_11 == 86) :
                                                    alt52 = 1
                                    elif LA52 == DOUBLEQUOTED_STRING:
                                        LA52_7 = self.input.LA(5)

                                        if (LA52_7 == DOUBLEQUOTED_STRING or LA52_7 == ID or (58 <= LA52_7 <= 63) or (66 <= LA52_7 <= 68) or LA52_7 == 72 or (74 <= LA52_7 <= 76) or LA52_7 == 82 or LA52_7 == 86 or LA52_7 == 91 or (102 <= LA52_7 <= 103) or LA52_7 == 109 or LA52_7 == 112 or (114 <= LA52_7 <= 117) or (121 <= LA52_7 <= 124) or (131 <= LA52_7 <= 132) or (137 <= LA52_7 <= 138) or LA52_7 == 144 or LA52_7 == 150 or LA52_7 == 160 or (162 <= LA52_7 <= 163)) :
                                            alt52 = 1
                                        elif (LA52_7 == DOT) :
                                            LA52_9 = self.input.LA(6)

                                            if (LA52_9 == DOUBLEQUOTED_STRING or LA52_9 == ID) :
                                                LA52_11 = self.input.LA(7)

                                                if (LA52_11 == 86) :
                                                    alt52 = 1
                        if alt52 == 1:
                            # ./output/PLSQL3.g:241:68: keyLOCAL
                            pass
                            self._state.following.append(self.FOLLOW_keyLOCAL_in_datatype1362)
                            keyLOCAL245 = self.keyLOCAL()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, keyLOCAL245.tree)





                        self._state.following.append(self.FOLLOW_keyTIME_in_datatype1367)
                        keyTIME246 = self.keyTIME()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyTIME246.tree)


                        self._state.following.append(self.FOLLOW_keyZONE_in_datatype1369)
                        keyZONE247 = self.keyZONE()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyZONE247.tree)






                elif alt79 == 14:
                    # ./output/PLSQL3.g:242:4: 'INTEGER'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal248 = self.match(self.input, 103, self.FOLLOW_103_in_datatype1376)
                    if self._state.backtracking == 0:
                        string_literal248_tree = self._adaptor.createWithPayload(string_literal248)
                        self._adaptor.addChild(root_0, string_literal248_tree)




                elif alt79 == 15:
                    # ./output/PLSQL3.g:243:4: 'INT'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal249 = self.match(self.input, 102, self.FOLLOW_102_in_datatype1381)
                    if self._state.backtracking == 0:
                        string_literal249_tree = self._adaptor.createWithPayload(string_literal249)
                        self._adaptor.addChild(root_0, string_literal249_tree)




                elif alt79 == 16:
                    # ./output/PLSQL3.g:244:4: 'SMALLINT'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal250 = self.match(self.input, 150, self.FOLLOW_150_in_datatype1386)
                    if self._state.backtracking == 0:
                        string_literal250_tree = self._adaptor.createWithPayload(string_literal250)
                        self._adaptor.addChild(root_0, string_literal250_tree)




                elif alt79 == 17:
                    # ./output/PLSQL3.g:245:4: 'FLOAT' ( LPAREN NUMBER RPAREN )?
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal251 = self.match(self.input, 91, self.FOLLOW_91_in_datatype1391)
                    if self._state.backtracking == 0:
                        string_literal251_tree = self._adaptor.createWithPayload(string_literal251)
                        self._adaptor.addChild(root_0, string_literal251_tree)



                    # ./output/PLSQL3.g:245:12: ( LPAREN NUMBER RPAREN )?
                    alt54 = 2
                    LA54_0 = self.input.LA(1)

                    if (LA54_0 == LPAREN) :
                        alt54 = 1
                    if alt54 == 1:
                        # ./output/PLSQL3.g:245:14: LPAREN NUMBER RPAREN
                        pass
                        LPAREN252 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1395)
                        if self._state.backtracking == 0:
                            LPAREN252_tree = self._adaptor.createWithPayload(LPAREN252)
                            self._adaptor.addChild(root_0, LPAREN252_tree)



                        NUMBER253 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1397)
                        if self._state.backtracking == 0:
                            NUMBER253_tree = self._adaptor.createWithPayload(NUMBER253)
                            self._adaptor.addChild(root_0, NUMBER253_tree)



                        RPAREN254 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1399)
                        if self._state.backtracking == 0:
                            RPAREN254_tree = self._adaptor.createWithPayload(RPAREN254)
                            self._adaptor.addChild(root_0, RPAREN254_tree)







                elif alt79 == 18:
                    # ./output/PLSQL3.g:246:4: 'REAL'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal255 = self.match(self.input, 138, self.FOLLOW_138_in_datatype1407)
                    if self._state.backtracking == 0:
                        string_literal255_tree = self._adaptor.createWithPayload(string_literal255)
                        self._adaptor.addChild(root_0, string_literal255_tree)




                elif alt79 == 19:
                    # ./output/PLSQL3.g:247:4: 'DOUBLE' keyPRECISION
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal256 = self.match(self.input, 82, self.FOLLOW_82_in_datatype1412)
                    if self._state.backtracking == 0:
                        string_literal256_tree = self._adaptor.createWithPayload(string_literal256)
                        self._adaptor.addChild(root_0, string_literal256_tree)



                    self._state.following.append(self.FOLLOW_keyPRECISION_in_datatype1414)
                    keyPRECISION257 = self.keyPRECISION()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyPRECISION257.tree)



                elif alt79 == 20:
                    # ./output/PLSQL3.g:248:4: 'CHAR' ( keyVARYING )? ( LPAREN NUMBER ( keyBYTE | 'CHAR' )? RPAREN )? ( 'CHARACTER' 'SET' ( identifier | column_spec CHARSET_ATTR ) )?
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal258 = self.match(self.input, 66, self.FOLLOW_66_in_datatype1419)
                    if self._state.backtracking == 0:
                        string_literal258_tree = self._adaptor.createWithPayload(string_literal258)
                        self._adaptor.addChild(root_0, string_literal258_tree)



                    # ./output/PLSQL3.g:248:16: ( keyVARYING )?
                    alt55 = 2
                    LA55_0 = self.input.LA(1)

                    if (LA55_0 == ID) :
                        LA55 = self.input.LA(2)
                        if LA55 == EOF or LA55 == ASSIGN or LA55 == COMMA or LA55 == LPAREN or LA55 == RPAREN or LA55 == SEMI or LA55 == 53 or LA55 == 56 or LA55 == 73 or LA55 == 78 or LA55 == 85 or LA55 == 94 or LA55 == 100 or LA55 == 106 or LA55 == 118 or LA55 == 133 or LA55 == 135:
                            alt55 = 1
                        elif LA55 == 67:
                            LA55_4 = self.input.LA(3)

                            if (LA55_4 == 148) :
                                alt55 = 1
                        elif LA55 == ID:
                            LA55 = self.input.LA(3)
                            if LA55 == DOUBLEQUOTED_STRING or LA55 == MINUS or LA55 == NUMBER or LA55 == PLUS or LA55 == QUOTED_STRING or LA55 == 58 or LA55 == 59 or LA55 == 60 or LA55 == 61 or LA55 == 62 or LA55 == 63 or LA55 == 66 or LA55 == 67 or LA55 == 68 or LA55 == 72 or LA55 == 74 or LA55 == 75 or LA55 == 76 or LA55 == 82 or LA55 == 86 or LA55 == 91 or LA55 == 102 or LA55 == 103 or LA55 == 109 or LA55 == 112 or LA55 == 114 or LA55 == 115 or LA55 == 116 or LA55 == 117 or LA55 == 121 or LA55 == 122 or LA55 == 123 or LA55 == 124 or LA55 == 131 or LA55 == 132 or LA55 == 137 or LA55 == 138 or LA55 == 144 or LA55 == 150 or LA55 == 160 or LA55 == 162 or LA55 == 163:
                                alt55 = 1
                            elif LA55 == ID:
                                LA55_7 = self.input.LA(4)

                                if (LA55_7 == ASSIGN or LA55_7 == AT_SIGN or LA55_7 == DOT or LA55_7 == ID or LA55_7 == ROWTYPE_ATTR or LA55_7 == SEMI or LA55_7 == TYPE_ATTR or LA55_7 == 78 or LA55_7 == 106 or LA55_7 == 118 or LA55_7 == 140 or LA55_7 == 167) :
                                    alt55 = 1
                                elif (LA55_7 == LPAREN) :
                                    LA55_9 = self.input.LA(5)

                                    if (LA55_9 == NUMBER) :
                                        LA55_11 = self.input.LA(6)

                                        if (LA55_11 == RPAREN) :
                                            LA55_12 = self.input.LA(7)

                                            if (LA55_12 == ASSIGN or LA55_12 == SEMI or LA55_12 == 78 or LA55_12 == 106 or LA55_12 == 118 or LA55_12 == 167) :
                                                alt55 = 1
                                    elif (LA55_9 == DOUBLEQUOTED_STRING or LA55_9 == ID) :
                                        alt55 = 1
                            elif LA55 == DOT:
                                LA55_8 = self.input.LA(4)

                                if (LA55_8 == DOUBLEQUOTED_STRING or LA55_8 == ID) :
                                    LA55_10 = self.input.LA(5)

                                    if (LA55_10 == 86) :
                                        alt55 = 1
                        elif LA55 == DOUBLEQUOTED_STRING:
                            LA55_6 = self.input.LA(3)

                            if (LA55_6 == DOUBLEQUOTED_STRING or LA55_6 == ID or (58 <= LA55_6 <= 63) or (66 <= LA55_6 <= 68) or LA55_6 == 72 or (74 <= LA55_6 <= 76) or LA55_6 == 82 or LA55_6 == 86 or LA55_6 == 91 or (102 <= LA55_6 <= 103) or LA55_6 == 109 or LA55_6 == 112 or (114 <= LA55_6 <= 117) or (121 <= LA55_6 <= 124) or (131 <= LA55_6 <= 132) or (137 <= LA55_6 <= 138) or LA55_6 == 144 or LA55_6 == 150 or LA55_6 == 160 or (162 <= LA55_6 <= 163)) :
                                alt55 = 1
                            elif (LA55_6 == DOT) :
                                LA55_8 = self.input.LA(4)

                                if (LA55_8 == DOUBLEQUOTED_STRING or LA55_8 == ID) :
                                    LA55_10 = self.input.LA(5)

                                    if (LA55_10 == 86) :
                                        alt55 = 1
                    if alt55 == 1:
                        # ./output/PLSQL3.g:248:18: keyVARYING
                        pass
                        self._state.following.append(self.FOLLOW_keyVARYING_in_datatype1428)
                        keyVARYING259 = self.keyVARYING()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyVARYING259.tree)





                    # ./output/PLSQL3.g:248:32: ( LPAREN NUMBER ( keyBYTE | 'CHAR' )? RPAREN )?
                    alt57 = 2
                    LA57_0 = self.input.LA(1)

                    if (LA57_0 == LPAREN) :
                        alt57 = 1
                    if alt57 == 1:
                        # ./output/PLSQL3.g:248:34: LPAREN NUMBER ( keyBYTE | 'CHAR' )? RPAREN
                        pass
                        LPAREN260 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1435)
                        if self._state.backtracking == 0:
                            LPAREN260_tree = self._adaptor.createWithPayload(LPAREN260)
                            self._adaptor.addChild(root_0, LPAREN260_tree)



                        NUMBER261 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1437)
                        if self._state.backtracking == 0:
                            NUMBER261_tree = self._adaptor.createWithPayload(NUMBER261)
                            self._adaptor.addChild(root_0, NUMBER261_tree)



                        # ./output/PLSQL3.g:248:48: ( keyBYTE | 'CHAR' )?
                        alt56 = 3
                        LA56_0 = self.input.LA(1)

                        if (LA56_0 == ID) :
                            alt56 = 1
                        elif (LA56_0 == 66) :
                            alt56 = 2
                        if alt56 == 1:
                            # ./output/PLSQL3.g:248:50: keyBYTE
                            pass
                            self._state.following.append(self.FOLLOW_keyBYTE_in_datatype1441)
                            keyBYTE262 = self.keyBYTE()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, keyBYTE262.tree)



                        elif alt56 == 2:
                            # ./output/PLSQL3.g:248:60: 'CHAR'
                            pass
                            string_literal263 = self.match(self.input, 66, self.FOLLOW_66_in_datatype1445)
                            if self._state.backtracking == 0:
                                string_literal263_tree = self._adaptor.createWithPayload(string_literal263)
                                self._adaptor.addChild(root_0, string_literal263_tree)






                        RPAREN264 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1450)
                        if self._state.backtracking == 0:
                            RPAREN264_tree = self._adaptor.createWithPayload(RPAREN264)
                            self._adaptor.addChild(root_0, RPAREN264_tree)






                    # ./output/PLSQL3.g:248:80: ( 'CHARACTER' 'SET' ( identifier | column_spec CHARSET_ATTR ) )?
                    alt59 = 2
                    LA59_0 = self.input.LA(1)

                    if (LA59_0 == 67) :
                        alt59 = 1
                    if alt59 == 1:
                        # ./output/PLSQL3.g:248:82: 'CHARACTER' 'SET' ( identifier | column_spec CHARSET_ATTR )
                        pass
                        string_literal265 = self.match(self.input, 67, self.FOLLOW_67_in_datatype1457)
                        if self._state.backtracking == 0:
                            string_literal265_tree = self._adaptor.createWithPayload(string_literal265)
                            self._adaptor.addChild(root_0, string_literal265_tree)



                        string_literal266 = self.match(self.input, 148, self.FOLLOW_148_in_datatype1459)
                        if self._state.backtracking == 0:
                            string_literal266_tree = self._adaptor.createWithPayload(string_literal266)
                            self._adaptor.addChild(root_0, string_literal266_tree)



                        # ./output/PLSQL3.g:248:100: ( identifier | column_spec CHARSET_ATTR )
                        alt58 = 2
                        LA58_0 = self.input.LA(1)

                        if (LA58_0 == DOUBLEQUOTED_STRING or LA58_0 == ID) :
                            LA58_1 = self.input.LA(2)

                            if (LA58_1 == EOF or LA58_1 == ASSIGN or LA58_1 == COMMA or LA58_1 == DOUBLEQUOTED_STRING or LA58_1 == ID or (RPAREN <= LA58_1 <= SEMI) or LA58_1 == 53 or LA58_1 == 56 or LA58_1 == 73 or LA58_1 == 78 or LA58_1 == 85 or LA58_1 == 94 or LA58_1 == 100 or LA58_1 == 106 or LA58_1 == 118 or LA58_1 == 133 or LA58_1 == 135) :
                                alt58 = 1
                            elif (LA58_1 == CHARSET_ATTR or LA58_1 == DOT) :
                                alt58 = 2
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 58, 1, self.input)

                                raise nvae


                        elif (LA58_0 == 144) :
                            alt58 = 2
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 58, 0, self.input)

                            raise nvae


                        if alt58 == 1:
                            # ./output/PLSQL3.g:248:102: identifier
                            pass
                            self._state.following.append(self.FOLLOW_identifier_in_datatype1463)
                            identifier267 = self.identifier()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, identifier267.tree)



                        elif alt58 == 2:
                            # ./output/PLSQL3.g:248:115: column_spec CHARSET_ATTR
                            pass
                            self._state.following.append(self.FOLLOW_column_spec_in_datatype1467)
                            column_spec268 = self.column_spec()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, column_spec268.tree)


                            CHARSET_ATTR269 = self.match(self.input, CHARSET_ATTR, self.FOLLOW_CHARSET_ATTR_in_datatype1469)
                            if self._state.backtracking == 0:
                                CHARSET_ATTR269_tree = self._adaptor.createWithPayload(CHARSET_ATTR269)
                                self._adaptor.addChild(root_0, CHARSET_ATTR269_tree)










                elif alt79 == 21:
                    # ./output/PLSQL3.g:249:4: 'VARCHAR' ( LPAREN NUMBER ( keyBYTE | 'CHAR' )? RPAREN )? ( 'CHARACTER' 'SET' ( identifier | column_spec CHARSET_ATTR ) )?
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal270 = self.match(self.input, 162, self.FOLLOW_162_in_datatype1479)
                    if self._state.backtracking == 0:
                        string_literal270_tree = self._adaptor.createWithPayload(string_literal270)
                        self._adaptor.addChild(root_0, string_literal270_tree)



                    # ./output/PLSQL3.g:249:32: ( LPAREN NUMBER ( keyBYTE | 'CHAR' )? RPAREN )?
                    alt61 = 2
                    LA61_0 = self.input.LA(1)

                    if (LA61_0 == LPAREN) :
                        alt61 = 1
                    if alt61 == 1:
                        # ./output/PLSQL3.g:249:34: LPAREN NUMBER ( keyBYTE | 'CHAR' )? RPAREN
                        pass
                        LPAREN271 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1501)
                        if self._state.backtracking == 0:
                            LPAREN271_tree = self._adaptor.createWithPayload(LPAREN271)
                            self._adaptor.addChild(root_0, LPAREN271_tree)



                        NUMBER272 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1503)
                        if self._state.backtracking == 0:
                            NUMBER272_tree = self._adaptor.createWithPayload(NUMBER272)
                            self._adaptor.addChild(root_0, NUMBER272_tree)



                        # ./output/PLSQL3.g:249:48: ( keyBYTE | 'CHAR' )?
                        alt60 = 3
                        LA60_0 = self.input.LA(1)

                        if (LA60_0 == ID) :
                            alt60 = 1
                        elif (LA60_0 == 66) :
                            alt60 = 2
                        if alt60 == 1:
                            # ./output/PLSQL3.g:249:50: keyBYTE
                            pass
                            self._state.following.append(self.FOLLOW_keyBYTE_in_datatype1507)
                            keyBYTE273 = self.keyBYTE()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, keyBYTE273.tree)



                        elif alt60 == 2:
                            # ./output/PLSQL3.g:249:60: 'CHAR'
                            pass
                            string_literal274 = self.match(self.input, 66, self.FOLLOW_66_in_datatype1511)
                            if self._state.backtracking == 0:
                                string_literal274_tree = self._adaptor.createWithPayload(string_literal274)
                                self._adaptor.addChild(root_0, string_literal274_tree)






                        RPAREN275 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1516)
                        if self._state.backtracking == 0:
                            RPAREN275_tree = self._adaptor.createWithPayload(RPAREN275)
                            self._adaptor.addChild(root_0, RPAREN275_tree)






                    # ./output/PLSQL3.g:249:80: ( 'CHARACTER' 'SET' ( identifier | column_spec CHARSET_ATTR ) )?
                    alt63 = 2
                    LA63_0 = self.input.LA(1)

                    if (LA63_0 == 67) :
                        alt63 = 1
                    if alt63 == 1:
                        # ./output/PLSQL3.g:249:82: 'CHARACTER' 'SET' ( identifier | column_spec CHARSET_ATTR )
                        pass
                        string_literal276 = self.match(self.input, 67, self.FOLLOW_67_in_datatype1523)
                        if self._state.backtracking == 0:
                            string_literal276_tree = self._adaptor.createWithPayload(string_literal276)
                            self._adaptor.addChild(root_0, string_literal276_tree)



                        string_literal277 = self.match(self.input, 148, self.FOLLOW_148_in_datatype1525)
                        if self._state.backtracking == 0:
                            string_literal277_tree = self._adaptor.createWithPayload(string_literal277)
                            self._adaptor.addChild(root_0, string_literal277_tree)



                        # ./output/PLSQL3.g:249:100: ( identifier | column_spec CHARSET_ATTR )
                        alt62 = 2
                        LA62_0 = self.input.LA(1)

                        if (LA62_0 == DOUBLEQUOTED_STRING or LA62_0 == ID) :
                            LA62_1 = self.input.LA(2)

                            if (LA62_1 == EOF or LA62_1 == ASSIGN or LA62_1 == COMMA or LA62_1 == DOUBLEQUOTED_STRING or LA62_1 == ID or (RPAREN <= LA62_1 <= SEMI) or LA62_1 == 53 or LA62_1 == 56 or LA62_1 == 73 or LA62_1 == 78 or LA62_1 == 85 or LA62_1 == 94 or LA62_1 == 100 or LA62_1 == 106 or LA62_1 == 118 or LA62_1 == 133 or LA62_1 == 135) :
                                alt62 = 1
                            elif (LA62_1 == CHARSET_ATTR or LA62_1 == DOT) :
                                alt62 = 2
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 62, 1, self.input)

                                raise nvae


                        elif (LA62_0 == 144) :
                            alt62 = 2
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 62, 0, self.input)

                            raise nvae


                        if alt62 == 1:
                            # ./output/PLSQL3.g:249:102: identifier
                            pass
                            self._state.following.append(self.FOLLOW_identifier_in_datatype1529)
                            identifier278 = self.identifier()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, identifier278.tree)



                        elif alt62 == 2:
                            # ./output/PLSQL3.g:249:115: column_spec CHARSET_ATTR
                            pass
                            self._state.following.append(self.FOLLOW_column_spec_in_datatype1533)
                            column_spec279 = self.column_spec()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, column_spec279.tree)


                            CHARSET_ATTR280 = self.match(self.input, CHARSET_ATTR, self.FOLLOW_CHARSET_ATTR_in_datatype1535)
                            if self._state.backtracking == 0:
                                CHARSET_ATTR280_tree = self._adaptor.createWithPayload(CHARSET_ATTR280)
                                self._adaptor.addChild(root_0, CHARSET_ATTR280_tree)










                elif alt79 == 22:
                    # ./output/PLSQL3.g:250:4: 'VARCHAR2' ( LPAREN NUMBER ( keyBYTE | 'CHAR' )? RPAREN )? ( 'CHARACTER' 'SET' ( identifier | column_spec CHARSET_ATTR ) )?
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal281 = self.match(self.input, 163, self.FOLLOW_163_in_datatype1545)
                    if self._state.backtracking == 0:
                        string_literal281_tree = self._adaptor.createWithPayload(string_literal281)
                        self._adaptor.addChild(root_0, string_literal281_tree)



                    # ./output/PLSQL3.g:250:32: ( LPAREN NUMBER ( keyBYTE | 'CHAR' )? RPAREN )?
                    alt65 = 2
                    LA65_0 = self.input.LA(1)

                    if (LA65_0 == LPAREN) :
                        alt65 = 1
                    if alt65 == 1:
                        # ./output/PLSQL3.g:250:34: LPAREN NUMBER ( keyBYTE | 'CHAR' )? RPAREN
                        pass
                        LPAREN282 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1566)
                        if self._state.backtracking == 0:
                            LPAREN282_tree = self._adaptor.createWithPayload(LPAREN282)
                            self._adaptor.addChild(root_0, LPAREN282_tree)



                        NUMBER283 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1568)
                        if self._state.backtracking == 0:
                            NUMBER283_tree = self._adaptor.createWithPayload(NUMBER283)
                            self._adaptor.addChild(root_0, NUMBER283_tree)



                        # ./output/PLSQL3.g:250:48: ( keyBYTE | 'CHAR' )?
                        alt64 = 3
                        LA64_0 = self.input.LA(1)

                        if (LA64_0 == ID) :
                            alt64 = 1
                        elif (LA64_0 == 66) :
                            alt64 = 2
                        if alt64 == 1:
                            # ./output/PLSQL3.g:250:50: keyBYTE
                            pass
                            self._state.following.append(self.FOLLOW_keyBYTE_in_datatype1572)
                            keyBYTE284 = self.keyBYTE()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, keyBYTE284.tree)



                        elif alt64 == 2:
                            # ./output/PLSQL3.g:250:60: 'CHAR'
                            pass
                            string_literal285 = self.match(self.input, 66, self.FOLLOW_66_in_datatype1576)
                            if self._state.backtracking == 0:
                                string_literal285_tree = self._adaptor.createWithPayload(string_literal285)
                                self._adaptor.addChild(root_0, string_literal285_tree)






                        RPAREN286 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1581)
                        if self._state.backtracking == 0:
                            RPAREN286_tree = self._adaptor.createWithPayload(RPAREN286)
                            self._adaptor.addChild(root_0, RPAREN286_tree)






                    # ./output/PLSQL3.g:250:80: ( 'CHARACTER' 'SET' ( identifier | column_spec CHARSET_ATTR ) )?
                    alt67 = 2
                    LA67_0 = self.input.LA(1)

                    if (LA67_0 == 67) :
                        alt67 = 1
                    if alt67 == 1:
                        # ./output/PLSQL3.g:250:82: 'CHARACTER' 'SET' ( identifier | column_spec CHARSET_ATTR )
                        pass
                        string_literal287 = self.match(self.input, 67, self.FOLLOW_67_in_datatype1588)
                        if self._state.backtracking == 0:
                            string_literal287_tree = self._adaptor.createWithPayload(string_literal287)
                            self._adaptor.addChild(root_0, string_literal287_tree)



                        string_literal288 = self.match(self.input, 148, self.FOLLOW_148_in_datatype1590)
                        if self._state.backtracking == 0:
                            string_literal288_tree = self._adaptor.createWithPayload(string_literal288)
                            self._adaptor.addChild(root_0, string_literal288_tree)



                        # ./output/PLSQL3.g:250:100: ( identifier | column_spec CHARSET_ATTR )
                        alt66 = 2
                        LA66_0 = self.input.LA(1)

                        if (LA66_0 == DOUBLEQUOTED_STRING or LA66_0 == ID) :
                            LA66_1 = self.input.LA(2)

                            if (LA66_1 == EOF or LA66_1 == ASSIGN or LA66_1 == COMMA or LA66_1 == DOUBLEQUOTED_STRING or LA66_1 == ID or (RPAREN <= LA66_1 <= SEMI) or LA66_1 == 53 or LA66_1 == 56 or LA66_1 == 73 or LA66_1 == 78 or LA66_1 == 85 or LA66_1 == 94 or LA66_1 == 100 or LA66_1 == 106 or LA66_1 == 118 or LA66_1 == 133 or LA66_1 == 135) :
                                alt66 = 1
                            elif (LA66_1 == CHARSET_ATTR or LA66_1 == DOT) :
                                alt66 = 2
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 66, 1, self.input)

                                raise nvae


                        elif (LA66_0 == 144) :
                            alt66 = 2
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 66, 0, self.input)

                            raise nvae


                        if alt66 == 1:
                            # ./output/PLSQL3.g:250:102: identifier
                            pass
                            self._state.following.append(self.FOLLOW_identifier_in_datatype1594)
                            identifier289 = self.identifier()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, identifier289.tree)



                        elif alt66 == 2:
                            # ./output/PLSQL3.g:250:115: column_spec CHARSET_ATTR
                            pass
                            self._state.following.append(self.FOLLOW_column_spec_in_datatype1598)
                            column_spec290 = self.column_spec()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, column_spec290.tree)


                            CHARSET_ATTR291 = self.match(self.input, CHARSET_ATTR, self.FOLLOW_CHARSET_ATTR_in_datatype1600)
                            if self._state.backtracking == 0:
                                CHARSET_ATTR291_tree = self._adaptor.createWithPayload(CHARSET_ATTR291)
                                self._adaptor.addChild(root_0, CHARSET_ATTR291_tree)










                elif alt79 == 23:
                    # ./output/PLSQL3.g:251:4: 'CHARACTER' ( keyVARYING )? ( LPAREN NUMBER RPAREN )?
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal292 = self.match(self.input, 67, self.FOLLOW_67_in_datatype1610)
                    if self._state.backtracking == 0:
                        string_literal292_tree = self._adaptor.createWithPayload(string_literal292)
                        self._adaptor.addChild(root_0, string_literal292_tree)



                    # ./output/PLSQL3.g:251:16: ( keyVARYING )?
                    alt68 = 2
                    LA68_0 = self.input.LA(1)

                    if (LA68_0 == ID) :
                        LA68 = self.input.LA(2)
                        if LA68 == EOF or LA68 == ASSIGN or LA68 == COMMA or LA68 == LPAREN or LA68 == RPAREN or LA68 == SEMI or LA68 == 53 or LA68 == 56 or LA68 == 73 or LA68 == 78 or LA68 == 85 or LA68 == 94 or LA68 == 100 or LA68 == 106 or LA68 == 118 or LA68 == 133 or LA68 == 135:
                            alt68 = 1
                        elif LA68 == ID:
                            LA68 = self.input.LA(3)
                            if LA68 == DOUBLEQUOTED_STRING or LA68 == MINUS or LA68 == NUMBER or LA68 == PLUS or LA68 == QUOTED_STRING or LA68 == 58 or LA68 == 59 or LA68 == 60 or LA68 == 61 or LA68 == 62 or LA68 == 63 or LA68 == 66 or LA68 == 67 or LA68 == 68 or LA68 == 72 or LA68 == 74 or LA68 == 75 or LA68 == 76 or LA68 == 82 or LA68 == 86 or LA68 == 91 or LA68 == 102 or LA68 == 103 or LA68 == 109 or LA68 == 112 or LA68 == 114 or LA68 == 115 or LA68 == 116 or LA68 == 117 or LA68 == 121 or LA68 == 122 or LA68 == 123 or LA68 == 124 or LA68 == 131 or LA68 == 132 or LA68 == 137 or LA68 == 138 or LA68 == 144 or LA68 == 150 or LA68 == 160 or LA68 == 162 or LA68 == 163:
                                alt68 = 1
                            elif LA68 == ID:
                                LA68_6 = self.input.LA(4)

                                if (LA68_6 == ASSIGN or LA68_6 == AT_SIGN or LA68_6 == DOT or LA68_6 == ID or LA68_6 == ROWTYPE_ATTR or LA68_6 == SEMI or LA68_6 == TYPE_ATTR or LA68_6 == 78 or LA68_6 == 106 or LA68_6 == 118 or LA68_6 == 140 or LA68_6 == 167) :
                                    alt68 = 1
                                elif (LA68_6 == LPAREN) :
                                    LA68_8 = self.input.LA(5)

                                    if (LA68_8 == NUMBER) :
                                        LA68_10 = self.input.LA(6)

                                        if (LA68_10 == RPAREN) :
                                            LA68_11 = self.input.LA(7)

                                            if (LA68_11 == ASSIGN or LA68_11 == SEMI or LA68_11 == 78 or LA68_11 == 106 or LA68_11 == 118 or LA68_11 == 167) :
                                                alt68 = 1
                                    elif (LA68_8 == DOUBLEQUOTED_STRING or LA68_8 == ID) :
                                        alt68 = 1
                            elif LA68 == DOT:
                                LA68_7 = self.input.LA(4)

                                if (LA68_7 == DOUBLEQUOTED_STRING or LA68_7 == ID) :
                                    LA68_9 = self.input.LA(5)

                                    if (LA68_9 == 86) :
                                        alt68 = 1
                        elif LA68 == DOUBLEQUOTED_STRING:
                            LA68_5 = self.input.LA(3)

                            if (LA68_5 == DOUBLEQUOTED_STRING or LA68_5 == ID or (58 <= LA68_5 <= 63) or (66 <= LA68_5 <= 68) or LA68_5 == 72 or (74 <= LA68_5 <= 76) or LA68_5 == 82 or LA68_5 == 86 or LA68_5 == 91 or (102 <= LA68_5 <= 103) or LA68_5 == 109 or LA68_5 == 112 or (114 <= LA68_5 <= 117) or (121 <= LA68_5 <= 124) or (131 <= LA68_5 <= 132) or (137 <= LA68_5 <= 138) or LA68_5 == 144 or LA68_5 == 150 or LA68_5 == 160 or (162 <= LA68_5 <= 163)) :
                                alt68 = 1
                            elif (LA68_5 == DOT) :
                                LA68_7 = self.input.LA(4)

                                if (LA68_7 == DOUBLEQUOTED_STRING or LA68_7 == ID) :
                                    LA68_9 = self.input.LA(5)

                                    if (LA68_9 == 86) :
                                        alt68 = 1
                    if alt68 == 1:
                        # ./output/PLSQL3.g:251:18: keyVARYING
                        pass
                        self._state.following.append(self.FOLLOW_keyVARYING_in_datatype1614)
                        keyVARYING293 = self.keyVARYING()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyVARYING293.tree)





                    # ./output/PLSQL3.g:251:32: ( LPAREN NUMBER RPAREN )?
                    alt69 = 2
                    LA69_0 = self.input.LA(1)

                    if (LA69_0 == LPAREN) :
                        alt69 = 1
                    if alt69 == 1:
                        # ./output/PLSQL3.g:251:34: LPAREN NUMBER RPAREN
                        pass
                        LPAREN294 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1621)
                        if self._state.backtracking == 0:
                            LPAREN294_tree = self._adaptor.createWithPayload(LPAREN294)
                            self._adaptor.addChild(root_0, LPAREN294_tree)



                        NUMBER295 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1623)
                        if self._state.backtracking == 0:
                            NUMBER295_tree = self._adaptor.createWithPayload(NUMBER295)
                            self._adaptor.addChild(root_0, NUMBER295_tree)



                        RPAREN296 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1625)
                        if self._state.backtracking == 0:
                            RPAREN296_tree = self._adaptor.createWithPayload(RPAREN296)
                            self._adaptor.addChild(root_0, RPAREN296_tree)







                elif alt79 == 24:
                    # ./output/PLSQL3.g:252:4: 'NCHAR' ( keyVARYING )? ( LPAREN NUMBER RPAREN )?
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal297 = self.match(self.input, 116, self.FOLLOW_116_in_datatype1633)
                    if self._state.backtracking == 0:
                        string_literal297_tree = self._adaptor.createWithPayload(string_literal297)
                        self._adaptor.addChild(root_0, string_literal297_tree)



                    # ./output/PLSQL3.g:252:16: ( keyVARYING )?
                    alt70 = 2
                    LA70_0 = self.input.LA(1)

                    if (LA70_0 == ID) :
                        LA70 = self.input.LA(2)
                        if LA70 == EOF or LA70 == ASSIGN or LA70 == COMMA or LA70 == LPAREN or LA70 == RPAREN or LA70 == SEMI or LA70 == 53 or LA70 == 56 or LA70 == 73 or LA70 == 78 or LA70 == 85 or LA70 == 94 or LA70 == 100 or LA70 == 106 or LA70 == 118 or LA70 == 133 or LA70 == 135:
                            alt70 = 1
                        elif LA70 == ID:
                            LA70 = self.input.LA(3)
                            if LA70 == DOUBLEQUOTED_STRING or LA70 == MINUS or LA70 == NUMBER or LA70 == PLUS or LA70 == QUOTED_STRING or LA70 == 58 or LA70 == 59 or LA70 == 60 or LA70 == 61 or LA70 == 62 or LA70 == 63 or LA70 == 66 or LA70 == 67 or LA70 == 68 or LA70 == 72 or LA70 == 74 or LA70 == 75 or LA70 == 76 or LA70 == 82 or LA70 == 86 or LA70 == 91 or LA70 == 102 or LA70 == 103 or LA70 == 109 or LA70 == 112 or LA70 == 114 or LA70 == 115 or LA70 == 116 or LA70 == 117 or LA70 == 121 or LA70 == 122 or LA70 == 123 or LA70 == 124 or LA70 == 131 or LA70 == 132 or LA70 == 137 or LA70 == 138 or LA70 == 144 or LA70 == 150 or LA70 == 160 or LA70 == 162 or LA70 == 163:
                                alt70 = 1
                            elif LA70 == ID:
                                LA70_6 = self.input.LA(4)

                                if (LA70_6 == ASSIGN or LA70_6 == AT_SIGN or LA70_6 == DOT or LA70_6 == ID or LA70_6 == ROWTYPE_ATTR or LA70_6 == SEMI or LA70_6 == TYPE_ATTR or LA70_6 == 78 or LA70_6 == 106 or LA70_6 == 118 or LA70_6 == 140 or LA70_6 == 167) :
                                    alt70 = 1
                                elif (LA70_6 == LPAREN) :
                                    LA70_8 = self.input.LA(5)

                                    if (LA70_8 == NUMBER) :
                                        LA70_10 = self.input.LA(6)

                                        if (LA70_10 == RPAREN) :
                                            LA70_11 = self.input.LA(7)

                                            if (LA70_11 == ASSIGN or LA70_11 == SEMI or LA70_11 == 78 or LA70_11 == 106 or LA70_11 == 118 or LA70_11 == 167) :
                                                alt70 = 1
                                    elif (LA70_8 == DOUBLEQUOTED_STRING or LA70_8 == ID) :
                                        alt70 = 1
                            elif LA70 == DOT:
                                LA70_7 = self.input.LA(4)

                                if (LA70_7 == DOUBLEQUOTED_STRING or LA70_7 == ID) :
                                    LA70_9 = self.input.LA(5)

                                    if (LA70_9 == 86) :
                                        alt70 = 1
                        elif LA70 == DOUBLEQUOTED_STRING:
                            LA70_5 = self.input.LA(3)

                            if (LA70_5 == DOUBLEQUOTED_STRING or LA70_5 == ID or (58 <= LA70_5 <= 63) or (66 <= LA70_5 <= 68) or LA70_5 == 72 or (74 <= LA70_5 <= 76) or LA70_5 == 82 or LA70_5 == 86 or LA70_5 == 91 or (102 <= LA70_5 <= 103) or LA70_5 == 109 or LA70_5 == 112 or (114 <= LA70_5 <= 117) or (121 <= LA70_5 <= 124) or (131 <= LA70_5 <= 132) or (137 <= LA70_5 <= 138) or LA70_5 == 144 or LA70_5 == 150 or LA70_5 == 160 or (162 <= LA70_5 <= 163)) :
                                alt70 = 1
                            elif (LA70_5 == DOT) :
                                LA70_7 = self.input.LA(4)

                                if (LA70_7 == DOUBLEQUOTED_STRING or LA70_7 == ID) :
                                    LA70_9 = self.input.LA(5)

                                    if (LA70_9 == 86) :
                                        alt70 = 1
                    if alt70 == 1:
                        # ./output/PLSQL3.g:252:18: keyVARYING
                        pass
                        self._state.following.append(self.FOLLOW_keyVARYING_in_datatype1641)
                        keyVARYING298 = self.keyVARYING()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyVARYING298.tree)





                    # ./output/PLSQL3.g:252:32: ( LPAREN NUMBER RPAREN )?
                    alt71 = 2
                    LA71_0 = self.input.LA(1)

                    if (LA71_0 == LPAREN) :
                        alt71 = 1
                    if alt71 == 1:
                        # ./output/PLSQL3.g:252:34: LPAREN NUMBER RPAREN
                        pass
                        LPAREN299 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1648)
                        if self._state.backtracking == 0:
                            LPAREN299_tree = self._adaptor.createWithPayload(LPAREN299)
                            self._adaptor.addChild(root_0, LPAREN299_tree)



                        NUMBER300 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1650)
                        if self._state.backtracking == 0:
                            NUMBER300_tree = self._adaptor.createWithPayload(NUMBER300)
                            self._adaptor.addChild(root_0, NUMBER300_tree)



                        RPAREN301 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1652)
                        if self._state.backtracking == 0:
                            RPAREN301_tree = self._adaptor.createWithPayload(RPAREN301)
                            self._adaptor.addChild(root_0, RPAREN301_tree)







                elif alt79 == 25:
                    # ./output/PLSQL3.g:253:4: 'NVARCHAR' ( LPAREN NUMBER RPAREN )?
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal302 = self.match(self.input, 123, self.FOLLOW_123_in_datatype1660)
                    if self._state.backtracking == 0:
                        string_literal302_tree = self._adaptor.createWithPayload(string_literal302)
                        self._adaptor.addChild(root_0, string_literal302_tree)



                    # ./output/PLSQL3.g:253:16: ( LPAREN NUMBER RPAREN )?
                    alt72 = 2
                    LA72_0 = self.input.LA(1)

                    if (LA72_0 == LPAREN) :
                        alt72 = 1
                    if alt72 == 1:
                        # ./output/PLSQL3.g:253:18: LPAREN NUMBER RPAREN
                        pass
                        LPAREN303 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1665)
                        if self._state.backtracking == 0:
                            LPAREN303_tree = self._adaptor.createWithPayload(LPAREN303)
                            self._adaptor.addChild(root_0, LPAREN303_tree)



                        NUMBER304 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1667)
                        if self._state.backtracking == 0:
                            NUMBER304_tree = self._adaptor.createWithPayload(NUMBER304)
                            self._adaptor.addChild(root_0, NUMBER304_tree)



                        RPAREN305 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1669)
                        if self._state.backtracking == 0:
                            RPAREN305_tree = self._adaptor.createWithPayload(RPAREN305)
                            self._adaptor.addChild(root_0, RPAREN305_tree)







                elif alt79 == 26:
                    # ./output/PLSQL3.g:254:4: 'NVARCHAR2' ( LPAREN NUMBER RPAREN )?
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal306 = self.match(self.input, 124, self.FOLLOW_124_in_datatype1677)
                    if self._state.backtracking == 0:
                        string_literal306_tree = self._adaptor.createWithPayload(string_literal306)
                        self._adaptor.addChild(root_0, string_literal306_tree)



                    # ./output/PLSQL3.g:254:16: ( LPAREN NUMBER RPAREN )?
                    alt73 = 2
                    LA73_0 = self.input.LA(1)

                    if (LA73_0 == LPAREN) :
                        alt73 = 1
                    if alt73 == 1:
                        # ./output/PLSQL3.g:254:18: LPAREN NUMBER RPAREN
                        pass
                        LPAREN307 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1681)
                        if self._state.backtracking == 0:
                            LPAREN307_tree = self._adaptor.createWithPayload(LPAREN307)
                            self._adaptor.addChild(root_0, LPAREN307_tree)



                        NUMBER308 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1683)
                        if self._state.backtracking == 0:
                            NUMBER308_tree = self._adaptor.createWithPayload(NUMBER308)
                            self._adaptor.addChild(root_0, NUMBER308_tree)



                        RPAREN309 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1685)
                        if self._state.backtracking == 0:
                            RPAREN309_tree = self._adaptor.createWithPayload(RPAREN309)
                            self._adaptor.addChild(root_0, RPAREN309_tree)







                elif alt79 == 27:
                    # ./output/PLSQL3.g:255:4: 'NATIONAL' ( 'CHARACTER' | 'CHAR' ) ( keyVARYING )? ( LPAREN NUMBER RPAREN )?
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal310 = self.match(self.input, 114, self.FOLLOW_114_in_datatype1693)
                    if self._state.backtracking == 0:
                        string_literal310_tree = self._adaptor.createWithPayload(string_literal310)
                        self._adaptor.addChild(root_0, string_literal310_tree)



                    set311 = self.input.LT(1)

                    if (66 <= self.input.LA(1) <= 67):
                        self.input.consume()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set311))

                        self._state.errorRecovery = False


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        mse = MismatchedSetException(None, self.input)
                        raise mse



                    # ./output/PLSQL3.g:255:41: ( keyVARYING )?
                    alt74 = 2
                    LA74_0 = self.input.LA(1)

                    if (LA74_0 == ID) :
                        LA74 = self.input.LA(2)
                        if LA74 == EOF or LA74 == ASSIGN or LA74 == COMMA or LA74 == LPAREN or LA74 == RPAREN or LA74 == SEMI or LA74 == 53 or LA74 == 56 or LA74 == 73 or LA74 == 78 or LA74 == 85 or LA74 == 94 or LA74 == 100 or LA74 == 106 or LA74 == 118 or LA74 == 133 or LA74 == 135:
                            alt74 = 1
                        elif LA74 == ID:
                            LA74 = self.input.LA(3)
                            if LA74 == DOUBLEQUOTED_STRING or LA74 == MINUS or LA74 == NUMBER or LA74 == PLUS or LA74 == QUOTED_STRING or LA74 == 58 or LA74 == 59 or LA74 == 60 or LA74 == 61 or LA74 == 62 or LA74 == 63 or LA74 == 66 or LA74 == 67 or LA74 == 68 or LA74 == 72 or LA74 == 74 or LA74 == 75 or LA74 == 76 or LA74 == 82 or LA74 == 86 or LA74 == 91 or LA74 == 102 or LA74 == 103 or LA74 == 109 or LA74 == 112 or LA74 == 114 or LA74 == 115 or LA74 == 116 or LA74 == 117 or LA74 == 121 or LA74 == 122 or LA74 == 123 or LA74 == 124 or LA74 == 131 or LA74 == 132 or LA74 == 137 or LA74 == 138 or LA74 == 144 or LA74 == 150 or LA74 == 160 or LA74 == 162 or LA74 == 163:
                                alt74 = 1
                            elif LA74 == ID:
                                LA74_6 = self.input.LA(4)

                                if (LA74_6 == ASSIGN or LA74_6 == AT_SIGN or LA74_6 == DOT or LA74_6 == ID or LA74_6 == ROWTYPE_ATTR or LA74_6 == SEMI or LA74_6 == TYPE_ATTR or LA74_6 == 78 or LA74_6 == 106 or LA74_6 == 118 or LA74_6 == 140 or LA74_6 == 167) :
                                    alt74 = 1
                                elif (LA74_6 == LPAREN) :
                                    LA74_8 = self.input.LA(5)

                                    if (LA74_8 == NUMBER) :
                                        LA74_10 = self.input.LA(6)

                                        if (LA74_10 == RPAREN) :
                                            LA74_11 = self.input.LA(7)

                                            if (LA74_11 == ASSIGN or LA74_11 == SEMI or LA74_11 == 78 or LA74_11 == 106 or LA74_11 == 118 or LA74_11 == 167) :
                                                alt74 = 1
                                    elif (LA74_8 == DOUBLEQUOTED_STRING or LA74_8 == ID) :
                                        alt74 = 1
                            elif LA74 == DOT:
                                LA74_7 = self.input.LA(4)

                                if (LA74_7 == DOUBLEQUOTED_STRING or LA74_7 == ID) :
                                    LA74_9 = self.input.LA(5)

                                    if (LA74_9 == 86) :
                                        alt74 = 1
                        elif LA74 == DOUBLEQUOTED_STRING:
                            LA74_5 = self.input.LA(3)

                            if (LA74_5 == DOUBLEQUOTED_STRING or LA74_5 == ID or (58 <= LA74_5 <= 63) or (66 <= LA74_5 <= 68) or LA74_5 == 72 or (74 <= LA74_5 <= 76) or LA74_5 == 82 or LA74_5 == 86 or LA74_5 == 91 or (102 <= LA74_5 <= 103) or LA74_5 == 109 or LA74_5 == 112 or (114 <= LA74_5 <= 117) or (121 <= LA74_5 <= 124) or (131 <= LA74_5 <= 132) or (137 <= LA74_5 <= 138) or LA74_5 == 144 or LA74_5 == 150 or LA74_5 == 160 or (162 <= LA74_5 <= 163)) :
                                alt74 = 1
                            elif (LA74_5 == DOT) :
                                LA74_7 = self.input.LA(4)

                                if (LA74_7 == DOUBLEQUOTED_STRING or LA74_7 == ID) :
                                    LA74_9 = self.input.LA(5)

                                    if (LA74_9 == 86) :
                                        alt74 = 1
                    if alt74 == 1:
                        # ./output/PLSQL3.g:255:43: keyVARYING
                        pass
                        self._state.following.append(self.FOLLOW_keyVARYING_in_datatype1708)
                        keyVARYING312 = self.keyVARYING()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyVARYING312.tree)





                    # ./output/PLSQL3.g:255:57: ( LPAREN NUMBER RPAREN )?
                    alt75 = 2
                    LA75_0 = self.input.LA(1)

                    if (LA75_0 == LPAREN) :
                        alt75 = 1
                    if alt75 == 1:
                        # ./output/PLSQL3.g:255:59: LPAREN NUMBER RPAREN
                        pass
                        LPAREN313 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1715)
                        if self._state.backtracking == 0:
                            LPAREN313_tree = self._adaptor.createWithPayload(LPAREN313)
                            self._adaptor.addChild(root_0, LPAREN313_tree)



                        NUMBER314 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1717)
                        if self._state.backtracking == 0:
                            NUMBER314_tree = self._adaptor.createWithPayload(NUMBER314)
                            self._adaptor.addChild(root_0, NUMBER314_tree)



                        RPAREN315 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1719)
                        if self._state.backtracking == 0:
                            RPAREN315_tree = self._adaptor.createWithPayload(RPAREN315)
                            self._adaptor.addChild(root_0, RPAREN315_tree)







                elif alt79 == 28:
                    # ./output/PLSQL3.g:256:4: 'MLSLABEL'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal316 = self.match(self.input, 112, self.FOLLOW_112_in_datatype1727)
                    if self._state.backtracking == 0:
                        string_literal316_tree = self._adaptor.createWithPayload(string_literal316)
                        self._adaptor.addChild(root_0, string_literal316_tree)




                elif alt79 == 29:
                    # ./output/PLSQL3.g:257:4: 'PLS_INTEGER'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal317 = self.match(self.input, 131, self.FOLLOW_131_in_datatype1732)
                    if self._state.backtracking == 0:
                        string_literal317_tree = self._adaptor.createWithPayload(string_literal317)
                        self._adaptor.addChild(root_0, string_literal317_tree)




                elif alt79 == 30:
                    # ./output/PLSQL3.g:258:4: 'BLOB'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal318 = self.match(self.input, 62, self.FOLLOW_62_in_datatype1737)
                    if self._state.backtracking == 0:
                        string_literal318_tree = self._adaptor.createWithPayload(string_literal318)
                        self._adaptor.addChild(root_0, string_literal318_tree)




                elif alt79 == 31:
                    # ./output/PLSQL3.g:259:4: 'CLOB' ( 'CHARACTER' 'SET' ( identifier | column_spec CHARSET_ATTR ) )?
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal319 = self.match(self.input, 68, self.FOLLOW_68_in_datatype1742)
                    if self._state.backtracking == 0:
                        string_literal319_tree = self._adaptor.createWithPayload(string_literal319)
                        self._adaptor.addChild(root_0, string_literal319_tree)



                    # ./output/PLSQL3.g:259:11: ( 'CHARACTER' 'SET' ( identifier | column_spec CHARSET_ATTR ) )?
                    alt77 = 2
                    LA77_0 = self.input.LA(1)

                    if (LA77_0 == 67) :
                        alt77 = 1
                    if alt77 == 1:
                        # ./output/PLSQL3.g:259:13: 'CHARACTER' 'SET' ( identifier | column_spec CHARSET_ATTR )
                        pass
                        string_literal320 = self.match(self.input, 67, self.FOLLOW_67_in_datatype1746)
                        if self._state.backtracking == 0:
                            string_literal320_tree = self._adaptor.createWithPayload(string_literal320)
                            self._adaptor.addChild(root_0, string_literal320_tree)



                        string_literal321 = self.match(self.input, 148, self.FOLLOW_148_in_datatype1748)
                        if self._state.backtracking == 0:
                            string_literal321_tree = self._adaptor.createWithPayload(string_literal321)
                            self._adaptor.addChild(root_0, string_literal321_tree)



                        # ./output/PLSQL3.g:259:31: ( identifier | column_spec CHARSET_ATTR )
                        alt76 = 2
                        LA76_0 = self.input.LA(1)

                        if (LA76_0 == DOUBLEQUOTED_STRING or LA76_0 == ID) :
                            LA76_1 = self.input.LA(2)

                            if (LA76_1 == EOF or LA76_1 == ASSIGN or LA76_1 == COMMA or LA76_1 == DOUBLEQUOTED_STRING or LA76_1 == ID or (RPAREN <= LA76_1 <= SEMI) or LA76_1 == 53 or LA76_1 == 56 or LA76_1 == 73 or LA76_1 == 78 or LA76_1 == 85 or LA76_1 == 94 or LA76_1 == 100 or LA76_1 == 106 or LA76_1 == 118 or LA76_1 == 133 or LA76_1 == 135) :
                                alt76 = 1
                            elif (LA76_1 == CHARSET_ATTR or LA76_1 == DOT) :
                                alt76 = 2
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 76, 1, self.input)

                                raise nvae


                        elif (LA76_0 == 144) :
                            alt76 = 2
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 76, 0, self.input)

                            raise nvae


                        if alt76 == 1:
                            # ./output/PLSQL3.g:259:33: identifier
                            pass
                            self._state.following.append(self.FOLLOW_identifier_in_datatype1752)
                            identifier322 = self.identifier()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, identifier322.tree)



                        elif alt76 == 2:
                            # ./output/PLSQL3.g:259:46: column_spec CHARSET_ATTR
                            pass
                            self._state.following.append(self.FOLLOW_column_spec_in_datatype1756)
                            column_spec323 = self.column_spec()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, column_spec323.tree)


                            CHARSET_ATTR324 = self.match(self.input, CHARSET_ATTR, self.FOLLOW_CHARSET_ATTR_in_datatype1758)
                            if self._state.backtracking == 0:
                                CHARSET_ATTR324_tree = self._adaptor.createWithPayload(CHARSET_ATTR324)
                                self._adaptor.addChild(root_0, CHARSET_ATTR324_tree)










                elif alt79 == 32:
                    # ./output/PLSQL3.g:260:4: 'NCLOB'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal325 = self.match(self.input, 117, self.FOLLOW_117_in_datatype1768)
                    if self._state.backtracking == 0:
                        string_literal325_tree = self._adaptor.createWithPayload(string_literal325)
                        self._adaptor.addChild(root_0, string_literal325_tree)




                elif alt79 == 33:
                    # ./output/PLSQL3.g:261:4: 'BFILE'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal326 = self.match(self.input, 58, self.FOLLOW_58_in_datatype1773)
                    if self._state.backtracking == 0:
                        string_literal326_tree = self._adaptor.createWithPayload(string_literal326)
                        self._adaptor.addChild(root_0, string_literal326_tree)




                elif alt79 == 34:
                    # ./output/PLSQL3.g:262:4: 'ROWID'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal327 = self.match(self.input, 144, self.FOLLOW_144_in_datatype1778)
                    if self._state.backtracking == 0:
                        string_literal327_tree = self._adaptor.createWithPayload(string_literal327)
                        self._adaptor.addChild(root_0, string_literal327_tree)




                elif alt79 == 35:
                    # ./output/PLSQL3.g:263:4: 'UROWID' ( LPAREN NUMBER RPAREN )?
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal328 = self.match(self.input, 160, self.FOLLOW_160_in_datatype1784)
                    if self._state.backtracking == 0:
                        string_literal328_tree = self._adaptor.createWithPayload(string_literal328)
                        self._adaptor.addChild(root_0, string_literal328_tree)



                    # ./output/PLSQL3.g:263:13: ( LPAREN NUMBER RPAREN )?
                    alt78 = 2
                    LA78_0 = self.input.LA(1)

                    if (LA78_0 == LPAREN) :
                        alt78 = 1
                    if alt78 == 1:
                        # ./output/PLSQL3.g:263:15: LPAREN NUMBER RPAREN
                        pass
                        LPAREN329 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1788)
                        if self._state.backtracking == 0:
                            LPAREN329_tree = self._adaptor.createWithPayload(LPAREN329)
                            self._adaptor.addChild(root_0, LPAREN329_tree)



                        NUMBER330 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1790)
                        if self._state.backtracking == 0:
                            NUMBER330_tree = self._adaptor.createWithPayload(NUMBER330)
                            self._adaptor.addChild(root_0, NUMBER330_tree)



                        RPAREN331 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1792)
                        if self._state.backtracking == 0:
                            RPAREN331_tree = self._adaptor.createWithPayload(RPAREN331)
                            self._adaptor.addChild(root_0, RPAREN331_tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 28, datatype_StartIndex, success)


            pass
        return retval

    # $ANTLR end "datatype"


    class type_spec_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.type_spec_return, self).__init__()

            self.tree = None





    # $ANTLR start "type_spec"
    # ./output/PLSQL3.g:266:1: type_spec : ( datatype | column_spec TYPE_ATTR | table_spec ROWTYPE_ATTR | type_name ( LPAREN NUMBER RPAREN )? );
    def type_spec(self, ):
        retval = self.type_spec_return()
        retval.start = self.input.LT(1)

        type_spec_StartIndex = self.input.index()

        root_0 = None

        TYPE_ATTR334 = None
        ROWTYPE_ATTR336 = None
        LPAREN338 = None
        NUMBER339 = None
        RPAREN340 = None
        datatype332 = None

        column_spec333 = None

        table_spec335 = None

        type_name337 = None


        TYPE_ATTR334_tree = None
        ROWTYPE_ATTR336_tree = None
        LPAREN338_tree = None
        NUMBER339_tree = None
        RPAREN340_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 29):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:267:2: ( datatype | column_spec TYPE_ATTR | table_spec ROWTYPE_ATTR | type_name ( LPAREN NUMBER RPAREN )? )
                alt81 = 4
                LA81 = self.input.LA(1)
                if LA81 == 58 or LA81 == 59 or LA81 == 60 or LA81 == 61 or LA81 == 62 or LA81 == 63 or LA81 == 66 or LA81 == 67 or LA81 == 68 or LA81 == 74 or LA81 == 75 or LA81 == 76 or LA81 == 82 or LA81 == 91 or LA81 == 102 or LA81 == 103 or LA81 == 109 or LA81 == 112 or LA81 == 114 or LA81 == 115 or LA81 == 116 or LA81 == 117 or LA81 == 121 or LA81 == 122 or LA81 == 123 or LA81 == 124 or LA81 == 131 or LA81 == 132 or LA81 == 137 or LA81 == 138 or LA81 == 150 or LA81 == 160 or LA81 == 162 or LA81 == 163:
                    alt81 = 1
                elif LA81 == ID:
                    LA81_2 = self.input.LA(2)

                    if (LA81_2 == DOT) :
                        LA81_5 = self.input.LA(3)

                        if (LA81_5 == DOUBLEQUOTED_STRING or LA81_5 == ID) :
                            LA81_10 = self.input.LA(4)

                            if (LA81_10 == DOT or LA81_10 == TYPE_ATTR) :
                                alt81 = 2
                            elif (LA81_10 == AT_SIGN or LA81_10 == ROWTYPE_ATTR) :
                                alt81 = 3
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 81, 10, self.input)

                                raise nvae


                        elif (LA81_5 == 144) :
                            LA81_11 = self.input.LA(4)

                            if (LA81_11 == DOT or LA81_11 == TYPE_ATTR) :
                                alt81 = 2
                            elif (LA81_11 == AT_SIGN or LA81_11 == ROWTYPE_ATTR) :
                                alt81 = 3
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 81, 11, self.input)

                                raise nvae


                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 81, 5, self.input)

                            raise nvae


                    elif (LA81_2 == TYPE_ATTR) :
                        alt81 = 2
                    elif (LA81_2 == AT_SIGN or LA81_2 == ROWTYPE_ATTR) :
                        alt81 = 3
                    elif (((((self.synpred172_PLSQL3()) and (self.synpred172_PLSQL3()))) and ((((self.input).LT(1).text.upper() == "TIMESTAMP") or ((this.input).LT(1).text.upper() == "TIME") or ((this.input).LT(1).text.upper() == "INTERVAL"))))) :
                        alt81 = 1
                    elif (True) :
                        alt81 = 4
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 81, 2, self.input)

                        raise nvae


                elif LA81 == 144:
                    LA81 = self.input.LA(2)
                    if LA81 == EOF or LA81 == ASSIGN or LA81 == COMMA or LA81 == DOUBLEQUOTED_STRING or LA81 == ID or LA81 == RPAREN or LA81 == SEMI or LA81 == 53 or LA81 == 56 or LA81 == 73 or LA81 == 78 or LA81 == 85 or LA81 == 94 or LA81 == 100 or LA81 == 106 or LA81 == 118 or LA81 == 133 or LA81 == 135:
                        alt81 = 1
                    elif LA81 == DOT:
                        LA81_5 = self.input.LA(3)

                        if (LA81_5 == DOUBLEQUOTED_STRING or LA81_5 == ID) :
                            LA81_10 = self.input.LA(4)

                            if (LA81_10 == DOT or LA81_10 == TYPE_ATTR) :
                                alt81 = 2
                            elif (LA81_10 == AT_SIGN or LA81_10 == ROWTYPE_ATTR) :
                                alt81 = 3
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 81, 10, self.input)

                                raise nvae


                        elif (LA81_5 == 144) :
                            LA81_11 = self.input.LA(4)

                            if (LA81_11 == DOT or LA81_11 == TYPE_ATTR) :
                                alt81 = 2
                            elif (LA81_11 == AT_SIGN or LA81_11 == ROWTYPE_ATTR) :
                                alt81 = 3
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 81, 11, self.input)

                                raise nvae


                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 81, 5, self.input)

                            raise nvae


                    elif LA81 == TYPE_ATTR:
                        alt81 = 2
                    elif LA81 == AT_SIGN or LA81 == ROWTYPE_ATTR:
                        alt81 = 3
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 81, 3, self.input)

                        raise nvae


                elif LA81 == DOUBLEQUOTED_STRING:
                    LA81 = self.input.LA(2)
                    if LA81 == DOT:
                        LA81_9 = self.input.LA(3)

                        if (LA81_9 == DOUBLEQUOTED_STRING or LA81_9 == ID) :
                            LA81 = self.input.LA(4)
                            if LA81 == DOT:
                                LA81_13 = self.input.LA(5)

                                if (LA81_13 == DOUBLEQUOTED_STRING or LA81_13 == ID) :
                                    LA81_14 = self.input.LA(6)

                                    if (LA81_14 == TYPE_ATTR) :
                                        alt81 = 2
                                    elif (LA81_14 == EOF or LA81_14 == ASSIGN or LA81_14 == COMMA or LA81_14 == DOT or LA81_14 == DOUBLEQUOTED_STRING or LA81_14 == ID or LA81_14 == LPAREN or (RPAREN <= LA81_14 <= SEMI) or LA81_14 == 53 or LA81_14 == 56 or LA81_14 == 73 or LA81_14 == 78 or LA81_14 == 85 or LA81_14 == 94 or LA81_14 == 100 or LA81_14 == 106 or LA81_14 == 118 or LA81_14 == 133 or LA81_14 == 135) :
                                        alt81 = 4
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 81, 14, self.input)

                                        raise nvae


                                elif (LA81_13 == 144) :
                                    alt81 = 2
                                else:
                                    if self._state.backtracking > 0:
                                        raise BacktrackingFailed


                                    nvae = NoViableAltException("", 81, 13, self.input)

                                    raise nvae


                            elif LA81 == TYPE_ATTR:
                                alt81 = 2
                            elif LA81 == AT_SIGN or LA81 == ROWTYPE_ATTR:
                                alt81 = 3
                            elif LA81 == EOF or LA81 == ASSIGN or LA81 == COMMA or LA81 == DOUBLEQUOTED_STRING or LA81 == ID or LA81 == LPAREN or LA81 == RPAREN or LA81 == SEMI or LA81 == 53 or LA81 == 56 or LA81 == 73 or LA81 == 78 or LA81 == 85 or LA81 == 94 or LA81 == 100 or LA81 == 106 or LA81 == 118 or LA81 == 133 or LA81 == 135:
                                alt81 = 4
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 81, 12, self.input)

                                raise nvae


                        elif (LA81_9 == 144) :
                            LA81_11 = self.input.LA(4)

                            if (LA81_11 == DOT or LA81_11 == TYPE_ATTR) :
                                alt81 = 2
                            elif (LA81_11 == AT_SIGN or LA81_11 == ROWTYPE_ATTR) :
                                alt81 = 3
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 81, 11, self.input)

                                raise nvae


                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 81, 9, self.input)

                            raise nvae


                    elif LA81 == TYPE_ATTR:
                        alt81 = 2
                    elif LA81 == AT_SIGN or LA81 == ROWTYPE_ATTR:
                        alt81 = 3
                    elif LA81 == EOF or LA81 == ASSIGN or LA81 == COMMA or LA81 == DOUBLEQUOTED_STRING or LA81 == ID or LA81 == LPAREN or LA81 == RPAREN or LA81 == SEMI or LA81 == 53 or LA81 == 56 or LA81 == 73 or LA81 == 78 or LA81 == 85 or LA81 == 94 or LA81 == 100 or LA81 == 106 or LA81 == 118 or LA81 == 133 or LA81 == 135:
                        alt81 = 4
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 81, 4, self.input)

                        raise nvae


                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 81, 0, self.input)

                    raise nvae


                if alt81 == 1:
                    # ./output/PLSQL3.g:267:4: datatype
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_datatype_in_type_spec1806)
                    datatype332 = self.datatype()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, datatype332.tree)



                elif alt81 == 2:
                    # ./output/PLSQL3.g:269:4: column_spec TYPE_ATTR
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_column_spec_in_type_spec1813)
                    column_spec333 = self.column_spec()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, column_spec333.tree)


                    TYPE_ATTR334 = self.match(self.input, TYPE_ATTR, self.FOLLOW_TYPE_ATTR_in_type_spec1815)
                    if self._state.backtracking == 0:
                        TYPE_ATTR334_tree = self._adaptor.createWithPayload(TYPE_ATTR334)
                        self._adaptor.addChild(root_0, TYPE_ATTR334_tree)




                elif alt81 == 3:
                    # ./output/PLSQL3.g:271:4: table_spec ROWTYPE_ATTR
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_table_spec_in_type_spec1821)
                    table_spec335 = self.table_spec()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, table_spec335.tree)


                    ROWTYPE_ATTR336 = self.match(self.input, ROWTYPE_ATTR, self.FOLLOW_ROWTYPE_ATTR_in_type_spec1823)
                    if self._state.backtracking == 0:
                        ROWTYPE_ATTR336_tree = self._adaptor.createWithPayload(ROWTYPE_ATTR336)
                        self._adaptor.addChild(root_0, ROWTYPE_ATTR336_tree)




                elif alt81 == 4:
                    # ./output/PLSQL3.g:273:4: type_name ( LPAREN NUMBER RPAREN )?
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_type_name_in_type_spec1829)
                    type_name337 = self.type_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, type_name337.tree)


                    # ./output/PLSQL3.g:273:14: ( LPAREN NUMBER RPAREN )?
                    alt80 = 2
                    LA80_0 = self.input.LA(1)

                    if (LA80_0 == LPAREN) :
                        alt80 = 1
                    if alt80 == 1:
                        # ./output/PLSQL3.g:273:16: LPAREN NUMBER RPAREN
                        pass
                        LPAREN338 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_type_spec1833)
                        if self._state.backtracking == 0:
                            LPAREN338_tree = self._adaptor.createWithPayload(LPAREN338)
                            self._adaptor.addChild(root_0, LPAREN338_tree)



                        NUMBER339 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_type_spec1835)
                        if self._state.backtracking == 0:
                            NUMBER339_tree = self._adaptor.createWithPayload(NUMBER339)
                            self._adaptor.addChild(root_0, NUMBER339_tree)



                        RPAREN340 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_type_spec1837)
                        if self._state.backtracking == 0:
                            RPAREN340_tree = self._adaptor.createWithPayload(RPAREN340)
                            self._adaptor.addChild(root_0, RPAREN340_tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 29, type_spec_StartIndex, success)


            pass
        return retval

    # $ANTLR end "type_spec"


    class type_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.type_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "type_name"
    # ./output/PLSQL3.g:276:1: type_name : identifier ( DOT identifier )* ;
    def type_name(self, ):
        retval = self.type_name_return()
        retval.start = self.input.LT(1)

        type_name_StartIndex = self.input.index()

        root_0 = None

        DOT342 = None
        identifier341 = None

        identifier343 = None


        DOT342_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 30):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:277:2: ( identifier ( DOT identifier )* )
                # ./output/PLSQL3.g:277:4: identifier ( DOT identifier )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_identifier_in_type_name1851)
                identifier341 = self.identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, identifier341.tree)


                # ./output/PLSQL3.g:277:15: ( DOT identifier )*
                while True: #loop82
                    alt82 = 2
                    LA82_0 = self.input.LA(1)

                    if (LA82_0 == DOT) :
                        alt82 = 1


                    if alt82 == 1:
                        # ./output/PLSQL3.g:277:17: DOT identifier
                        pass
                        DOT342 = self.match(self.input, DOT, self.FOLLOW_DOT_in_type_name1855)
                        if self._state.backtracking == 0:
                            DOT342_tree = self._adaptor.createWithPayload(DOT342)
                            self._adaptor.addChild(root_0, DOT342_tree)



                        self._state.following.append(self.FOLLOW_identifier_in_type_name1857)
                        identifier343 = self.identifier()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, identifier343.tree)



                    else:
                        break #loop82




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 30, type_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "type_name"


    class parameter_specs_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.parameter_specs_return, self).__init__()

            self.tree = None





    # $ANTLR start "parameter_specs"
    # ./output/PLSQL3.g:280:1: parameter_specs : parameter_spec ( COMMA parameter_spec )* ;
    def parameter_specs(self, ):
        retval = self.parameter_specs_return()
        retval.start = self.input.LT(1)

        parameter_specs_StartIndex = self.input.index()

        root_0 = None

        COMMA345 = None
        parameter_spec344 = None

        parameter_spec346 = None


        COMMA345_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 31):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:281:2: ( parameter_spec ( COMMA parameter_spec )* )
                # ./output/PLSQL3.g:281:4: parameter_spec ( COMMA parameter_spec )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_parameter_spec_in_parameter_specs1871)
                parameter_spec344 = self.parameter_spec()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, parameter_spec344.tree)


                # ./output/PLSQL3.g:281:19: ( COMMA parameter_spec )*
                while True: #loop83
                    alt83 = 2
                    LA83_0 = self.input.LA(1)

                    if (LA83_0 == COMMA) :
                        alt83 = 1


                    if alt83 == 1:
                        # ./output/PLSQL3.g:281:21: COMMA parameter_spec
                        pass
                        COMMA345 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_parameter_specs1875)
                        if self._state.backtracking == 0:
                            COMMA345_tree = self._adaptor.createWithPayload(COMMA345)
                            self._adaptor.addChild(root_0, COMMA345_tree)



                        self._state.following.append(self.FOLLOW_parameter_spec_in_parameter_specs1877)
                        parameter_spec346 = self.parameter_spec()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, parameter_spec346.tree)



                    else:
                        break #loop83




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 31, parameter_specs_StartIndex, success)


            pass
        return retval

    # $ANTLR end "parameter_specs"


    class parameter_spec_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.parameter_spec_return, self).__init__()

            self.tree = None





    # $ANTLR start "parameter_spec"
    # ./output/PLSQL3.g:284:1: parameter_spec : parameter_name ( 'IN' )? ( type_spec )? ;
    def parameter_spec(self, ):
        retval = self.parameter_spec_return()
        retval.start = self.input.LT(1)

        parameter_spec_StartIndex = self.input.index()

        root_0 = None

        string_literal348 = None
        parameter_name347 = None

        type_spec349 = None


        string_literal348_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 32):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:285:2: ( parameter_name ( 'IN' )? ( type_spec )? )
                # ./output/PLSQL3.g:285:4: parameter_name ( 'IN' )? ( type_spec )?
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_parameter_name_in_parameter_spec1891)
                parameter_name347 = self.parameter_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, parameter_name347.tree)


                # ./output/PLSQL3.g:285:19: ( 'IN' )?
                alt84 = 2
                LA84_0 = self.input.LA(1)

                if (LA84_0 == 99) :
                    alt84 = 1
                if alt84 == 1:
                    # ./output/PLSQL3.g:285:21: 'IN'
                    pass
                    string_literal348 = self.match(self.input, 99, self.FOLLOW_99_in_parameter_spec1895)
                    if self._state.backtracking == 0:
                        string_literal348_tree = self._adaptor.createWithPayload(string_literal348)
                        self._adaptor.addChild(root_0, string_literal348_tree)






                # ./output/PLSQL3.g:285:29: ( type_spec )?
                alt85 = 2
                LA85_0 = self.input.LA(1)

                if (LA85_0 == DOUBLEQUOTED_STRING or LA85_0 == ID or (58 <= LA85_0 <= 63) or (66 <= LA85_0 <= 68) or (74 <= LA85_0 <= 76) or LA85_0 == 82 or LA85_0 == 91 or (102 <= LA85_0 <= 103) or LA85_0 == 109 or LA85_0 == 112 or (114 <= LA85_0 <= 117) or (121 <= LA85_0 <= 124) or (131 <= LA85_0 <= 132) or (137 <= LA85_0 <= 138) or LA85_0 == 144 or LA85_0 == 150 or LA85_0 == 160 or (162 <= LA85_0 <= 163)) :
                    alt85 = 1
                if alt85 == 1:
                    # ./output/PLSQL3.g:285:31: type_spec
                    pass
                    self._state.following.append(self.FOLLOW_type_spec_in_parameter_spec1902)
                    type_spec349 = self.type_spec()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, type_spec349.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 32, parameter_spec_StartIndex, success)


            pass
        return retval

    # $ANTLR end "parameter_spec"


    class parameter_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.parameter_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "parameter_name"
    # ./output/PLSQL3.g:288:1: parameter_name : identifier ;
    def parameter_name(self, ):
        retval = self.parameter_name_return()
        retval.start = self.input.LT(1)

        parameter_name_StartIndex = self.input.index()

        root_0 = None

        identifier350 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 33):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:289:2: ( identifier )
                # ./output/PLSQL3.g:289:4: identifier
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_identifier_in_parameter_name1917)
                identifier350 = self.identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, identifier350.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 33, parameter_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "parameter_name"


    class cursor_spec_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.cursor_spec_return, self).__init__()

            self.tree = None





    # $ANTLR start "cursor_spec"
    # ./output/PLSQL3.g:292:1: cursor_spec : keyCURSOR cursor_name ( LPAREN parameter_specs RPAREN )? keyRETURN return_type SEMI !;
    def cursor_spec(self, ):
        retval = self.cursor_spec_return()
        retval.start = self.input.LT(1)

        cursor_spec_StartIndex = self.input.index()

        root_0 = None

        LPAREN353 = None
        RPAREN355 = None
        SEMI358 = None
        keyCURSOR351 = None

        cursor_name352 = None

        parameter_specs354 = None

        keyRETURN356 = None

        return_type357 = None


        LPAREN353_tree = None
        RPAREN355_tree = None
        SEMI358_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 34):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:293:2: ( keyCURSOR cursor_name ( LPAREN parameter_specs RPAREN )? keyRETURN return_type SEMI !)
                # ./output/PLSQL3.g:293:4: keyCURSOR cursor_name ( LPAREN parameter_specs RPAREN )? keyRETURN return_type SEMI !
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyCURSOR_in_cursor_spec1928)
                keyCURSOR351 = self.keyCURSOR()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyCURSOR351.tree)


                self._state.following.append(self.FOLLOW_cursor_name_in_cursor_spec1930)
                cursor_name352 = self.cursor_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, cursor_name352.tree)


                # ./output/PLSQL3.g:294:3: ( LPAREN parameter_specs RPAREN )?
                alt86 = 2
                LA86_0 = self.input.LA(1)

                if (LA86_0 == LPAREN) :
                    alt86 = 1
                if alt86 == 1:
                    # ./output/PLSQL3.g:294:5: LPAREN parameter_specs RPAREN
                    pass
                    LPAREN353 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_cursor_spec1937)
                    if self._state.backtracking == 0:
                        LPAREN353_tree = self._adaptor.createWithPayload(LPAREN353)
                        self._adaptor.addChild(root_0, LPAREN353_tree)



                    self._state.following.append(self.FOLLOW_parameter_specs_in_cursor_spec1939)
                    parameter_specs354 = self.parameter_specs()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, parameter_specs354.tree)


                    RPAREN355 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_cursor_spec1941)
                    if self._state.backtracking == 0:
                        RPAREN355_tree = self._adaptor.createWithPayload(RPAREN355)
                        self._adaptor.addChild(root_0, RPAREN355_tree)






                self._state.following.append(self.FOLLOW_keyRETURN_in_cursor_spec1948)
                keyRETURN356 = self.keyRETURN()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyRETURN356.tree)


                self._state.following.append(self.FOLLOW_return_type_in_cursor_spec1950)
                return_type357 = self.return_type()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, return_type357.tree)


                SEMI358 = self.match(self.input, SEMI, self.FOLLOW_SEMI_in_cursor_spec1952)



                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 34, cursor_spec_StartIndex, success)


            pass
        return retval

    # $ANTLR end "cursor_spec"


    class procedure_spec_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.procedure_spec_return, self).__init__()

            self.tree = None





    # $ANTLR start "procedure_spec"
    # ./output/PLSQL3.g:298:1: procedure_spec : 'PROCEDURE' procedure_name ( LPAREN arguments RPAREN )? SEMI ;
    def procedure_spec(self, ):
        retval = self.procedure_spec_return()
        retval.start = self.input.LT(1)

        procedure_spec_StartIndex = self.input.index()

        root_0 = None

        string_literal359 = None
        LPAREN361 = None
        RPAREN363 = None
        SEMI364 = None
        procedure_name360 = None

        arguments362 = None


        string_literal359_tree = None
        LPAREN361_tree = None
        RPAREN363_tree = None
        SEMI364_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 35):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:298:15: ( 'PROCEDURE' procedure_name ( LPAREN arguments RPAREN )? SEMI )
                # ./output/PLSQL3.g:299:2: 'PROCEDURE' procedure_name ( LPAREN arguments RPAREN )? SEMI
                pass
                root_0 = self._adaptor.nil()


                string_literal359 = self.match(self.input, 135, self.FOLLOW_135_in_procedure_spec1965)
                if self._state.backtracking == 0:
                    string_literal359_tree = self._adaptor.createWithPayload(string_literal359)
                    self._adaptor.addChild(root_0, string_literal359_tree)



                self._state.following.append(self.FOLLOW_procedure_name_in_procedure_spec1967)
                procedure_name360 = self.procedure_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, procedure_name360.tree)


                # ./output/PLSQL3.g:300:2: ( LPAREN arguments RPAREN )?
                alt87 = 2
                LA87_0 = self.input.LA(1)

                if (LA87_0 == LPAREN) :
                    alt87 = 1
                if alt87 == 1:
                    # ./output/PLSQL3.g:300:4: LPAREN arguments RPAREN
                    pass
                    LPAREN361 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_procedure_spec1973)
                    if self._state.backtracking == 0:
                        LPAREN361_tree = self._adaptor.createWithPayload(LPAREN361)
                        self._adaptor.addChild(root_0, LPAREN361_tree)



                    self._state.following.append(self.FOLLOW_arguments_in_procedure_spec1975)
                    arguments362 = self.arguments()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, arguments362.tree)


                    RPAREN363 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_procedure_spec1977)
                    if self._state.backtracking == 0:
                        RPAREN363_tree = self._adaptor.createWithPayload(RPAREN363)
                        self._adaptor.addChild(root_0, RPAREN363_tree)






                SEMI364 = self.match(self.input, SEMI, self.FOLLOW_SEMI_in_procedure_spec1982)
                if self._state.backtracking == 0:
                    SEMI364_tree = self._adaptor.createWithPayload(SEMI364)
                    self._adaptor.addChild(root_0, SEMI364_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 35, procedure_spec_StartIndex, success)


            pass
        return retval

    # $ANTLR end "procedure_spec"


    class function_spec_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.function_spec_return, self).__init__()

            self.tree = None





    # $ANTLR start "function_spec"
    # ./output/PLSQL3.g:303:1: function_spec : 'FUNCTION' function_name ( LPAREN arguments RPAREN )? keyRETURN return_type SEMI ;
    def function_spec(self, ):
        retval = self.function_spec_return()
        retval.start = self.input.LT(1)

        function_spec_StartIndex = self.input.index()

        root_0 = None

        string_literal365 = None
        LPAREN367 = None
        RPAREN369 = None
        SEMI372 = None
        function_name366 = None

        arguments368 = None

        keyRETURN370 = None

        return_type371 = None


        string_literal365_tree = None
        LPAREN367_tree = None
        RPAREN369_tree = None
        SEMI372_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 36):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:304:2: ( 'FUNCTION' function_name ( LPAREN arguments RPAREN )? keyRETURN return_type SEMI )
                # ./output/PLSQL3.g:304:4: 'FUNCTION' function_name ( LPAREN arguments RPAREN )? keyRETURN return_type SEMI
                pass
                root_0 = self._adaptor.nil()


                string_literal365 = self.match(self.input, 94, self.FOLLOW_94_in_function_spec1993)
                if self._state.backtracking == 0:
                    string_literal365_tree = self._adaptor.createWithPayload(string_literal365)
                    self._adaptor.addChild(root_0, string_literal365_tree)



                self._state.following.append(self.FOLLOW_function_name_in_function_spec1995)
                function_name366 = self.function_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, function_name366.tree)


                # ./output/PLSQL3.g:305:3: ( LPAREN arguments RPAREN )?
                alt88 = 2
                LA88_0 = self.input.LA(1)

                if (LA88_0 == LPAREN) :
                    alt88 = 1
                if alt88 == 1:
                    # ./output/PLSQL3.g:305:5: LPAREN arguments RPAREN
                    pass
                    LPAREN367 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_function_spec2002)
                    if self._state.backtracking == 0:
                        LPAREN367_tree = self._adaptor.createWithPayload(LPAREN367)
                        self._adaptor.addChild(root_0, LPAREN367_tree)



                    self._state.following.append(self.FOLLOW_arguments_in_function_spec2004)
                    arguments368 = self.arguments()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, arguments368.tree)


                    RPAREN369 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_function_spec2006)
                    if self._state.backtracking == 0:
                        RPAREN369_tree = self._adaptor.createWithPayload(RPAREN369)
                        self._adaptor.addChild(root_0, RPAREN369_tree)






                self._state.following.append(self.FOLLOW_keyRETURN_in_function_spec2013)
                keyRETURN370 = self.keyRETURN()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyRETURN370.tree)


                self._state.following.append(self.FOLLOW_return_type_in_function_spec2015)
                return_type371 = self.return_type()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, return_type371.tree)


                SEMI372 = self.match(self.input, SEMI, self.FOLLOW_SEMI_in_function_spec2017)
                if self._state.backtracking == 0:
                    SEMI372_tree = self._adaptor.createWithPayload(SEMI372)
                    self._adaptor.addChild(root_0, SEMI372_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 36, function_spec_StartIndex, success)


            pass
        return retval

    # $ANTLR end "function_spec"


    class exception_declaration_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.exception_declaration_return, self).__init__()

            self.tree = None





    # $ANTLR start "exception_declaration"
    # ./output/PLSQL3.g:309:1: exception_declaration : exception_name 'EXCEPTION' SEMI ;
    def exception_declaration(self, ):
        retval = self.exception_declaration_return()
        retval.start = self.input.LT(1)

        exception_declaration_StartIndex = self.input.index()

        root_0 = None

        string_literal374 = None
        SEMI375 = None
        exception_name373 = None


        string_literal374_tree = None
        SEMI375_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 37):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:310:2: ( exception_name 'EXCEPTION' SEMI )
                # ./output/PLSQL3.g:310:4: exception_name 'EXCEPTION' SEMI
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_exception_name_in_exception_declaration2028)
                exception_name373 = self.exception_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, exception_name373.tree)


                string_literal374 = self.match(self.input, 86, self.FOLLOW_86_in_exception_declaration2030)
                if self._state.backtracking == 0:
                    string_literal374_tree = self._adaptor.createWithPayload(string_literal374)
                    self._adaptor.addChild(root_0, string_literal374_tree)



                SEMI375 = self.match(self.input, SEMI, self.FOLLOW_SEMI_in_exception_declaration2032)
                if self._state.backtracking == 0:
                    SEMI375_tree = self._adaptor.createWithPayload(SEMI375)
                    self._adaptor.addChild(root_0, SEMI375_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 37, exception_declaration_StartIndex, success)


            pass
        return retval

    # $ANTLR end "exception_declaration"


    class exception_names_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.exception_names_return, self).__init__()

            self.tree = None





    # $ANTLR start "exception_names"
    # ./output/PLSQL3.g:313:1: exception_names : exception_name ( 'OR' exception_name )* ;
    def exception_names(self, ):
        retval = self.exception_names_return()
        retval.start = self.input.LT(1)

        exception_names_StartIndex = self.input.index()

        root_0 = None

        string_literal377 = None
        exception_name376 = None

        exception_name378 = None


        string_literal377_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 38):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:314:2: ( exception_name ( 'OR' exception_name )* )
                # ./output/PLSQL3.g:314:4: exception_name ( 'OR' exception_name )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_exception_name_in_exception_names2043)
                exception_name376 = self.exception_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, exception_name376.tree)


                # ./output/PLSQL3.g:314:19: ( 'OR' exception_name )*
                while True: #loop89
                    alt89 = 2
                    LA89_0 = self.input.LA(1)

                    if (LA89_0 == 127) :
                        alt89 = 1


                    if alt89 == 1:
                        # ./output/PLSQL3.g:314:21: 'OR' exception_name
                        pass
                        string_literal377 = self.match(self.input, 127, self.FOLLOW_127_in_exception_names2047)
                        if self._state.backtracking == 0:
                            string_literal377_tree = self._adaptor.createWithPayload(string_literal377)
                            self._adaptor.addChild(root_0, string_literal377_tree)



                        self._state.following.append(self.FOLLOW_exception_name_in_exception_names2049)
                        exception_name378 = self.exception_name()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, exception_name378.tree)



                    else:
                        break #loop89




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 38, exception_names_StartIndex, success)


            pass
        return retval

    # $ANTLR end "exception_names"


    class exception_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.exception_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "exception_name"
    # ./output/PLSQL3.g:317:1: exception_name : ( exception_package_name DOT )? identifier ;
    def exception_name(self, ):
        retval = self.exception_name_return()
        retval.start = self.input.LT(1)

        exception_name_StartIndex = self.input.index()

        root_0 = None

        DOT380 = None
        exception_package_name379 = None

        identifier381 = None


        DOT380_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 39):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:318:2: ( ( exception_package_name DOT )? identifier )
                # ./output/PLSQL3.g:318:4: ( exception_package_name DOT )? identifier
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:318:4: ( exception_package_name DOT )?
                alt90 = 2
                LA90_0 = self.input.LA(1)

                if (LA90_0 == DOUBLEQUOTED_STRING or LA90_0 == ID) :
                    LA90_1 = self.input.LA(2)

                    if (LA90_1 == DOT) :
                        alt90 = 1
                if alt90 == 1:
                    # ./output/PLSQL3.g:318:6: exception_package_name DOT
                    pass
                    self._state.following.append(self.FOLLOW_exception_package_name_in_exception_name2065)
                    exception_package_name379 = self.exception_package_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, exception_package_name379.tree)


                    DOT380 = self.match(self.input, DOT, self.FOLLOW_DOT_in_exception_name2067)
                    if self._state.backtracking == 0:
                        DOT380_tree = self._adaptor.createWithPayload(DOT380)
                        self._adaptor.addChild(root_0, DOT380_tree)






                self._state.following.append(self.FOLLOW_identifier_in_exception_name2072)
                identifier381 = self.identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, identifier381.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 39, exception_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "exception_name"


    class exception_package_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.exception_package_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "exception_package_name"
    # ./output/PLSQL3.g:321:1: exception_package_name : identifier ;
    def exception_package_name(self, ):
        retval = self.exception_package_name_return()
        retval.start = self.input.LT(1)

        exception_package_name_StartIndex = self.input.index()

        root_0 = None

        identifier382 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 40):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:322:2: ( identifier )
                # ./output/PLSQL3.g:322:4: identifier
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_identifier_in_exception_package_name2083)
                identifier382 = self.identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, identifier382.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 40, exception_package_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "exception_package_name"


    class record_declaration_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.record_declaration_return, self).__init__()

            self.tree = None





    # $ANTLR start "record_declaration"
    # ./output/PLSQL3.g:331:1: record_declaration : record_type_dec ;
    def record_declaration(self, ):
        retval = self.record_declaration_return()
        retval.start = self.input.LT(1)

        record_declaration_StartIndex = self.input.index()

        root_0 = None

        record_type_dec383 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 41):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:332:2: ( record_type_dec )
                # ./output/PLSQL3.g:332:4: record_type_dec
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_record_type_dec_in_record_declaration2102)
                record_type_dec383 = self.record_type_dec()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, record_type_dec383.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 41, record_declaration_StartIndex, success)


            pass
        return retval

    # $ANTLR end "record_declaration"


    class record_type_dec_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.record_type_dec_return, self).__init__()

            self.tree = None





    # $ANTLR start "record_type_dec"
    # ./output/PLSQL3.g:336:1: record_type_dec : keyTYPE type_name 'IS' keyRECORD LPAREN field_specs RPAREN SEMI ;
    def record_type_dec(self, ):
        retval = self.record_type_dec_return()
        retval.start = self.input.LT(1)

        record_type_dec_StartIndex = self.input.index()

        root_0 = None

        string_literal386 = None
        LPAREN388 = None
        RPAREN390 = None
        SEMI391 = None
        keyTYPE384 = None

        type_name385 = None

        keyRECORD387 = None

        field_specs389 = None


        string_literal386_tree = None
        LPAREN388_tree = None
        RPAREN390_tree = None
        SEMI391_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 42):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:337:2: ( keyTYPE type_name 'IS' keyRECORD LPAREN field_specs RPAREN SEMI )
                # ./output/PLSQL3.g:337:4: keyTYPE type_name 'IS' keyRECORD LPAREN field_specs RPAREN SEMI
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyTYPE_in_record_type_dec2115)
                keyTYPE384 = self.keyTYPE()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyTYPE384.tree)


                self._state.following.append(self.FOLLOW_type_name_in_record_type_dec2117)
                type_name385 = self.type_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, type_name385.tree)


                string_literal386 = self.match(self.input, 106, self.FOLLOW_106_in_record_type_dec2119)
                if self._state.backtracking == 0:
                    string_literal386_tree = self._adaptor.createWithPayload(string_literal386)
                    self._adaptor.addChild(root_0, string_literal386_tree)



                self._state.following.append(self.FOLLOW_keyRECORD_in_record_type_dec2121)
                keyRECORD387 = self.keyRECORD()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyRECORD387.tree)


                LPAREN388 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_record_type_dec2126)
                if self._state.backtracking == 0:
                    LPAREN388_tree = self._adaptor.createWithPayload(LPAREN388)
                    self._adaptor.addChild(root_0, LPAREN388_tree)



                self._state.following.append(self.FOLLOW_field_specs_in_record_type_dec2128)
                field_specs389 = self.field_specs()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, field_specs389.tree)


                RPAREN390 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_record_type_dec2130)
                if self._state.backtracking == 0:
                    RPAREN390_tree = self._adaptor.createWithPayload(RPAREN390)
                    self._adaptor.addChild(root_0, RPAREN390_tree)



                SEMI391 = self.match(self.input, SEMI, self.FOLLOW_SEMI_in_record_type_dec2132)
                if self._state.backtracking == 0:
                    SEMI391_tree = self._adaptor.createWithPayload(SEMI391)
                    self._adaptor.addChild(root_0, SEMI391_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 42, record_type_dec_StartIndex, success)


            pass
        return retval

    # $ANTLR end "record_type_dec"


    class field_specs_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.field_specs_return, self).__init__()

            self.tree = None





    # $ANTLR start "field_specs"
    # ./output/PLSQL3.g:345:1: field_specs : field_spec ( COMMA field_spec )* ;
    def field_specs(self, ):
        retval = self.field_specs_return()
        retval.start = self.input.LT(1)

        field_specs_StartIndex = self.input.index()

        root_0 = None

        COMMA393 = None
        field_spec392 = None

        field_spec394 = None


        COMMA393_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 43):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:346:2: ( field_spec ( COMMA field_spec )* )
                # ./output/PLSQL3.g:346:4: field_spec ( COMMA field_spec )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_field_spec_in_field_specs2147)
                field_spec392 = self.field_spec()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, field_spec392.tree)


                # ./output/PLSQL3.g:346:15: ( COMMA field_spec )*
                while True: #loop91
                    alt91 = 2
                    LA91_0 = self.input.LA(1)

                    if (LA91_0 == COMMA) :
                        alt91 = 1


                    if alt91 == 1:
                        # ./output/PLSQL3.g:346:17: COMMA field_spec
                        pass
                        COMMA393 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_field_specs2151)
                        if self._state.backtracking == 0:
                            COMMA393_tree = self._adaptor.createWithPayload(COMMA393)
                            self._adaptor.addChild(root_0, COMMA393_tree)



                        self._state.following.append(self.FOLLOW_field_spec_in_field_specs2153)
                        field_spec394 = self.field_spec()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, field_spec394.tree)



                    else:
                        break #loop91




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 43, field_specs_StartIndex, success)


            pass
        return retval

    # $ANTLR end "field_specs"


    class field_spec_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.field_spec_return, self).__init__()

            self.tree = None





    # $ANTLR start "field_spec"
    # ./output/PLSQL3.g:348:1: field_spec : column_name type_spec ( 'NOT' 'NULL' )? ( ( ASSIGN | 'DEFAULT' ) plsql_expression )? ;
    def field_spec(self, ):
        retval = self.field_spec_return()
        retval.start = self.input.LT(1)

        field_spec_StartIndex = self.input.index()

        root_0 = None

        string_literal397 = None
        string_literal398 = None
        set399 = None
        column_name395 = None

        type_spec396 = None

        plsql_expression400 = None


        string_literal397_tree = None
        string_literal398_tree = None
        set399_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 44):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:349:2: ( column_name type_spec ( 'NOT' 'NULL' )? ( ( ASSIGN | 'DEFAULT' ) plsql_expression )? )
                # ./output/PLSQL3.g:349:4: column_name type_spec ( 'NOT' 'NULL' )? ( ( ASSIGN | 'DEFAULT' ) plsql_expression )?
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_column_name_in_field_spec2166)
                column_name395 = self.column_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, column_name395.tree)


                self._state.following.append(self.FOLLOW_type_spec_in_field_spec2168)
                type_spec396 = self.type_spec()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, type_spec396.tree)


                # ./output/PLSQL3.g:350:3: ( 'NOT' 'NULL' )?
                alt92 = 2
                LA92_0 = self.input.LA(1)

                if (LA92_0 == 118) :
                    alt92 = 1
                if alt92 == 1:
                    # ./output/PLSQL3.g:350:4: 'NOT' 'NULL'
                    pass
                    string_literal397 = self.match(self.input, 118, self.FOLLOW_118_in_field_spec2173)
                    if self._state.backtracking == 0:
                        string_literal397_tree = self._adaptor.createWithPayload(string_literal397)
                        self._adaptor.addChild(root_0, string_literal397_tree)



                    string_literal398 = self.match(self.input, 120, self.FOLLOW_120_in_field_spec2175)
                    if self._state.backtracking == 0:
                        string_literal398_tree = self._adaptor.createWithPayload(string_literal398)
                        self._adaptor.addChild(root_0, string_literal398_tree)






                # ./output/PLSQL3.g:351:3: ( ( ASSIGN | 'DEFAULT' ) plsql_expression )?
                alt93 = 2
                LA93_0 = self.input.LA(1)

                if (LA93_0 == ASSIGN or LA93_0 == 78) :
                    alt93 = 1
                if alt93 == 1:
                    # ./output/PLSQL3.g:351:5: ( ASSIGN | 'DEFAULT' ) plsql_expression
                    pass
                    set399 = self.input.LT(1)

                    if self.input.LA(1) == ASSIGN or self.input.LA(1) == 78:
                        self.input.consume()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set399))

                        self._state.errorRecovery = False


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        mse = MismatchedSetException(None, self.input)
                        raise mse



                    self._state.following.append(self.FOLLOW_plsql_expression_in_field_spec2194)
                    plsql_expression400 = self.plsql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, plsql_expression400.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 44, field_spec_StartIndex, success)


            pass
        return retval

    # $ANTLR end "field_spec"


    class plsql_table_declaration_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.plsql_table_declaration_return, self).__init__()

            self.tree = None





    # $ANTLR start "plsql_table_declaration"
    # ./output/PLSQL3.g:354:1: plsql_table_declaration : table_type_dec ;
    def plsql_table_declaration(self, ):
        retval = self.plsql_table_declaration_return()
        retval.start = self.input.LT(1)

        plsql_table_declaration_StartIndex = self.input.index()

        root_0 = None

        table_type_dec401 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 45):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:355:2: ( table_type_dec )
                # ./output/PLSQL3.g:355:4: table_type_dec
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_table_type_dec_in_plsql_table_declaration2207)
                table_type_dec401 = self.table_type_dec()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, table_type_dec401.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 45, plsql_table_declaration_StartIndex, success)


            pass
        return retval

    # $ANTLR end "plsql_table_declaration"


    class table_type_dec_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.table_type_dec_return, self).__init__()

            self.tree = None





    # $ANTLR start "table_type_dec"
    # ./output/PLSQL3.g:359:1: table_type_dec : keyTYPE type_name 'IS' 'TABLE' 'OF' type_spec ( 'NOT' 'NULL' )? ( 'INDEX' 'BY' ( 'BINARY_INTEGER' | 'PLS_INTEGER' | 'VARCHAR2' LPAREN integer RPAREN ) )? SEMI ;
    def table_type_dec(self, ):
        retval = self.table_type_dec_return()
        retval.start = self.input.LT(1)

        table_type_dec_StartIndex = self.input.index()

        root_0 = None

        string_literal404 = None
        string_literal405 = None
        string_literal406 = None
        string_literal408 = None
        string_literal409 = None
        string_literal410 = None
        string_literal411 = None
        string_literal412 = None
        string_literal413 = None
        string_literal414 = None
        LPAREN415 = None
        RPAREN417 = None
        SEMI418 = None
        keyTYPE402 = None

        type_name403 = None

        type_spec407 = None

        integer416 = None


        string_literal404_tree = None
        string_literal405_tree = None
        string_literal406_tree = None
        string_literal408_tree = None
        string_literal409_tree = None
        string_literal410_tree = None
        string_literal411_tree = None
        string_literal412_tree = None
        string_literal413_tree = None
        string_literal414_tree = None
        LPAREN415_tree = None
        RPAREN417_tree = None
        SEMI418_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 46):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:360:2: ( keyTYPE type_name 'IS' 'TABLE' 'OF' type_spec ( 'NOT' 'NULL' )? ( 'INDEX' 'BY' ( 'BINARY_INTEGER' | 'PLS_INTEGER' | 'VARCHAR2' LPAREN integer RPAREN ) )? SEMI )
                # ./output/PLSQL3.g:360:4: keyTYPE type_name 'IS' 'TABLE' 'OF' type_spec ( 'NOT' 'NULL' )? ( 'INDEX' 'BY' ( 'BINARY_INTEGER' | 'PLS_INTEGER' | 'VARCHAR2' LPAREN integer RPAREN ) )? SEMI
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyTYPE_in_table_type_dec2219)
                keyTYPE402 = self.keyTYPE()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyTYPE402.tree)


                self._state.following.append(self.FOLLOW_type_name_in_table_type_dec2221)
                type_name403 = self.type_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, type_name403.tree)


                string_literal404 = self.match(self.input, 106, self.FOLLOW_106_in_table_type_dec2223)
                if self._state.backtracking == 0:
                    string_literal404_tree = self._adaptor.createWithPayload(string_literal404)
                    self._adaptor.addChild(root_0, string_literal404_tree)



                string_literal405 = self.match(self.input, 153, self.FOLLOW_153_in_table_type_dec2225)
                if self._state.backtracking == 0:
                    string_literal405_tree = self._adaptor.createWithPayload(string_literal405)
                    self._adaptor.addChild(root_0, string_literal405_tree)



                string_literal406 = self.match(self.input, 125, self.FOLLOW_125_in_table_type_dec2230)
                if self._state.backtracking == 0:
                    string_literal406_tree = self._adaptor.createWithPayload(string_literal406)
                    self._adaptor.addChild(root_0, string_literal406_tree)



                self._state.following.append(self.FOLLOW_type_spec_in_table_type_dec2232)
                type_spec407 = self.type_spec()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, type_spec407.tree)


                # ./output/PLSQL3.g:361:18: ( 'NOT' 'NULL' )?
                alt94 = 2
                LA94_0 = self.input.LA(1)

                if (LA94_0 == 118) :
                    alt94 = 1
                if alt94 == 1:
                    # ./output/PLSQL3.g:361:20: 'NOT' 'NULL'
                    pass
                    string_literal408 = self.match(self.input, 118, self.FOLLOW_118_in_table_type_dec2236)
                    if self._state.backtracking == 0:
                        string_literal408_tree = self._adaptor.createWithPayload(string_literal408)
                        self._adaptor.addChild(root_0, string_literal408_tree)



                    string_literal409 = self.match(self.input, 120, self.FOLLOW_120_in_table_type_dec2238)
                    if self._state.backtracking == 0:
                        string_literal409_tree = self._adaptor.createWithPayload(string_literal409)
                        self._adaptor.addChild(root_0, string_literal409_tree)






                # ./output/PLSQL3.g:362:3: ( 'INDEX' 'BY' ( 'BINARY_INTEGER' | 'PLS_INTEGER' | 'VARCHAR2' LPAREN integer RPAREN ) )?
                alt96 = 2
                LA96_0 = self.input.LA(1)

                if (LA96_0 == 100) :
                    alt96 = 1
                if alt96 == 1:
                    # ./output/PLSQL3.g:362:5: 'INDEX' 'BY' ( 'BINARY_INTEGER' | 'PLS_INTEGER' | 'VARCHAR2' LPAREN integer RPAREN )
                    pass
                    string_literal410 = self.match(self.input, 100, self.FOLLOW_100_in_table_type_dec2247)
                    if self._state.backtracking == 0:
                        string_literal410_tree = self._adaptor.createWithPayload(string_literal410)
                        self._adaptor.addChild(root_0, string_literal410_tree)



                    string_literal411 = self.match(self.input, 64, self.FOLLOW_64_in_table_type_dec2249)
                    if self._state.backtracking == 0:
                        string_literal411_tree = self._adaptor.createWithPayload(string_literal411)
                        self._adaptor.addChild(root_0, string_literal411_tree)



                    # ./output/PLSQL3.g:363:4: ( 'BINARY_INTEGER' | 'PLS_INTEGER' | 'VARCHAR2' LPAREN integer RPAREN )
                    alt95 = 3
                    LA95 = self.input.LA(1)
                    if LA95 == 61:
                        alt95 = 1
                    elif LA95 == 131:
                        alt95 = 2
                    elif LA95 == 163:
                        alt95 = 3
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 95, 0, self.input)

                        raise nvae


                    if alt95 == 1:
                        # ./output/PLSQL3.g:363:6: 'BINARY_INTEGER'
                        pass
                        string_literal412 = self.match(self.input, 61, self.FOLLOW_61_in_table_type_dec2257)
                        if self._state.backtracking == 0:
                            string_literal412_tree = self._adaptor.createWithPayload(string_literal412)
                            self._adaptor.addChild(root_0, string_literal412_tree)




                    elif alt95 == 2:
                        # ./output/PLSQL3.g:364:6: 'PLS_INTEGER'
                        pass
                        string_literal413 = self.match(self.input, 131, self.FOLLOW_131_in_table_type_dec2264)
                        if self._state.backtracking == 0:
                            string_literal413_tree = self._adaptor.createWithPayload(string_literal413)
                            self._adaptor.addChild(root_0, string_literal413_tree)




                    elif alt95 == 3:
                        # ./output/PLSQL3.g:365:6: 'VARCHAR2' LPAREN integer RPAREN
                        pass
                        string_literal414 = self.match(self.input, 163, self.FOLLOW_163_in_table_type_dec2271)
                        if self._state.backtracking == 0:
                            string_literal414_tree = self._adaptor.createWithPayload(string_literal414)
                            self._adaptor.addChild(root_0, string_literal414_tree)



                        LPAREN415 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_table_type_dec2273)
                        if self._state.backtracking == 0:
                            LPAREN415_tree = self._adaptor.createWithPayload(LPAREN415)
                            self._adaptor.addChild(root_0, LPAREN415_tree)



                        self._state.following.append(self.FOLLOW_integer_in_table_type_dec2275)
                        integer416 = self.integer()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, integer416.tree)


                        RPAREN417 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_table_type_dec2277)
                        if self._state.backtracking == 0:
                            RPAREN417_tree = self._adaptor.createWithPayload(RPAREN417)
                            self._adaptor.addChild(root_0, RPAREN417_tree)









                SEMI418 = self.match(self.input, SEMI, self.FOLLOW_SEMI_in_table_type_dec2291)
                if self._state.backtracking == 0:
                    SEMI418_tree = self._adaptor.createWithPayload(SEMI418)
                    self._adaptor.addChild(root_0, SEMI418_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 46, table_type_dec_StartIndex, success)


            pass
        return retval

    # $ANTLR end "table_type_dec"


    class table_var_dec_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.table_var_dec_return, self).__init__()

            self.tree = None





    # $ANTLR start "table_var_dec"
    # ./output/PLSQL3.g:371:1: table_var_dec : plsql_table_name type_name SEMI ;
    def table_var_dec(self, ):
        retval = self.table_var_dec_return()
        retval.start = self.input.LT(1)

        table_var_dec_StartIndex = self.input.index()

        root_0 = None

        SEMI421 = None
        plsql_table_name419 = None

        type_name420 = None


        SEMI421_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 47):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:372:2: ( plsql_table_name type_name SEMI )
                # ./output/PLSQL3.g:372:4: plsql_table_name type_name SEMI
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_plsql_table_name_in_table_var_dec2302)
                plsql_table_name419 = self.plsql_table_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, plsql_table_name419.tree)


                self._state.following.append(self.FOLLOW_type_name_in_table_var_dec2304)
                type_name420 = self.type_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, type_name420.tree)


                SEMI421 = self.match(self.input, SEMI, self.FOLLOW_SEMI_in_table_var_dec2306)
                if self._state.backtracking == 0:
                    SEMI421_tree = self._adaptor.createWithPayload(SEMI421)
                    self._adaptor.addChild(root_0, SEMI421_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 47, table_var_dec_StartIndex, success)


            pass
        return retval

    # $ANTLR end "table_var_dec"


    class plsql_table_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.plsql_table_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "plsql_table_name"
    # ./output/PLSQL3.g:375:1: plsql_table_name : identifier ( DOT identifier )* ;
    def plsql_table_name(self, ):
        retval = self.plsql_table_name_return()
        retval.start = self.input.LT(1)

        plsql_table_name_StartIndex = self.input.index()

        root_0 = None

        DOT423 = None
        identifier422 = None

        identifier424 = None


        DOT423_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 48):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:376:2: ( identifier ( DOT identifier )* )
                # ./output/PLSQL3.g:376:4: identifier ( DOT identifier )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_identifier_in_plsql_table_name2317)
                identifier422 = self.identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, identifier422.tree)


                # ./output/PLSQL3.g:376:15: ( DOT identifier )*
                while True: #loop97
                    alt97 = 2
                    LA97_0 = self.input.LA(1)

                    if (LA97_0 == DOT) :
                        alt97 = 1


                    if alt97 == 1:
                        # ./output/PLSQL3.g:376:17: DOT identifier
                        pass
                        DOT423 = self.match(self.input, DOT, self.FOLLOW_DOT_in_plsql_table_name2321)
                        if self._state.backtracking == 0:
                            DOT423_tree = self._adaptor.createWithPayload(DOT423)
                            self._adaptor.addChild(root_0, DOT423_tree)



                        self._state.following.append(self.FOLLOW_identifier_in_plsql_table_name2323)
                        identifier424 = self.identifier()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, identifier424.tree)



                    else:
                        break #loop97




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 48, plsql_table_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "plsql_table_name"


    class varray_declaration_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.varray_declaration_return, self).__init__()

            self.tree = None





    # $ANTLR start "varray_declaration"
    # ./output/PLSQL3.g:379:1: varray_declaration : keyTYPE type_name 'IS' ( keyVARRAY | keyVARYING keyARRAY ) LPAREN integer RPAREN 'OF' type_spec ( 'NOT' 'NULL' )? ;
    def varray_declaration(self, ):
        retval = self.varray_declaration_return()
        retval.start = self.input.LT(1)

        varray_declaration_StartIndex = self.input.index()

        root_0 = None

        string_literal427 = None
        LPAREN431 = None
        RPAREN433 = None
        string_literal434 = None
        string_literal436 = None
        string_literal437 = None
        keyTYPE425 = None

        type_name426 = None

        keyVARRAY428 = None

        keyVARYING429 = None

        keyARRAY430 = None

        integer432 = None

        type_spec435 = None


        string_literal427_tree = None
        LPAREN431_tree = None
        RPAREN433_tree = None
        string_literal434_tree = None
        string_literal436_tree = None
        string_literal437_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 49):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:380:2: ( keyTYPE type_name 'IS' ( keyVARRAY | keyVARYING keyARRAY ) LPAREN integer RPAREN 'OF' type_spec ( 'NOT' 'NULL' )? )
                # ./output/PLSQL3.g:380:4: keyTYPE type_name 'IS' ( keyVARRAY | keyVARYING keyARRAY ) LPAREN integer RPAREN 'OF' type_spec ( 'NOT' 'NULL' )?
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyTYPE_in_varray_declaration2337)
                keyTYPE425 = self.keyTYPE()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyTYPE425.tree)


                self._state.following.append(self.FOLLOW_type_name_in_varray_declaration2339)
                type_name426 = self.type_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, type_name426.tree)


                string_literal427 = self.match(self.input, 106, self.FOLLOW_106_in_varray_declaration2341)
                if self._state.backtracking == 0:
                    string_literal427_tree = self._adaptor.createWithPayload(string_literal427)
                    self._adaptor.addChild(root_0, string_literal427_tree)



                # ./output/PLSQL3.g:381:3: ( keyVARRAY | keyVARYING keyARRAY )
                alt98 = 2
                LA98_0 = self.input.LA(1)

                if (LA98_0 == ID) :
                    LA98_1 = self.input.LA(2)

                    if (LA98_1 == LPAREN) :
                        alt98 = 1
                    elif (LA98_1 == ID) :
                        alt98 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 98, 1, self.input)

                        raise nvae


                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 98, 0, self.input)

                    raise nvae


                if alt98 == 1:
                    # ./output/PLSQL3.g:381:5: keyVARRAY
                    pass
                    self._state.following.append(self.FOLLOW_keyVARRAY_in_varray_declaration2348)
                    keyVARRAY428 = self.keyVARRAY()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyVARRAY428.tree)



                elif alt98 == 2:
                    # ./output/PLSQL3.g:381:17: keyVARYING keyARRAY
                    pass
                    self._state.following.append(self.FOLLOW_keyVARYING_in_varray_declaration2352)
                    keyVARYING429 = self.keyVARYING()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyVARYING429.tree)


                    self._state.following.append(self.FOLLOW_keyARRAY_in_varray_declaration2354)
                    keyARRAY430 = self.keyARRAY()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyARRAY430.tree)





                LPAREN431 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_varray_declaration2358)
                if self._state.backtracking == 0:
                    LPAREN431_tree = self._adaptor.createWithPayload(LPAREN431)
                    self._adaptor.addChild(root_0, LPAREN431_tree)



                self._state.following.append(self.FOLLOW_integer_in_varray_declaration2360)
                integer432 = self.integer()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, integer432.tree)


                RPAREN433 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_varray_declaration2362)
                if self._state.backtracking == 0:
                    RPAREN433_tree = self._adaptor.createWithPayload(RPAREN433)
                    self._adaptor.addChild(root_0, RPAREN433_tree)



                string_literal434 = self.match(self.input, 125, self.FOLLOW_125_in_varray_declaration2366)
                if self._state.backtracking == 0:
                    string_literal434_tree = self._adaptor.createWithPayload(string_literal434)
                    self._adaptor.addChild(root_0, string_literal434_tree)



                self._state.following.append(self.FOLLOW_type_spec_in_varray_declaration2368)
                type_spec435 = self.type_spec()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, type_spec435.tree)


                # ./output/PLSQL3.g:382:18: ( 'NOT' 'NULL' )?
                alt99 = 2
                LA99_0 = self.input.LA(1)

                if (LA99_0 == 118) :
                    alt99 = 1
                if alt99 == 1:
                    # ./output/PLSQL3.g:382:20: 'NOT' 'NULL'
                    pass
                    string_literal436 = self.match(self.input, 118, self.FOLLOW_118_in_varray_declaration2372)
                    if self._state.backtracking == 0:
                        string_literal436_tree = self._adaptor.createWithPayload(string_literal436)
                        self._adaptor.addChild(root_0, string_literal436_tree)



                    string_literal437 = self.match(self.input, 120, self.FOLLOW_120_in_varray_declaration2374)
                    if self._state.backtracking == 0:
                        string_literal437_tree = self._adaptor.createWithPayload(string_literal437)
                        self._adaptor.addChild(root_0, string_literal437_tree)








                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 49, varray_declaration_StartIndex, success)


            pass
        return retval

    # $ANTLR end "varray_declaration"


    class procedure_declaration_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.procedure_declaration_return, self).__init__()

            self.tree = None





    # $ANTLR start "procedure_declaration"
    # ./output/PLSQL3.g:385:1: procedure_declaration : procedure_body ;
    def procedure_declaration(self, ):
        retval = self.procedure_declaration_return()
        retval.start = self.input.LT(1)

        procedure_declaration_StartIndex = self.input.index()

        root_0 = None

        procedure_body438 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 50):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:386:2: ( procedure_body )
                # ./output/PLSQL3.g:386:4: procedure_body
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_procedure_body_in_procedure_declaration2388)
                procedure_body438 = self.procedure_body()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, procedure_body438.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 50, procedure_declaration_StartIndex, success)


            pass
        return retval

    # $ANTLR end "procedure_declaration"


    class procedure_body_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.procedure_body_return, self).__init__()

            self.tree = None





    # $ANTLR start "procedure_body"
    # ./output/PLSQL3.g:389:1: procedure_body : ( proc_fun_start )? 'PROCEDURE' ^ procedure_name ( LPAREN argument ( COMMA argument )* RPAREN )? ( 'IS' | 'AS' ) ( ( declare_spec )=> ( declare_spec )* ) ( 'BEGIN' ) ( seq_of_statements ) ( 'EXCEPTION' ( exception_handler )* )? 'END' ( procedure_name )? SEMI ;
    def procedure_body(self, ):
        retval = self.procedure_body_return()
        retval.start = self.input.LT(1)

        procedure_body_StartIndex = self.input.index()

        root_0 = None

        string_literal440 = None
        LPAREN442 = None
        COMMA444 = None
        RPAREN446 = None
        set447 = None
        string_literal449 = None
        string_literal451 = None
        string_literal453 = None
        SEMI455 = None
        proc_fun_start439 = None

        procedure_name441 = None

        argument443 = None

        argument445 = None

        declare_spec448 = None

        seq_of_statements450 = None

        exception_handler452 = None

        procedure_name454 = None


        string_literal440_tree = None
        LPAREN442_tree = None
        COMMA444_tree = None
        RPAREN446_tree = None
        set447_tree = None
        string_literal449_tree = None
        string_literal451_tree = None
        string_literal453_tree = None
        SEMI455_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 51):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:390:2: ( ( proc_fun_start )? 'PROCEDURE' ^ procedure_name ( LPAREN argument ( COMMA argument )* RPAREN )? ( 'IS' | 'AS' ) ( ( declare_spec )=> ( declare_spec )* ) ( 'BEGIN' ) ( seq_of_statements ) ( 'EXCEPTION' ( exception_handler )* )? 'END' ( procedure_name )? SEMI )
                # ./output/PLSQL3.g:390:4: ( proc_fun_start )? 'PROCEDURE' ^ procedure_name ( LPAREN argument ( COMMA argument )* RPAREN )? ( 'IS' | 'AS' ) ( ( declare_spec )=> ( declare_spec )* ) ( 'BEGIN' ) ( seq_of_statements ) ( 'EXCEPTION' ( exception_handler )* )? 'END' ( procedure_name )? SEMI
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:390:4: ( proc_fun_start )?
                alt100 = 2
                LA100_0 = self.input.LA(1)

                if (LA100_0 == 73) :
                    alt100 = 1
                if alt100 == 1:
                    # ./output/PLSQL3.g:390:6: proc_fun_start
                    pass
                    self._state.following.append(self.FOLLOW_proc_fun_start_in_procedure_body2401)
                    proc_fun_start439 = self.proc_fun_start()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, proc_fun_start439.tree)





                string_literal440 = self.match(self.input, 135, self.FOLLOW_135_in_procedure_body2406)
                if self._state.backtracking == 0:
                    string_literal440_tree = self._adaptor.createWithPayload(string_literal440)
                    root_0 = self._adaptor.becomeRoot(string_literal440_tree, root_0)



                self._state.following.append(self.FOLLOW_procedure_name_in_procedure_body2409)
                procedure_name441 = self.procedure_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, procedure_name441.tree)


                # ./output/PLSQL3.g:391:3: ( LPAREN argument ( COMMA argument )* RPAREN )?
                alt102 = 2
                LA102_0 = self.input.LA(1)

                if (LA102_0 == LPAREN) :
                    alt102 = 1
                if alt102 == 1:
                    # ./output/PLSQL3.g:391:5: LPAREN argument ( COMMA argument )* RPAREN
                    pass
                    LPAREN442 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_procedure_body2416)
                    if self._state.backtracking == 0:
                        LPAREN442_tree = self._adaptor.createWithPayload(LPAREN442)
                        self._adaptor.addChild(root_0, LPAREN442_tree)



                    self._state.following.append(self.FOLLOW_argument_in_procedure_body2418)
                    argument443 = self.argument()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, argument443.tree)


                    # ./output/PLSQL3.g:391:21: ( COMMA argument )*
                    while True: #loop101
                        alt101 = 2
                        LA101_0 = self.input.LA(1)

                        if (LA101_0 == COMMA) :
                            alt101 = 1


                        if alt101 == 1:
                            # ./output/PLSQL3.g:391:23: COMMA argument
                            pass
                            COMMA444 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_procedure_body2422)
                            if self._state.backtracking == 0:
                                COMMA444_tree = self._adaptor.createWithPayload(COMMA444)
                                self._adaptor.addChild(root_0, COMMA444_tree)



                            self._state.following.append(self.FOLLOW_argument_in_procedure_body2424)
                            argument445 = self.argument()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, argument445.tree)



                        else:
                            break #loop101


                    RPAREN446 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_procedure_body2429)
                    if self._state.backtracking == 0:
                        RPAREN446_tree = self._adaptor.createWithPayload(RPAREN446)
                        self._adaptor.addChild(root_0, RPAREN446_tree)






                set447 = self.input.LT(1)

                if self.input.LA(1) == 53 or self.input.LA(1) == 106:
                    self.input.consume()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set447))

                    self._state.errorRecovery = False


                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    mse = MismatchedSetException(None, self.input)
                    raise mse



                # ./output/PLSQL3.g:394:3: ( ( declare_spec )=> ( declare_spec )* )
                # ./output/PLSQL3.g:394:5: ( declare_spec )=> ( declare_spec )*
                pass
                # ./output/PLSQL3.g:394:25: ( declare_spec )*
                while True: #loop103
                    alt103 = 2
                    LA103_0 = self.input.LA(1)

                    if (LA103_0 == DOUBLEQUOTED_STRING or LA103_0 == ID or LA103_0 == 73 or LA103_0 == 94 or LA103_0 == 133 or LA103_0 == 135) :
                        alt103 = 1


                    if alt103 == 1:
                        # ./output/PLSQL3.g:394:27: declare_spec
                        pass
                        self._state.following.append(self.FOLLOW_declare_spec_in_procedure_body2464)
                        declare_spec448 = self.declare_spec()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, declare_spec448.tree)



                    else:
                        break #loop103





                # ./output/PLSQL3.g:395:3: ( 'BEGIN' )
                # ./output/PLSQL3.g:395:5: 'BEGIN'
                pass
                string_literal449 = self.match(self.input, 56, self.FOLLOW_56_in_procedure_body2475)
                if self._state.backtracking == 0:
                    string_literal449_tree = self._adaptor.createWithPayload(string_literal449)
                    self._adaptor.addChild(root_0, string_literal449_tree)






                # ./output/PLSQL3.g:396:3: ( seq_of_statements )
                # ./output/PLSQL3.g:396:5: seq_of_statements
                pass
                self._state.following.append(self.FOLLOW_seq_of_statements_in_procedure_body2483)
                seq_of_statements450 = self.seq_of_statements()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, seq_of_statements450.tree)





                # ./output/PLSQL3.g:397:3: ( 'EXCEPTION' ( exception_handler )* )?
                alt105 = 2
                LA105_0 = self.input.LA(1)

                if (LA105_0 == 86) :
                    alt105 = 1
                if alt105 == 1:
                    # ./output/PLSQL3.g:397:5: 'EXCEPTION' ( exception_handler )*
                    pass
                    string_literal451 = self.match(self.input, 86, self.FOLLOW_86_in_procedure_body2491)
                    if self._state.backtracking == 0:
                        string_literal451_tree = self._adaptor.createWithPayload(string_literal451)
                        self._adaptor.addChild(root_0, string_literal451_tree)



                    # ./output/PLSQL3.g:397:17: ( exception_handler )*
                    while True: #loop104
                        alt104 = 2
                        LA104_0 = self.input.LA(1)

                        if (LA104_0 == 164) :
                            alt104 = 1


                        if alt104 == 1:
                            # ./output/PLSQL3.g:397:19: exception_handler
                            pass
                            self._state.following.append(self.FOLLOW_exception_handler_in_procedure_body2495)
                            exception_handler452 = self.exception_handler()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, exception_handler452.tree)



                        else:
                            break #loop104





                string_literal453 = self.match(self.input, 85, self.FOLLOW_85_in_procedure_body2505)
                if self._state.backtracking == 0:
                    string_literal453_tree = self._adaptor.createWithPayload(string_literal453)
                    self._adaptor.addChild(root_0, string_literal453_tree)



                # ./output/PLSQL3.g:398:9: ( procedure_name )?
                alt106 = 2
                LA106_0 = self.input.LA(1)

                if (LA106_0 == DOUBLEQUOTED_STRING or LA106_0 == ID or LA106_0 == QUOTED_STRING) :
                    alt106 = 1
                if alt106 == 1:
                    # ./output/PLSQL3.g:398:11: procedure_name
                    pass
                    self._state.following.append(self.FOLLOW_procedure_name_in_procedure_body2509)
                    procedure_name454 = self.procedure_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, procedure_name454.tree)





                SEMI455 = self.match(self.input, SEMI, self.FOLLOW_SEMI_in_procedure_body2514)
                if self._state.backtracking == 0:
                    SEMI455_tree = self._adaptor.createWithPayload(SEMI455)
                    self._adaptor.addChild(root_0, SEMI455_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 51, procedure_body_StartIndex, success)


            pass
        return retval

    # $ANTLR end "procedure_body"


    class begin_block_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.begin_block_return, self).__init__()

            self.tree = None





    # $ANTLR start "begin_block"
    # ./output/PLSQL3.g:401:1: begin_block : 'BEGIN' ( seq_of_statements ) ( 'EXCEPTION' ( exception_handler )+ )? 'END' ;
    def begin_block(self, ):
        retval = self.begin_block_return()
        retval.start = self.input.LT(1)

        begin_block_StartIndex = self.input.index()

        root_0 = None

        string_literal456 = None
        string_literal458 = None
        string_literal460 = None
        seq_of_statements457 = None

        exception_handler459 = None


        string_literal456_tree = None
        string_literal458_tree = None
        string_literal460_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 52):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:402:2: ( 'BEGIN' ( seq_of_statements ) ( 'EXCEPTION' ( exception_handler )+ )? 'END' )
                # ./output/PLSQL3.g:402:4: 'BEGIN' ( seq_of_statements ) ( 'EXCEPTION' ( exception_handler )+ )? 'END'
                pass
                root_0 = self._adaptor.nil()


                string_literal456 = self.match(self.input, 56, self.FOLLOW_56_in_begin_block2525)
                if self._state.backtracking == 0:
                    string_literal456_tree = self._adaptor.createWithPayload(string_literal456)
                    self._adaptor.addChild(root_0, string_literal456_tree)



                # ./output/PLSQL3.g:403:3: ( seq_of_statements )
                # ./output/PLSQL3.g:403:5: seq_of_statements
                pass
                self._state.following.append(self.FOLLOW_seq_of_statements_in_begin_block2531)
                seq_of_statements457 = self.seq_of_statements()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, seq_of_statements457.tree)





                # ./output/PLSQL3.g:404:3: ( 'EXCEPTION' ( exception_handler )+ )?
                alt108 = 2
                LA108_0 = self.input.LA(1)

                if (LA108_0 == 86) :
                    alt108 = 1
                if alt108 == 1:
                    # ./output/PLSQL3.g:404:5: 'EXCEPTION' ( exception_handler )+
                    pass
                    string_literal458 = self.match(self.input, 86, self.FOLLOW_86_in_begin_block2539)
                    if self._state.backtracking == 0:
                        string_literal458_tree = self._adaptor.createWithPayload(string_literal458)
                        self._adaptor.addChild(root_0, string_literal458_tree)



                    # ./output/PLSQL3.g:404:17: ( exception_handler )+
                    cnt107 = 0
                    while True: #loop107
                        alt107 = 2
                        LA107_0 = self.input.LA(1)

                        if (LA107_0 == 164) :
                            alt107 = 1


                        if alt107 == 1:
                            # ./output/PLSQL3.g:404:19: exception_handler
                            pass
                            self._state.following.append(self.FOLLOW_exception_handler_in_begin_block2543)
                            exception_handler459 = self.exception_handler()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, exception_handler459.tree)



                        else:
                            if cnt107 >= 1:
                                break #loop107

                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            eee = EarlyExitException(107, self.input)
                            raise eee

                        cnt107 += 1





                string_literal460 = self.match(self.input, 85, self.FOLLOW_85_in_begin_block2553)
                if self._state.backtracking == 0:
                    string_literal460_tree = self._adaptor.createWithPayload(string_literal460)
                    self._adaptor.addChild(root_0, string_literal460_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 52, begin_block_StartIndex, success)


            pass
        return retval

    # $ANTLR end "begin_block"


    class exception_handler_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.exception_handler_return, self).__init__()

            self.tree = None





    # $ANTLR start "exception_handler"
    # ./output/PLSQL3.g:409:1: exception_handler : 'WHEN' exception_names 'THEN' seq_of_statements ;
    def exception_handler(self, ):
        retval = self.exception_handler_return()
        retval.start = self.input.LT(1)

        exception_handler_StartIndex = self.input.index()

        root_0 = None

        string_literal461 = None
        string_literal463 = None
        exception_names462 = None

        seq_of_statements464 = None


        string_literal461_tree = None
        string_literal463_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 53):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:410:2: ( 'WHEN' exception_names 'THEN' seq_of_statements )
                # ./output/PLSQL3.g:410:4: 'WHEN' exception_names 'THEN' seq_of_statements
                pass
                root_0 = self._adaptor.nil()


                string_literal461 = self.match(self.input, 164, self.FOLLOW_164_in_exception_handler2565)
                if self._state.backtracking == 0:
                    string_literal461_tree = self._adaptor.createWithPayload(string_literal461)
                    self._adaptor.addChild(root_0, string_literal461_tree)



                self._state.following.append(self.FOLLOW_exception_names_in_exception_handler2567)
                exception_names462 = self.exception_names()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, exception_names462.tree)


                string_literal463 = self.match(self.input, 154, self.FOLLOW_154_in_exception_handler2569)
                if self._state.backtracking == 0:
                    string_literal463_tree = self._adaptor.createWithPayload(string_literal463)
                    self._adaptor.addChild(root_0, string_literal463_tree)



                self._state.following.append(self.FOLLOW_seq_of_statements_in_exception_handler2573)
                seq_of_statements464 = self.seq_of_statements()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, seq_of_statements464.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 53, exception_handler_StartIndex, success)


            pass
        return retval

    # $ANTLR end "exception_handler"


    class proc_fun_start_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.proc_fun_start_return, self).__init__()

            self.tree = None





    # $ANTLR start "proc_fun_start"
    # ./output/PLSQL3.g:414:1: proc_fun_start : 'CREATE' ( 'OR' keyREPLACE )? ;
    def proc_fun_start(self, ):
        retval = self.proc_fun_start_return()
        retval.start = self.input.LT(1)

        proc_fun_start_StartIndex = self.input.index()

        root_0 = None

        string_literal465 = None
        string_literal466 = None
        keyREPLACE467 = None


        string_literal465_tree = None
        string_literal466_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 54):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:415:2: ( 'CREATE' ( 'OR' keyREPLACE )? )
                # ./output/PLSQL3.g:415:4: 'CREATE' ( 'OR' keyREPLACE )?
                pass
                root_0 = self._adaptor.nil()


                string_literal465 = self.match(self.input, 73, self.FOLLOW_73_in_proc_fun_start2584)
                if self._state.backtracking == 0:
                    string_literal465_tree = self._adaptor.createWithPayload(string_literal465)
                    self._adaptor.addChild(root_0, string_literal465_tree)



                # ./output/PLSQL3.g:415:13: ( 'OR' keyREPLACE )?
                alt109 = 2
                LA109_0 = self.input.LA(1)

                if (LA109_0 == 127) :
                    alt109 = 1
                if alt109 == 1:
                    # ./output/PLSQL3.g:415:15: 'OR' keyREPLACE
                    pass
                    string_literal466 = self.match(self.input, 127, self.FOLLOW_127_in_proc_fun_start2588)
                    if self._state.backtracking == 0:
                        string_literal466_tree = self._adaptor.createWithPayload(string_literal466)
                        self._adaptor.addChild(root_0, string_literal466_tree)



                    self._state.following.append(self.FOLLOW_keyREPLACE_in_proc_fun_start2590)
                    keyREPLACE467 = self.keyREPLACE()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyREPLACE467.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 54, proc_fun_start_StartIndex, success)


            pass
        return retval

    # $ANTLR end "proc_fun_start"


    class function_body_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.function_body_return, self).__init__()

            self.tree = None





    # $ANTLR start "function_body"
    # ./output/PLSQL3.g:418:1: function_body : ( proc_fun_start )? 'FUNCTION' ^ function_name ( LPAREN arguments RPAREN )? keyRETURN return_type ( 'IS' | 'AS' ) ( ( declare_spec )=> ( declare_spec )* ) ( 'BEGIN' ) ( seq_of_statements ) ( 'EXCEPTION' ( exception_handler )+ )? 'END' ( function_name )? SEMI ;
    def function_body(self, ):
        retval = self.function_body_return()
        retval.start = self.input.LT(1)

        function_body_StartIndex = self.input.index()

        root_0 = None

        string_literal469 = None
        LPAREN471 = None
        RPAREN473 = None
        set476 = None
        string_literal478 = None
        string_literal480 = None
        string_literal482 = None
        SEMI484 = None
        proc_fun_start468 = None

        function_name470 = None

        arguments472 = None

        keyRETURN474 = None

        return_type475 = None

        declare_spec477 = None

        seq_of_statements479 = None

        exception_handler481 = None

        function_name483 = None


        string_literal469_tree = None
        LPAREN471_tree = None
        RPAREN473_tree = None
        set476_tree = None
        string_literal478_tree = None
        string_literal480_tree = None
        string_literal482_tree = None
        SEMI484_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 55):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:419:2: ( ( proc_fun_start )? 'FUNCTION' ^ function_name ( LPAREN arguments RPAREN )? keyRETURN return_type ( 'IS' | 'AS' ) ( ( declare_spec )=> ( declare_spec )* ) ( 'BEGIN' ) ( seq_of_statements ) ( 'EXCEPTION' ( exception_handler )+ )? 'END' ( function_name )? SEMI )
                # ./output/PLSQL3.g:419:4: ( proc_fun_start )? 'FUNCTION' ^ function_name ( LPAREN arguments RPAREN )? keyRETURN return_type ( 'IS' | 'AS' ) ( ( declare_spec )=> ( declare_spec )* ) ( 'BEGIN' ) ( seq_of_statements ) ( 'EXCEPTION' ( exception_handler )+ )? 'END' ( function_name )? SEMI
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:419:4: ( proc_fun_start )?
                alt110 = 2
                LA110_0 = self.input.LA(1)

                if (LA110_0 == 73) :
                    alt110 = 1
                if alt110 == 1:
                    # ./output/PLSQL3.g:419:6: proc_fun_start
                    pass
                    self._state.following.append(self.FOLLOW_proc_fun_start_in_function_body2606)
                    proc_fun_start468 = self.proc_fun_start()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, proc_fun_start468.tree)





                string_literal469 = self.match(self.input, 94, self.FOLLOW_94_in_function_body2611)
                if self._state.backtracking == 0:
                    string_literal469_tree = self._adaptor.createWithPayload(string_literal469)
                    root_0 = self._adaptor.becomeRoot(string_literal469_tree, root_0)



                self._state.following.append(self.FOLLOW_function_name_in_function_body2614)
                function_name470 = self.function_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, function_name470.tree)


                # ./output/PLSQL3.g:420:3: ( LPAREN arguments RPAREN )?
                alt111 = 2
                LA111_0 = self.input.LA(1)

                if (LA111_0 == LPAREN) :
                    alt111 = 1
                if alt111 == 1:
                    # ./output/PLSQL3.g:420:5: LPAREN arguments RPAREN
                    pass
                    LPAREN471 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_function_body2621)
                    if self._state.backtracking == 0:
                        LPAREN471_tree = self._adaptor.createWithPayload(LPAREN471)
                        self._adaptor.addChild(root_0, LPAREN471_tree)



                    self._state.following.append(self.FOLLOW_arguments_in_function_body2623)
                    arguments472 = self.arguments()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, arguments472.tree)


                    RPAREN473 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_function_body2625)
                    if self._state.backtracking == 0:
                        RPAREN473_tree = self._adaptor.createWithPayload(RPAREN473)
                        self._adaptor.addChild(root_0, RPAREN473_tree)






                self._state.following.append(self.FOLLOW_keyRETURN_in_function_body2633)
                keyRETURN474 = self.keyRETURN()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyRETURN474.tree)


                self._state.following.append(self.FOLLOW_return_type_in_function_body2635)
                return_type475 = self.return_type()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, return_type475.tree)


                set476 = self.input.LT(1)

                if self.input.LA(1) == 53 or self.input.LA(1) == 106:
                    self.input.consume()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set476))

                    self._state.errorRecovery = False


                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    mse = MismatchedSetException(None, self.input)
                    raise mse



                # ./output/PLSQL3.g:423:3: ( ( declare_spec )=> ( declare_spec )* )
                # ./output/PLSQL3.g:423:5: ( declare_spec )=> ( declare_spec )*
                pass
                # ./output/PLSQL3.g:423:25: ( declare_spec )*
                while True: #loop112
                    alt112 = 2
                    LA112_0 = self.input.LA(1)

                    if (LA112_0 == DOUBLEQUOTED_STRING or LA112_0 == ID or LA112_0 == 73 or LA112_0 == 94 or LA112_0 == 133 or LA112_0 == 135) :
                        alt112 = 1


                    if alt112 == 1:
                        # ./output/PLSQL3.g:423:27: declare_spec
                        pass
                        self._state.following.append(self.FOLLOW_declare_spec_in_function_body2664)
                        declare_spec477 = self.declare_spec()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, declare_spec477.tree)



                    else:
                        break #loop112





                # ./output/PLSQL3.g:424:3: ( 'BEGIN' )
                # ./output/PLSQL3.g:424:5: 'BEGIN'
                pass
                string_literal478 = self.match(self.input, 56, self.FOLLOW_56_in_function_body2675)
                if self._state.backtracking == 0:
                    string_literal478_tree = self._adaptor.createWithPayload(string_literal478)
                    self._adaptor.addChild(root_0, string_literal478_tree)






                # ./output/PLSQL3.g:425:3: ( seq_of_statements )
                # ./output/PLSQL3.g:425:5: seq_of_statements
                pass
                self._state.following.append(self.FOLLOW_seq_of_statements_in_function_body2683)
                seq_of_statements479 = self.seq_of_statements()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, seq_of_statements479.tree)





                # ./output/PLSQL3.g:426:3: ( 'EXCEPTION' ( exception_handler )+ )?
                alt114 = 2
                LA114_0 = self.input.LA(1)

                if (LA114_0 == 86) :
                    alt114 = 1
                if alt114 == 1:
                    # ./output/PLSQL3.g:426:5: 'EXCEPTION' ( exception_handler )+
                    pass
                    string_literal480 = self.match(self.input, 86, self.FOLLOW_86_in_function_body2691)
                    if self._state.backtracking == 0:
                        string_literal480_tree = self._adaptor.createWithPayload(string_literal480)
                        self._adaptor.addChild(root_0, string_literal480_tree)



                    # ./output/PLSQL3.g:426:17: ( exception_handler )+
                    cnt113 = 0
                    while True: #loop113
                        alt113 = 2
                        LA113_0 = self.input.LA(1)

                        if (LA113_0 == 164) :
                            alt113 = 1


                        if alt113 == 1:
                            # ./output/PLSQL3.g:426:19: exception_handler
                            pass
                            self._state.following.append(self.FOLLOW_exception_handler_in_function_body2695)
                            exception_handler481 = self.exception_handler()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, exception_handler481.tree)



                        else:
                            if cnt113 >= 1:
                                break #loop113

                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            eee = EarlyExitException(113, self.input)
                            raise eee

                        cnt113 += 1





                string_literal482 = self.match(self.input, 85, self.FOLLOW_85_in_function_body2705)
                if self._state.backtracking == 0:
                    string_literal482_tree = self._adaptor.createWithPayload(string_literal482)
                    self._adaptor.addChild(root_0, string_literal482_tree)



                # ./output/PLSQL3.g:427:9: ( function_name )?
                alt115 = 2
                LA115_0 = self.input.LA(1)

                if (LA115_0 == DOUBLEQUOTED_STRING or LA115_0 == ID or LA115_0 == QUOTED_STRING) :
                    alt115 = 1
                if alt115 == 1:
                    # ./output/PLSQL3.g:427:11: function_name
                    pass
                    self._state.following.append(self.FOLLOW_function_name_in_function_body2709)
                    function_name483 = self.function_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, function_name483.tree)





                SEMI484 = self.match(self.input, SEMI, self.FOLLOW_SEMI_in_function_body2714)
                if self._state.backtracking == 0:
                    SEMI484_tree = self._adaptor.createWithPayload(SEMI484)
                    self._adaptor.addChild(root_0, SEMI484_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 55, function_body_StartIndex, success)


            pass
        return retval

    # $ANTLR end "function_body"


    class function_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.function_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "function_name"
    # ./output/PLSQL3.g:430:1: function_name : ( identifier | QUOTED_STRING );
    def function_name(self, ):
        retval = self.function_name_return()
        retval.start = self.input.LT(1)

        function_name_StartIndex = self.input.index()

        root_0 = None

        QUOTED_STRING486 = None
        identifier485 = None


        QUOTED_STRING486_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 56):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:431:2: ( identifier | QUOTED_STRING )
                alt116 = 2
                LA116_0 = self.input.LA(1)

                if (LA116_0 == DOUBLEQUOTED_STRING or LA116_0 == ID) :
                    alt116 = 1
                elif (LA116_0 == QUOTED_STRING) :
                    alt116 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 116, 0, self.input)

                    raise nvae


                if alt116 == 1:
                    # ./output/PLSQL3.g:431:4: identifier
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_identifier_in_function_name2725)
                    identifier485 = self.identifier()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, identifier485.tree)



                elif alt116 == 2:
                    # ./output/PLSQL3.g:431:17: QUOTED_STRING
                    pass
                    root_0 = self._adaptor.nil()


                    QUOTED_STRING486 = self.match(self.input, QUOTED_STRING, self.FOLLOW_QUOTED_STRING_in_function_name2729)
                    if self._state.backtracking == 0:
                        QUOTED_STRING486_tree = self._adaptor.createWithPayload(QUOTED_STRING486)
                        self._adaptor.addChild(root_0, QUOTED_STRING486_tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 56, function_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "function_name"


    class procedure_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.procedure_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "procedure_name"
    # ./output/PLSQL3.g:434:1: procedure_name : ( identifier | QUOTED_STRING );
    def procedure_name(self, ):
        retval = self.procedure_name_return()
        retval.start = self.input.LT(1)

        procedure_name_StartIndex = self.input.index()

        root_0 = None

        QUOTED_STRING488 = None
        identifier487 = None


        QUOTED_STRING488_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 57):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:435:2: ( identifier | QUOTED_STRING )
                alt117 = 2
                LA117_0 = self.input.LA(1)

                if (LA117_0 == DOUBLEQUOTED_STRING or LA117_0 == ID) :
                    alt117 = 1
                elif (LA117_0 == QUOTED_STRING) :
                    alt117 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 117, 0, self.input)

                    raise nvae


                if alt117 == 1:
                    # ./output/PLSQL3.g:435:4: identifier
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_identifier_in_procedure_name2741)
                    identifier487 = self.identifier()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, identifier487.tree)



                elif alt117 == 2:
                    # ./output/PLSQL3.g:435:17: QUOTED_STRING
                    pass
                    root_0 = self._adaptor.nil()


                    QUOTED_STRING488 = self.match(self.input, QUOTED_STRING, self.FOLLOW_QUOTED_STRING_in_procedure_name2745)
                    if self._state.backtracking == 0:
                        QUOTED_STRING488_tree = self._adaptor.createWithPayload(QUOTED_STRING488)
                        self._adaptor.addChild(root_0, QUOTED_STRING488_tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 57, procedure_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "procedure_name"


    class arguments_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.arguments_return, self).__init__()

            self.tree = None





    # $ANTLR start "arguments"
    # ./output/PLSQL3.g:438:1: arguments : argument ( COMMA argument )* ;
    def arguments(self, ):
        retval = self.arguments_return()
        retval.start = self.input.LT(1)

        arguments_StartIndex = self.input.index()

        root_0 = None

        COMMA490 = None
        argument489 = None

        argument491 = None


        COMMA490_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 58):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:439:2: ( argument ( COMMA argument )* )
                # ./output/PLSQL3.g:439:4: argument ( COMMA argument )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_argument_in_arguments2757)
                argument489 = self.argument()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, argument489.tree)


                # ./output/PLSQL3.g:439:13: ( COMMA argument )*
                while True: #loop118
                    alt118 = 2
                    LA118_0 = self.input.LA(1)

                    if (LA118_0 == COMMA) :
                        alt118 = 1


                    if alt118 == 1:
                        # ./output/PLSQL3.g:439:15: COMMA argument
                        pass
                        COMMA490 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_arguments2761)
                        if self._state.backtracking == 0:
                            COMMA490_tree = self._adaptor.createWithPayload(COMMA490)
                            self._adaptor.addChild(root_0, COMMA490_tree)



                        self._state.following.append(self.FOLLOW_argument_in_arguments2763)
                        argument491 = self.argument()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, argument491.tree)



                    else:
                        break #loop118




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 58, arguments_StartIndex, success)


            pass
        return retval

    # $ANTLR end "arguments"


    class argument_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.argument_return, self).__init__()

            self.tree = None





    # $ANTLR start "argument"
    # ./output/PLSQL3.g:442:1: argument : argument_name ( keyOUT | 'IN' keyOUT | 'IN' )? ( argument_type )? ( ( ASSIGN | 'DEFAULT' ) plsql_expression )? ;
    def argument(self, ):
        retval = self.argument_return()
        retval.start = self.input.LT(1)

        argument_StartIndex = self.input.index()

        root_0 = None

        string_literal494 = None
        string_literal496 = None
        set498 = None
        argument_name492 = None

        keyOUT493 = None

        keyOUT495 = None

        argument_type497 = None

        plsql_expression499 = None


        string_literal494_tree = None
        string_literal496_tree = None
        set498_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 59):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:443:2: ( argument_name ( keyOUT | 'IN' keyOUT | 'IN' )? ( argument_type )? ( ( ASSIGN | 'DEFAULT' ) plsql_expression )? )
                # ./output/PLSQL3.g:443:4: argument_name ( keyOUT | 'IN' keyOUT | 'IN' )? ( argument_type )? ( ( ASSIGN | 'DEFAULT' ) plsql_expression )?
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_argument_name_in_argument2777)
                argument_name492 = self.argument_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, argument_name492.tree)


                # ./output/PLSQL3.g:443:18: ( keyOUT | 'IN' keyOUT | 'IN' )?
                alt119 = 4
                LA119_0 = self.input.LA(1)

                if (LA119_0 == 129) :
                    alt119 = 1
                elif (LA119_0 == 99) :
                    LA119_2 = self.input.LA(2)

                    if (LA119_2 == 129) :
                        alt119 = 2
                    elif (LA119_2 == EOF or LA119_2 == ASSIGN or LA119_2 == COMMA or LA119_2 == DOUBLEQUOTED_STRING or LA119_2 == ID or LA119_2 == RPAREN or (58 <= LA119_2 <= 63) or (66 <= LA119_2 <= 68) or (74 <= LA119_2 <= 76) or LA119_2 == 78 or LA119_2 == 82 or LA119_2 == 91 or (102 <= LA119_2 <= 103) or LA119_2 == 109 or LA119_2 == 112 or (114 <= LA119_2 <= 117) or (121 <= LA119_2 <= 124) or (131 <= LA119_2 <= 132) or (137 <= LA119_2 <= 138) or LA119_2 == 144 or LA119_2 == 150 or LA119_2 == 160 or (162 <= LA119_2 <= 163)) :
                        alt119 = 3
                if alt119 == 1:
                    # ./output/PLSQL3.g:443:20: keyOUT
                    pass
                    self._state.following.append(self.FOLLOW_keyOUT_in_argument2781)
                    keyOUT493 = self.keyOUT()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyOUT493.tree)



                elif alt119 == 2:
                    # ./output/PLSQL3.g:443:29: 'IN' keyOUT
                    pass
                    string_literal494 = self.match(self.input, 99, self.FOLLOW_99_in_argument2785)
                    if self._state.backtracking == 0:
                        string_literal494_tree = self._adaptor.createWithPayload(string_literal494)
                        self._adaptor.addChild(root_0, string_literal494_tree)



                    self._state.following.append(self.FOLLOW_keyOUT_in_argument2787)
                    keyOUT495 = self.keyOUT()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyOUT495.tree)



                elif alt119 == 3:
                    # ./output/PLSQL3.g:443:43: 'IN'
                    pass
                    string_literal496 = self.match(self.input, 99, self.FOLLOW_99_in_argument2791)
                    if self._state.backtracking == 0:
                        string_literal496_tree = self._adaptor.createWithPayload(string_literal496)
                        self._adaptor.addChild(root_0, string_literal496_tree)






                # ./output/PLSQL3.g:443:51: ( argument_type )?
                alt120 = 2
                LA120_0 = self.input.LA(1)

                if (LA120_0 == DOUBLEQUOTED_STRING or LA120_0 == ID or (58 <= LA120_0 <= 63) or (66 <= LA120_0 <= 68) or (74 <= LA120_0 <= 76) or LA120_0 == 82 or LA120_0 == 91 or (102 <= LA120_0 <= 103) or LA120_0 == 109 or LA120_0 == 112 or (114 <= LA120_0 <= 117) or (121 <= LA120_0 <= 124) or (131 <= LA120_0 <= 132) or (137 <= LA120_0 <= 138) or LA120_0 == 144 or LA120_0 == 150 or LA120_0 == 160 or (162 <= LA120_0 <= 163)) :
                    alt120 = 1
                if alt120 == 1:
                    # ./output/PLSQL3.g:443:52: argument_type
                    pass
                    self._state.following.append(self.FOLLOW_argument_type_in_argument2797)
                    argument_type497 = self.argument_type()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, argument_type497.tree)





                # ./output/PLSQL3.g:444:3: ( ( ASSIGN | 'DEFAULT' ) plsql_expression )?
                alt121 = 2
                LA121_0 = self.input.LA(1)

                if (LA121_0 == ASSIGN or LA121_0 == 78) :
                    alt121 = 1
                if alt121 == 1:
                    # ./output/PLSQL3.g:444:5: ( ASSIGN | 'DEFAULT' ) plsql_expression
                    pass
                    set498 = self.input.LT(1)

                    if self.input.LA(1) == ASSIGN or self.input.LA(1) == 78:
                        self.input.consume()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set498))

                        self._state.errorRecovery = False


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        mse = MismatchedSetException(None, self.input)
                        raise mse



                    self._state.following.append(self.FOLLOW_plsql_expression_in_argument2816)
                    plsql_expression499 = self.plsql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, plsql_expression499.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 59, argument_StartIndex, success)


            pass
        return retval

    # $ANTLR end "argument"


    class argument_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.argument_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "argument_name"
    # ./output/PLSQL3.g:447:1: argument_name : identifier ;
    def argument_name(self, ):
        retval = self.argument_name_return()
        retval.start = self.input.LT(1)

        argument_name_StartIndex = self.input.index()

        root_0 = None

        identifier500 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 60):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:448:2: ( identifier )
                # ./output/PLSQL3.g:448:4: identifier
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_identifier_in_argument_name2830)
                identifier500 = self.identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, identifier500.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 60, argument_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "argument_name"


    class argument_type_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.argument_type_return, self).__init__()

            self.tree = None





    # $ANTLR start "argument_type"
    # ./output/PLSQL3.g:451:1: argument_type : type_spec ;
    def argument_type(self, ):
        retval = self.argument_type_return()
        retval.start = self.input.LT(1)

        argument_type_StartIndex = self.input.index()

        root_0 = None

        type_spec501 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 61):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:452:2: ( type_spec )
                # ./output/PLSQL3.g:452:4: type_spec
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_type_spec_in_argument_type2841)
                type_spec501 = self.type_spec()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, type_spec501.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 61, argument_type_StartIndex, success)


            pass
        return retval

    # $ANTLR end "argument_type"


    class value_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.value_return, self).__init__()

            self.tree = None





    # $ANTLR start "value"
    # ./output/PLSQL3.g:455:1: value : ( ( PLUS | MINUS )? NUMBER | quoted_string | 'TRUE' | 'FALSE' | 'NULL' );
    def value(self, ):
        retval = self.value_return()
        retval.start = self.input.LT(1)

        value_StartIndex = self.input.index()

        root_0 = None

        set502 = None
        NUMBER503 = None
        string_literal505 = None
        string_literal506 = None
        string_literal507 = None
        quoted_string504 = None


        set502_tree = None
        NUMBER503_tree = None
        string_literal505_tree = None
        string_literal506_tree = None
        string_literal507_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 62):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:456:2: ( ( PLUS | MINUS )? NUMBER | quoted_string | 'TRUE' | 'FALSE' | 'NULL' )
                alt123 = 5
                LA123 = self.input.LA(1)
                if LA123 == MINUS or LA123 == NUMBER or LA123 == PLUS:
                    alt123 = 1
                elif LA123 == QUOTED_STRING:
                    alt123 = 2
                elif LA123 == 156:
                    alt123 = 3
                elif LA123 == 89:
                    alt123 = 4
                elif LA123 == 120:
                    alt123 = 5
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 123, 0, self.input)

                    raise nvae


                if alt123 == 1:
                    # ./output/PLSQL3.g:456:4: ( PLUS | MINUS )? NUMBER
                    pass
                    root_0 = self._adaptor.nil()


                    # ./output/PLSQL3.g:456:4: ( PLUS | MINUS )?
                    alt122 = 2
                    LA122_0 = self.input.LA(1)

                    if (LA122_0 == MINUS or LA122_0 == PLUS) :
                        alt122 = 1
                    if alt122 == 1:
                        # ./output/PLSQL3.g:
                        pass
                        set502 = self.input.LT(1)

                        if self.input.LA(1) == MINUS or self.input.LA(1) == PLUS:
                            self.input.consume()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set502))

                            self._state.errorRecovery = False


                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            mse = MismatchedSetException(None, self.input)
                            raise mse






                    NUMBER503 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_value2863)
                    if self._state.backtracking == 0:
                        NUMBER503_tree = self._adaptor.createWithPayload(NUMBER503)
                        self._adaptor.addChild(root_0, NUMBER503_tree)




                elif alt123 == 2:
                    # ./output/PLSQL3.g:457:4: quoted_string
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_quoted_string_in_value2868)
                    quoted_string504 = self.quoted_string()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, quoted_string504.tree)



                elif alt123 == 3:
                    # ./output/PLSQL3.g:458:4: 'TRUE'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal505 = self.match(self.input, 156, self.FOLLOW_156_in_value2873)
                    if self._state.backtracking == 0:
                        string_literal505_tree = self._adaptor.createWithPayload(string_literal505)
                        self._adaptor.addChild(root_0, string_literal505_tree)




                elif alt123 == 4:
                    # ./output/PLSQL3.g:458:13: 'FALSE'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal506 = self.match(self.input, 89, self.FOLLOW_89_in_value2877)
                    if self._state.backtracking == 0:
                        string_literal506_tree = self._adaptor.createWithPayload(string_literal506)
                        self._adaptor.addChild(root_0, string_literal506_tree)




                elif alt123 == 5:
                    # ./output/PLSQL3.g:459:4: 'NULL'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal507 = self.match(self.input, 120, self.FOLLOW_120_in_value2882)
                    if self._state.backtracking == 0:
                        string_literal507_tree = self._adaptor.createWithPayload(string_literal507)
                        self._adaptor.addChild(root_0, string_literal507_tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 62, value_StartIndex, success)


            pass
        return retval

    # $ANTLR end "value"


    class return_type_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.return_type_return, self).__init__()

            self.tree = None





    # $ANTLR start "return_type"
    # ./output/PLSQL3.g:462:1: return_type : type_spec ;
    def return_type(self, ):
        retval = self.return_type_return()
        retval.start = self.input.LT(1)

        return_type_StartIndex = self.input.index()

        root_0 = None

        type_spec508 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 63):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:463:2: ( type_spec )
                # ./output/PLSQL3.g:463:4: type_spec
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_type_spec_in_return_type2893)
                type_spec508 = self.type_spec()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, type_spec508.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 63, return_type_StartIndex, success)


            pass
        return retval

    # $ANTLR end "return_type"


    class function_declaration_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.function_declaration_return, self).__init__()

            self.tree = None





    # $ANTLR start "function_declaration"
    # ./output/PLSQL3.g:466:1: function_declaration : function_body ;
    def function_declaration(self, ):
        retval = self.function_declaration_return()
        retval.start = self.input.LT(1)

        function_declaration_StartIndex = self.input.index()

        root_0 = None

        function_body509 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 64):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:467:2: ( function_body )
                # ./output/PLSQL3.g:467:4: function_body
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_function_body_in_function_declaration2904)
                function_body509 = self.function_body()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, function_body509.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 64, function_declaration_StartIndex, success)


            pass
        return retval

    # $ANTLR end "function_declaration"


    class function_call_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.function_call_return, self).__init__()

            self.tree = None





    # $ANTLR start "function_call"
    # ./output/PLSQL3.g:470:1: function_call : user_defined_function ({...}? LPAREN ( call_parameters )? RPAREN )? ;
    def function_call(self, ):
        retval = self.function_call_return()
        retval.start = self.input.LT(1)

        function_call_StartIndex = self.input.index()

        root_0 = None

        LPAREN511 = None
        RPAREN513 = None
        user_defined_function510 = None

        call_parameters512 = None


        LPAREN511_tree = None
        RPAREN513_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 65):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:471:2: ( user_defined_function ({...}? LPAREN ( call_parameters )? RPAREN )? )
                # ./output/PLSQL3.g:471:4: user_defined_function ({...}? LPAREN ( call_parameters )? RPAREN )?
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_user_defined_function_in_function_call2915)
                user_defined_function510 = self.user_defined_function()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, user_defined_function510.tree)


                # ./output/PLSQL3.g:471:26: ({...}? LPAREN ( call_parameters )? RPAREN )?
                alt125 = 2
                alt125 = self.dfa125.predict(self.input)
                if alt125 == 1:
                    # ./output/PLSQL3.g:471:28: {...}? LPAREN ( call_parameters )? RPAREN
                    pass
                    if not ((input.LA(1) != LPAREN or input.LA(2) != PLUS or input.LA(3) != RPAREN )):
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        raise FailedPredicateException(self.input, "function_call", " input.LA(1) != LPAREN or input.LA(2) != PLUS or input.LA(3) != RPAREN ")


                    LPAREN511 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_function_call2921)
                    if self._state.backtracking == 0:
                        LPAREN511_tree = self._adaptor.createWithPayload(LPAREN511)
                        self._adaptor.addChild(root_0, LPAREN511_tree)



                    # ./output/PLSQL3.g:471:110: ( call_parameters )?
                    alt124 = 2
                    LA124_0 = self.input.LA(1)

                    if (LA124_0 == DOUBLEQUOTED_STRING or LA124_0 == ID or LA124_0 == LPAREN or LA124_0 == MINUS or LA124_0 == NUMBER or LA124_0 == PLUS or LA124_0 == QUOTED_STRING or LA124_0 == 65 or LA124_0 == 81 or LA124_0 == 89 or LA124_0 == 118 or LA124_0 == 120 or LA124_0 == 144 or LA124_0 == 147 or LA124_0 == 151 or LA124_0 == 156) :
                        alt124 = 1
                    if alt124 == 1:
                        # ./output/PLSQL3.g:471:112: call_parameters
                        pass
                        self._state.following.append(self.FOLLOW_call_parameters_in_function_call2925)
                        call_parameters512 = self.call_parameters()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, call_parameters512.tree)





                    RPAREN513 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_function_call2930)
                    if self._state.backtracking == 0:
                        RPAREN513_tree = self._adaptor.createWithPayload(RPAREN513)
                        self._adaptor.addChild(root_0, RPAREN513_tree)








                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 65, function_call_StartIndex, success)


            pass
        return retval

    # $ANTLR end "function_call"


    class collection_function_call_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.collection_function_call_return, self).__init__()

            self.tree = None





    # $ANTLR start "collection_function_call"
    # ./output/PLSQL3.g:479:1: collection_function_call : plsql_table_name ;
    def collection_function_call(self, ):
        retval = self.collection_function_call_return()
        retval.start = self.input.LT(1)

        collection_function_call_StartIndex = self.input.index()

        root_0 = None

        plsql_table_name514 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 66):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:480:2: ( plsql_table_name )
                # ./output/PLSQL3.g:480:4: plsql_table_name
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_plsql_table_name_in_collection_function_call2949)
                plsql_table_name514 = self.plsql_table_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, plsql_table_name514.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 66, collection_function_call_StartIndex, success)


            pass
        return retval

    # $ANTLR end "collection_function_call"


    class variable_names_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.variable_names_return, self).__init__()

            self.tree = None





    # $ANTLR start "variable_names"
    # ./output/PLSQL3.g:483:1: variable_names : variable_name ( COMMA variable_name )* ;
    def variable_names(self, ):
        retval = self.variable_names_return()
        retval.start = self.input.LT(1)

        variable_names_StartIndex = self.input.index()

        root_0 = None

        COMMA516 = None
        variable_name515 = None

        variable_name517 = None


        COMMA516_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 67):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:484:2: ( variable_name ( COMMA variable_name )* )
                # ./output/PLSQL3.g:484:4: variable_name ( COMMA variable_name )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_variable_name_in_variable_names2960)
                variable_name515 = self.variable_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, variable_name515.tree)


                # ./output/PLSQL3.g:484:18: ( COMMA variable_name )*
                while True: #loop126
                    alt126 = 2
                    LA126_0 = self.input.LA(1)

                    if (LA126_0 == COMMA) :
                        alt126 = 1


                    if alt126 == 1:
                        # ./output/PLSQL3.g:484:20: COMMA variable_name
                        pass
                        COMMA516 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_variable_names2964)
                        if self._state.backtracking == 0:
                            COMMA516_tree = self._adaptor.createWithPayload(COMMA516)
                            self._adaptor.addChild(root_0, COMMA516_tree)



                        self._state.following.append(self.FOLLOW_variable_name_in_variable_names2966)
                        variable_name517 = self.variable_name()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, variable_name517.tree)



                    else:
                        break #loop126




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 67, variable_names_StartIndex, success)


            pass
        return retval

    # $ANTLR end "variable_names"


    class variable_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.variable_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "variable_name"
    # ./output/PLSQL3.g:486:1: variable_name : identifier ;
    def variable_name(self, ):
        retval = self.variable_name_return()
        retval.start = self.input.LT(1)

        variable_name_StartIndex = self.input.index()

        root_0 = None

        identifier518 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 68):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:487:2: ( identifier )
                # ./output/PLSQL3.g:487:4: identifier
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_identifier_in_variable_name2979)
                identifier518 = self.identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, identifier518.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 68, variable_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "variable_name"


    class null_statement_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.null_statement_return, self).__init__()

            self.tree = None





    # $ANTLR start "null_statement"
    # ./output/PLSQL3.g:490:1: null_statement : 'NULL' ;
    def null_statement(self, ):
        retval = self.null_statement_return()
        retval.start = self.input.LT(1)

        null_statement_StartIndex = self.input.index()

        root_0 = None

        string_literal519 = None

        string_literal519_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 69):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:491:2: ( 'NULL' )
                # ./output/PLSQL3.g:491:4: 'NULL'
                pass
                root_0 = self._adaptor.nil()


                string_literal519 = self.match(self.input, 120, self.FOLLOW_120_in_null_statement2990)
                if self._state.backtracking == 0:
                    string_literal519_tree = self._adaptor.createWithPayload(string_literal519)
                    self._adaptor.addChild(root_0, string_literal519_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 69, null_statement_StartIndex, success)


            pass
        return retval

    # $ANTLR end "null_statement"


    class raise_statement_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.raise_statement_return, self).__init__()

            self.tree = None





    # $ANTLR start "raise_statement"
    # ./output/PLSQL3.g:494:1: raise_statement : keyRAISE ( exception_name )? ;
    def raise_statement(self, ):
        retval = self.raise_statement_return()
        retval.start = self.input.LT(1)

        raise_statement_StartIndex = self.input.index()

        root_0 = None

        keyRAISE520 = None

        exception_name521 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 70):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:495:2: ( keyRAISE ( exception_name )? )
                # ./output/PLSQL3.g:495:4: keyRAISE ( exception_name )?
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyRAISE_in_raise_statement3002)
                keyRAISE520 = self.keyRAISE()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyRAISE520.tree)


                # ./output/PLSQL3.g:495:13: ( exception_name )?
                alt127 = 2
                LA127_0 = self.input.LA(1)

                if (LA127_0 == DOUBLEQUOTED_STRING or LA127_0 == ID) :
                    alt127 = 1
                if alt127 == 1:
                    # ./output/PLSQL3.g:495:15: exception_name
                    pass
                    self._state.following.append(self.FOLLOW_exception_name_in_raise_statement3006)
                    exception_name521 = self.exception_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, exception_name521.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 70, raise_statement_StartIndex, success)


            pass
        return retval

    # $ANTLR end "raise_statement"


    class return_statement_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.return_statement_return, self).__init__()

            self.tree = None





    # $ANTLR start "return_statement"
    # ./output/PLSQL3.g:498:1: return_statement : keyRETURN ( plsql_expression )? ;
    def return_statement(self, ):
        retval = self.return_statement_return()
        retval.start = self.input.LT(1)

        return_statement_StartIndex = self.input.index()

        root_0 = None

        keyRETURN522 = None

        plsql_expression523 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 71):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:499:2: ( keyRETURN ( plsql_expression )? )
                # ./output/PLSQL3.g:499:4: keyRETURN ( plsql_expression )?
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyRETURN_in_return_statement3021)
                keyRETURN522 = self.keyRETURN()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyRETURN522.tree)


                # ./output/PLSQL3.g:499:14: ( plsql_expression )?
                alt128 = 2
                LA128_0 = self.input.LA(1)

                if (LA128_0 == DOUBLEQUOTED_STRING or LA128_0 == ID or LA128_0 == LPAREN or LA128_0 == MINUS or LA128_0 == NUMBER or LA128_0 == PLUS or LA128_0 == QUOTED_STRING or LA128_0 == 65 or LA128_0 == 81 or LA128_0 == 89 or LA128_0 == 118 or LA128_0 == 120 or LA128_0 == 144 or LA128_0 == 147 or LA128_0 == 151 or LA128_0 == 156) :
                    alt128 = 1
                if alt128 == 1:
                    # ./output/PLSQL3.g:499:16: plsql_expression
                    pass
                    self._state.following.append(self.FOLLOW_plsql_expression_in_return_statement3025)
                    plsql_expression523 = self.plsql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, plsql_expression523.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 71, return_statement_StartIndex, success)


            pass
        return retval

    # $ANTLR end "return_statement"


    class loop_statement_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.loop_statement_return, self).__init__()

            self.tree = None





    # $ANTLR start "loop_statement"
    # ./output/PLSQL3.g:502:1: loop_statement : ( LLABEL label_name RLABEL )? ( keyWHILE ^ plsql_condition | ( 'FOR' ^ ( ( numeric_loop_param )=> numeric_loop_param | ( cursor_loop_param )=> cursor_loop_param ) ) )? keyLOOP seq_of_statements 'END' keyLOOP ( label_name )? ;
    def loop_statement(self, ):
        retval = self.loop_statement_return()
        retval.start = self.input.LT(1)

        loop_statement_StartIndex = self.input.index()

        root_0 = None

        LLABEL524 = None
        RLABEL526 = None
        string_literal529 = None
        string_literal534 = None
        label_name525 = None

        keyWHILE527 = None

        plsql_condition528 = None

        numeric_loop_param530 = None

        cursor_loop_param531 = None

        keyLOOP532 = None

        seq_of_statements533 = None

        keyLOOP535 = None

        label_name536 = None


        LLABEL524_tree = None
        RLABEL526_tree = None
        string_literal529_tree = None
        string_literal534_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 72):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:503:2: ( ( LLABEL label_name RLABEL )? ( keyWHILE ^ plsql_condition | ( 'FOR' ^ ( ( numeric_loop_param )=> numeric_loop_param | ( cursor_loop_param )=> cursor_loop_param ) ) )? keyLOOP seq_of_statements 'END' keyLOOP ( label_name )? )
                # ./output/PLSQL3.g:503:4: ( LLABEL label_name RLABEL )? ( keyWHILE ^ plsql_condition | ( 'FOR' ^ ( ( numeric_loop_param )=> numeric_loop_param | ( cursor_loop_param )=> cursor_loop_param ) ) )? keyLOOP seq_of_statements 'END' keyLOOP ( label_name )?
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:503:4: ( LLABEL label_name RLABEL )?
                alt129 = 2
                LA129_0 = self.input.LA(1)

                if (LA129_0 == LLABEL) :
                    alt129 = 1
                if alt129 == 1:
                    # ./output/PLSQL3.g:503:6: LLABEL label_name RLABEL
                    pass
                    LLABEL524 = self.match(self.input, LLABEL, self.FOLLOW_LLABEL_in_loop_statement3041)
                    if self._state.backtracking == 0:
                        LLABEL524_tree = self._adaptor.createWithPayload(LLABEL524)
                        self._adaptor.addChild(root_0, LLABEL524_tree)



                    self._state.following.append(self.FOLLOW_label_name_in_loop_statement3043)
                    label_name525 = self.label_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, label_name525.tree)


                    RLABEL526 = self.match(self.input, RLABEL, self.FOLLOW_RLABEL_in_loop_statement3045)
                    if self._state.backtracking == 0:
                        RLABEL526_tree = self._adaptor.createWithPayload(RLABEL526)
                        self._adaptor.addChild(root_0, RLABEL526_tree)






                # ./output/PLSQL3.g:504:3: ( keyWHILE ^ plsql_condition | ( 'FOR' ^ ( ( numeric_loop_param )=> numeric_loop_param | ( cursor_loop_param )=> cursor_loop_param ) ) )?
                alt131 = 3
                LA131_0 = self.input.LA(1)

                if (LA131_0 == 166) :
                    alt131 = 1
                elif (LA131_0 == 92) :
                    alt131 = 2
                if alt131 == 1:
                    # ./output/PLSQL3.g:504:5: keyWHILE ^ plsql_condition
                    pass
                    self._state.following.append(self.FOLLOW_keyWHILE_in_loop_statement3054)
                    keyWHILE527 = self.keyWHILE()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        root_0 = self._adaptor.becomeRoot(keyWHILE527.tree, root_0)


                    self._state.following.append(self.FOLLOW_plsql_condition_in_loop_statement3057)
                    plsql_condition528 = self.plsql_condition()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, plsql_condition528.tree)



                elif alt131 == 2:
                    # ./output/PLSQL3.g:505:6: ( 'FOR' ^ ( ( numeric_loop_param )=> numeric_loop_param | ( cursor_loop_param )=> cursor_loop_param ) )
                    pass
                    # ./output/PLSQL3.g:505:6: ( 'FOR' ^ ( ( numeric_loop_param )=> numeric_loop_param | ( cursor_loop_param )=> cursor_loop_param ) )
                    # ./output/PLSQL3.g:505:8: 'FOR' ^ ( ( numeric_loop_param )=> numeric_loop_param | ( cursor_loop_param )=> cursor_loop_param )
                    pass
                    string_literal529 = self.match(self.input, 92, self.FOLLOW_92_in_loop_statement3066)
                    if self._state.backtracking == 0:
                        string_literal529_tree = self._adaptor.createWithPayload(string_literal529)
                        root_0 = self._adaptor.becomeRoot(string_literal529_tree, root_0)



                    # ./output/PLSQL3.g:506:5: ( ( numeric_loop_param )=> numeric_loop_param | ( cursor_loop_param )=> cursor_loop_param )
                    alt130 = 2
                    LA130_0 = self.input.LA(1)

                    if (LA130_0 == DOUBLEQUOTED_STRING or LA130_0 == ID) :
                        LA130_1 = self.input.LA(2)

                        if (self.synpred238_PLSQL3()) :
                            alt130 = 1
                        elif (self.synpred239_PLSQL3()) :
                            alt130 = 2
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 130, 1, self.input)

                            raise nvae


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 130, 0, self.input)

                        raise nvae


                    if alt130 == 1:
                        # ./output/PLSQL3.g:506:7: ( numeric_loop_param )=> numeric_loop_param
                        pass
                        self._state.following.append(self.FOLLOW_numeric_loop_param_in_loop_statement3083)
                        numeric_loop_param530 = self.numeric_loop_param()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, numeric_loop_param530.tree)



                    elif alt130 == 2:
                        # ./output/PLSQL3.g:507:7: ( cursor_loop_param )=> cursor_loop_param
                        pass
                        self._state.following.append(self.FOLLOW_cursor_loop_param_in_loop_statement3099)
                        cursor_loop_param531 = self.cursor_loop_param()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, cursor_loop_param531.tree)











                self._state.following.append(self.FOLLOW_keyLOOP_in_loop_statement3120)
                keyLOOP532 = self.keyLOOP()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyLOOP532.tree)


                self._state.following.append(self.FOLLOW_seq_of_statements_in_loop_statement3124)
                seq_of_statements533 = self.seq_of_statements()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, seq_of_statements533.tree)


                string_literal534 = self.match(self.input, 85, self.FOLLOW_85_in_loop_statement3128)
                if self._state.backtracking == 0:
                    string_literal534_tree = self._adaptor.createWithPayload(string_literal534)
                    self._adaptor.addChild(root_0, string_literal534_tree)



                self._state.following.append(self.FOLLOW_keyLOOP_in_loop_statement3130)
                keyLOOP535 = self.keyLOOP()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyLOOP535.tree)


                # ./output/PLSQL3.g:514:3: ( label_name )?
                alt132 = 2
                LA132_0 = self.input.LA(1)

                if (LA132_0 == DOUBLEQUOTED_STRING or LA132_0 == ID) :
                    alt132 = 1
                if alt132 == 1:
                    # ./output/PLSQL3.g:514:5: label_name
                    pass
                    self._state.following.append(self.FOLLOW_label_name_in_loop_statement3137)
                    label_name536 = self.label_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, label_name536.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 72, loop_statement_StartIndex, success)


            pass
        return retval

    # $ANTLR end "loop_statement"


    class numeric_loop_param_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.numeric_loop_param_return, self).__init__()

            self.tree = None





    # $ANTLR start "numeric_loop_param"
    # ./output/PLSQL3.g:517:1: numeric_loop_param : index_name 'IN' ( keyREVERSE )? integer_expr DOUBLEDOT integer_expr ;
    def numeric_loop_param(self, ):
        retval = self.numeric_loop_param_return()
        retval.start = self.input.LT(1)

        numeric_loop_param_StartIndex = self.input.index()

        root_0 = None

        string_literal538 = None
        DOUBLEDOT541 = None
        index_name537 = None

        keyREVERSE539 = None

        integer_expr540 = None

        integer_expr542 = None


        string_literal538_tree = None
        DOUBLEDOT541_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 73):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:518:2: ( index_name 'IN' ( keyREVERSE )? integer_expr DOUBLEDOT integer_expr )
                # ./output/PLSQL3.g:518:4: index_name 'IN' ( keyREVERSE )? integer_expr DOUBLEDOT integer_expr
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_index_name_in_numeric_loop_param3151)
                index_name537 = self.index_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, index_name537.tree)


                string_literal538 = self.match(self.input, 99, self.FOLLOW_99_in_numeric_loop_param3153)
                if self._state.backtracking == 0:
                    string_literal538_tree = self._adaptor.createWithPayload(string_literal538)
                    self._adaptor.addChild(root_0, string_literal538_tree)



                # ./output/PLSQL3.g:518:20: ( keyREVERSE )?
                alt133 = 2
                LA133_0 = self.input.LA(1)

                if (LA133_0 == ID) :
                    LA133_1 = self.input.LA(2)

                    if (((((((self.input).LT(1).text.upper() == "REVERSE")) and (((this.input).LT(1).text.upper() == "REVERSE")))) and (self.synpred242_PLSQL3()))) :
                        alt133 = 1
                if alt133 == 1:
                    # ./output/PLSQL3.g:518:22: keyREVERSE
                    pass
                    self._state.following.append(self.FOLLOW_keyREVERSE_in_numeric_loop_param3157)
                    keyREVERSE539 = self.keyREVERSE()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyREVERSE539.tree)





                self._state.following.append(self.FOLLOW_integer_expr_in_numeric_loop_param3162)
                integer_expr540 = self.integer_expr()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, integer_expr540.tree)


                DOUBLEDOT541 = self.match(self.input, DOUBLEDOT, self.FOLLOW_DOUBLEDOT_in_numeric_loop_param3164)
                if self._state.backtracking == 0:
                    DOUBLEDOT541_tree = self._adaptor.createWithPayload(DOUBLEDOT541)
                    self._adaptor.addChild(root_0, DOUBLEDOT541_tree)



                self._state.following.append(self.FOLLOW_integer_expr_in_numeric_loop_param3166)
                integer_expr542 = self.integer_expr()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, integer_expr542.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 73, numeric_loop_param_StartIndex, success)


            pass
        return retval

    # $ANTLR end "numeric_loop_param"


    class index_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.index_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "index_name"
    # ./output/PLSQL3.g:521:1: index_name : identifier ;
    def index_name(self, ):
        retval = self.index_name_return()
        retval.start = self.input.LT(1)

        index_name_StartIndex = self.input.index()

        root_0 = None

        identifier543 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 74):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:522:2: ( identifier )
                # ./output/PLSQL3.g:522:4: identifier
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_identifier_in_index_name3177)
                identifier543 = self.identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, identifier543.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 74, index_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "index_name"


    class integer_expr_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.integer_expr_return, self).__init__()

            self.tree = None





    # $ANTLR start "integer_expr"
    # ./output/PLSQL3.g:526:1: integer_expr : sql_expression ;
    def integer_expr(self, ):
        retval = self.integer_expr_return()
        retval.start = self.input.LT(1)

        integer_expr_StartIndex = self.input.index()

        root_0 = None

        sql_expression544 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 75):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:527:2: ( sql_expression )
                # ./output/PLSQL3.g:527:4: sql_expression
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_sql_expression_in_integer_expr3189)
                sql_expression544 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression544.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 75, integer_expr_StartIndex, success)


            pass
        return retval

    # $ANTLR end "integer_expr"


    class cursor_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.cursor_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "cursor_name"
    # ./output/PLSQL3.g:530:1: cursor_name : identifier ;
    def cursor_name(self, ):
        retval = self.cursor_name_return()
        retval.start = self.input.LT(1)

        cursor_name_StartIndex = self.input.index()

        root_0 = None

        identifier545 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 76):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:531:2: ( identifier )
                # ./output/PLSQL3.g:531:4: identifier
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_identifier_in_cursor_name3200)
                identifier545 = self.identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, identifier545.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 76, cursor_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "cursor_name"


    class cursor_loop_param_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.cursor_loop_param_return, self).__init__()

            self.tree = None





    # $ANTLR start "cursor_loop_param"
    # ./output/PLSQL3.g:534:1: cursor_loop_param : record_name 'IN' ( cursor_name ( LPAREN plsql_expressions RPAREN )? | LPAREN select_statement RPAREN ) ;
    def cursor_loop_param(self, ):
        retval = self.cursor_loop_param_return()
        retval.start = self.input.LT(1)

        cursor_loop_param_StartIndex = self.input.index()

        root_0 = None

        string_literal547 = None
        LPAREN549 = None
        RPAREN551 = None
        LPAREN552 = None
        RPAREN554 = None
        record_name546 = None

        cursor_name548 = None

        plsql_expressions550 = None

        select_statement553 = None


        string_literal547_tree = None
        LPAREN549_tree = None
        RPAREN551_tree = None
        LPAREN552_tree = None
        RPAREN554_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 77):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:535:2: ( record_name 'IN' ( cursor_name ( LPAREN plsql_expressions RPAREN )? | LPAREN select_statement RPAREN ) )
                # ./output/PLSQL3.g:535:4: record_name 'IN' ( cursor_name ( LPAREN plsql_expressions RPAREN )? | LPAREN select_statement RPAREN )
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_record_name_in_cursor_loop_param3211)
                record_name546 = self.record_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, record_name546.tree)


                string_literal547 = self.match(self.input, 99, self.FOLLOW_99_in_cursor_loop_param3213)
                if self._state.backtracking == 0:
                    string_literal547_tree = self._adaptor.createWithPayload(string_literal547)
                    self._adaptor.addChild(root_0, string_literal547_tree)



                # ./output/PLSQL3.g:536:3: ( cursor_name ( LPAREN plsql_expressions RPAREN )? | LPAREN select_statement RPAREN )
                alt135 = 2
                LA135_0 = self.input.LA(1)

                if (LA135_0 == DOUBLEQUOTED_STRING or LA135_0 == ID) :
                    alt135 = 1
                elif (LA135_0 == LPAREN) :
                    alt135 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 135, 0, self.input)

                    raise nvae


                if alt135 == 1:
                    # ./output/PLSQL3.g:536:5: cursor_name ( LPAREN plsql_expressions RPAREN )?
                    pass
                    self._state.following.append(self.FOLLOW_cursor_name_in_cursor_loop_param3219)
                    cursor_name548 = self.cursor_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, cursor_name548.tree)


                    # ./output/PLSQL3.g:536:17: ( LPAREN plsql_expressions RPAREN )?
                    alt134 = 2
                    LA134_0 = self.input.LA(1)

                    if (LA134_0 == LPAREN) :
                        alt134 = 1
                    if alt134 == 1:
                        # ./output/PLSQL3.g:536:19: LPAREN plsql_expressions RPAREN
                        pass
                        LPAREN549 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_cursor_loop_param3223)
                        if self._state.backtracking == 0:
                            LPAREN549_tree = self._adaptor.createWithPayload(LPAREN549)
                            self._adaptor.addChild(root_0, LPAREN549_tree)



                        self._state.following.append(self.FOLLOW_plsql_expressions_in_cursor_loop_param3225)
                        plsql_expressions550 = self.plsql_expressions()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, plsql_expressions550.tree)


                        RPAREN551 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_cursor_loop_param3227)
                        if self._state.backtracking == 0:
                            RPAREN551_tree = self._adaptor.createWithPayload(RPAREN551)
                            self._adaptor.addChild(root_0, RPAREN551_tree)







                elif alt135 == 2:
                    # ./output/PLSQL3.g:537:5: LPAREN select_statement RPAREN
                    pass
                    LPAREN552 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_cursor_loop_param3236)
                    if self._state.backtracking == 0:
                        LPAREN552_tree = self._adaptor.createWithPayload(LPAREN552)
                        self._adaptor.addChild(root_0, LPAREN552_tree)



                    self._state.following.append(self.FOLLOW_select_statement_in_cursor_loop_param3238)
                    select_statement553 = self.select_statement()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, select_statement553.tree)


                    RPAREN554 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_cursor_loop_param3240)
                    if self._state.backtracking == 0:
                        RPAREN554_tree = self._adaptor.createWithPayload(RPAREN554)
                        self._adaptor.addChild(root_0, RPAREN554_tree)








                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 77, cursor_loop_param_StartIndex, success)


            pass
        return retval

    # $ANTLR end "cursor_loop_param"


    class record_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.record_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "record_name"
    # ./output/PLSQL3.g:541:1: record_name : identifier ;
    def record_name(self, ):
        retval = self.record_name_return()
        retval.start = self.input.LT(1)

        record_name_StartIndex = self.input.index()

        root_0 = None

        identifier555 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 78):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:542:2: ( identifier )
                # ./output/PLSQL3.g:542:4: identifier
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_identifier_in_record_name3255)
                identifier555 = self.identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, identifier555.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 78, record_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "record_name"


    class commit_statement_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.commit_statement_return, self).__init__()

            self.tree = None





    # $ANTLR start "commit_statement"
    # ./output/PLSQL3.g:545:1: commit_statement : 'COMMIT' ;
    def commit_statement(self, ):
        retval = self.commit_statement_return()
        retval.start = self.input.LT(1)

        commit_statement_StartIndex = self.input.index()

        root_0 = None

        string_literal556 = None

        string_literal556_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 79):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:546:2: ( 'COMMIT' )
                # ./output/PLSQL3.g:546:4: 'COMMIT'
                pass
                root_0 = self._adaptor.nil()


                string_literal556 = self.match(self.input, 70, self.FOLLOW_70_in_commit_statement3266)
                if self._state.backtracking == 0:
                    string_literal556_tree = self._adaptor.createWithPayload(string_literal556)
                    self._adaptor.addChild(root_0, string_literal556_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 79, commit_statement_StartIndex, success)


            pass
        return retval

    # $ANTLR end "commit_statement"


    class if_statement_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.if_statement_return, self).__init__()

            self.tree = None





    # $ANTLR start "if_statement"
    # ./output/PLSQL3.g:549:1: if_statement : 'IF' ^ plsql_condition 'THEN' seq_of_statements ( keyELSIF plsql_condition 'THEN' seq_of_statements )* ( 'ELSE' seq_of_statements )? 'END' 'IF' ;
    def if_statement(self, ):
        retval = self.if_statement_return()
        retval.start = self.input.LT(1)

        if_statement_StartIndex = self.input.index()

        root_0 = None

        string_literal557 = None
        string_literal559 = None
        string_literal563 = None
        string_literal565 = None
        string_literal567 = None
        string_literal568 = None
        plsql_condition558 = None

        seq_of_statements560 = None

        keyELSIF561 = None

        plsql_condition562 = None

        seq_of_statements564 = None

        seq_of_statements566 = None


        string_literal557_tree = None
        string_literal559_tree = None
        string_literal563_tree = None
        string_literal565_tree = None
        string_literal567_tree = None
        string_literal568_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 80):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:550:2: ( 'IF' ^ plsql_condition 'THEN' seq_of_statements ( keyELSIF plsql_condition 'THEN' seq_of_statements )* ( 'ELSE' seq_of_statements )? 'END' 'IF' )
                # ./output/PLSQL3.g:550:4: 'IF' ^ plsql_condition 'THEN' seq_of_statements ( keyELSIF plsql_condition 'THEN' seq_of_statements )* ( 'ELSE' seq_of_statements )? 'END' 'IF'
                pass
                root_0 = self._adaptor.nil()


                string_literal557 = self.match(self.input, 98, self.FOLLOW_98_in_if_statement3277)
                if self._state.backtracking == 0:
                    string_literal557_tree = self._adaptor.createWithPayload(string_literal557)
                    root_0 = self._adaptor.becomeRoot(string_literal557_tree, root_0)



                self._state.following.append(self.FOLLOW_plsql_condition_in_if_statement3280)
                plsql_condition558 = self.plsql_condition()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, plsql_condition558.tree)


                string_literal559 = self.match(self.input, 154, self.FOLLOW_154_in_if_statement3282)
                if self._state.backtracking == 0:
                    string_literal559_tree = self._adaptor.createWithPayload(string_literal559)
                    self._adaptor.addChild(root_0, string_literal559_tree)



                self._state.following.append(self.FOLLOW_seq_of_statements_in_if_statement3284)
                seq_of_statements560 = self.seq_of_statements()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, seq_of_statements560.tree)


                # ./output/PLSQL3.g:551:3: ( keyELSIF plsql_condition 'THEN' seq_of_statements )*
                while True: #loop136
                    alt136 = 2
                    LA136_0 = self.input.LA(1)

                    if (LA136_0 == 84) :
                        alt136 = 1


                    if alt136 == 1:
                        # ./output/PLSQL3.g:552:4: keyELSIF plsql_condition 'THEN' seq_of_statements
                        pass
                        self._state.following.append(self.FOLLOW_keyELSIF_in_if_statement3294)
                        keyELSIF561 = self.keyELSIF()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyELSIF561.tree)


                        self._state.following.append(self.FOLLOW_plsql_condition_in_if_statement3296)
                        plsql_condition562 = self.plsql_condition()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, plsql_condition562.tree)


                        string_literal563 = self.match(self.input, 154, self.FOLLOW_154_in_if_statement3298)
                        if self._state.backtracking == 0:
                            string_literal563_tree = self._adaptor.createWithPayload(string_literal563)
                            self._adaptor.addChild(root_0, string_literal563_tree)



                        self._state.following.append(self.FOLLOW_seq_of_statements_in_if_statement3300)
                        seq_of_statements564 = self.seq_of_statements()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, seq_of_statements564.tree)



                    else:
                        break #loop136


                # ./output/PLSQL3.g:554:3: ( 'ELSE' seq_of_statements )?
                alt137 = 2
                LA137_0 = self.input.LA(1)

                if (LA137_0 == 83) :
                    alt137 = 1
                if alt137 == 1:
                    # ./output/PLSQL3.g:554:5: 'ELSE' seq_of_statements
                    pass
                    string_literal565 = self.match(self.input, 83, self.FOLLOW_83_in_if_statement3311)
                    if self._state.backtracking == 0:
                        string_literal565_tree = self._adaptor.createWithPayload(string_literal565)
                        self._adaptor.addChild(root_0, string_literal565_tree)



                    self._state.following.append(self.FOLLOW_seq_of_statements_in_if_statement3313)
                    seq_of_statements566 = self.seq_of_statements()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, seq_of_statements566.tree)





                string_literal567 = self.match(self.input, 85, self.FOLLOW_85_in_if_statement3320)
                if self._state.backtracking == 0:
                    string_literal567_tree = self._adaptor.createWithPayload(string_literal567)
                    self._adaptor.addChild(root_0, string_literal567_tree)



                string_literal568 = self.match(self.input, 98, self.FOLLOW_98_in_if_statement3322)
                if self._state.backtracking == 0:
                    string_literal568_tree = self._adaptor.createWithPayload(string_literal568)
                    self._adaptor.addChild(root_0, string_literal568_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 80, if_statement_StartIndex, success)


            pass
        return retval

    # $ANTLR end "if_statement"


    class sql_statement_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.sql_statement_return, self).__init__()

            self.tree = None





    # $ANTLR start "sql_statement"
    # ./output/PLSQL3.g:558:1: sql_statement : sql_command ;
    def sql_statement(self, ):
        retval = self.sql_statement_return()
        retval.start = self.input.LT(1)

        sql_statement_StartIndex = self.input.index()

        root_0 = None

        sql_command569 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 81):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:559:2: ( sql_command )
                # ./output/PLSQL3.g:559:4: sql_command
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_sql_command_in_sql_statement3333)
                sql_command569 = self.sql_command()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_command569.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 81, sql_statement_StartIndex, success)


            pass
        return retval

    # $ANTLR end "sql_statement"


    class sql_command_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.sql_command_return, self).__init__()

            self.tree = None





    # $ANTLR start "sql_command"
    # ./output/PLSQL3.g:562:1: sql_command : ( to_modify_data | to_control_data );
    def sql_command(self, ):
        retval = self.sql_command_return()
        retval.start = self.input.LT(1)

        sql_command_StartIndex = self.input.index()

        root_0 = None

        to_modify_data570 = None

        to_control_data571 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 82):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:563:2: ( to_modify_data | to_control_data )
                alt138 = 2
                LA138_0 = self.input.LA(1)

                if (LA138_0 == 79 or LA138_0 == 101 or (147 <= LA138_0 <= 148) or LA138_0 == 159) :
                    alt138 = 1
                elif (LA138_0 == ID or LA138_0 == 70 or LA138_0 == 90 or LA138_0 == 108 or LA138_0 == 142 or LA138_0 == 146) :
                    alt138 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 138, 0, self.input)

                    raise nvae


                if alt138 == 1:
                    # ./output/PLSQL3.g:563:4: to_modify_data
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_to_modify_data_in_sql_command3344)
                    to_modify_data570 = self.to_modify_data()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, to_modify_data570.tree)



                elif alt138 == 2:
                    # ./output/PLSQL3.g:564:4: to_control_data
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_to_control_data_in_sql_command3349)
                    to_control_data571 = self.to_control_data()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, to_control_data571.tree)



                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 82, sql_command_StartIndex, success)


            pass
        return retval

    # $ANTLR end "sql_command"


    class to_modify_data_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.to_modify_data_return, self).__init__()

            self.tree = None





    # $ANTLR start "to_modify_data"
    # ./output/PLSQL3.g:567:1: to_modify_data : ( select_command | insert_command | update_command | delete_command | set_transaction_command );
    def to_modify_data(self, ):
        retval = self.to_modify_data_return()
        retval.start = self.input.LT(1)

        to_modify_data_StartIndex = self.input.index()

        root_0 = None

        select_command572 = None

        insert_command573 = None

        update_command574 = None

        delete_command575 = None

        set_transaction_command576 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 83):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:568:2: ( select_command | insert_command | update_command | delete_command | set_transaction_command )
                alt139 = 5
                LA139 = self.input.LA(1)
                if LA139 == 147:
                    alt139 = 1
                elif LA139 == 101:
                    alt139 = 2
                elif LA139 == 159:
                    alt139 = 3
                elif LA139 == 79:
                    alt139 = 4
                elif LA139 == 148:
                    alt139 = 5
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 139, 0, self.input)

                    raise nvae


                if alt139 == 1:
                    # ./output/PLSQL3.g:568:4: select_command
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_select_command_in_to_modify_data3360)
                    select_command572 = self.select_command()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, select_command572.tree)



                elif alt139 == 2:
                    # ./output/PLSQL3.g:569:4: insert_command
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_insert_command_in_to_modify_data3365)
                    insert_command573 = self.insert_command()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, insert_command573.tree)



                elif alt139 == 3:
                    # ./output/PLSQL3.g:570:4: update_command
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_update_command_in_to_modify_data3370)
                    update_command574 = self.update_command()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, update_command574.tree)



                elif alt139 == 4:
                    # ./output/PLSQL3.g:571:4: delete_command
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_delete_command_in_to_modify_data3375)
                    delete_command575 = self.delete_command()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, delete_command575.tree)



                elif alt139 == 5:
                    # ./output/PLSQL3.g:572:4: set_transaction_command
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_set_transaction_command_in_to_modify_data3380)
                    set_transaction_command576 = self.set_transaction_command()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, set_transaction_command576.tree)



                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 83, to_modify_data_StartIndex, success)


            pass
        return retval

    # $ANTLR end "to_modify_data"


    class to_control_data_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.to_control_data_return, self).__init__()

            self.tree = None





    # $ANTLR start "to_control_data"
    # ./output/PLSQL3.g:575:1: to_control_data : ( close_statement | commit_statement | fetch_statement | lock_table_statement | open_statement | rollback_statement | savepoint_statement );
    def to_control_data(self, ):
        retval = self.to_control_data_return()
        retval.start = self.input.LT(1)

        to_control_data_StartIndex = self.input.index()

        root_0 = None

        close_statement577 = None

        commit_statement578 = None

        fetch_statement579 = None

        lock_table_statement580 = None

        open_statement581 = None

        rollback_statement582 = None

        savepoint_statement583 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 84):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:576:2: ( close_statement | commit_statement | fetch_statement | lock_table_statement | open_statement | rollback_statement | savepoint_statement )
                alt140 = 7
                LA140 = self.input.LA(1)
                if LA140 == ID:
                    LA140_1 = self.input.LA(2)

                    if (LA140_1 == DOUBLEQUOTED_STRING or LA140_1 == ID) :
                        LA140_7 = self.input.LA(3)

                        if (((((((self.input).LT(1).text.upper() == "CLOSE")) and (((this.input).LT(1).text.upper() == "CLOSE")))) and (self.synpred252_PLSQL3()))) :
                            alt140 = 1
                        elif (((((((self.input).LT(1).text.upper() == "OPEN")) and (((this.input).LT(1).text.upper() == "OPEN")))) and (self.synpred256_PLSQL3()))) :
                            alt140 = 5
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 140, 7, self.input)

                            raise nvae


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 140, 1, self.input)

                        raise nvae


                elif LA140 == 70:
                    alt140 = 2
                elif LA140 == 90:
                    alt140 = 3
                elif LA140 == 108:
                    alt140 = 4
                elif LA140 == 142:
                    alt140 = 6
                elif LA140 == 146:
                    alt140 = 7
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 140, 0, self.input)

                    raise nvae


                if alt140 == 1:
                    # ./output/PLSQL3.g:576:4: close_statement
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_close_statement_in_to_control_data3391)
                    close_statement577 = self.close_statement()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, close_statement577.tree)



                elif alt140 == 2:
                    # ./output/PLSQL3.g:577:4: commit_statement
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_commit_statement_in_to_control_data3396)
                    commit_statement578 = self.commit_statement()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, commit_statement578.tree)



                elif alt140 == 3:
                    # ./output/PLSQL3.g:578:4: fetch_statement
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_fetch_statement_in_to_control_data3401)
                    fetch_statement579 = self.fetch_statement()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, fetch_statement579.tree)



                elif alt140 == 4:
                    # ./output/PLSQL3.g:579:4: lock_table_statement
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_lock_table_statement_in_to_control_data3406)
                    lock_table_statement580 = self.lock_table_statement()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, lock_table_statement580.tree)



                elif alt140 == 5:
                    # ./output/PLSQL3.g:580:4: open_statement
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_open_statement_in_to_control_data3411)
                    open_statement581 = self.open_statement()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, open_statement581.tree)



                elif alt140 == 6:
                    # ./output/PLSQL3.g:581:4: rollback_statement
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_rollback_statement_in_to_control_data3416)
                    rollback_statement582 = self.rollback_statement()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, rollback_statement582.tree)



                elif alt140 == 7:
                    # ./output/PLSQL3.g:582:4: savepoint_statement
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_savepoint_statement_in_to_control_data3421)
                    savepoint_statement583 = self.savepoint_statement()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, savepoint_statement583.tree)



                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 84, to_control_data_StartIndex, success)


            pass
        return retval

    # $ANTLR end "to_control_data"


    class select_command_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.select_command_return, self).__init__()

            self.tree = None





    # $ANTLR start "select_command"
    # ./output/PLSQL3.g:585:1: select_command : select_statement ;
    def select_command(self, ):
        retval = self.select_command_return()
        retval.start = self.input.LT(1)

        select_command_StartIndex = self.input.index()

        root_0 = None

        select_statement584 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 85):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:586:2: ( select_statement )
                # ./output/PLSQL3.g:586:4: select_statement
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_select_statement_in_select_command3432)
                select_statement584 = self.select_statement()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, select_statement584.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 85, select_command_StartIndex, success)


            pass
        return retval

    # $ANTLR end "select_command"


    class select_statement_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.select_statement_return, self).__init__()

            self.tree = None





    # $ANTLR start "select_statement"
    # ./output/PLSQL3.g:589:1: select_statement : select_expression ;
    def select_statement(self, ):
        retval = self.select_statement_return()
        retval.start = self.input.LT(1)

        select_statement_StartIndex = self.input.index()

        root_0 = None

        select_expression585 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 86):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:590:2: ( select_expression )
                # ./output/PLSQL3.g:591:3: select_expression
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_select_expression_in_select_statement3446)
                select_expression585 = self.select_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, select_expression585.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 86, select_statement_StartIndex, success)


            pass
        return retval

    # $ANTLR end "select_statement"


    class select_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.select_expression_return, self).__init__()

            self.tree = None





    # $ANTLR start "select_expression"
    # ./output/PLSQL3.g:594:1: select_expression : 'SELECT' ( 'DISTINCT' | 'UNIQUE' | 'ALL' )? select_list ( keyBULK keyCOLLECT )? ( 'INTO' lvalues )? 'FROM' ( join_clause | LPAREN join_clause RPAREN | table_reference_list ) ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( 'HAVING' sql_condition )? ( model_clause )? ( ( 'UNION' ( 'ALL' )? | 'INTERSECT' | 'MINUS' ) ( select_expression | subquery ) )? ( order_by_clause )? ;
    def select_expression(self, ):
        retval = self.select_expression_return()
        retval.start = self.input.LT(1)

        select_expression_StartIndex = self.input.index()

        root_0 = None

        string_literal586 = None
        set587 = None
        string_literal591 = None
        string_literal593 = None
        LPAREN595 = None
        RPAREN597 = None
        string_literal602 = None
        string_literal605 = None
        string_literal606 = None
        string_literal607 = None
        string_literal608 = None
        select_list588 = None

        keyBULK589 = None

        keyCOLLECT590 = None

        lvalues592 = None

        join_clause594 = None

        join_clause596 = None

        table_reference_list598 = None

        where_clause599 = None

        hierarchical_query_clause600 = None

        group_by_clause601 = None

        sql_condition603 = None

        model_clause604 = None

        select_expression609 = None

        subquery610 = None

        order_by_clause611 = None


        string_literal586_tree = None
        set587_tree = None
        string_literal591_tree = None
        string_literal593_tree = None
        LPAREN595_tree = None
        RPAREN597_tree = None
        string_literal602_tree = None
        string_literal605_tree = None
        string_literal606_tree = None
        string_literal607_tree = None
        string_literal608_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 87):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:595:2: ( 'SELECT' ( 'DISTINCT' | 'UNIQUE' | 'ALL' )? select_list ( keyBULK keyCOLLECT )? ( 'INTO' lvalues )? 'FROM' ( join_clause | LPAREN join_clause RPAREN | table_reference_list ) ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( 'HAVING' sql_condition )? ( model_clause )? ( ( 'UNION' ( 'ALL' )? | 'INTERSECT' | 'MINUS' ) ( select_expression | subquery ) )? ( order_by_clause )? )
                # ./output/PLSQL3.g:596:3: 'SELECT' ( 'DISTINCT' | 'UNIQUE' | 'ALL' )? select_list ( keyBULK keyCOLLECT )? ( 'INTO' lvalues )? 'FROM' ( join_clause | LPAREN join_clause RPAREN | table_reference_list ) ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( 'HAVING' sql_condition )? ( model_clause )? ( ( 'UNION' ( 'ALL' )? | 'INTERSECT' | 'MINUS' ) ( select_expression | subquery ) )? ( order_by_clause )?
                pass
                root_0 = self._adaptor.nil()


                string_literal586 = self.match(self.input, 147, self.FOLLOW_147_in_select_expression3461)
                if self._state.backtracking == 0:
                    string_literal586_tree = self._adaptor.createWithPayload(string_literal586)
                    self._adaptor.addChild(root_0, string_literal586_tree)



                # ./output/PLSQL3.g:596:26: ( 'DISTINCT' | 'UNIQUE' | 'ALL' )?
                alt141 = 2
                LA141_0 = self.input.LA(1)

                if (LA141_0 == 81) :
                    LA141_1 = self.input.LA(2)

                    if (not (((is_sql )))) :
                        alt141 = 1
                elif (LA141_0 == 50 or LA141_0 == 158) :
                    alt141 = 1
                if alt141 == 1:
                    # ./output/PLSQL3.g:
                    pass
                    set587 = self.input.LT(1)

                    if self.input.LA(1) == 50 or self.input.LA(1) == 81 or self.input.LA(1) == 158:
                        self.input.consume()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set587))

                        self._state.errorRecovery = False


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        mse = MismatchedSetException(None, self.input)
                        raise mse






                self._state.following.append(self.FOLLOW_select_list_in_select_expression3480)
                select_list588 = self.select_list()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, select_list588.tree)


                # ./output/PLSQL3.g:597:3: ( keyBULK keyCOLLECT )?
                alt142 = 2
                LA142_0 = self.input.LA(1)

                if (LA142_0 == ID) :
                    alt142 = 1
                if alt142 == 1:
                    # ./output/PLSQL3.g:597:5: keyBULK keyCOLLECT
                    pass
                    self._state.following.append(self.FOLLOW_keyBULK_in_select_expression3486)
                    keyBULK589 = self.keyBULK()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyBULK589.tree)


                    self._state.following.append(self.FOLLOW_keyCOLLECT_in_select_expression3488)
                    keyCOLLECT590 = self.keyCOLLECT()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyCOLLECT590.tree)





                # ./output/PLSQL3.g:598:3: ( 'INTO' lvalues )?
                alt143 = 2
                LA143_0 = self.input.LA(1)

                if (LA143_0 == 105) :
                    alt143 = 1
                if alt143 == 1:
                    # ./output/PLSQL3.g:598:5: 'INTO' lvalues
                    pass
                    string_literal591 = self.match(self.input, 105, self.FOLLOW_105_in_select_expression3497)
                    if self._state.backtracking == 0:
                        string_literal591_tree = self._adaptor.createWithPayload(string_literal591)
                        self._adaptor.addChild(root_0, string_literal591_tree)



                    self._state.following.append(self.FOLLOW_lvalues_in_select_expression3499)
                    lvalues592 = self.lvalues()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, lvalues592.tree)





                string_literal593 = self.match(self.input, 93, self.FOLLOW_93_in_select_expression3506)
                if self._state.backtracking == 0:
                    string_literal593_tree = self._adaptor.createWithPayload(string_literal593)
                    self._adaptor.addChild(root_0, string_literal593_tree)



                # ./output/PLSQL3.g:599:10: ( join_clause | LPAREN join_clause RPAREN | table_reference_list )
                alt144 = 3
                LA144 = self.input.LA(1)
                if LA144 == ID:
                    LA144_1 = self.input.LA(2)

                    if (self.synpred263_PLSQL3()) :
                        alt144 = 1
                    elif (True) :
                        alt144 = 3
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 144, 1, self.input)

                        raise nvae


                elif LA144 == 144:
                    LA144_2 = self.input.LA(2)

                    if (self.synpred263_PLSQL3()) :
                        alt144 = 1
                    elif (True) :
                        alt144 = 3
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 144, 2, self.input)

                        raise nvae


                elif LA144 == 153:
                    LA144_3 = self.input.LA(2)

                    if (self.synpred263_PLSQL3()) :
                        alt144 = 1
                    elif (True) :
                        alt144 = 3
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 144, 3, self.input)

                        raise nvae


                elif LA144 == DOUBLEQUOTED_STRING:
                    LA144_4 = self.input.LA(2)

                    if (self.synpred263_PLSQL3()) :
                        alt144 = 1
                    elif (True) :
                        alt144 = 3
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 144, 4, self.input)

                        raise nvae


                elif LA144 == LPAREN:
                    LA144_5 = self.input.LA(2)

                    if (self.synpred263_PLSQL3()) :
                        alt144 = 1
                    elif (self.synpred264_PLSQL3()) :
                        alt144 = 2
                    elif (True) :
                        alt144 = 3
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 144, 5, self.input)

                        raise nvae


                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 144, 0, self.input)

                    raise nvae


                if alt144 == 1:
                    # ./output/PLSQL3.g:599:12: join_clause
                    pass
                    self._state.following.append(self.FOLLOW_join_clause_in_select_expression3510)
                    join_clause594 = self.join_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, join_clause594.tree)



                elif alt144 == 2:
                    # ./output/PLSQL3.g:599:26: LPAREN join_clause RPAREN
                    pass
                    LPAREN595 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_select_expression3514)
                    if self._state.backtracking == 0:
                        LPAREN595_tree = self._adaptor.createWithPayload(LPAREN595)
                        self._adaptor.addChild(root_0, LPAREN595_tree)



                    self._state.following.append(self.FOLLOW_join_clause_in_select_expression3516)
                    join_clause596 = self.join_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, join_clause596.tree)


                    RPAREN597 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_select_expression3518)
                    if self._state.backtracking == 0:
                        RPAREN597_tree = self._adaptor.createWithPayload(RPAREN597)
                        self._adaptor.addChild(root_0, RPAREN597_tree)




                elif alt144 == 3:
                    # ./output/PLSQL3.g:599:54: table_reference_list
                    pass
                    self._state.following.append(self.FOLLOW_table_reference_list_in_select_expression3522)
                    table_reference_list598 = self.table_reference_list()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, table_reference_list598.tree)





                # ./output/PLSQL3.g:600:3: ( where_clause )?
                alt145 = 2
                LA145_0 = self.input.LA(1)

                if (LA145_0 == 165) :
                    LA145_1 = self.input.LA(2)

                    if (self.synpred265_PLSQL3()) :
                        alt145 = 1
                if alt145 == 1:
                    # ./output/PLSQL3.g:600:5: where_clause
                    pass
                    self._state.following.append(self.FOLLOW_where_clause_in_select_expression3530)
                    where_clause599 = self.where_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, where_clause599.tree)





                # ./output/PLSQL3.g:600:21: ( hierarchical_query_clause )?
                alt146 = 2
                LA146_0 = self.input.LA(1)

                if (LA146_0 == 152) :
                    LA146_1 = self.input.LA(2)

                    if (self.synpred266_PLSQL3()) :
                        alt146 = 1
                elif (LA146_0 == 71) :
                    LA146_2 = self.input.LA(2)

                    if (self.synpred266_PLSQL3()) :
                        alt146 = 1
                if alt146 == 1:
                    # ./output/PLSQL3.g:600:23: hierarchical_query_clause
                    pass
                    self._state.following.append(self.FOLLOW_hierarchical_query_clause_in_select_expression3537)
                    hierarchical_query_clause600 = self.hierarchical_query_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, hierarchical_query_clause600.tree)





                # ./output/PLSQL3.g:600:52: ( group_by_clause )?
                alt147 = 2
                LA147_0 = self.input.LA(1)

                if (LA147_0 == 96) :
                    LA147_1 = self.input.LA(2)

                    if (self.synpred267_PLSQL3()) :
                        alt147 = 1
                if alt147 == 1:
                    # ./output/PLSQL3.g:600:54: group_by_clause
                    pass
                    self._state.following.append(self.FOLLOW_group_by_clause_in_select_expression3544)
                    group_by_clause601 = self.group_by_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, group_by_clause601.tree)





                # ./output/PLSQL3.g:601:3: ( 'HAVING' sql_condition )?
                alt148 = 2
                LA148_0 = self.input.LA(1)

                if (LA148_0 == 97) :
                    LA148_1 = self.input.LA(2)

                    if (self.synpred268_PLSQL3()) :
                        alt148 = 1
                if alt148 == 1:
                    # ./output/PLSQL3.g:601:5: 'HAVING' sql_condition
                    pass
                    string_literal602 = self.match(self.input, 97, self.FOLLOW_97_in_select_expression3553)
                    if self._state.backtracking == 0:
                        string_literal602_tree = self._adaptor.createWithPayload(string_literal602)
                        self._adaptor.addChild(root_0, string_literal602_tree)



                    self._state.following.append(self.FOLLOW_sql_condition_in_select_expression3555)
                    sql_condition603 = self.sql_condition()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_condition603.tree)





                # ./output/PLSQL3.g:601:31: ( model_clause )?
                alt149 = 2
                LA149_0 = self.input.LA(1)

                if (LA149_0 == ID) :
                    LA149_1 = self.input.LA(2)

                    if (((((((self.input).LT(1).text.upper() == "MODEL")) and (((this.input).LT(1).text.upper() == "MODEL")))) and (self.synpred269_PLSQL3()))) :
                        alt149 = 1
                if alt149 == 1:
                    # ./output/PLSQL3.g:601:33: model_clause
                    pass
                    self._state.following.append(self.FOLLOW_model_clause_in_select_expression3562)
                    model_clause604 = self.model_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, model_clause604.tree)





                # ./output/PLSQL3.g:602:3: ( ( 'UNION' ( 'ALL' )? | 'INTERSECT' | 'MINUS' ) ( select_expression | subquery ) )?
                alt153 = 2
                LA153 = self.input.LA(1)
                if LA153 == 157:
                    LA153_1 = self.input.LA(2)

                    if (self.synpred274_PLSQL3()) :
                        alt153 = 1
                elif LA153 == 104:
                    LA153_2 = self.input.LA(2)

                    if (self.synpred274_PLSQL3()) :
                        alt153 = 1
                elif LA153 == 111:
                    LA153_3 = self.input.LA(2)

                    if (self.synpred274_PLSQL3()) :
                        alt153 = 1
                if alt153 == 1:
                    # ./output/PLSQL3.g:602:5: ( 'UNION' ( 'ALL' )? | 'INTERSECT' | 'MINUS' ) ( select_expression | subquery )
                    pass
                    # ./output/PLSQL3.g:602:5: ( 'UNION' ( 'ALL' )? | 'INTERSECT' | 'MINUS' )
                    alt151 = 3
                    LA151 = self.input.LA(1)
                    if LA151 == 157:
                        alt151 = 1
                    elif LA151 == 104:
                        alt151 = 2
                    elif LA151 == 111:
                        alt151 = 3
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 151, 0, self.input)

                        raise nvae


                    if alt151 == 1:
                        # ./output/PLSQL3.g:602:7: 'UNION' ( 'ALL' )?
                        pass
                        string_literal605 = self.match(self.input, 157, self.FOLLOW_157_in_select_expression3573)
                        if self._state.backtracking == 0:
                            string_literal605_tree = self._adaptor.createWithPayload(string_literal605)
                            self._adaptor.addChild(root_0, string_literal605_tree)



                        # ./output/PLSQL3.g:602:15: ( 'ALL' )?
                        alt150 = 2
                        LA150_0 = self.input.LA(1)

                        if (LA150_0 == 50) :
                            alt150 = 1
                        if alt150 == 1:
                            # ./output/PLSQL3.g:602:17: 'ALL'
                            pass
                            string_literal606 = self.match(self.input, 50, self.FOLLOW_50_in_select_expression3577)
                            if self._state.backtracking == 0:
                                string_literal606_tree = self._adaptor.createWithPayload(string_literal606)
                                self._adaptor.addChild(root_0, string_literal606_tree)







                    elif alt151 == 2:
                        # ./output/PLSQL3.g:603:6: 'INTERSECT'
                        pass
                        string_literal607 = self.match(self.input, 104, self.FOLLOW_104_in_select_expression3587)
                        if self._state.backtracking == 0:
                            string_literal607_tree = self._adaptor.createWithPayload(string_literal607)
                            self._adaptor.addChild(root_0, string_literal607_tree)




                    elif alt151 == 3:
                        # ./output/PLSQL3.g:604:6: 'MINUS'
                        pass
                        string_literal608 = self.match(self.input, 111, self.FOLLOW_111_in_select_expression3594)
                        if self._state.backtracking == 0:
                            string_literal608_tree = self._adaptor.createWithPayload(string_literal608)
                            self._adaptor.addChild(root_0, string_literal608_tree)






                    # ./output/PLSQL3.g:606:4: ( select_expression | subquery )
                    alt152 = 2
                    LA152_0 = self.input.LA(1)

                    if (LA152_0 == 147) :
                        alt152 = 1
                    elif (LA152_0 == LPAREN) :
                        alt152 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 152, 0, self.input)

                        raise nvae


                    if alt152 == 1:
                        # ./output/PLSQL3.g:606:6: select_expression
                        pass
                        self._state.following.append(self.FOLLOW_select_expression_in_select_expression3606)
                        select_expression609 = self.select_expression()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, select_expression609.tree)



                    elif alt152 == 2:
                        # ./output/PLSQL3.g:607:6: subquery
                        pass
                        self._state.following.append(self.FOLLOW_subquery_in_select_expression3614)
                        subquery610 = self.subquery()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, subquery610.tree)








                # ./output/PLSQL3.g:610:3: ( order_by_clause )?
                alt154 = 2
                LA154_0 = self.input.LA(1)

                if (LA154_0 == 128) :
                    LA154_1 = self.input.LA(2)

                    if (self.synpred275_PLSQL3()) :
                        alt154 = 1
                if alt154 == 1:
                    # ./output/PLSQL3.g:610:5: order_by_clause
                    pass
                    self._state.following.append(self.FOLLOW_order_by_clause_in_select_expression3630)
                    order_by_clause611 = self.order_by_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, order_by_clause611.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 87, select_expression_StartIndex, success)


            pass
        return retval

    # $ANTLR end "select_expression"


    class select_list_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.select_list_return, self).__init__()

            self.tree = None





    # $ANTLR start "select_list"
    # ./output/PLSQL3.g:613:1: select_list : ( ASTERISK | displayed_column ( COMMA displayed_column )* );
    def select_list(self, ):
        retval = self.select_list_return()
        retval.start = self.input.LT(1)

        select_list_StartIndex = self.input.index()

        root_0 = None

        ASTERISK612 = None
        COMMA614 = None
        displayed_column613 = None

        displayed_column615 = None


        ASTERISK612_tree = None
        COMMA614_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 88):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:614:2: ( ASTERISK | displayed_column ( COMMA displayed_column )* )
                alt156 = 2
                LA156_0 = self.input.LA(1)

                if (LA156_0 == ASTERISK) :
                    alt156 = 1
                elif (LA156_0 == DOUBLEQUOTED_STRING or LA156_0 == ID or LA156_0 == LPAREN or LA156_0 == MINUS or LA156_0 == NUMBER or LA156_0 == PLUS or LA156_0 == QUOTED_STRING or LA156_0 == 65 or LA156_0 == 81 or LA156_0 == 89 or LA156_0 == 120 or LA156_0 == 144 or LA156_0 == 147 or LA156_0 == 151 or LA156_0 == 156) :
                    alt156 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 156, 0, self.input)

                    raise nvae


                if alt156 == 1:
                    # ./output/PLSQL3.g:614:4: ASTERISK
                    pass
                    root_0 = self._adaptor.nil()


                    ASTERISK612 = self.match(self.input, ASTERISK, self.FOLLOW_ASTERISK_in_select_list3644)
                    if self._state.backtracking == 0:
                        ASTERISK612_tree = self._adaptor.createWithPayload(ASTERISK612)
                        self._adaptor.addChild(root_0, ASTERISK612_tree)




                elif alt156 == 2:
                    # ./output/PLSQL3.g:615:4: displayed_column ( COMMA displayed_column )*
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_displayed_column_in_select_list3649)
                    displayed_column613 = self.displayed_column()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, displayed_column613.tree)


                    # ./output/PLSQL3.g:615:21: ( COMMA displayed_column )*
                    while True: #loop155
                        alt155 = 2
                        LA155_0 = self.input.LA(1)

                        if (LA155_0 == COMMA) :
                            alt155 = 1


                        if alt155 == 1:
                            # ./output/PLSQL3.g:615:23: COMMA displayed_column
                            pass
                            COMMA614 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_select_list3653)
                            if self._state.backtracking == 0:
                                COMMA614_tree = self._adaptor.createWithPayload(COMMA614)
                                self._adaptor.addChild(root_0, COMMA614_tree)



                            self._state.following.append(self.FOLLOW_displayed_column_in_select_list3655)
                            displayed_column615 = self.displayed_column()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, displayed_column615.tree)



                        else:
                            break #loop155



                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 88, select_list_StartIndex, success)


            pass
        return retval

    # $ANTLR end "select_list"


    class table_reference_list_from_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.table_reference_list_from_return, self).__init__()

            self.tree = None





    # $ANTLR start "table_reference_list_from"
    # ./output/PLSQL3.g:618:1: table_reference_list_from : 'FROM' table_reference_list ;
    def table_reference_list_from(self, ):
        retval = self.table_reference_list_from_return()
        retval.start = self.input.LT(1)

        table_reference_list_from_StartIndex = self.input.index()

        root_0 = None

        string_literal616 = None
        table_reference_list617 = None


        string_literal616_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 89):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:619:2: ( 'FROM' table_reference_list )
                # ./output/PLSQL3.g:619:4: 'FROM' table_reference_list
                pass
                root_0 = self._adaptor.nil()


                string_literal616 = self.match(self.input, 93, self.FOLLOW_93_in_table_reference_list_from3669)
                if self._state.backtracking == 0:
                    string_literal616_tree = self._adaptor.createWithPayload(string_literal616)
                    self._adaptor.addChild(root_0, string_literal616_tree)



                self._state.following.append(self.FOLLOW_table_reference_list_in_table_reference_list_from3671)
                table_reference_list617 = self.table_reference_list()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, table_reference_list617.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 89, table_reference_list_from_StartIndex, success)


            pass
        return retval

    # $ANTLR end "table_reference_list_from"


    class table_reference_list_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.table_reference_list_return, self).__init__()

            self.tree = None





    # $ANTLR start "table_reference_list"
    # ./output/PLSQL3.g:622:1: table_reference_list : selected_table ( COMMA selected_table )* ;
    def table_reference_list(self, ):
        retval = self.table_reference_list_return()
        retval.start = self.input.LT(1)

        table_reference_list_StartIndex = self.input.index()

        root_0 = None

        COMMA619 = None
        selected_table618 = None

        selected_table620 = None


        COMMA619_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 90):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:623:2: ( selected_table ( COMMA selected_table )* )
                # ./output/PLSQL3.g:623:4: selected_table ( COMMA selected_table )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_selected_table_in_table_reference_list3682)
                selected_table618 = self.selected_table()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, selected_table618.tree)


                # ./output/PLSQL3.g:623:19: ( COMMA selected_table )*
                while True: #loop157
                    alt157 = 2
                    alt157 = self.dfa157.predict(self.input)
                    if alt157 == 1:
                        # ./output/PLSQL3.g:623:21: COMMA selected_table
                        pass
                        COMMA619 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_table_reference_list3686)
                        if self._state.backtracking == 0:
                            COMMA619_tree = self._adaptor.createWithPayload(COMMA619)
                            self._adaptor.addChild(root_0, COMMA619_tree)



                        self._state.following.append(self.FOLLOW_selected_table_in_table_reference_list3688)
                        selected_table620 = self.selected_table()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, selected_table620.tree)



                    else:
                        break #loop157




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 90, table_reference_list_StartIndex, success)


            pass
        return retval

    # $ANTLR end "table_reference_list"


    class join_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.join_clause_return, self).__init__()

            self.tree = None





    # $ANTLR start "join_clause"
    # ./output/PLSQL3.g:626:1: join_clause : selected_table ( inner_cross_join_clause | outer_join_clause )+ ;
    def join_clause(self, ):
        retval = self.join_clause_return()
        retval.start = self.input.LT(1)

        join_clause_StartIndex = self.input.index()

        root_0 = None

        selected_table621 = None

        inner_cross_join_clause622 = None

        outer_join_clause623 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 91):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:627:2: ( selected_table ( inner_cross_join_clause | outer_join_clause )+ )
                # ./output/PLSQL3.g:627:4: selected_table ( inner_cross_join_clause | outer_join_clause )+
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_selected_table_in_join_clause3702)
                selected_table621 = self.selected_table()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, selected_table621.tree)


                # ./output/PLSQL3.g:627:19: ( inner_cross_join_clause | outer_join_clause )+
                cnt158 = 0
                while True: #loop158
                    alt158 = 3
                    LA158_0 = self.input.LA(1)

                    if (LA158_0 == ID) :
                        LA158_2 = self.input.LA(2)

                        if ((((((((self.input).LT(1).text.upper() == "INNER") or ((this.input).LT(1).text.upper() == "JOIN") or ((this.input).LT(1).text.upper() == "NATURAL") or ((this.input).LT(1).text.upper() == "CROSS"))) and ((((this.input).LT(1).text.upper() == "INNER") or ((this.input).LT(1).text.upper() == "JOIN") or ((this.input).LT(1).text.upper() == "NATURAL") or ((this.input).LT(1).text.upper() == "CROSS"))))) and (self.synpred279_PLSQL3()))) :
                            alt158 = 1
                        elif ((((((((self.input).LT(1).text.upper() == "PARTITION") or ((this.input).LT(1).text.upper() == "FULL") or ((this.input).LT(1).text.upper() == "NATURAL") or ((this.input).LT(1).text.upper() == "LEFT") or ((this.input).LT(1).text.upper() == "RIGHT"))) and ((((this.input).LT(1).text.upper() == "PARTITION") or ((this.input).LT(1).text.upper() == "FULL") or ((this.input).LT(1).text.upper() == "NATURAL") or ((this.input).LT(1).text.upper() == "LEFT") or ((this.input).LT(1).text.upper() == "RIGHT"))))) and (self.synpred280_PLSQL3()))) :
                            alt158 = 2




                    if alt158 == 1:
                        # ./output/PLSQL3.g:627:21: inner_cross_join_clause
                        pass
                        self._state.following.append(self.FOLLOW_inner_cross_join_clause_in_join_clause3706)
                        inner_cross_join_clause622 = self.inner_cross_join_clause()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, inner_cross_join_clause622.tree)



                    elif alt158 == 2:
                        # ./output/PLSQL3.g:627:47: outer_join_clause
                        pass
                        self._state.following.append(self.FOLLOW_outer_join_clause_in_join_clause3710)
                        outer_join_clause623 = self.outer_join_clause()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, outer_join_clause623.tree)



                    else:
                        if cnt158 >= 1:
                            break #loop158

                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        eee = EarlyExitException(158, self.input)
                        raise eee

                    cnt158 += 1




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 91, join_clause_StartIndex, success)


            pass
        return retval

    # $ANTLR end "join_clause"


    class inner_cross_join_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.inner_cross_join_clause_return, self).__init__()

            self.tree = None





    # $ANTLR start "inner_cross_join_clause"
    # ./output/PLSQL3.g:629:1: inner_cross_join_clause : ( ( keyINNER )? keyJOIN table_name ( 'ON' sql_condition | keyUSING LPAREN column_specs RPAREN ) | ( keyCROSS | keyNATURAL ( keyINNER ) ) keyJOIN table_name );
    def inner_cross_join_clause(self, ):
        retval = self.inner_cross_join_clause_return()
        retval.start = self.input.LT(1)

        inner_cross_join_clause_StartIndex = self.input.index()

        root_0 = None

        string_literal627 = None
        LPAREN630 = None
        RPAREN632 = None
        keyINNER624 = None

        keyJOIN625 = None

        table_name626 = None

        sql_condition628 = None

        keyUSING629 = None

        column_specs631 = None

        keyCROSS633 = None

        keyNATURAL634 = None

        keyINNER635 = None

        keyJOIN636 = None

        table_name637 = None


        string_literal627_tree = None
        LPAREN630_tree = None
        RPAREN632_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 92):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:630:2: ( ( keyINNER )? keyJOIN table_name ( 'ON' sql_condition | keyUSING LPAREN column_specs RPAREN ) | ( keyCROSS | keyNATURAL ( keyINNER ) ) keyJOIN table_name )
                alt162 = 2
                LA162_0 = self.input.LA(1)

                if (LA162_0 == ID) :
                    LA162_1 = self.input.LA(2)

                    if ((((((((self.input).LT(1).text.upper() == "INNER") or ((this.input).LT(1).text.upper() == "JOIN"))) and ((((this.input).LT(1).text.upper() == "INNER") or ((this.input).LT(1).text.upper() == "JOIN"))))) and (self.synpred283_PLSQL3()))) :
                        alt162 = 1
                    elif ((((self.input).LT(1).text.upper() == "NATURAL") or ((this.input).LT(1).text.upper() == "CROSS"))) :
                        alt162 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 162, 1, self.input)

                        raise nvae


                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 162, 0, self.input)

                    raise nvae


                if alt162 == 1:
                    # ./output/PLSQL3.g:630:4: ( keyINNER )? keyJOIN table_name ( 'ON' sql_condition | keyUSING LPAREN column_specs RPAREN )
                    pass
                    root_0 = self._adaptor.nil()


                    # ./output/PLSQL3.g:630:4: ( keyINNER )?
                    alt159 = 2
                    LA159_0 = self.input.LA(1)

                    if (LA159_0 == ID) :
                        LA159_1 = self.input.LA(2)

                        if (LA159_1 == ID) :
                            LA159_2 = self.input.LA(3)

                            if (LA159_2 == ID) :
                                LA159_4 = self.input.LA(4)

                                if (LA159_4 == ID or LA159_4 == 126) :
                                    alt159 = 1
                            elif (LA159_2 == DOUBLEQUOTED_STRING or LA159_2 == 144) :
                                alt159 = 1
                    if alt159 == 1:
                        # ./output/PLSQL3.g:630:6: keyINNER
                        pass
                        self._state.following.append(self.FOLLOW_keyINNER_in_inner_cross_join_clause3725)
                        keyINNER624 = self.keyINNER()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyINNER624.tree)





                    self._state.following.append(self.FOLLOW_keyJOIN_in_inner_cross_join_clause3730)
                    keyJOIN625 = self.keyJOIN()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyJOIN625.tree)


                    self._state.following.append(self.FOLLOW_table_name_in_inner_cross_join_clause3732)
                    table_name626 = self.table_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, table_name626.tree)


                    # ./output/PLSQL3.g:630:37: ( 'ON' sql_condition | keyUSING LPAREN column_specs RPAREN )
                    alt160 = 2
                    LA160_0 = self.input.LA(1)

                    if (LA160_0 == 126) :
                        alt160 = 1
                    elif (LA160_0 == ID) :
                        alt160 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 160, 0, self.input)

                        raise nvae


                    if alt160 == 1:
                        # ./output/PLSQL3.g:630:39: 'ON' sql_condition
                        pass
                        string_literal627 = self.match(self.input, 126, self.FOLLOW_126_in_inner_cross_join_clause3736)
                        if self._state.backtracking == 0:
                            string_literal627_tree = self._adaptor.createWithPayload(string_literal627)
                            self._adaptor.addChild(root_0, string_literal627_tree)



                        self._state.following.append(self.FOLLOW_sql_condition_in_inner_cross_join_clause3738)
                        sql_condition628 = self.sql_condition()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, sql_condition628.tree)



                    elif alt160 == 2:
                        # ./output/PLSQL3.g:630:60: keyUSING LPAREN column_specs RPAREN
                        pass
                        self._state.following.append(self.FOLLOW_keyUSING_in_inner_cross_join_clause3742)
                        keyUSING629 = self.keyUSING()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyUSING629.tree)


                        LPAREN630 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_inner_cross_join_clause3744)
                        if self._state.backtracking == 0:
                            LPAREN630_tree = self._adaptor.createWithPayload(LPAREN630)
                            self._adaptor.addChild(root_0, LPAREN630_tree)



                        self._state.following.append(self.FOLLOW_column_specs_in_inner_cross_join_clause3746)
                        column_specs631 = self.column_specs()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, column_specs631.tree)


                        RPAREN632 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_inner_cross_join_clause3748)
                        if self._state.backtracking == 0:
                            RPAREN632_tree = self._adaptor.createWithPayload(RPAREN632)
                            self._adaptor.addChild(root_0, RPAREN632_tree)







                elif alt162 == 2:
                    # ./output/PLSQL3.g:631:4: ( keyCROSS | keyNATURAL ( keyINNER ) ) keyJOIN table_name
                    pass
                    root_0 = self._adaptor.nil()


                    # ./output/PLSQL3.g:631:4: ( keyCROSS | keyNATURAL ( keyINNER ) )
                    alt161 = 2
                    LA161_0 = self.input.LA(1)

                    if (LA161_0 == ID) :
                        LA161_1 = self.input.LA(2)

                        if (LA161_1 == ID) :
                            LA161_2 = self.input.LA(3)

                            if (LA161_2 == ID) :
                                LA161 = self.input.LA(4)
                                if LA161 == EOF or LA161 == ASTERISK or LA161 == BULK_ROWCOUNT_ATTR or LA161 == COMMA or LA161 == DIVIDE or LA161 == DOUBLEDOT or LA161 == DOUBLEVERTBAR or LA161 == EQ or LA161 == EXPONENT or LA161 == FOUND_ATTR or LA161 == GEQ or LA161 == GTH or LA161 == ISOPEN_ATTR or LA161 == LEQ or LA161 == LPAREN or LA161 == LTH or LA161 == MINUS or LA161 == NOTFOUND_ATTR or LA161 == NOT_EQ or LA161 == NUMBER or LA161 == PLUS or LA161 == QUOTED_STRING or LA161 == RBRACK or LA161 == ROWCOUNT_ATTR or LA161 == RPAREN or LA161 == SEMI or LA161 == 51 or LA161 == 52 or LA161 == 53 or LA161 == 54 or LA161 == 55 or LA161 == 57 or LA161 == 65 or LA161 == 71 or LA161 == 80 or LA161 == 81 or LA161 == 83 or LA161 == 85 or LA161 == 88 or LA161 == 89 or LA161 == 93 or LA161 == 96 or LA161 == 97 or LA161 == 99 or LA161 == 104 or LA161 == 105 or LA161 == 106 or LA161 == 107 or LA161 == 110 or LA161 == 111 or LA161 == 118 or LA161 == 120 or LA161 == 126 or LA161 == 127 or LA161 == 128 or LA161 == 134 or LA161 == 140 or LA161 == 141 or LA161 == 147 or LA161 == 151 or LA161 == 152 or LA161 == 154 or LA161 == 156 or LA161 == 157 or LA161 == 164 or LA161 == 165:
                                    alt161 = 1
                                elif LA161 == ID:
                                    LA161_5 = self.input.LA(5)

                                    if (((((self.synpred284_PLSQL3()) and (self.synpred284_PLSQL3()))) and (((self.input).LT(1).text.upper() == "CROSS")))) :
                                        alt161 = 1
                                    elif (((self.input).LT(1).text.upper() == "NATURAL")) :
                                        alt161 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 161, 5, self.input)

                                        raise nvae


                                elif LA161 == DOUBLEQUOTED_STRING:
                                    LA161_6 = self.input.LA(5)

                                    if (((((self.synpred284_PLSQL3()) and (self.synpred284_PLSQL3()))) and (((self.input).LT(1).text.upper() == "CROSS")))) :
                                        alt161 = 1
                                    elif (((self.input).LT(1).text.upper() == "NATURAL")) :
                                        alt161 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 161, 6, self.input)

                                        raise nvae


                                elif LA161 == 144:
                                    LA161_7 = self.input.LA(5)

                                    if (((((self.synpred284_PLSQL3()) and (self.synpred284_PLSQL3()))) and (((self.input).LT(1).text.upper() == "CROSS")))) :
                                        alt161 = 1
                                    elif (((self.input).LT(1).text.upper() == "NATURAL")) :
                                        alt161 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 161, 7, self.input)

                                        raise nvae


                                else:
                                    if self._state.backtracking > 0:
                                        raise BacktrackingFailed


                                    nvae = NoViableAltException("", 161, 3, self.input)

                                    raise nvae


                            elif (LA161_2 == DOUBLEQUOTED_STRING or LA161_2 == 144) :
                                alt161 = 1
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 161, 2, self.input)

                                raise nvae


                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 161, 1, self.input)

                            raise nvae


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 161, 0, self.input)

                        raise nvae


                    if alt161 == 1:
                        # ./output/PLSQL3.g:631:6: keyCROSS
                        pass
                        self._state.following.append(self.FOLLOW_keyCROSS_in_inner_cross_join_clause3757)
                        keyCROSS633 = self.keyCROSS()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyCROSS633.tree)



                    elif alt161 == 2:
                        # ./output/PLSQL3.g:631:17: keyNATURAL ( keyINNER )
                        pass
                        self._state.following.append(self.FOLLOW_keyNATURAL_in_inner_cross_join_clause3761)
                        keyNATURAL634 = self.keyNATURAL()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyNATURAL634.tree)


                        # ./output/PLSQL3.g:631:28: ( keyINNER )
                        # ./output/PLSQL3.g:631:30: keyINNER
                        pass
                        self._state.following.append(self.FOLLOW_keyINNER_in_inner_cross_join_clause3765)
                        keyINNER635 = self.keyINNER()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyINNER635.tree)








                    self._state.following.append(self.FOLLOW_keyJOIN_in_inner_cross_join_clause3771)
                    keyJOIN636 = self.keyJOIN()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyJOIN636.tree)


                    self._state.following.append(self.FOLLOW_table_name_in_inner_cross_join_clause3773)
                    table_name637 = self.table_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, table_name637.tree)



                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 92, inner_cross_join_clause_StartIndex, success)


            pass
        return retval

    # $ANTLR end "inner_cross_join_clause"


    class outer_join_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.outer_join_clause_return, self).__init__()

            self.tree = None





    # $ANTLR start "outer_join_clause"
    # ./output/PLSQL3.g:633:1: outer_join_clause : ( query_partition_clause )? ( outer_join_type keyJOIN | keyNATURAL ( outer_join_type )? keyJOIN ) selected_table ( query_partition_clause )? ( 'ON' sql_condition | keyUSING LPAREN column_specs RPAREN )? ;
    def outer_join_clause(self, ):
        retval = self.outer_join_clause_return()
        retval.start = self.input.LT(1)

        outer_join_clause_StartIndex = self.input.index()

        root_0 = None

        string_literal646 = None
        LPAREN649 = None
        RPAREN651 = None
        query_partition_clause638 = None

        outer_join_type639 = None

        keyJOIN640 = None

        keyNATURAL641 = None

        outer_join_type642 = None

        keyJOIN643 = None

        selected_table644 = None

        query_partition_clause645 = None

        sql_condition647 = None

        keyUSING648 = None

        column_specs650 = None


        string_literal646_tree = None
        LPAREN649_tree = None
        RPAREN651_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 93):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:634:2: ( ( query_partition_clause )? ( outer_join_type keyJOIN | keyNATURAL ( outer_join_type )? keyJOIN ) selected_table ( query_partition_clause )? ( 'ON' sql_condition | keyUSING LPAREN column_specs RPAREN )? )
                # ./output/PLSQL3.g:634:4: ( query_partition_clause )? ( outer_join_type keyJOIN | keyNATURAL ( outer_join_type )? keyJOIN ) selected_table ( query_partition_clause )? ( 'ON' sql_condition | keyUSING LPAREN column_specs RPAREN )?
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:634:4: ( query_partition_clause )?
                alt163 = 2
                LA163_0 = self.input.LA(1)

                if (LA163_0 == ID) :
                    LA163_1 = self.input.LA(2)

                    if (LA163_1 == 64) :
                        alt163 = 1
                if alt163 == 1:
                    # ./output/PLSQL3.g:634:6: query_partition_clause
                    pass
                    self._state.following.append(self.FOLLOW_query_partition_clause_in_outer_join_clause3785)
                    query_partition_clause638 = self.query_partition_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, query_partition_clause638.tree)





                # ./output/PLSQL3.g:635:3: ( outer_join_type keyJOIN | keyNATURAL ( outer_join_type )? keyJOIN )
                alt165 = 2
                LA165_0 = self.input.LA(1)

                if (LA165_0 == ID) :
                    LA165_1 = self.input.LA(2)

                    if (LA165_1 == ID) :
                        LA165_2 = self.input.LA(3)

                        if (((((self.synpred286_PLSQL3()) and (self.synpred286_PLSQL3()))) and ((((self.input).LT(1).text.upper() == "FULL") or ((this.input).LT(1).text.upper() == "RIGHT") or ((this.input).LT(1).text.upper() == "LEFT"))))) :
                            alt165 = 1
                        elif (((self.input).LT(1).text.upper() == "NATURAL")) :
                            alt165 = 2
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 165, 2, self.input)

                            raise nvae


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 165, 1, self.input)

                        raise nvae


                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 165, 0, self.input)

                    raise nvae


                if alt165 == 1:
                    # ./output/PLSQL3.g:635:5: outer_join_type keyJOIN
                    pass
                    self._state.following.append(self.FOLLOW_outer_join_type_in_outer_join_clause3794)
                    outer_join_type639 = self.outer_join_type()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, outer_join_type639.tree)


                    self._state.following.append(self.FOLLOW_keyJOIN_in_outer_join_clause3796)
                    keyJOIN640 = self.keyJOIN()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyJOIN640.tree)



                elif alt165 == 2:
                    # ./output/PLSQL3.g:636:5: keyNATURAL ( outer_join_type )? keyJOIN
                    pass
                    self._state.following.append(self.FOLLOW_keyNATURAL_in_outer_join_clause3802)
                    keyNATURAL641 = self.keyNATURAL()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyNATURAL641.tree)


                    # ./output/PLSQL3.g:636:16: ( outer_join_type )?
                    alt164 = 2
                    LA164_0 = self.input.LA(1)

                    if (LA164_0 == ID) :
                        LA164_1 = self.input.LA(2)

                        if (LA164_1 == ID) :
                            LA164_2 = self.input.LA(3)

                            if (((((self.synpred287_PLSQL3()) and (self.synpred287_PLSQL3()))) and ((((self.input).LT(1).text.upper() == "FULL") or ((this.input).LT(1).text.upper() == "RIGHT") or ((this.input).LT(1).text.upper() == "LEFT"))))) :
                                alt164 = 1
                    if alt164 == 1:
                        # ./output/PLSQL3.g:636:18: outer_join_type
                        pass
                        self._state.following.append(self.FOLLOW_outer_join_type_in_outer_join_clause3806)
                        outer_join_type642 = self.outer_join_type()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, outer_join_type642.tree)





                    self._state.following.append(self.FOLLOW_keyJOIN_in_outer_join_clause3811)
                    keyJOIN643 = self.keyJOIN()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyJOIN643.tree)





                self._state.following.append(self.FOLLOW_selected_table_in_outer_join_clause3819)
                selected_table644 = self.selected_table()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, selected_table644.tree)


                # ./output/PLSQL3.g:638:18: ( query_partition_clause )?
                alt166 = 2
                alt166 = self.dfa166.predict(self.input)
                if alt166 == 1:
                    # ./output/PLSQL3.g:638:20: query_partition_clause
                    pass
                    self._state.following.append(self.FOLLOW_query_partition_clause_in_outer_join_clause3823)
                    query_partition_clause645 = self.query_partition_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, query_partition_clause645.tree)





                # ./output/PLSQL3.g:639:3: ( 'ON' sql_condition | keyUSING LPAREN column_specs RPAREN )?
                alt167 = 3
                LA167_0 = self.input.LA(1)

                if (LA167_0 == 126) :
                    LA167_1 = self.input.LA(2)

                    if (self.synpred289_PLSQL3()) :
                        alt167 = 1
                elif (LA167_0 == ID) :
                    LA167_2 = self.input.LA(2)

                    if (((((((self.input).LT(1).text.upper() == "USING")) and (((this.input).LT(1).text.upper() == "USING")))) and (self.synpred290_PLSQL3()))) :
                        alt167 = 2
                if alt167 == 1:
                    # ./output/PLSQL3.g:639:5: 'ON' sql_condition
                    pass
                    string_literal646 = self.match(self.input, 126, self.FOLLOW_126_in_outer_join_clause3832)
                    if self._state.backtracking == 0:
                        string_literal646_tree = self._adaptor.createWithPayload(string_literal646)
                        self._adaptor.addChild(root_0, string_literal646_tree)



                    self._state.following.append(self.FOLLOW_sql_condition_in_outer_join_clause3834)
                    sql_condition647 = self.sql_condition()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_condition647.tree)



                elif alt167 == 2:
                    # ./output/PLSQL3.g:639:26: keyUSING LPAREN column_specs RPAREN
                    pass
                    self._state.following.append(self.FOLLOW_keyUSING_in_outer_join_clause3838)
                    keyUSING648 = self.keyUSING()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyUSING648.tree)


                    LPAREN649 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_outer_join_clause3840)
                    if self._state.backtracking == 0:
                        LPAREN649_tree = self._adaptor.createWithPayload(LPAREN649)
                        self._adaptor.addChild(root_0, LPAREN649_tree)



                    self._state.following.append(self.FOLLOW_column_specs_in_outer_join_clause3842)
                    column_specs650 = self.column_specs()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, column_specs650.tree)


                    RPAREN651 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_outer_join_clause3844)
                    if self._state.backtracking == 0:
                        RPAREN651_tree = self._adaptor.createWithPayload(RPAREN651)
                        self._adaptor.addChild(root_0, RPAREN651_tree)








                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 93, outer_join_clause_StartIndex, success)


            pass
        return retval

    # $ANTLR end "outer_join_clause"


    class query_partition_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.query_partition_clause_return, self).__init__()

            self.tree = None





    # $ANTLR start "query_partition_clause"
    # ./output/PLSQL3.g:641:1: query_partition_clause : keyPARTITION 'BY' expression_list ;
    def query_partition_clause(self, ):
        retval = self.query_partition_clause_return()
        retval.start = self.input.LT(1)

        query_partition_clause_StartIndex = self.input.index()

        root_0 = None

        string_literal653 = None
        keyPARTITION652 = None

        expression_list654 = None


        string_literal653_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 94):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:642:2: ( keyPARTITION 'BY' expression_list )
                # ./output/PLSQL3.g:642:4: keyPARTITION 'BY' expression_list
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyPARTITION_in_query_partition_clause3857)
                keyPARTITION652 = self.keyPARTITION()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyPARTITION652.tree)


                string_literal653 = self.match(self.input, 64, self.FOLLOW_64_in_query_partition_clause3859)
                if self._state.backtracking == 0:
                    string_literal653_tree = self._adaptor.createWithPayload(string_literal653)
                    self._adaptor.addChild(root_0, string_literal653_tree)



                self._state.following.append(self.FOLLOW_expression_list_in_query_partition_clause3861)
                expression_list654 = self.expression_list()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, expression_list654.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 94, query_partition_clause_StartIndex, success)


            pass
        return retval

    # $ANTLR end "query_partition_clause"


    class outer_join_type_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.outer_join_type_return, self).__init__()

            self.tree = None





    # $ANTLR start "outer_join_type"
    # ./output/PLSQL3.g:644:1: outer_join_type : ( keyFULL | keyLEFT | keyRIGHT ) ( keyOUTER )? ;
    def outer_join_type(self, ):
        retval = self.outer_join_type_return()
        retval.start = self.input.LT(1)

        outer_join_type_StartIndex = self.input.index()

        root_0 = None

        keyFULL655 = None

        keyLEFT656 = None

        keyRIGHT657 = None

        keyOUTER658 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 95):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:645:2: ( ( keyFULL | keyLEFT | keyRIGHT ) ( keyOUTER )? )
                # ./output/PLSQL3.g:645:4: ( keyFULL | keyLEFT | keyRIGHT ) ( keyOUTER )?
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:645:4: ( keyFULL | keyLEFT | keyRIGHT )
                alt168 = 3
                LA168_0 = self.input.LA(1)

                if (LA168_0 == ID) :
                    LA168_1 = self.input.LA(2)

                    if (((((self.synpred291_PLSQL3()) and (self.synpred291_PLSQL3()))) and (((self.input).LT(1).text.upper() == "FULL")))) :
                        alt168 = 1
                    elif (((((self.synpred292_PLSQL3()) and (self.synpred292_PLSQL3()))) and (((self.input).LT(1).text.upper() == "LEFT")))) :
                        alt168 = 2
                    elif (((self.input).LT(1).text.upper() == "RIGHT")) :
                        alt168 = 3
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 168, 1, self.input)

                        raise nvae


                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 168, 0, self.input)

                    raise nvae


                if alt168 == 1:
                    # ./output/PLSQL3.g:645:6: keyFULL
                    pass
                    self._state.following.append(self.FOLLOW_keyFULL_in_outer_join_type3873)
                    keyFULL655 = self.keyFULL()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyFULL655.tree)



                elif alt168 == 2:
                    # ./output/PLSQL3.g:645:16: keyLEFT
                    pass
                    self._state.following.append(self.FOLLOW_keyLEFT_in_outer_join_type3877)
                    keyLEFT656 = self.keyLEFT()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyLEFT656.tree)



                elif alt168 == 3:
                    # ./output/PLSQL3.g:645:26: keyRIGHT
                    pass
                    self._state.following.append(self.FOLLOW_keyRIGHT_in_outer_join_type3881)
                    keyRIGHT657 = self.keyRIGHT()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyRIGHT657.tree)





                # ./output/PLSQL3.g:645:37: ( keyOUTER )?
                alt169 = 2
                LA169_0 = self.input.LA(1)

                if (LA169_0 == ID) :
                    LA169_1 = self.input.LA(2)

                    if (LA169_1 == ID) :
                        LA169_3 = self.input.LA(3)

                        if (((((self.synpred293_PLSQL3()) and (self.synpred293_PLSQL3()))) and (((self.input).LT(1).text.upper() == "OUTER")))) :
                            alt169 = 1
                    elif (LA169_1 == EOF) :
                        alt169 = 1
                if alt169 == 1:
                    # ./output/PLSQL3.g:645:39: keyOUTER
                    pass
                    self._state.following.append(self.FOLLOW_keyOUTER_in_outer_join_type3887)
                    keyOUTER658 = self.keyOUTER()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyOUTER658.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 95, outer_join_type_StartIndex, success)


            pass
        return retval

    # $ANTLR end "outer_join_type"


    class outer_join_sign_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.outer_join_sign_return, self).__init__()

            self.tree = None





    # $ANTLR start "outer_join_sign"
    # ./output/PLSQL3.g:647:1: outer_join_sign : LPAREN PLUS RPAREN ;
    def outer_join_sign(self, ):
        retval = self.outer_join_sign_return()
        retval.start = self.input.LT(1)

        outer_join_sign_StartIndex = self.input.index()

        root_0 = None

        LPAREN659 = None
        PLUS660 = None
        RPAREN661 = None

        LPAREN659_tree = None
        PLUS660_tree = None
        RPAREN661_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 96):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:648:2: ( LPAREN PLUS RPAREN )
                # ./output/PLSQL3.g:648:4: LPAREN PLUS RPAREN
                pass
                root_0 = self._adaptor.nil()


                LPAREN659 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_outer_join_sign3900)
                if self._state.backtracking == 0:
                    LPAREN659_tree = self._adaptor.createWithPayload(LPAREN659)
                    self._adaptor.addChild(root_0, LPAREN659_tree)



                PLUS660 = self.match(self.input, PLUS, self.FOLLOW_PLUS_in_outer_join_sign3902)
                if self._state.backtracking == 0:
                    PLUS660_tree = self._adaptor.createWithPayload(PLUS660)
                    self._adaptor.addChild(root_0, PLUS660_tree)



                RPAREN661 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_outer_join_sign3904)
                if self._state.backtracking == 0:
                    RPAREN661_tree = self._adaptor.createWithPayload(RPAREN661)
                    self._adaptor.addChild(root_0, RPAREN661_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 96, outer_join_sign_StartIndex, success)


            pass
        return retval

    # $ANTLR end "outer_join_sign"


    class where_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.where_clause_return, self).__init__()

            self.tree = None





    # $ANTLR start "where_clause"
    # ./output/PLSQL3.g:650:1: where_clause : 'WHERE' sql_condition ;
    def where_clause(self, ):
        retval = self.where_clause_return()
        retval.start = self.input.LT(1)

        where_clause_StartIndex = self.input.index()

        root_0 = None

        string_literal662 = None
        sql_condition663 = None


        string_literal662_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 97):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:651:2: ( 'WHERE' sql_condition )
                # ./output/PLSQL3.g:651:4: 'WHERE' sql_condition
                pass
                root_0 = self._adaptor.nil()


                string_literal662 = self.match(self.input, 165, self.FOLLOW_165_in_where_clause3914)
                if self._state.backtracking == 0:
                    string_literal662_tree = self._adaptor.createWithPayload(string_literal662)
                    self._adaptor.addChild(root_0, string_literal662_tree)



                self._state.following.append(self.FOLLOW_sql_condition_in_where_clause3916)
                sql_condition663 = self.sql_condition()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_condition663.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 97, where_clause_StartIndex, success)


            pass
        return retval

    # $ANTLR end "where_clause"


    class hierarchical_query_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.hierarchical_query_clause_return, self).__init__()

            self.tree = None





    # $ANTLR start "hierarchical_query_clause"
    # ./output/PLSQL3.g:653:1: hierarchical_query_clause : ( 'START' 'WITH' sql_condition )? 'CONNECT' 'BY' ( keyNOCYCLE )? sql_condition ;
    def hierarchical_query_clause(self, ):
        retval = self.hierarchical_query_clause_return()
        retval.start = self.input.LT(1)

        hierarchical_query_clause_StartIndex = self.input.index()

        root_0 = None

        string_literal664 = None
        string_literal665 = None
        string_literal667 = None
        string_literal668 = None
        sql_condition666 = None

        keyNOCYCLE669 = None

        sql_condition670 = None


        string_literal664_tree = None
        string_literal665_tree = None
        string_literal667_tree = None
        string_literal668_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 98):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:654:2: ( ( 'START' 'WITH' sql_condition )? 'CONNECT' 'BY' ( keyNOCYCLE )? sql_condition )
                # ./output/PLSQL3.g:654:4: ( 'START' 'WITH' sql_condition )? 'CONNECT' 'BY' ( keyNOCYCLE )? sql_condition
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:654:4: ( 'START' 'WITH' sql_condition )?
                alt170 = 2
                LA170_0 = self.input.LA(1)

                if (LA170_0 == 152) :
                    alt170 = 1
                if alt170 == 1:
                    # ./output/PLSQL3.g:654:6: 'START' 'WITH' sql_condition
                    pass
                    string_literal664 = self.match(self.input, 152, self.FOLLOW_152_in_hierarchical_query_clause3928)
                    if self._state.backtracking == 0:
                        string_literal664_tree = self._adaptor.createWithPayload(string_literal664)
                        self._adaptor.addChild(root_0, string_literal664_tree)



                    string_literal665 = self.match(self.input, 167, self.FOLLOW_167_in_hierarchical_query_clause3930)
                    if self._state.backtracking == 0:
                        string_literal665_tree = self._adaptor.createWithPayload(string_literal665)
                        self._adaptor.addChild(root_0, string_literal665_tree)



                    self._state.following.append(self.FOLLOW_sql_condition_in_hierarchical_query_clause3932)
                    sql_condition666 = self.sql_condition()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_condition666.tree)





                string_literal667 = self.match(self.input, 71, self.FOLLOW_71_in_hierarchical_query_clause3937)
                if self._state.backtracking == 0:
                    string_literal667_tree = self._adaptor.createWithPayload(string_literal667)
                    self._adaptor.addChild(root_0, string_literal667_tree)



                string_literal668 = self.match(self.input, 64, self.FOLLOW_64_in_hierarchical_query_clause3939)
                if self._state.backtracking == 0:
                    string_literal668_tree = self._adaptor.createWithPayload(string_literal668)
                    self._adaptor.addChild(root_0, string_literal668_tree)



                # ./output/PLSQL3.g:654:53: ( keyNOCYCLE )?
                alt171 = 2
                LA171_0 = self.input.LA(1)

                if (LA171_0 == ID) :
                    LA171_1 = self.input.LA(2)

                    if (((((self.synpred295_PLSQL3()) and (self.synpred295_PLSQL3()))) and (((self.input).LT(1).text.upper() == "NOCYCLE")))) :
                        alt171 = 1
                if alt171 == 1:
                    # ./output/PLSQL3.g:654:55: keyNOCYCLE
                    pass
                    self._state.following.append(self.FOLLOW_keyNOCYCLE_in_hierarchical_query_clause3943)
                    keyNOCYCLE669 = self.keyNOCYCLE()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyNOCYCLE669.tree)





                self._state.following.append(self.FOLLOW_sql_condition_in_hierarchical_query_clause3948)
                sql_condition670 = self.sql_condition()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_condition670.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 98, hierarchical_query_clause_StartIndex, success)


            pass
        return retval

    # $ANTLR end "hierarchical_query_clause"


    class group_by_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.group_by_clause_return, self).__init__()

            self.tree = None





    # $ANTLR start "group_by_clause"
    # ./output/PLSQL3.g:656:1: group_by_clause : 'GROUP' 'BY' group_by_exprs ;
    def group_by_clause(self, ):
        retval = self.group_by_clause_return()
        retval.start = self.input.LT(1)

        group_by_clause_StartIndex = self.input.index()

        root_0 = None

        string_literal671 = None
        string_literal672 = None
        group_by_exprs673 = None


        string_literal671_tree = None
        string_literal672_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 99):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:657:2: ( 'GROUP' 'BY' group_by_exprs )
                # ./output/PLSQL3.g:657:4: 'GROUP' 'BY' group_by_exprs
                pass
                root_0 = self._adaptor.nil()


                string_literal671 = self.match(self.input, 96, self.FOLLOW_96_in_group_by_clause3958)
                if self._state.backtracking == 0:
                    string_literal671_tree = self._adaptor.createWithPayload(string_literal671)
                    self._adaptor.addChild(root_0, string_literal671_tree)



                string_literal672 = self.match(self.input, 64, self.FOLLOW_64_in_group_by_clause3960)
                if self._state.backtracking == 0:
                    string_literal672_tree = self._adaptor.createWithPayload(string_literal672)
                    self._adaptor.addChild(root_0, string_literal672_tree)



                self._state.following.append(self.FOLLOW_group_by_exprs_in_group_by_clause3962)
                group_by_exprs673 = self.group_by_exprs()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, group_by_exprs673.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 99, group_by_clause_StartIndex, success)


            pass
        return retval

    # $ANTLR end "group_by_clause"


    class group_by_exprs_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.group_by_exprs_return, self).__init__()

            self.tree = None





    # $ANTLR start "group_by_exprs"
    # ./output/PLSQL3.g:659:1: group_by_exprs : group_by_expr ( COMMA group_by_expr )* ;
    def group_by_exprs(self, ):
        retval = self.group_by_exprs_return()
        retval.start = self.input.LT(1)

        group_by_exprs_StartIndex = self.input.index()

        root_0 = None

        COMMA675 = None
        group_by_expr674 = None

        group_by_expr676 = None


        COMMA675_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 100):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:660:2: ( group_by_expr ( COMMA group_by_expr )* )
                # ./output/PLSQL3.g:660:4: group_by_expr ( COMMA group_by_expr )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_group_by_expr_in_group_by_exprs3972)
                group_by_expr674 = self.group_by_expr()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, group_by_expr674.tree)


                # ./output/PLSQL3.g:660:18: ( COMMA group_by_expr )*
                while True: #loop172
                    alt172 = 2
                    LA172_0 = self.input.LA(1)

                    if (LA172_0 == COMMA) :
                        LA172_2 = self.input.LA(2)

                        if (self.synpred296_PLSQL3()) :
                            alt172 = 1




                    if alt172 == 1:
                        # ./output/PLSQL3.g:660:20: COMMA group_by_expr
                        pass
                        COMMA675 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_group_by_exprs3976)
                        if self._state.backtracking == 0:
                            COMMA675_tree = self._adaptor.createWithPayload(COMMA675)
                            self._adaptor.addChild(root_0, COMMA675_tree)



                        self._state.following.append(self.FOLLOW_group_by_expr_in_group_by_exprs3978)
                        group_by_expr676 = self.group_by_expr()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, group_by_expr676.tree)



                    else:
                        break #loop172




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 100, group_by_exprs_StartIndex, success)


            pass
        return retval

    # $ANTLR end "group_by_exprs"


    class group_by_expr_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.group_by_expr_return, self).__init__()

            self.tree = None





    # $ANTLR start "group_by_expr"
    # ./output/PLSQL3.g:662:1: group_by_expr : ( rollup_cube_clause | grouping_sets_clause | grouping_expression_list );
    def group_by_expr(self, ):
        retval = self.group_by_expr_return()
        retval.start = self.input.LT(1)

        group_by_expr_StartIndex = self.input.index()

        root_0 = None

        rollup_cube_clause677 = None

        grouping_sets_clause678 = None

        grouping_expression_list679 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 101):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:663:2: ( rollup_cube_clause | grouping_sets_clause | grouping_expression_list )
                alt173 = 3
                LA173_0 = self.input.LA(1)

                if (LA173_0 == ID) :
                    LA173_1 = self.input.LA(2)

                    if ((((((((self.input).LT(1).text.upper() == "CUBE") or ((this.input).LT(1).text.upper() == "ROLLUP"))) and ((((this.input).LT(1).text.upper() == "CUBE") or ((this.input).LT(1).text.upper() == "ROLLUP"))))) and (self.synpred297_PLSQL3()))) :
                        alt173 = 1
                    elif (((((self.synpred298_PLSQL3()) and (self.synpred298_PLSQL3()))) and (((self.input).LT(1).text.upper() == "GROUPING")))) :
                        alt173 = 2
                    elif (True) :
                        alt173 = 3
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 173, 1, self.input)

                        raise nvae


                elif (LA173_0 == DOUBLEQUOTED_STRING or LA173_0 == LPAREN or LA173_0 == MINUS or LA173_0 == NUMBER or LA173_0 == PLUS or LA173_0 == QUOTED_STRING or LA173_0 == 65 or LA173_0 == 81 or LA173_0 == 89 or LA173_0 == 120 or LA173_0 == 144 or LA173_0 == 147 or LA173_0 == 151 or LA173_0 == 156) :
                    alt173 = 3
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 173, 0, self.input)

                    raise nvae


                if alt173 == 1:
                    # ./output/PLSQL3.g:663:4: rollup_cube_clause
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_rollup_cube_clause_in_group_by_expr3991)
                    rollup_cube_clause677 = self.rollup_cube_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, rollup_cube_clause677.tree)



                elif alt173 == 2:
                    # ./output/PLSQL3.g:664:4: grouping_sets_clause
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_grouping_sets_clause_in_group_by_expr3996)
                    grouping_sets_clause678 = self.grouping_sets_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, grouping_sets_clause678.tree)



                elif alt173 == 3:
                    # ./output/PLSQL3.g:665:4: grouping_expression_list
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_grouping_expression_list_in_group_by_expr4001)
                    grouping_expression_list679 = self.grouping_expression_list()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, grouping_expression_list679.tree)



                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 101, group_by_expr_StartIndex, success)


            pass
        return retval

    # $ANTLR end "group_by_expr"


    class rollup_cube_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.rollup_cube_clause_return, self).__init__()

            self.tree = None





    # $ANTLR start "rollup_cube_clause"
    # ./output/PLSQL3.g:667:1: rollup_cube_clause : ( keyROLLUP | keyCUBE ) LPAREN grouping_expression_list RPAREN ;
    def rollup_cube_clause(self, ):
        retval = self.rollup_cube_clause_return()
        retval.start = self.input.LT(1)

        rollup_cube_clause_StartIndex = self.input.index()

        root_0 = None

        LPAREN682 = None
        RPAREN684 = None
        keyROLLUP680 = None

        keyCUBE681 = None

        grouping_expression_list683 = None


        LPAREN682_tree = None
        RPAREN684_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 102):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:668:2: ( ( keyROLLUP | keyCUBE ) LPAREN grouping_expression_list RPAREN )
                # ./output/PLSQL3.g:668:4: ( keyROLLUP | keyCUBE ) LPAREN grouping_expression_list RPAREN
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:668:4: ( keyROLLUP | keyCUBE )
                alt174 = 2
                LA174_0 = self.input.LA(1)

                if (LA174_0 == ID) :
                    LA174_1 = self.input.LA(2)

                    if (((((((self.input).LT(1).text.upper() == "ROLLUP")) and (((this.input).LT(1).text.upper() == "ROLLUP")))) and (self.synpred299_PLSQL3()))) :
                        alt174 = 1
                    elif (((self.input).LT(1).text.upper() == "CUBE")) :
                        alt174 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 174, 1, self.input)

                        raise nvae


                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 174, 0, self.input)

                    raise nvae


                if alt174 == 1:
                    # ./output/PLSQL3.g:668:6: keyROLLUP
                    pass
                    self._state.following.append(self.FOLLOW_keyROLLUP_in_rollup_cube_clause4013)
                    keyROLLUP680 = self.keyROLLUP()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyROLLUP680.tree)



                elif alt174 == 2:
                    # ./output/PLSQL3.g:668:18: keyCUBE
                    pass
                    self._state.following.append(self.FOLLOW_keyCUBE_in_rollup_cube_clause4017)
                    keyCUBE681 = self.keyCUBE()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyCUBE681.tree)





                LPAREN682 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_rollup_cube_clause4021)
                if self._state.backtracking == 0:
                    LPAREN682_tree = self._adaptor.createWithPayload(LPAREN682)
                    self._adaptor.addChild(root_0, LPAREN682_tree)



                self._state.following.append(self.FOLLOW_grouping_expression_list_in_rollup_cube_clause4023)
                grouping_expression_list683 = self.grouping_expression_list()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, grouping_expression_list683.tree)


                RPAREN684 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_rollup_cube_clause4025)
                if self._state.backtracking == 0:
                    RPAREN684_tree = self._adaptor.createWithPayload(RPAREN684)
                    self._adaptor.addChild(root_0, RPAREN684_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 102, rollup_cube_clause_StartIndex, success)


            pass
        return retval

    # $ANTLR end "rollup_cube_clause"


    class grouping_sets_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.grouping_sets_clause_return, self).__init__()

            self.tree = None





    # $ANTLR start "grouping_sets_clause"
    # ./output/PLSQL3.g:670:1: grouping_sets_clause : keyGROUPING keySETS LPAREN grouping_expression_list RPAREN ;
    def grouping_sets_clause(self, ):
        retval = self.grouping_sets_clause_return()
        retval.start = self.input.LT(1)

        grouping_sets_clause_StartIndex = self.input.index()

        root_0 = None

        LPAREN687 = None
        RPAREN689 = None
        keyGROUPING685 = None

        keySETS686 = None

        grouping_expression_list688 = None


        LPAREN687_tree = None
        RPAREN689_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 103):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:671:2: ( keyGROUPING keySETS LPAREN grouping_expression_list RPAREN )
                # ./output/PLSQL3.g:671:4: keyGROUPING keySETS LPAREN grouping_expression_list RPAREN
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyGROUPING_in_grouping_sets_clause4035)
                keyGROUPING685 = self.keyGROUPING()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyGROUPING685.tree)


                self._state.following.append(self.FOLLOW_keySETS_in_grouping_sets_clause4037)
                keySETS686 = self.keySETS()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keySETS686.tree)


                LPAREN687 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_grouping_sets_clause4039)
                if self._state.backtracking == 0:
                    LPAREN687_tree = self._adaptor.createWithPayload(LPAREN687)
                    self._adaptor.addChild(root_0, LPAREN687_tree)



                self._state.following.append(self.FOLLOW_grouping_expression_list_in_grouping_sets_clause4041)
                grouping_expression_list688 = self.grouping_expression_list()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, grouping_expression_list688.tree)


                RPAREN689 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_grouping_sets_clause4043)
                if self._state.backtracking == 0:
                    RPAREN689_tree = self._adaptor.createWithPayload(RPAREN689)
                    self._adaptor.addChild(root_0, RPAREN689_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 103, grouping_sets_clause_StartIndex, success)


            pass
        return retval

    # $ANTLR end "grouping_sets_clause"


    class grouping_sets_exprs_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.grouping_sets_exprs_return, self).__init__()

            self.tree = None





    # $ANTLR start "grouping_sets_exprs"
    # ./output/PLSQL3.g:673:1: grouping_sets_exprs : grouping_sets_expr ( COMMA grouping_sets_expr )* ;
    def grouping_sets_exprs(self, ):
        retval = self.grouping_sets_exprs_return()
        retval.start = self.input.LT(1)

        grouping_sets_exprs_StartIndex = self.input.index()

        root_0 = None

        COMMA691 = None
        grouping_sets_expr690 = None

        grouping_sets_expr692 = None


        COMMA691_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 104):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:674:2: ( grouping_sets_expr ( COMMA grouping_sets_expr )* )
                # ./output/PLSQL3.g:674:4: grouping_sets_expr ( COMMA grouping_sets_expr )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_grouping_sets_expr_in_grouping_sets_exprs4053)
                grouping_sets_expr690 = self.grouping_sets_expr()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, grouping_sets_expr690.tree)


                # ./output/PLSQL3.g:674:23: ( COMMA grouping_sets_expr )*
                while True: #loop175
                    alt175 = 2
                    LA175_0 = self.input.LA(1)

                    if (LA175_0 == COMMA) :
                        alt175 = 1


                    if alt175 == 1:
                        # ./output/PLSQL3.g:674:25: COMMA grouping_sets_expr
                        pass
                        COMMA691 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_grouping_sets_exprs4057)
                        if self._state.backtracking == 0:
                            COMMA691_tree = self._adaptor.createWithPayload(COMMA691)
                            self._adaptor.addChild(root_0, COMMA691_tree)



                        self._state.following.append(self.FOLLOW_grouping_sets_expr_in_grouping_sets_exprs4059)
                        grouping_sets_expr692 = self.grouping_sets_expr()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, grouping_sets_expr692.tree)



                    else:
                        break #loop175




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 104, grouping_sets_exprs_StartIndex, success)


            pass
        return retval

    # $ANTLR end "grouping_sets_exprs"


    class grouping_sets_expr_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.grouping_sets_expr_return, self).__init__()

            self.tree = None





    # $ANTLR start "grouping_sets_expr"
    # ./output/PLSQL3.g:676:1: grouping_sets_expr : ( rollup_cube_clause | grouping_expression_list );
    def grouping_sets_expr(self, ):
        retval = self.grouping_sets_expr_return()
        retval.start = self.input.LT(1)

        grouping_sets_expr_StartIndex = self.input.index()

        root_0 = None

        rollup_cube_clause693 = None

        grouping_expression_list694 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 105):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:677:2: ( rollup_cube_clause | grouping_expression_list )
                alt176 = 2
                LA176_0 = self.input.LA(1)

                if (LA176_0 == ID) :
                    LA176_1 = self.input.LA(2)

                    if ((((((((self.input).LT(1).text.upper() == "CUBE") or ((this.input).LT(1).text.upper() == "ROLLUP"))) and ((((this.input).LT(1).text.upper() == "CUBE") or ((this.input).LT(1).text.upper() == "ROLLUP"))))) and (self.synpred301_PLSQL3()))) :
                        alt176 = 1
                    elif (True) :
                        alt176 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 176, 1, self.input)

                        raise nvae


                elif (LA176_0 == DOUBLEQUOTED_STRING or LA176_0 == LPAREN or LA176_0 == MINUS or LA176_0 == NUMBER or LA176_0 == PLUS or LA176_0 == QUOTED_STRING or LA176_0 == 65 or LA176_0 == 81 or LA176_0 == 89 or LA176_0 == 120 or LA176_0 == 144 or LA176_0 == 147 or LA176_0 == 151 or LA176_0 == 156) :
                    alt176 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 176, 0, self.input)

                    raise nvae


                if alt176 == 1:
                    # ./output/PLSQL3.g:677:4: rollup_cube_clause
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_rollup_cube_clause_in_grouping_sets_expr4072)
                    rollup_cube_clause693 = self.rollup_cube_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, rollup_cube_clause693.tree)



                elif alt176 == 2:
                    # ./output/PLSQL3.g:677:25: grouping_expression_list
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_grouping_expression_list_in_grouping_sets_expr4076)
                    grouping_expression_list694 = self.grouping_expression_list()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, grouping_expression_list694.tree)



                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 105, grouping_sets_expr_StartIndex, success)


            pass
        return retval

    # $ANTLR end "grouping_sets_expr"


    class model_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.model_clause_return, self).__init__()

            self.tree = None





    # $ANTLR start "model_clause"
    # ./output/PLSQL3.g:679:1: model_clause : keyMODEL ( cell_reference_options ) ( return_rows_clause )? ( reference_model )+ main_model ;
    def model_clause(self, ):
        retval = self.model_clause_return()
        retval.start = self.input.LT(1)

        model_clause_StartIndex = self.input.index()

        root_0 = None

        keyMODEL695 = None

        cell_reference_options696 = None

        return_rows_clause697 = None

        reference_model698 = None

        main_model699 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 106):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:680:2: ( keyMODEL ( cell_reference_options ) ( return_rows_clause )? ( reference_model )+ main_model )
                # ./output/PLSQL3.g:680:4: keyMODEL ( cell_reference_options ) ( return_rows_clause )? ( reference_model )+ main_model
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyMODEL_in_model_clause4086)
                keyMODEL695 = self.keyMODEL()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyMODEL695.tree)


                # ./output/PLSQL3.g:680:13: ( cell_reference_options )
                # ./output/PLSQL3.g:680:15: cell_reference_options
                pass
                self._state.following.append(self.FOLLOW_cell_reference_options_in_model_clause4090)
                cell_reference_options696 = self.cell_reference_options()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, cell_reference_options696.tree)





                # ./output/PLSQL3.g:681:3: ( return_rows_clause )?
                alt177 = 2
                LA177_0 = self.input.LA(1)

                if (LA177_0 == 140) :
                    alt177 = 1
                if alt177 == 1:
                    # ./output/PLSQL3.g:681:5: return_rows_clause
                    pass
                    self._state.following.append(self.FOLLOW_return_rows_clause_in_model_clause4098)
                    return_rows_clause697 = self.return_rows_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, return_rows_clause697.tree)





                # ./output/PLSQL3.g:682:3: ( reference_model )+
                cnt178 = 0
                while True: #loop178
                    alt178 = 2
                    LA178_0 = self.input.LA(1)

                    if (LA178_0 == ID) :
                        LA178_1 = self.input.LA(2)

                        if (LA178_1 == DOUBLEQUOTED_STRING or LA178_1 == ID) :
                            LA178_2 = self.input.LA(3)

                            if (LA178_2 == 126) :
                                alt178 = 1






                    if alt178 == 1:
                        # ./output/PLSQL3.g:682:5: reference_model
                        pass
                        self._state.following.append(self.FOLLOW_reference_model_in_model_clause4107)
                        reference_model698 = self.reference_model()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, reference_model698.tree)



                    else:
                        if cnt178 >= 1:
                            break #loop178

                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        eee = EarlyExitException(178, self.input)
                        raise eee

                    cnt178 += 1


                self._state.following.append(self.FOLLOW_main_model_in_model_clause4112)
                main_model699 = self.main_model()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, main_model699.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 106, model_clause_StartIndex, success)


            pass
        return retval

    # $ANTLR end "model_clause"


    class cell_reference_options_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.cell_reference_options_return, self).__init__()

            self.tree = None





    # $ANTLR start "cell_reference_options"
    # ./output/PLSQL3.g:684:1: cell_reference_options : ( ( keyIGNORE | keyKEEP ) keyNAV )? ( 'UNIQUE' ( keyDIMENSION | keySINGLE keyREFERENCE ) )? ;
    def cell_reference_options(self, ):
        retval = self.cell_reference_options_return()
        retval.start = self.input.LT(1)

        cell_reference_options_StartIndex = self.input.index()

        root_0 = None

        string_literal703 = None
        keyIGNORE700 = None

        keyKEEP701 = None

        keyNAV702 = None

        keyDIMENSION704 = None

        keySINGLE705 = None

        keyREFERENCE706 = None


        string_literal703_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 107):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:685:2: ( ( ( keyIGNORE | keyKEEP ) keyNAV )? ( 'UNIQUE' ( keyDIMENSION | keySINGLE keyREFERENCE ) )? )
                # ./output/PLSQL3.g:685:4: ( ( keyIGNORE | keyKEEP ) keyNAV )? ( 'UNIQUE' ( keyDIMENSION | keySINGLE keyREFERENCE ) )?
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:685:4: ( ( keyIGNORE | keyKEEP ) keyNAV )?
                alt180 = 2
                LA180_0 = self.input.LA(1)

                if (LA180_0 == ID) :
                    LA180_1 = self.input.LA(2)

                    if (LA180_1 == ID) :
                        LA180_3 = self.input.LA(3)

                        if ((((((((self.input).LT(1).text.upper() == "KEEP") or ((this.input).LT(1).text.upper() == "IGNORE"))) and ((((this.input).LT(1).text.upper() == "KEEP") or ((this.input).LT(1).text.upper() == "IGNORE"))))) and (self.synpred305_PLSQL3()))) :
                            alt180 = 1
                if alt180 == 1:
                    # ./output/PLSQL3.g:685:6: ( keyIGNORE | keyKEEP ) keyNAV
                    pass
                    # ./output/PLSQL3.g:685:6: ( keyIGNORE | keyKEEP )
                    alt179 = 2
                    LA179_0 = self.input.LA(1)

                    if (LA179_0 == ID) :
                        LA179_1 = self.input.LA(2)

                        if (((((self.synpred304_PLSQL3()) and (self.synpred304_PLSQL3()))) and (((self.input).LT(1).text.upper() == "IGNORE")))) :
                            alt179 = 1
                        elif (((self.input).LT(1).text.upper() == "KEEP")) :
                            alt179 = 2
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 179, 1, self.input)

                            raise nvae


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 179, 0, self.input)

                        raise nvae


                    if alt179 == 1:
                        # ./output/PLSQL3.g:685:8: keyIGNORE
                        pass
                        self._state.following.append(self.FOLLOW_keyIGNORE_in_cell_reference_options4126)
                        keyIGNORE700 = self.keyIGNORE()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyIGNORE700.tree)



                    elif alt179 == 2:
                        # ./output/PLSQL3.g:685:20: keyKEEP
                        pass
                        self._state.following.append(self.FOLLOW_keyKEEP_in_cell_reference_options4130)
                        keyKEEP701 = self.keyKEEP()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyKEEP701.tree)





                    self._state.following.append(self.FOLLOW_keyNAV_in_cell_reference_options4134)
                    keyNAV702 = self.keyNAV()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyNAV702.tree)





                # ./output/PLSQL3.g:686:3: ( 'UNIQUE' ( keyDIMENSION | keySINGLE keyREFERENCE ) )?
                alt182 = 2
                LA182_0 = self.input.LA(1)

                if (LA182_0 == 158) :
                    alt182 = 1
                if alt182 == 1:
                    # ./output/PLSQL3.g:686:5: 'UNIQUE' ( keyDIMENSION | keySINGLE keyREFERENCE )
                    pass
                    string_literal703 = self.match(self.input, 158, self.FOLLOW_158_in_cell_reference_options4143)
                    if self._state.backtracking == 0:
                        string_literal703_tree = self._adaptor.createWithPayload(string_literal703)
                        self._adaptor.addChild(root_0, string_literal703_tree)



                    # ./output/PLSQL3.g:686:14: ( keyDIMENSION | keySINGLE keyREFERENCE )
                    alt181 = 2
                    LA181_0 = self.input.LA(1)

                    if (LA181_0 == ID) :
                        LA181_1 = self.input.LA(2)

                        if (LA181_1 == EOF or LA181_1 == LPAREN or LA181_1 == 140) :
                            alt181 = 1
                        elif (LA181_1 == ID) :
                            LA181_3 = self.input.LA(3)

                            if (((((self.synpred306_PLSQL3()) and (self.synpred306_PLSQL3()))) and (((self.input).LT(1).text.upper() == "DIMENSION")))) :
                                alt181 = 1
                            elif (((self.input).LT(1).text.upper() == "SINGLE")) :
                                alt181 = 2
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 181, 3, self.input)

                                raise nvae


                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 181, 1, self.input)

                            raise nvae


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 181, 0, self.input)

                        raise nvae


                    if alt181 == 1:
                        # ./output/PLSQL3.g:686:16: keyDIMENSION
                        pass
                        self._state.following.append(self.FOLLOW_keyDIMENSION_in_cell_reference_options4147)
                        keyDIMENSION704 = self.keyDIMENSION()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyDIMENSION704.tree)



                    elif alt181 == 2:
                        # ./output/PLSQL3.g:686:31: keySINGLE keyREFERENCE
                        pass
                        self._state.following.append(self.FOLLOW_keySINGLE_in_cell_reference_options4151)
                        keySINGLE705 = self.keySINGLE()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keySINGLE705.tree)


                        self._state.following.append(self.FOLLOW_keyREFERENCE_in_cell_reference_options4153)
                        keyREFERENCE706 = self.keyREFERENCE()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyREFERENCE706.tree)










                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 107, cell_reference_options_StartIndex, success)


            pass
        return retval

    # $ANTLR end "cell_reference_options"


    class return_rows_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.return_rows_clause_return, self).__init__()

            self.tree = None





    # $ANTLR start "return_rows_clause"
    # ./output/PLSQL3.g:688:1: return_rows_clause : keyRETURN ( keyUPDATED | 'ALL' ) 'ROWS' ;
    def return_rows_clause(self, ):
        retval = self.return_rows_clause_return()
        retval.start = self.input.LT(1)

        return_rows_clause_StartIndex = self.input.index()

        root_0 = None

        string_literal709 = None
        string_literal710 = None
        keyRETURN707 = None

        keyUPDATED708 = None


        string_literal709_tree = None
        string_literal710_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 108):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:689:2: ( keyRETURN ( keyUPDATED | 'ALL' ) 'ROWS' )
                # ./output/PLSQL3.g:689:4: keyRETURN ( keyUPDATED | 'ALL' ) 'ROWS'
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyRETURN_in_return_rows_clause4168)
                keyRETURN707 = self.keyRETURN()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyRETURN707.tree)


                # ./output/PLSQL3.g:689:14: ( keyUPDATED | 'ALL' )
                alt183 = 2
                LA183_0 = self.input.LA(1)

                if (LA183_0 == ID) :
                    alt183 = 1
                elif (LA183_0 == 50) :
                    alt183 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 183, 0, self.input)

                    raise nvae


                if alt183 == 1:
                    # ./output/PLSQL3.g:689:16: keyUPDATED
                    pass
                    self._state.following.append(self.FOLLOW_keyUPDATED_in_return_rows_clause4172)
                    keyUPDATED708 = self.keyUPDATED()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyUPDATED708.tree)



                elif alt183 == 2:
                    # ./output/PLSQL3.g:689:29: 'ALL'
                    pass
                    string_literal709 = self.match(self.input, 50, self.FOLLOW_50_in_return_rows_clause4176)
                    if self._state.backtracking == 0:
                        string_literal709_tree = self._adaptor.createWithPayload(string_literal709)
                        self._adaptor.addChild(root_0, string_literal709_tree)






                string_literal710 = self.match(self.input, 145, self.FOLLOW_145_in_return_rows_clause4180)
                if self._state.backtracking == 0:
                    string_literal710_tree = self._adaptor.createWithPayload(string_literal710)
                    self._adaptor.addChild(root_0, string_literal710_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 108, return_rows_clause_StartIndex, success)


            pass
        return retval

    # $ANTLR end "return_rows_clause"


    class reference_model_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.reference_model_return, self).__init__()

            self.tree = None





    # $ANTLR start "reference_model"
    # ./output/PLSQL3.g:691:1: reference_model : keyREFERENCE reference_model_name 'ON' LPAREN subquery RPAREN model_column_clauses ( cell_reference_options ) ;
    def reference_model(self, ):
        retval = self.reference_model_return()
        retval.start = self.input.LT(1)

        reference_model_StartIndex = self.input.index()

        root_0 = None

        string_literal713 = None
        LPAREN714 = None
        RPAREN716 = None
        keyREFERENCE711 = None

        reference_model_name712 = None

        subquery715 = None

        model_column_clauses717 = None

        cell_reference_options718 = None


        string_literal713_tree = None
        LPAREN714_tree = None
        RPAREN716_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 109):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:692:2: ( keyREFERENCE reference_model_name 'ON' LPAREN subquery RPAREN model_column_clauses ( cell_reference_options ) )
                # ./output/PLSQL3.g:692:4: keyREFERENCE reference_model_name 'ON' LPAREN subquery RPAREN model_column_clauses ( cell_reference_options )
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyREFERENCE_in_reference_model4190)
                keyREFERENCE711 = self.keyREFERENCE()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyREFERENCE711.tree)


                self._state.following.append(self.FOLLOW_reference_model_name_in_reference_model4192)
                reference_model_name712 = self.reference_model_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, reference_model_name712.tree)


                string_literal713 = self.match(self.input, 126, self.FOLLOW_126_in_reference_model4194)
                if self._state.backtracking == 0:
                    string_literal713_tree = self._adaptor.createWithPayload(string_literal713)
                    self._adaptor.addChild(root_0, string_literal713_tree)



                LPAREN714 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_reference_model4196)
                if self._state.backtracking == 0:
                    LPAREN714_tree = self._adaptor.createWithPayload(LPAREN714)
                    self._adaptor.addChild(root_0, LPAREN714_tree)



                self._state.following.append(self.FOLLOW_subquery_in_reference_model4198)
                subquery715 = self.subquery()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, subquery715.tree)


                RPAREN716 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_reference_model4200)
                if self._state.backtracking == 0:
                    RPAREN716_tree = self._adaptor.createWithPayload(RPAREN716)
                    self._adaptor.addChild(root_0, RPAREN716_tree)



                self._state.following.append(self.FOLLOW_model_column_clauses_in_reference_model4204)
                model_column_clauses717 = self.model_column_clauses()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, model_column_clauses717.tree)


                # ./output/PLSQL3.g:693:24: ( cell_reference_options )
                # ./output/PLSQL3.g:693:26: cell_reference_options
                pass
                self._state.following.append(self.FOLLOW_cell_reference_options_in_reference_model4208)
                cell_reference_options718 = self.cell_reference_options()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, cell_reference_options718.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 109, reference_model_StartIndex, success)


            pass
        return retval

    # $ANTLR end "reference_model"


    class reference_model_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.reference_model_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "reference_model_name"
    # ./output/PLSQL3.g:695:1: reference_model_name : identifier ;
    def reference_model_name(self, ):
        retval = self.reference_model_name_return()
        retval.start = self.input.LT(1)

        reference_model_name_StartIndex = self.input.index()

        root_0 = None

        identifier719 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 110):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:696:2: ( identifier )
                # ./output/PLSQL3.g:696:4: identifier
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_identifier_in_reference_model_name4220)
                identifier719 = self.identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, identifier719.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 110, reference_model_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "reference_model_name"


    class main_model_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.main_model_return, self).__init__()

            self.tree = None





    # $ANTLR start "main_model"
    # ./output/PLSQL3.g:698:1: main_model : ( keyMAIN main_model_name )? model_column_clauses ( cell_reference_options ) model_rules_clause ;
    def main_model(self, ):
        retval = self.main_model_return()
        retval.start = self.input.LT(1)

        main_model_StartIndex = self.input.index()

        root_0 = None

        keyMAIN720 = None

        main_model_name721 = None

        model_column_clauses722 = None

        cell_reference_options723 = None

        model_rules_clause724 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 111):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:699:2: ( ( keyMAIN main_model_name )? model_column_clauses ( cell_reference_options ) model_rules_clause )
                # ./output/PLSQL3.g:699:4: ( keyMAIN main_model_name )? model_column_clauses ( cell_reference_options ) model_rules_clause
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:699:4: ( keyMAIN main_model_name )?
                alt184 = 2
                LA184_0 = self.input.LA(1)

                if (LA184_0 == ID) :
                    LA184_1 = self.input.LA(2)

                    if (LA184_1 == DOUBLEQUOTED_STRING or LA184_1 == ID) :
                        alt184 = 1
                if alt184 == 1:
                    # ./output/PLSQL3.g:699:6: keyMAIN main_model_name
                    pass
                    self._state.following.append(self.FOLLOW_keyMAIN_in_main_model4232)
                    keyMAIN720 = self.keyMAIN()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyMAIN720.tree)


                    self._state.following.append(self.FOLLOW_main_model_name_in_main_model4234)
                    main_model_name721 = self.main_model_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, main_model_name721.tree)





                self._state.following.append(self.FOLLOW_model_column_clauses_in_main_model4239)
                model_column_clauses722 = self.model_column_clauses()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, model_column_clauses722.tree)


                # ./output/PLSQL3.g:700:3: ( cell_reference_options )
                # ./output/PLSQL3.g:700:5: cell_reference_options
                pass
                self._state.following.append(self.FOLLOW_cell_reference_options_in_main_model4245)
                cell_reference_options723 = self.cell_reference_options()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, cell_reference_options723.tree)





                self._state.following.append(self.FOLLOW_model_rules_clause_in_main_model4249)
                model_rules_clause724 = self.model_rules_clause()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, model_rules_clause724.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 111, main_model_StartIndex, success)


            pass
        return retval

    # $ANTLR end "main_model"


    class main_model_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.main_model_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "main_model_name"
    # ./output/PLSQL3.g:702:1: main_model_name : identifier ;
    def main_model_name(self, ):
        retval = self.main_model_name_return()
        retval.start = self.input.LT(1)

        main_model_name_StartIndex = self.input.index()

        root_0 = None

        identifier725 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 112):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:703:2: ( identifier )
                # ./output/PLSQL3.g:703:4: identifier
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_identifier_in_main_model_name4259)
                identifier725 = self.identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, identifier725.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 112, main_model_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "main_model_name"


    class model_column_clauses_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.model_column_clauses_return, self).__init__()

            self.tree = None





    # $ANTLR start "model_column_clauses"
    # ./output/PLSQL3.g:705:1: model_column_clauses : ( query_partition_clause ( column_spec )? )? keyDIMENSION 'BY' LPAREN model_columns RPAREN keyMEASURES LPAREN model_columns RPAREN ;
    def model_column_clauses(self, ):
        retval = self.model_column_clauses_return()
        retval.start = self.input.LT(1)

        model_column_clauses_StartIndex = self.input.index()

        root_0 = None

        string_literal729 = None
        LPAREN730 = None
        RPAREN732 = None
        LPAREN734 = None
        RPAREN736 = None
        query_partition_clause726 = None

        column_spec727 = None

        keyDIMENSION728 = None

        model_columns731 = None

        keyMEASURES733 = None

        model_columns735 = None


        string_literal729_tree = None
        LPAREN730_tree = None
        RPAREN732_tree = None
        LPAREN734_tree = None
        RPAREN736_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 113):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:706:2: ( ( query_partition_clause ( column_spec )? )? keyDIMENSION 'BY' LPAREN model_columns RPAREN keyMEASURES LPAREN model_columns RPAREN )
                # ./output/PLSQL3.g:706:4: ( query_partition_clause ( column_spec )? )? keyDIMENSION 'BY' LPAREN model_columns RPAREN keyMEASURES LPAREN model_columns RPAREN
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:706:4: ( query_partition_clause ( column_spec )? )?
                alt186 = 2
                LA186_0 = self.input.LA(1)

                if (LA186_0 == ID) :
                    LA186_1 = self.input.LA(2)

                    if (((((((self.input).LT(1).text.upper() == "PARTITION")) and (((this.input).LT(1).text.upper() == "PARTITION")))) and (self.synpred311_PLSQL3()))) :
                        alt186 = 1
                if alt186 == 1:
                    # ./output/PLSQL3.g:706:6: query_partition_clause ( column_spec )?
                    pass
                    self._state.following.append(self.FOLLOW_query_partition_clause_in_model_column_clauses4271)
                    query_partition_clause726 = self.query_partition_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, query_partition_clause726.tree)


                    # ./output/PLSQL3.g:706:29: ( column_spec )?
                    alt185 = 2
                    LA185_0 = self.input.LA(1)

                    if (LA185_0 == ID) :
                        LA185_1 = self.input.LA(2)

                        if (LA185_1 == DOT or LA185_1 == ID) :
                            alt185 = 1
                    elif (LA185_0 == DOUBLEQUOTED_STRING or LA185_0 == 144) :
                        alt185 = 1
                    if alt185 == 1:
                        # ./output/PLSQL3.g:706:31: column_spec
                        pass
                        self._state.following.append(self.FOLLOW_column_spec_in_model_column_clauses4275)
                        column_spec727 = self.column_spec()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, column_spec727.tree)








                self._state.following.append(self.FOLLOW_keyDIMENSION_in_model_column_clauses4285)
                keyDIMENSION728 = self.keyDIMENSION()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyDIMENSION728.tree)


                string_literal729 = self.match(self.input, 64, self.FOLLOW_64_in_model_column_clauses4287)
                if self._state.backtracking == 0:
                    string_literal729_tree = self._adaptor.createWithPayload(string_literal729)
                    self._adaptor.addChild(root_0, string_literal729_tree)



                LPAREN730 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_model_column_clauses4289)
                if self._state.backtracking == 0:
                    LPAREN730_tree = self._adaptor.createWithPayload(LPAREN730)
                    self._adaptor.addChild(root_0, LPAREN730_tree)



                self._state.following.append(self.FOLLOW_model_columns_in_model_column_clauses4291)
                model_columns731 = self.model_columns()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, model_columns731.tree)


                RPAREN732 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_model_column_clauses4293)
                if self._state.backtracking == 0:
                    RPAREN732_tree = self._adaptor.createWithPayload(RPAREN732)
                    self._adaptor.addChild(root_0, RPAREN732_tree)



                self._state.following.append(self.FOLLOW_keyMEASURES_in_model_column_clauses4297)
                keyMEASURES733 = self.keyMEASURES()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyMEASURES733.tree)


                LPAREN734 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_model_column_clauses4299)
                if self._state.backtracking == 0:
                    LPAREN734_tree = self._adaptor.createWithPayload(LPAREN734)
                    self._adaptor.addChild(root_0, LPAREN734_tree)



                self._state.following.append(self.FOLLOW_model_columns_in_model_column_clauses4301)
                model_columns735 = self.model_columns()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, model_columns735.tree)


                RPAREN736 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_model_column_clauses4303)
                if self._state.backtracking == 0:
                    RPAREN736_tree = self._adaptor.createWithPayload(RPAREN736)
                    self._adaptor.addChild(root_0, RPAREN736_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 113, model_column_clauses_StartIndex, success)


            pass
        return retval

    # $ANTLR end "model_column_clauses"


    class model_columns_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.model_columns_return, self).__init__()

            self.tree = None





    # $ANTLR start "model_columns"
    # ./output/PLSQL3.g:710:1: model_columns : model_column ( COMMA model_column )* ;
    def model_columns(self, ):
        retval = self.model_columns_return()
        retval.start = self.input.LT(1)

        model_columns_StartIndex = self.input.index()

        root_0 = None

        COMMA738 = None
        model_column737 = None

        model_column739 = None


        COMMA738_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 114):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:711:2: ( model_column ( COMMA model_column )* )
                # ./output/PLSQL3.g:711:4: model_column ( COMMA model_column )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_model_column_in_model_columns4313)
                model_column737 = self.model_column()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, model_column737.tree)


                # ./output/PLSQL3.g:711:17: ( COMMA model_column )*
                while True: #loop187
                    alt187 = 2
                    LA187_0 = self.input.LA(1)

                    if (LA187_0 == COMMA) :
                        alt187 = 1


                    if alt187 == 1:
                        # ./output/PLSQL3.g:711:19: COMMA model_column
                        pass
                        COMMA738 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_model_columns4317)
                        if self._state.backtracking == 0:
                            COMMA738_tree = self._adaptor.createWithPayload(COMMA738)
                            self._adaptor.addChild(root_0, COMMA738_tree)



                        self._state.following.append(self.FOLLOW_model_column_in_model_columns4319)
                        model_column739 = self.model_column()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, model_column739.tree)



                    else:
                        break #loop187




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 114, model_columns_StartIndex, success)


            pass
        return retval

    # $ANTLR end "model_columns"


    class model_column_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.model_column_return, self).__init__()

            self.tree = None





    # $ANTLR start "model_column"
    # ./output/PLSQL3.g:713:1: model_column : sql_expression ( ( 'AS' )? column_spec )? ;
    def model_column(self, ):
        retval = self.model_column_return()
        retval.start = self.input.LT(1)

        model_column_StartIndex = self.input.index()

        root_0 = None

        string_literal741 = None
        sql_expression740 = None

        column_spec742 = None


        string_literal741_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 115):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:714:2: ( sql_expression ( ( 'AS' )? column_spec )? )
                # ./output/PLSQL3.g:714:4: sql_expression ( ( 'AS' )? column_spec )?
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_sql_expression_in_model_column4332)
                sql_expression740 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression740.tree)


                # ./output/PLSQL3.g:714:19: ( ( 'AS' )? column_spec )?
                alt189 = 2
                LA189_0 = self.input.LA(1)

                if (LA189_0 == DOUBLEQUOTED_STRING or LA189_0 == ID or LA189_0 == 53 or LA189_0 == 144) :
                    alt189 = 1
                if alt189 == 1:
                    # ./output/PLSQL3.g:714:21: ( 'AS' )? column_spec
                    pass
                    # ./output/PLSQL3.g:714:21: ( 'AS' )?
                    alt188 = 2
                    LA188_0 = self.input.LA(1)

                    if (LA188_0 == 53) :
                        alt188 = 1
                    if alt188 == 1:
                        # ./output/PLSQL3.g:714:23: 'AS'
                        pass
                        string_literal741 = self.match(self.input, 53, self.FOLLOW_53_in_model_column4338)
                        if self._state.backtracking == 0:
                            string_literal741_tree = self._adaptor.createWithPayload(string_literal741)
                            self._adaptor.addChild(root_0, string_literal741_tree)






                    self._state.following.append(self.FOLLOW_column_spec_in_model_column4343)
                    column_spec742 = self.column_spec()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, column_spec742.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 115, model_column_StartIndex, success)


            pass
        return retval

    # $ANTLR end "model_column"


    class model_rules_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.model_rules_clause_return, self).__init__()

            self.tree = None





    # $ANTLR start "model_rules_clause"
    # ./output/PLSQL3.g:716:1: model_rules_clause : ( keyRULES ( 'UPDATE' | keyUPSERT ( 'ALL' )? )? ( ( keyAUTOMATIC | keySEQUENTIAL ) 'ORDER' )? )? ( keyITERATE LPAREN NUMBER RPAREN ( keyUNTIL LPAREN sql_condition RPAREN )? )? LPAREN model_rules_exprs RPAREN ;
    def model_rules_clause(self, ):
        retval = self.model_rules_clause_return()
        retval.start = self.input.LT(1)

        model_rules_clause_StartIndex = self.input.index()

        root_0 = None

        string_literal744 = None
        string_literal746 = None
        string_literal749 = None
        LPAREN751 = None
        NUMBER752 = None
        RPAREN753 = None
        LPAREN755 = None
        RPAREN757 = None
        LPAREN758 = None
        RPAREN760 = None
        keyRULES743 = None

        keyUPSERT745 = None

        keyAUTOMATIC747 = None

        keySEQUENTIAL748 = None

        keyITERATE750 = None

        keyUNTIL754 = None

        sql_condition756 = None

        model_rules_exprs759 = None


        string_literal744_tree = None
        string_literal746_tree = None
        string_literal749_tree = None
        LPAREN751_tree = None
        NUMBER752_tree = None
        RPAREN753_tree = None
        LPAREN755_tree = None
        RPAREN757_tree = None
        LPAREN758_tree = None
        RPAREN760_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 116):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:717:2: ( ( keyRULES ( 'UPDATE' | keyUPSERT ( 'ALL' )? )? ( ( keyAUTOMATIC | keySEQUENTIAL ) 'ORDER' )? )? ( keyITERATE LPAREN NUMBER RPAREN ( keyUNTIL LPAREN sql_condition RPAREN )? )? LPAREN model_rules_exprs RPAREN )
                # ./output/PLSQL3.g:717:4: ( keyRULES ( 'UPDATE' | keyUPSERT ( 'ALL' )? )? ( ( keyAUTOMATIC | keySEQUENTIAL ) 'ORDER' )? )? ( keyITERATE LPAREN NUMBER RPAREN ( keyUNTIL LPAREN sql_condition RPAREN )? )? LPAREN model_rules_exprs RPAREN
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:717:4: ( keyRULES ( 'UPDATE' | keyUPSERT ( 'ALL' )? )? ( ( keyAUTOMATIC | keySEQUENTIAL ) 'ORDER' )? )?
                alt194 = 2
                LA194_0 = self.input.LA(1)

                if (LA194_0 == ID) :
                    LA194_1 = self.input.LA(2)

                    if (LA194_1 == ID or LA194_1 == 159) :
                        alt194 = 1
                    elif (LA194_1 == LPAREN) :
                        LA194_4 = self.input.LA(3)

                        if (LA194_4 == DOUBLEQUOTED_STRING or LA194_4 == ID or LA194_4 == 144 or LA194_4 == 159) :
                            alt194 = 1
                if alt194 == 1:
                    # ./output/PLSQL3.g:717:6: keyRULES ( 'UPDATE' | keyUPSERT ( 'ALL' )? )? ( ( keyAUTOMATIC | keySEQUENTIAL ) 'ORDER' )?
                    pass
                    self._state.following.append(self.FOLLOW_keyRULES_in_model_rules_clause4358)
                    keyRULES743 = self.keyRULES()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyRULES743.tree)


                    # ./output/PLSQL3.g:717:15: ( 'UPDATE' | keyUPSERT ( 'ALL' )? )?
                    alt191 = 3
                    LA191_0 = self.input.LA(1)

                    if (LA191_0 == 159) :
                        alt191 = 1
                    elif (LA191_0 == ID) :
                        LA191_2 = self.input.LA(2)

                        if (LA191_2 == ID or LA191_2 == 50) :
                            alt191 = 2
                        elif (LA191_2 == LPAREN) :
                            LA191_5 = self.input.LA(3)

                            if (LA191_5 == DOUBLEQUOTED_STRING or LA191_5 == ID or LA191_5 == 144 or LA191_5 == 159) :
                                alt191 = 2
                    if alt191 == 1:
                        # ./output/PLSQL3.g:717:17: 'UPDATE'
                        pass
                        string_literal744 = self.match(self.input, 159, self.FOLLOW_159_in_model_rules_clause4362)
                        if self._state.backtracking == 0:
                            string_literal744_tree = self._adaptor.createWithPayload(string_literal744)
                            self._adaptor.addChild(root_0, string_literal744_tree)




                    elif alt191 == 2:
                        # ./output/PLSQL3.g:717:28: keyUPSERT ( 'ALL' )?
                        pass
                        self._state.following.append(self.FOLLOW_keyUPSERT_in_model_rules_clause4366)
                        keyUPSERT745 = self.keyUPSERT()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyUPSERT745.tree)


                        # ./output/PLSQL3.g:717:38: ( 'ALL' )?
                        alt190 = 2
                        LA190_0 = self.input.LA(1)

                        if (LA190_0 == 50) :
                            alt190 = 1
                        if alt190 == 1:
                            # ./output/PLSQL3.g:717:40: 'ALL'
                            pass
                            string_literal746 = self.match(self.input, 50, self.FOLLOW_50_in_model_rules_clause4370)
                            if self._state.backtracking == 0:
                                string_literal746_tree = self._adaptor.createWithPayload(string_literal746)
                                self._adaptor.addChild(root_0, string_literal746_tree)









                    # ./output/PLSQL3.g:717:52: ( ( keyAUTOMATIC | keySEQUENTIAL ) 'ORDER' )?
                    alt193 = 2
                    LA193_0 = self.input.LA(1)

                    if (LA193_0 == ID) :
                        LA193_1 = self.input.LA(2)

                        if (LA193_1 == 128) :
                            alt193 = 1
                    if alt193 == 1:
                        # ./output/PLSQL3.g:717:54: ( keyAUTOMATIC | keySEQUENTIAL ) 'ORDER'
                        pass
                        # ./output/PLSQL3.g:717:54: ( keyAUTOMATIC | keySEQUENTIAL )
                        alt192 = 2
                        LA192_0 = self.input.LA(1)

                        if (LA192_0 == ID) :
                            LA192_1 = self.input.LA(2)

                            if (((((self.synpred318_PLSQL3()) and (self.synpred318_PLSQL3()))) and (((self.input).LT(1).text.upper() == "AUTOMATIC")))) :
                                alt192 = 1
                            elif (((self.input).LT(1).text.upper() == "SEQUENTIAL")) :
                                alt192 = 2
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 192, 1, self.input)

                                raise nvae


                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 192, 0, self.input)

                            raise nvae


                        if alt192 == 1:
                            # ./output/PLSQL3.g:717:56: keyAUTOMATIC
                            pass
                            self._state.following.append(self.FOLLOW_keyAUTOMATIC_in_model_rules_clause4382)
                            keyAUTOMATIC747 = self.keyAUTOMATIC()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, keyAUTOMATIC747.tree)



                        elif alt192 == 2:
                            # ./output/PLSQL3.g:717:71: keySEQUENTIAL
                            pass
                            self._state.following.append(self.FOLLOW_keySEQUENTIAL_in_model_rules_clause4386)
                            keySEQUENTIAL748 = self.keySEQUENTIAL()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, keySEQUENTIAL748.tree)





                        string_literal749 = self.match(self.input, 128, self.FOLLOW_128_in_model_rules_clause4390)
                        if self._state.backtracking == 0:
                            string_literal749_tree = self._adaptor.createWithPayload(string_literal749)
                            self._adaptor.addChild(root_0, string_literal749_tree)









                # ./output/PLSQL3.g:718:3: ( keyITERATE LPAREN NUMBER RPAREN ( keyUNTIL LPAREN sql_condition RPAREN )? )?
                alt196 = 2
                LA196_0 = self.input.LA(1)

                if (LA196_0 == ID) :
                    alt196 = 1
                if alt196 == 1:
                    # ./output/PLSQL3.g:718:5: keyITERATE LPAREN NUMBER RPAREN ( keyUNTIL LPAREN sql_condition RPAREN )?
                    pass
                    self._state.following.append(self.FOLLOW_keyITERATE_in_model_rules_clause4402)
                    keyITERATE750 = self.keyITERATE()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyITERATE750.tree)


                    LPAREN751 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_model_rules_clause4404)
                    if self._state.backtracking == 0:
                        LPAREN751_tree = self._adaptor.createWithPayload(LPAREN751)
                        self._adaptor.addChild(root_0, LPAREN751_tree)



                    NUMBER752 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_model_rules_clause4406)
                    if self._state.backtracking == 0:
                        NUMBER752_tree = self._adaptor.createWithPayload(NUMBER752)
                        self._adaptor.addChild(root_0, NUMBER752_tree)



                    RPAREN753 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_model_rules_clause4408)
                    if self._state.backtracking == 0:
                        RPAREN753_tree = self._adaptor.createWithPayload(RPAREN753)
                        self._adaptor.addChild(root_0, RPAREN753_tree)



                    # ./output/PLSQL3.g:718:37: ( keyUNTIL LPAREN sql_condition RPAREN )?
                    alt195 = 2
                    LA195_0 = self.input.LA(1)

                    if (LA195_0 == ID) :
                        alt195 = 1
                    if alt195 == 1:
                        # ./output/PLSQL3.g:718:39: keyUNTIL LPAREN sql_condition RPAREN
                        pass
                        self._state.following.append(self.FOLLOW_keyUNTIL_in_model_rules_clause4412)
                        keyUNTIL754 = self.keyUNTIL()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyUNTIL754.tree)


                        LPAREN755 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_model_rules_clause4414)
                        if self._state.backtracking == 0:
                            LPAREN755_tree = self._adaptor.createWithPayload(LPAREN755)
                            self._adaptor.addChild(root_0, LPAREN755_tree)



                        self._state.following.append(self.FOLLOW_sql_condition_in_model_rules_clause4416)
                        sql_condition756 = self.sql_condition()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, sql_condition756.tree)


                        RPAREN757 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_model_rules_clause4418)
                        if self._state.backtracking == 0:
                            RPAREN757_tree = self._adaptor.createWithPayload(RPAREN757)
                            self._adaptor.addChild(root_0, RPAREN757_tree)









                LPAREN758 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_model_rules_clause4428)
                if self._state.backtracking == 0:
                    LPAREN758_tree = self._adaptor.createWithPayload(LPAREN758)
                    self._adaptor.addChild(root_0, LPAREN758_tree)



                self._state.following.append(self.FOLLOW_model_rules_exprs_in_model_rules_clause4430)
                model_rules_exprs759 = self.model_rules_exprs()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, model_rules_exprs759.tree)


                RPAREN760 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_model_rules_clause4432)
                if self._state.backtracking == 0:
                    RPAREN760_tree = self._adaptor.createWithPayload(RPAREN760)
                    self._adaptor.addChild(root_0, RPAREN760_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 116, model_rules_clause_StartIndex, success)


            pass
        return retval

    # $ANTLR end "model_rules_clause"


    class model_rules_exprs_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.model_rules_exprs_return, self).__init__()

            self.tree = None





    # $ANTLR start "model_rules_exprs"
    # ./output/PLSQL3.g:721:1: model_rules_exprs : model_rules_expr ( COMMA model_rules_expr )* ;
    def model_rules_exprs(self, ):
        retval = self.model_rules_exprs_return()
        retval.start = self.input.LT(1)

        model_rules_exprs_StartIndex = self.input.index()

        root_0 = None

        COMMA762 = None
        model_rules_expr761 = None

        model_rules_expr763 = None


        COMMA762_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 117):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:722:2: ( model_rules_expr ( COMMA model_rules_expr )* )
                # ./output/PLSQL3.g:722:4: model_rules_expr ( COMMA model_rules_expr )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_model_rules_expr_in_model_rules_exprs4442)
                model_rules_expr761 = self.model_rules_expr()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, model_rules_expr761.tree)


                # ./output/PLSQL3.g:722:21: ( COMMA model_rules_expr )*
                while True: #loop197
                    alt197 = 2
                    LA197_0 = self.input.LA(1)

                    if (LA197_0 == COMMA) :
                        alt197 = 1


                    if alt197 == 1:
                        # ./output/PLSQL3.g:722:23: COMMA model_rules_expr
                        pass
                        COMMA762 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_model_rules_exprs4446)
                        if self._state.backtracking == 0:
                            COMMA762_tree = self._adaptor.createWithPayload(COMMA762)
                            self._adaptor.addChild(root_0, COMMA762_tree)



                        self._state.following.append(self.FOLLOW_model_rules_expr_in_model_rules_exprs4448)
                        model_rules_expr763 = self.model_rules_expr()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, model_rules_expr763.tree)



                    else:
                        break #loop197




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 117, model_rules_exprs_StartIndex, success)


            pass
        return retval

    # $ANTLR end "model_rules_exprs"


    class model_rules_expr_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.model_rules_expr_return, self).__init__()

            self.tree = None





    # $ANTLR start "model_rules_expr"
    # ./output/PLSQL3.g:724:1: model_rules_expr : ( 'UPDATE' | keyUPSERT ( 'ALL' )? )? cell_assignment ( order_by_clause )? EQ sql_expression ;
    def model_rules_expr(self, ):
        retval = self.model_rules_expr_return()
        retval.start = self.input.LT(1)

        model_rules_expr_StartIndex = self.input.index()

        root_0 = None

        string_literal764 = None
        string_literal766 = None
        EQ769 = None
        keyUPSERT765 = None

        cell_assignment767 = None

        order_by_clause768 = None

        sql_expression770 = None


        string_literal764_tree = None
        string_literal766_tree = None
        EQ769_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 118):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:725:2: ( ( 'UPDATE' | keyUPSERT ( 'ALL' )? )? cell_assignment ( order_by_clause )? EQ sql_expression )
                # ./output/PLSQL3.g:725:4: ( 'UPDATE' | keyUPSERT ( 'ALL' )? )? cell_assignment ( order_by_clause )? EQ sql_expression
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:725:4: ( 'UPDATE' | keyUPSERT ( 'ALL' )? )?
                alt199 = 3
                LA199_0 = self.input.LA(1)

                if (LA199_0 == 159) :
                    alt199 = 1
                elif (LA199_0 == ID) :
                    LA199_2 = self.input.LA(2)

                    if (LA199_2 == DOUBLEQUOTED_STRING or LA199_2 == ID or LA199_2 == 50 or LA199_2 == 144) :
                        alt199 = 2
                if alt199 == 1:
                    # ./output/PLSQL3.g:725:6: 'UPDATE'
                    pass
                    string_literal764 = self.match(self.input, 159, self.FOLLOW_159_in_model_rules_expr4463)
                    if self._state.backtracking == 0:
                        string_literal764_tree = self._adaptor.createWithPayload(string_literal764)
                        self._adaptor.addChild(root_0, string_literal764_tree)




                elif alt199 == 2:
                    # ./output/PLSQL3.g:725:17: keyUPSERT ( 'ALL' )?
                    pass
                    self._state.following.append(self.FOLLOW_keyUPSERT_in_model_rules_expr4467)
                    keyUPSERT765 = self.keyUPSERT()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyUPSERT765.tree)


                    # ./output/PLSQL3.g:725:27: ( 'ALL' )?
                    alt198 = 2
                    LA198_0 = self.input.LA(1)

                    if (LA198_0 == 50) :
                        alt198 = 1
                    if alt198 == 1:
                        # ./output/PLSQL3.g:725:29: 'ALL'
                        pass
                        string_literal766 = self.match(self.input, 50, self.FOLLOW_50_in_model_rules_expr4471)
                        if self._state.backtracking == 0:
                            string_literal766_tree = self._adaptor.createWithPayload(string_literal766)
                            self._adaptor.addChild(root_0, string_literal766_tree)









                self._state.following.append(self.FOLLOW_cell_assignment_in_model_rules_expr4479)
                cell_assignment767 = self.cell_assignment()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, cell_assignment767.tree)


                # ./output/PLSQL3.g:725:57: ( order_by_clause )?
                alt200 = 2
                LA200_0 = self.input.LA(1)

                if (LA200_0 == 128) :
                    alt200 = 1
                if alt200 == 1:
                    # ./output/PLSQL3.g:725:59: order_by_clause
                    pass
                    self._state.following.append(self.FOLLOW_order_by_clause_in_model_rules_expr4483)
                    order_by_clause768 = self.order_by_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, order_by_clause768.tree)





                EQ769 = self.match(self.input, EQ, self.FOLLOW_EQ_in_model_rules_expr4488)
                if self._state.backtracking == 0:
                    EQ769_tree = self._adaptor.createWithPayload(EQ769)
                    self._adaptor.addChild(root_0, EQ769_tree)



                self._state.following.append(self.FOLLOW_sql_expression_in_model_rules_expr4490)
                sql_expression770 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression770.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 118, model_rules_expr_StartIndex, success)


            pass
        return retval

    # $ANTLR end "model_rules_expr"


    class cell_assignment_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.cell_assignment_return, self).__init__()

            self.tree = None





    # $ANTLR start "cell_assignment"
    # ./output/PLSQL3.g:727:1: cell_assignment : measure_column LBRACK ( multi_column_for_loop | cell_assignment_exprs ) RBRACK ;
    def cell_assignment(self, ):
        retval = self.cell_assignment_return()
        retval.start = self.input.LT(1)

        cell_assignment_StartIndex = self.input.index()

        root_0 = None

        LBRACK772 = None
        RBRACK775 = None
        measure_column771 = None

        multi_column_for_loop773 = None

        cell_assignment_exprs774 = None


        LBRACK772_tree = None
        RBRACK775_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 119):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:728:2: ( measure_column LBRACK ( multi_column_for_loop | cell_assignment_exprs ) RBRACK )
                # ./output/PLSQL3.g:728:4: measure_column LBRACK ( multi_column_for_loop | cell_assignment_exprs ) RBRACK
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_measure_column_in_cell_assignment4500)
                measure_column771 = self.measure_column()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, measure_column771.tree)


                LBRACK772 = self.match(self.input, LBRACK, self.FOLLOW_LBRACK_in_cell_assignment4502)
                if self._state.backtracking == 0:
                    LBRACK772_tree = self._adaptor.createWithPayload(LBRACK772)
                    self._adaptor.addChild(root_0, LBRACK772_tree)



                # ./output/PLSQL3.g:728:26: ( multi_column_for_loop | cell_assignment_exprs )
                alt201 = 2
                LA201_0 = self.input.LA(1)

                if (LA201_0 == 92) :
                    LA201_1 = self.input.LA(2)

                    if (LA201_1 == LPAREN) :
                        alt201 = 1
                    elif (LA201_1 == DOUBLEQUOTED_STRING or LA201_1 == ID or LA201_1 == 144) :
                        alt201 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 201, 1, self.input)

                        raise nvae


                elif (LA201_0 == DOUBLEQUOTED_STRING or LA201_0 == ID or LA201_0 == LPAREN or LA201_0 == MINUS or LA201_0 == NUMBER or LA201_0 == PLUS or LA201_0 == QUOTED_STRING or LA201_0 == 52 or LA201_0 == 65 or LA201_0 == 81 or (88 <= LA201_0 <= 89) or LA201_0 == 118 or LA201_0 == 120 or LA201_0 == 134 or LA201_0 == 144 or LA201_0 == 147 or LA201_0 == 151 or LA201_0 == 156) :
                    alt201 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 201, 0, self.input)

                    raise nvae


                if alt201 == 1:
                    # ./output/PLSQL3.g:728:28: multi_column_for_loop
                    pass
                    self._state.following.append(self.FOLLOW_multi_column_for_loop_in_cell_assignment4506)
                    multi_column_for_loop773 = self.multi_column_for_loop()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, multi_column_for_loop773.tree)



                elif alt201 == 2:
                    # ./output/PLSQL3.g:728:52: cell_assignment_exprs
                    pass
                    self._state.following.append(self.FOLLOW_cell_assignment_exprs_in_cell_assignment4510)
                    cell_assignment_exprs774 = self.cell_assignment_exprs()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, cell_assignment_exprs774.tree)





                RBRACK775 = self.match(self.input, RBRACK, self.FOLLOW_RBRACK_in_cell_assignment4514)
                if self._state.backtracking == 0:
                    RBRACK775_tree = self._adaptor.createWithPayload(RBRACK775)
                    self._adaptor.addChild(root_0, RBRACK775_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 119, cell_assignment_StartIndex, success)


            pass
        return retval

    # $ANTLR end "cell_assignment"


    class cell_assignment_exprs_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.cell_assignment_exprs_return, self).__init__()

            self.tree = None





    # $ANTLR start "cell_assignment_exprs"
    # ./output/PLSQL3.g:730:1: cell_assignment_exprs : cell_assignment_expr ( COMMA cell_assignment_expr )* ;
    def cell_assignment_exprs(self, ):
        retval = self.cell_assignment_exprs_return()
        retval.start = self.input.LT(1)

        cell_assignment_exprs_StartIndex = self.input.index()

        root_0 = None

        COMMA777 = None
        cell_assignment_expr776 = None

        cell_assignment_expr778 = None


        COMMA777_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 120):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:731:2: ( cell_assignment_expr ( COMMA cell_assignment_expr )* )
                # ./output/PLSQL3.g:731:4: cell_assignment_expr ( COMMA cell_assignment_expr )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_cell_assignment_expr_in_cell_assignment_exprs4524)
                cell_assignment_expr776 = self.cell_assignment_expr()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, cell_assignment_expr776.tree)


                # ./output/PLSQL3.g:731:25: ( COMMA cell_assignment_expr )*
                while True: #loop202
                    alt202 = 2
                    LA202_0 = self.input.LA(1)

                    if (LA202_0 == COMMA) :
                        alt202 = 1


                    if alt202 == 1:
                        # ./output/PLSQL3.g:731:27: COMMA cell_assignment_expr
                        pass
                        COMMA777 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_cell_assignment_exprs4528)
                        if self._state.backtracking == 0:
                            COMMA777_tree = self._adaptor.createWithPayload(COMMA777)
                            self._adaptor.addChild(root_0, COMMA777_tree)



                        self._state.following.append(self.FOLLOW_cell_assignment_expr_in_cell_assignment_exprs4530)
                        cell_assignment_expr778 = self.cell_assignment_expr()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, cell_assignment_expr778.tree)



                    else:
                        break #loop202




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 120, cell_assignment_exprs_StartIndex, success)


            pass
        return retval

    # $ANTLR end "cell_assignment_exprs"


    class cell_assignment_expr_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.cell_assignment_expr_return, self).__init__()

            self.tree = None





    # $ANTLR start "cell_assignment_expr"
    # ./output/PLSQL3.g:733:1: cell_assignment_expr : ( sql_condition | sql_expression | single_column_for_loop );
    def cell_assignment_expr(self, ):
        retval = self.cell_assignment_expr_return()
        retval.start = self.input.LT(1)

        cell_assignment_expr_StartIndex = self.input.index()

        root_0 = None

        sql_condition779 = None

        sql_expression780 = None

        single_column_for_loop781 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 121):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:734:2: ( sql_condition | sql_expression | single_column_for_loop )
                alt203 = 3
                LA203 = self.input.LA(1)
                if LA203 == 52 or LA203 == 88 or LA203 == 118 or LA203 == 134:
                    alt203 = 1
                elif LA203 == MINUS or LA203 == PLUS:
                    LA203_3 = self.input.LA(2)

                    if (self.synpred330_PLSQL3()) :
                        alt203 = 1
                    elif (self.synpred331_PLSQL3()) :
                        alt203 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 203, 3, self.input)

                        raise nvae


                elif LA203 == LPAREN:
                    LA203_4 = self.input.LA(2)

                    if (self.synpred330_PLSQL3()) :
                        alt203 = 1
                    elif (self.synpred331_PLSQL3()) :
                        alt203 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 203, 4, self.input)

                        raise nvae


                elif LA203 == ID:
                    LA203_5 = self.input.LA(2)

                    if (self.synpred330_PLSQL3()) :
                        alt203 = 1
                    elif (self.synpred331_PLSQL3()) :
                        alt203 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 203, 5, self.input)

                        raise nvae


                elif LA203 == 144:
                    LA203_6 = self.input.LA(2)

                    if (self.synpred330_PLSQL3()) :
                        alt203 = 1
                    elif (self.synpred331_PLSQL3()) :
                        alt203 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 203, 6, self.input)

                        raise nvae


                elif LA203 == DOUBLEQUOTED_STRING:
                    LA203_7 = self.input.LA(2)

                    if (self.synpred330_PLSQL3()) :
                        alt203 = 1
                    elif (self.synpred331_PLSQL3()) :
                        alt203 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 203, 7, self.input)

                        raise nvae


                elif LA203 == 81:
                    LA203_8 = self.input.LA(2)

                    if ((((((is_sql )) and ((is_sql )))) and (self.synpred330_PLSQL3()))) :
                        alt203 = 1
                    elif ((((((is_sql )) and ((is_sql )))) and (self.synpred331_PLSQL3()))) :
                        alt203 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 203, 8, self.input)

                        raise nvae


                elif LA203 == 65:
                    LA203_9 = self.input.LA(2)

                    if (self.synpred330_PLSQL3()) :
                        alt203 = 1
                    elif (self.synpred331_PLSQL3()) :
                        alt203 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 203, 9, self.input)

                        raise nvae


                elif LA203 == 89 or LA203 == 156:
                    LA203_10 = self.input.LA(2)

                    if (self.synpred330_PLSQL3()) :
                        alt203 = 1
                    elif (self.synpred331_PLSQL3()) :
                        alt203 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 203, 10, self.input)

                        raise nvae


                elif LA203 == 151:
                    LA203_11 = self.input.LA(2)

                    if (self.synpred330_PLSQL3()) :
                        alt203 = 1
                    elif (self.synpred331_PLSQL3()) :
                        alt203 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 203, 11, self.input)

                        raise nvae


                elif LA203 == QUOTED_STRING:
                    LA203_12 = self.input.LA(2)

                    if (self.synpred330_PLSQL3()) :
                        alt203 = 1
                    elif (self.synpred331_PLSQL3()) :
                        alt203 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 203, 12, self.input)

                        raise nvae


                elif LA203 == NUMBER:
                    LA203_13 = self.input.LA(2)

                    if (self.synpred330_PLSQL3()) :
                        alt203 = 1
                    elif (self.synpred331_PLSQL3()) :
                        alt203 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 203, 13, self.input)

                        raise nvae


                elif LA203 == 120:
                    LA203_14 = self.input.LA(2)

                    if (self.synpred330_PLSQL3()) :
                        alt203 = 1
                    elif (self.synpred331_PLSQL3()) :
                        alt203 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 203, 14, self.input)

                        raise nvae


                elif LA203 == 147:
                    LA203_15 = self.input.LA(2)

                    if (self.synpred330_PLSQL3()) :
                        alt203 = 1
                    elif (self.synpred331_PLSQL3()) :
                        alt203 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 203, 15, self.input)

                        raise nvae


                elif LA203 == 92:
                    alt203 = 3
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 203, 0, self.input)

                    raise nvae


                if alt203 == 1:
                    # ./output/PLSQL3.g:734:4: sql_condition
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_sql_condition_in_cell_assignment_expr4543)
                    sql_condition779 = self.sql_condition()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_condition779.tree)



                elif alt203 == 2:
                    # ./output/PLSQL3.g:734:20: sql_expression
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_sql_expression_in_cell_assignment_expr4547)
                    sql_expression780 = self.sql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expression780.tree)



                elif alt203 == 3:
                    # ./output/PLSQL3.g:734:37: single_column_for_loop
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_single_column_for_loop_in_cell_assignment_expr4551)
                    single_column_for_loop781 = self.single_column_for_loop()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, single_column_for_loop781.tree)



                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 121, cell_assignment_expr_StartIndex, success)


            pass
        return retval

    # $ANTLR end "cell_assignment_expr"


    class measure_column_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.measure_column_return, self).__init__()

            self.tree = None





    # $ANTLR start "measure_column"
    # ./output/PLSQL3.g:736:1: measure_column : column_name ;
    def measure_column(self, ):
        retval = self.measure_column_return()
        retval.start = self.input.LT(1)

        measure_column_StartIndex = self.input.index()

        root_0 = None

        column_name782 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 122):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:737:2: ( column_name )
                # ./output/PLSQL3.g:737:4: column_name
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_column_name_in_measure_column4561)
                column_name782 = self.column_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, column_name782.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 122, measure_column_StartIndex, success)


            pass
        return retval

    # $ANTLR end "measure_column"


    class single_column_for_loop_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.single_column_for_loop_return, self).__init__()

            self.tree = None





    # $ANTLR start "single_column_for_loop"
    # ./output/PLSQL3.g:739:1: single_column_for_loop : 'FOR' column_name ( 'IN' LPAREN ( literals | subquery ) RPAREN | ( 'LIKE' pattern )? 'FROM' literal 'TO' literal ( keyINCREMENT | keyDECREMENT ) literal ) ;
    def single_column_for_loop(self, ):
        retval = self.single_column_for_loop_return()
        retval.start = self.input.LT(1)

        single_column_for_loop_StartIndex = self.input.index()

        root_0 = None

        string_literal783 = None
        string_literal785 = None
        LPAREN786 = None
        RPAREN789 = None
        string_literal790 = None
        string_literal792 = None
        string_literal794 = None
        column_name784 = None

        literals787 = None

        subquery788 = None

        pattern791 = None

        literal793 = None

        literal795 = None

        keyINCREMENT796 = None

        keyDECREMENT797 = None

        literal798 = None


        string_literal783_tree = None
        string_literal785_tree = None
        LPAREN786_tree = None
        RPAREN789_tree = None
        string_literal790_tree = None
        string_literal792_tree = None
        string_literal794_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 123):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:740:2: ( 'FOR' column_name ( 'IN' LPAREN ( literals | subquery ) RPAREN | ( 'LIKE' pattern )? 'FROM' literal 'TO' literal ( keyINCREMENT | keyDECREMENT ) literal ) )
                # ./output/PLSQL3.g:740:4: 'FOR' column_name ( 'IN' LPAREN ( literals | subquery ) RPAREN | ( 'LIKE' pattern )? 'FROM' literal 'TO' literal ( keyINCREMENT | keyDECREMENT ) literal )
                pass
                root_0 = self._adaptor.nil()


                string_literal783 = self.match(self.input, 92, self.FOLLOW_92_in_single_column_for_loop4571)
                if self._state.backtracking == 0:
                    string_literal783_tree = self._adaptor.createWithPayload(string_literal783)
                    self._adaptor.addChild(root_0, string_literal783_tree)



                self._state.following.append(self.FOLLOW_column_name_in_single_column_for_loop4573)
                column_name784 = self.column_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, column_name784.tree)


                # ./output/PLSQL3.g:741:3: ( 'IN' LPAREN ( literals | subquery ) RPAREN | ( 'LIKE' pattern )? 'FROM' literal 'TO' literal ( keyINCREMENT | keyDECREMENT ) literal )
                alt207 = 2
                LA207_0 = self.input.LA(1)

                if (LA207_0 == 99) :
                    alt207 = 1
                elif (LA207_0 == 93 or LA207_0 == 107) :
                    alt207 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 207, 0, self.input)

                    raise nvae


                if alt207 == 1:
                    # ./output/PLSQL3.g:741:5: 'IN' LPAREN ( literals | subquery ) RPAREN
                    pass
                    string_literal785 = self.match(self.input, 99, self.FOLLOW_99_in_single_column_for_loop4579)
                    if self._state.backtracking == 0:
                        string_literal785_tree = self._adaptor.createWithPayload(string_literal785)
                        self._adaptor.addChild(root_0, string_literal785_tree)



                    LPAREN786 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_single_column_for_loop4581)
                    if self._state.backtracking == 0:
                        LPAREN786_tree = self._adaptor.createWithPayload(LPAREN786)
                        self._adaptor.addChild(root_0, LPAREN786_tree)



                    # ./output/PLSQL3.g:741:17: ( literals | subquery )
                    alt204 = 2
                    LA204_0 = self.input.LA(1)

                    if (LA204_0 == MINUS or LA204_0 == NUMBER or LA204_0 == PLUS or LA204_0 == QUOTED_STRING) :
                        alt204 = 1
                    elif (LA204_0 == LPAREN) :
                        alt204 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 204, 0, self.input)

                        raise nvae


                    if alt204 == 1:
                        # ./output/PLSQL3.g:741:19: literals
                        pass
                        self._state.following.append(self.FOLLOW_literals_in_single_column_for_loop4585)
                        literals787 = self.literals()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, literals787.tree)



                    elif alt204 == 2:
                        # ./output/PLSQL3.g:741:30: subquery
                        pass
                        self._state.following.append(self.FOLLOW_subquery_in_single_column_for_loop4589)
                        subquery788 = self.subquery()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, subquery788.tree)





                    RPAREN789 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_single_column_for_loop4593)
                    if self._state.backtracking == 0:
                        RPAREN789_tree = self._adaptor.createWithPayload(RPAREN789)
                        self._adaptor.addChild(root_0, RPAREN789_tree)




                elif alt207 == 2:
                    # ./output/PLSQL3.g:742:5: ( 'LIKE' pattern )? 'FROM' literal 'TO' literal ( keyINCREMENT | keyDECREMENT ) literal
                    pass
                    # ./output/PLSQL3.g:742:5: ( 'LIKE' pattern )?
                    alt205 = 2
                    LA205_0 = self.input.LA(1)

                    if (LA205_0 == 107) :
                        alt205 = 1
                    if alt205 == 1:
                        # ./output/PLSQL3.g:742:7: 'LIKE' pattern
                        pass
                        string_literal790 = self.match(self.input, 107, self.FOLLOW_107_in_single_column_for_loop4601)
                        if self._state.backtracking == 0:
                            string_literal790_tree = self._adaptor.createWithPayload(string_literal790)
                            self._adaptor.addChild(root_0, string_literal790_tree)



                        self._state.following.append(self.FOLLOW_pattern_in_single_column_for_loop4603)
                        pattern791 = self.pattern()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, pattern791.tree)





                    string_literal792 = self.match(self.input, 93, self.FOLLOW_93_in_single_column_for_loop4608)
                    if self._state.backtracking == 0:
                        string_literal792_tree = self._adaptor.createWithPayload(string_literal792)
                        self._adaptor.addChild(root_0, string_literal792_tree)



                    self._state.following.append(self.FOLLOW_literal_in_single_column_for_loop4610)
                    literal793 = self.literal()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, literal793.tree)


                    string_literal794 = self.match(self.input, 155, self.FOLLOW_155_in_single_column_for_loop4612)
                    if self._state.backtracking == 0:
                        string_literal794_tree = self._adaptor.createWithPayload(string_literal794)
                        self._adaptor.addChild(root_0, string_literal794_tree)



                    self._state.following.append(self.FOLLOW_literal_in_single_column_for_loop4614)
                    literal795 = self.literal()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, literal795.tree)


                    # ./output/PLSQL3.g:742:53: ( keyINCREMENT | keyDECREMENT )
                    alt206 = 2
                    LA206_0 = self.input.LA(1)

                    if (LA206_0 == ID) :
                        LA206_1 = self.input.LA(2)

                        if (((((((self.input).LT(1).text.upper() == "INCREMENT")) and (((this.input).LT(1).text.upper() == "INCREMENT")))) and (self.synpred335_PLSQL3()))) :
                            alt206 = 1
                        elif (((self.input).LT(1).text.upper() == "DECREMENT")) :
                            alt206 = 2
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 206, 1, self.input)

                            raise nvae


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 206, 0, self.input)

                        raise nvae


                    if alt206 == 1:
                        # ./output/PLSQL3.g:742:55: keyINCREMENT
                        pass
                        self._state.following.append(self.FOLLOW_keyINCREMENT_in_single_column_for_loop4618)
                        keyINCREMENT796 = self.keyINCREMENT()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyINCREMENT796.tree)



                    elif alt206 == 2:
                        # ./output/PLSQL3.g:742:70: keyDECREMENT
                        pass
                        self._state.following.append(self.FOLLOW_keyDECREMENT_in_single_column_for_loop4622)
                        keyDECREMENT797 = self.keyDECREMENT()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyDECREMENT797.tree)





                    self._state.following.append(self.FOLLOW_literal_in_single_column_for_loop4626)
                    literal798 = self.literal()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, literal798.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 123, single_column_for_loop_StartIndex, success)


            pass
        return retval

    # $ANTLR end "single_column_for_loop"


    class literal_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.literal_return, self).__init__()

            self.tree = None





    # $ANTLR start "literal"
    # ./output/PLSQL3.g:745:1: literal : ( ( PLUS | MINUS )? NUMBER | QUOTED_STRING );
    def literal(self, ):
        retval = self.literal_return()
        retval.start = self.input.LT(1)

        literal_StartIndex = self.input.index()

        root_0 = None

        set799 = None
        NUMBER800 = None
        QUOTED_STRING801 = None

        set799_tree = None
        NUMBER800_tree = None
        QUOTED_STRING801_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 124):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:746:2: ( ( PLUS | MINUS )? NUMBER | QUOTED_STRING )
                alt209 = 2
                LA209_0 = self.input.LA(1)

                if (LA209_0 == MINUS or LA209_0 == NUMBER or LA209_0 == PLUS) :
                    alt209 = 1
                elif (LA209_0 == QUOTED_STRING) :
                    alt209 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 209, 0, self.input)

                    raise nvae


                if alt209 == 1:
                    # ./output/PLSQL3.g:746:4: ( PLUS | MINUS )? NUMBER
                    pass
                    root_0 = self._adaptor.nil()


                    # ./output/PLSQL3.g:746:4: ( PLUS | MINUS )?
                    alt208 = 2
                    LA208_0 = self.input.LA(1)

                    if (LA208_0 == MINUS or LA208_0 == PLUS) :
                        alt208 = 1
                    if alt208 == 1:
                        # ./output/PLSQL3.g:
                        pass
                        set799 = self.input.LT(1)

                        if self.input.LA(1) == MINUS or self.input.LA(1) == PLUS:
                            self.input.consume()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set799))

                            self._state.errorRecovery = False


                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            mse = MismatchedSetException(None, self.input)
                            raise mse






                    NUMBER800 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_literal4651)
                    if self._state.backtracking == 0:
                        NUMBER800_tree = self._adaptor.createWithPayload(NUMBER800)
                        self._adaptor.addChild(root_0, NUMBER800_tree)




                elif alt209 == 2:
                    # ./output/PLSQL3.g:747:4: QUOTED_STRING
                    pass
                    root_0 = self._adaptor.nil()


                    QUOTED_STRING801 = self.match(self.input, QUOTED_STRING, self.FOLLOW_QUOTED_STRING_in_literal4656)
                    if self._state.backtracking == 0:
                        QUOTED_STRING801_tree = self._adaptor.createWithPayload(QUOTED_STRING801)
                        self._adaptor.addChild(root_0, QUOTED_STRING801_tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 124, literal_StartIndex, success)


            pass
        return retval

    # $ANTLR end "literal"


    class literals_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.literals_return, self).__init__()

            self.tree = None





    # $ANTLR start "literals"
    # ./output/PLSQL3.g:749:1: literals : literal ( COMMA literal )* ;
    def literals(self, ):
        retval = self.literals_return()
        retval.start = self.input.LT(1)

        literals_StartIndex = self.input.index()

        root_0 = None

        COMMA803 = None
        literal802 = None

        literal804 = None


        COMMA803_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 125):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:750:2: ( literal ( COMMA literal )* )
                # ./output/PLSQL3.g:750:4: literal ( COMMA literal )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_literal_in_literals4666)
                literal802 = self.literal()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, literal802.tree)


                # ./output/PLSQL3.g:750:12: ( COMMA literal )*
                while True: #loop210
                    alt210 = 2
                    LA210_0 = self.input.LA(1)

                    if (LA210_0 == COMMA) :
                        alt210 = 1


                    if alt210 == 1:
                        # ./output/PLSQL3.g:750:14: COMMA literal
                        pass
                        COMMA803 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_literals4670)
                        if self._state.backtracking == 0:
                            COMMA803_tree = self._adaptor.createWithPayload(COMMA803)
                            self._adaptor.addChild(root_0, COMMA803_tree)



                        self._state.following.append(self.FOLLOW_literal_in_literals4672)
                        literal804 = self.literal()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, literal804.tree)



                    else:
                        break #loop210




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 125, literals_StartIndex, success)


            pass
        return retval

    # $ANTLR end "literals"


    class bracket_literals_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.bracket_literals_return, self).__init__()

            self.tree = None





    # $ANTLR start "bracket_literals"
    # ./output/PLSQL3.g:752:1: bracket_literals : LPAREN literals RPAREN ;
    def bracket_literals(self, ):
        retval = self.bracket_literals_return()
        retval.start = self.input.LT(1)

        bracket_literals_StartIndex = self.input.index()

        root_0 = None

        LPAREN805 = None
        RPAREN807 = None
        literals806 = None


        LPAREN805_tree = None
        RPAREN807_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 126):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:753:2: ( LPAREN literals RPAREN )
                # ./output/PLSQL3.g:753:4: LPAREN literals RPAREN
                pass
                root_0 = self._adaptor.nil()


                LPAREN805 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_bracket_literals4685)
                if self._state.backtracking == 0:
                    LPAREN805_tree = self._adaptor.createWithPayload(LPAREN805)
                    self._adaptor.addChild(root_0, LPAREN805_tree)



                self._state.following.append(self.FOLLOW_literals_in_bracket_literals4687)
                literals806 = self.literals()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, literals806.tree)


                RPAREN807 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_bracket_literals4689)
                if self._state.backtracking == 0:
                    RPAREN807_tree = self._adaptor.createWithPayload(RPAREN807)
                    self._adaptor.addChild(root_0, RPAREN807_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 126, bracket_literals_StartIndex, success)


            pass
        return retval

    # $ANTLR end "bracket_literals"


    class bracket_literals_list_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.bracket_literals_list_return, self).__init__()

            self.tree = None





    # $ANTLR start "bracket_literals_list"
    # ./output/PLSQL3.g:755:1: bracket_literals_list : bracket_literals ( COMMA bracket_literals )* ;
    def bracket_literals_list(self, ):
        retval = self.bracket_literals_list_return()
        retval.start = self.input.LT(1)

        bracket_literals_list_StartIndex = self.input.index()

        root_0 = None

        COMMA809 = None
        bracket_literals808 = None

        bracket_literals810 = None


        COMMA809_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 127):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:756:2: ( bracket_literals ( COMMA bracket_literals )* )
                # ./output/PLSQL3.g:756:4: bracket_literals ( COMMA bracket_literals )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_bracket_literals_in_bracket_literals_list4699)
                bracket_literals808 = self.bracket_literals()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, bracket_literals808.tree)


                # ./output/PLSQL3.g:756:21: ( COMMA bracket_literals )*
                while True: #loop211
                    alt211 = 2
                    LA211_0 = self.input.LA(1)

                    if (LA211_0 == COMMA) :
                        alt211 = 1


                    if alt211 == 1:
                        # ./output/PLSQL3.g:756:23: COMMA bracket_literals
                        pass
                        COMMA809 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_bracket_literals_list4703)
                        if self._state.backtracking == 0:
                            COMMA809_tree = self._adaptor.createWithPayload(COMMA809)
                            self._adaptor.addChild(root_0, COMMA809_tree)



                        self._state.following.append(self.FOLLOW_bracket_literals_in_bracket_literals_list4705)
                        bracket_literals810 = self.bracket_literals()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, bracket_literals810.tree)



                    else:
                        break #loop211




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 127, bracket_literals_list_StartIndex, success)


            pass
        return retval

    # $ANTLR end "bracket_literals_list"


    class pattern_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.pattern_return, self).__init__()

            self.tree = None





    # $ANTLR start "pattern"
    # ./output/PLSQL3.g:758:1: pattern : QUOTED_STRING ;
    def pattern(self, ):
        retval = self.pattern_return()
        retval.start = self.input.LT(1)

        pattern_StartIndex = self.input.index()

        root_0 = None

        QUOTED_STRING811 = None

        QUOTED_STRING811_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 128):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:759:2: ( QUOTED_STRING )
                # ./output/PLSQL3.g:759:4: QUOTED_STRING
                pass
                root_0 = self._adaptor.nil()


                QUOTED_STRING811 = self.match(self.input, QUOTED_STRING, self.FOLLOW_QUOTED_STRING_in_pattern4718)
                if self._state.backtracking == 0:
                    QUOTED_STRING811_tree = self._adaptor.createWithPayload(QUOTED_STRING811)
                    self._adaptor.addChild(root_0, QUOTED_STRING811_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 128, pattern_StartIndex, success)


            pass
        return retval

    # $ANTLR end "pattern"


    class multi_column_for_loop_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.multi_column_for_loop_return, self).__init__()

            self.tree = None





    # $ANTLR start "multi_column_for_loop"
    # ./output/PLSQL3.g:761:1: multi_column_for_loop : 'FOR' LPAREN column_specs RPAREN 'IN' LPAREN ( bracket_literals_list | subquery ) RPAREN ;
    def multi_column_for_loop(self, ):
        retval = self.multi_column_for_loop_return()
        retval.start = self.input.LT(1)

        multi_column_for_loop_StartIndex = self.input.index()

        root_0 = None

        string_literal812 = None
        LPAREN813 = None
        RPAREN815 = None
        string_literal816 = None
        LPAREN817 = None
        RPAREN820 = None
        column_specs814 = None

        bracket_literals_list818 = None

        subquery819 = None


        string_literal812_tree = None
        LPAREN813_tree = None
        RPAREN815_tree = None
        string_literal816_tree = None
        LPAREN817_tree = None
        RPAREN820_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 129):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:762:2: ( 'FOR' LPAREN column_specs RPAREN 'IN' LPAREN ( bracket_literals_list | subquery ) RPAREN )
                # ./output/PLSQL3.g:762:4: 'FOR' LPAREN column_specs RPAREN 'IN' LPAREN ( bracket_literals_list | subquery ) RPAREN
                pass
                root_0 = self._adaptor.nil()


                string_literal812 = self.match(self.input, 92, self.FOLLOW_92_in_multi_column_for_loop4728)
                if self._state.backtracking == 0:
                    string_literal812_tree = self._adaptor.createWithPayload(string_literal812)
                    self._adaptor.addChild(root_0, string_literal812_tree)



                LPAREN813 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_multi_column_for_loop4730)
                if self._state.backtracking == 0:
                    LPAREN813_tree = self._adaptor.createWithPayload(LPAREN813)
                    self._adaptor.addChild(root_0, LPAREN813_tree)



                self._state.following.append(self.FOLLOW_column_specs_in_multi_column_for_loop4732)
                column_specs814 = self.column_specs()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, column_specs814.tree)


                RPAREN815 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_multi_column_for_loop4734)
                if self._state.backtracking == 0:
                    RPAREN815_tree = self._adaptor.createWithPayload(RPAREN815)
                    self._adaptor.addChild(root_0, RPAREN815_tree)



                string_literal816 = self.match(self.input, 99, self.FOLLOW_99_in_multi_column_for_loop4736)
                if self._state.backtracking == 0:
                    string_literal816_tree = self._adaptor.createWithPayload(string_literal816)
                    self._adaptor.addChild(root_0, string_literal816_tree)



                LPAREN817 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_multi_column_for_loop4738)
                if self._state.backtracking == 0:
                    LPAREN817_tree = self._adaptor.createWithPayload(LPAREN817)
                    self._adaptor.addChild(root_0, LPAREN817_tree)



                # ./output/PLSQL3.g:762:49: ( bracket_literals_list | subquery )
                alt212 = 2
                LA212_0 = self.input.LA(1)

                if (LA212_0 == LPAREN) :
                    LA212_1 = self.input.LA(2)

                    if (LA212_1 == MINUS or LA212_1 == NUMBER or LA212_1 == PLUS or LA212_1 == QUOTED_STRING) :
                        alt212 = 1
                    elif (LA212_1 == 147) :
                        alt212 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 212, 1, self.input)

                        raise nvae


                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 212, 0, self.input)

                    raise nvae


                if alt212 == 1:
                    # ./output/PLSQL3.g:762:51: bracket_literals_list
                    pass
                    self._state.following.append(self.FOLLOW_bracket_literals_list_in_multi_column_for_loop4742)
                    bracket_literals_list818 = self.bracket_literals_list()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, bracket_literals_list818.tree)



                elif alt212 == 2:
                    # ./output/PLSQL3.g:762:75: subquery
                    pass
                    self._state.following.append(self.FOLLOW_subquery_in_multi_column_for_loop4746)
                    subquery819 = self.subquery()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, subquery819.tree)





                RPAREN820 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_multi_column_for_loop4750)
                if self._state.backtracking == 0:
                    RPAREN820_tree = self._adaptor.createWithPayload(RPAREN820)
                    self._adaptor.addChild(root_0, RPAREN820_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 129, multi_column_for_loop_StartIndex, success)


            pass
        return retval

    # $ANTLR end "multi_column_for_loop"


    class order_by_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.order_by_clause_return, self).__init__()

            self.tree = None





    # $ANTLR start "order_by_clause"
    # ./output/PLSQL3.g:764:1: order_by_clause : 'ORDER' ( keySIBLINGS )? 'BY' order_by_exprs ;
    def order_by_clause(self, ):
        retval = self.order_by_clause_return()
        retval.start = self.input.LT(1)

        order_by_clause_StartIndex = self.input.index()

        root_0 = None

        string_literal821 = None
        string_literal823 = None
        keySIBLINGS822 = None

        order_by_exprs824 = None


        string_literal821_tree = None
        string_literal823_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 130):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:765:2: ( 'ORDER' ( keySIBLINGS )? 'BY' order_by_exprs )
                # ./output/PLSQL3.g:765:4: 'ORDER' ( keySIBLINGS )? 'BY' order_by_exprs
                pass
                root_0 = self._adaptor.nil()


                string_literal821 = self.match(self.input, 128, self.FOLLOW_128_in_order_by_clause4760)
                if self._state.backtracking == 0:
                    string_literal821_tree = self._adaptor.createWithPayload(string_literal821)
                    self._adaptor.addChild(root_0, string_literal821_tree)



                # ./output/PLSQL3.g:765:12: ( keySIBLINGS )?
                alt213 = 2
                LA213_0 = self.input.LA(1)

                if (LA213_0 == ID) :
                    alt213 = 1
                if alt213 == 1:
                    # ./output/PLSQL3.g:765:14: keySIBLINGS
                    pass
                    self._state.following.append(self.FOLLOW_keySIBLINGS_in_order_by_clause4764)
                    keySIBLINGS822 = self.keySIBLINGS()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keySIBLINGS822.tree)





                string_literal823 = self.match(self.input, 64, self.FOLLOW_64_in_order_by_clause4769)
                if self._state.backtracking == 0:
                    string_literal823_tree = self._adaptor.createWithPayload(string_literal823)
                    self._adaptor.addChild(root_0, string_literal823_tree)



                self._state.following.append(self.FOLLOW_order_by_exprs_in_order_by_clause4771)
                order_by_exprs824 = self.order_by_exprs()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, order_by_exprs824.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 130, order_by_clause_StartIndex, success)


            pass
        return retval

    # $ANTLR end "order_by_clause"


    class order_by_exprs_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.order_by_exprs_return, self).__init__()

            self.tree = None





    # $ANTLR start "order_by_exprs"
    # ./output/PLSQL3.g:767:1: order_by_exprs : order_by_expr ( COMMA order_by_expr )* ;
    def order_by_exprs(self, ):
        retval = self.order_by_exprs_return()
        retval.start = self.input.LT(1)

        order_by_exprs_StartIndex = self.input.index()

        root_0 = None

        COMMA826 = None
        order_by_expr825 = None

        order_by_expr827 = None


        COMMA826_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 131):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:768:2: ( order_by_expr ( COMMA order_by_expr )* )
                # ./output/PLSQL3.g:768:4: order_by_expr ( COMMA order_by_expr )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_order_by_expr_in_order_by_exprs4781)
                order_by_expr825 = self.order_by_expr()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, order_by_expr825.tree)


                # ./output/PLSQL3.g:768:18: ( COMMA order_by_expr )*
                while True: #loop214
                    alt214 = 2
                    LA214_0 = self.input.LA(1)

                    if (LA214_0 == COMMA) :
                        LA214_2 = self.input.LA(2)

                        if (self.synpred343_PLSQL3()) :
                            alt214 = 1




                    if alt214 == 1:
                        # ./output/PLSQL3.g:768:20: COMMA order_by_expr
                        pass
                        COMMA826 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_order_by_exprs4785)
                        if self._state.backtracking == 0:
                            COMMA826_tree = self._adaptor.createWithPayload(COMMA826)
                            self._adaptor.addChild(root_0, COMMA826_tree)



                        self._state.following.append(self.FOLLOW_order_by_expr_in_order_by_exprs4787)
                        order_by_expr827 = self.order_by_expr()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, order_by_expr827.tree)



                    else:
                        break #loop214




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 131, order_by_exprs_StartIndex, success)


            pass
        return retval

    # $ANTLR end "order_by_exprs"


    class order_by_expr_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.order_by_expr_return, self).__init__()

            self.tree = None





    # $ANTLR start "order_by_expr"
    # ./output/PLSQL3.g:770:1: order_by_expr : ( sql_expression ) ( ( 'ASC' | 'DESC' )=> 'ASC' | 'DESC' )? ( keyNULLS keyFIRST | keyNULLS keyLAST )? ;
    def order_by_expr(self, ):
        retval = self.order_by_expr_return()
        retval.start = self.input.LT(1)

        order_by_expr_StartIndex = self.input.index()

        root_0 = None

        string_literal829 = None
        string_literal830 = None
        sql_expression828 = None

        keyNULLS831 = None

        keyFIRST832 = None

        keyNULLS833 = None

        keyLAST834 = None


        string_literal829_tree = None
        string_literal830_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 132):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:771:2: ( ( sql_expression ) ( ( 'ASC' | 'DESC' )=> 'ASC' | 'DESC' )? ( keyNULLS keyFIRST | keyNULLS keyLAST )? )
                # ./output/PLSQL3.g:771:4: ( sql_expression ) ( ( 'ASC' | 'DESC' )=> 'ASC' | 'DESC' )? ( keyNULLS keyFIRST | keyNULLS keyLAST )?
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:771:4: ( sql_expression )
                # ./output/PLSQL3.g:771:6: sql_expression
                pass
                self._state.following.append(self.FOLLOW_sql_expression_in_order_by_expr4802)
                sql_expression828 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression828.tree)





                # ./output/PLSQL3.g:775:3: ( ( 'ASC' | 'DESC' )=> 'ASC' | 'DESC' )?
                alt215 = 3
                LA215_0 = self.input.LA(1)

                if (LA215_0 == 54) :
                    LA215_1 = self.input.LA(2)

                    if (self.synpred345_PLSQL3()) :
                        alt215 = 1
                elif (LA215_0 == 80) :
                    LA215_2 = self.input.LA(2)

                    if (self.synpred346_PLSQL3()) :
                        alt215 = 2
                if alt215 == 1:
                    # ./output/PLSQL3.g:775:5: ( 'ASC' | 'DESC' )=> 'ASC'
                    pass
                    string_literal829 = self.match(self.input, 54, self.FOLLOW_54_in_order_by_expr4825)
                    if self._state.backtracking == 0:
                        string_literal829_tree = self._adaptor.createWithPayload(string_literal829)
                        self._adaptor.addChild(root_0, string_literal829_tree)




                elif alt215 == 2:
                    # ./output/PLSQL3.g:775:34: 'DESC'
                    pass
                    string_literal830 = self.match(self.input, 80, self.FOLLOW_80_in_order_by_expr4829)
                    if self._state.backtracking == 0:
                        string_literal830_tree = self._adaptor.createWithPayload(string_literal830)
                        self._adaptor.addChild(root_0, string_literal830_tree)






                # ./output/PLSQL3.g:775:44: ( keyNULLS keyFIRST | keyNULLS keyLAST )?
                alt216 = 3
                LA216_0 = self.input.LA(1)

                if (LA216_0 == ID) :
                    LA216_1 = self.input.LA(2)

                    if (((((((self.input).LT(1).text.upper() == "NULLS")) and (((this.input).LT(1).text.upper() == "NULLS")))) and (self.synpred347_PLSQL3()))) :
                        alt216 = 1
                    elif (((((((self.input).LT(1).text.upper() == "NULLS")) and (((this.input).LT(1).text.upper() == "NULLS")))) and (self.synpred348_PLSQL3()))) :
                        alt216 = 2
                if alt216 == 1:
                    # ./output/PLSQL3.g:775:46: keyNULLS keyFIRST
                    pass
                    self._state.following.append(self.FOLLOW_keyNULLS_in_order_by_expr4836)
                    keyNULLS831 = self.keyNULLS()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyNULLS831.tree)


                    self._state.following.append(self.FOLLOW_keyFIRST_in_order_by_expr4838)
                    keyFIRST832 = self.keyFIRST()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyFIRST832.tree)



                elif alt216 == 2:
                    # ./output/PLSQL3.g:775:66: keyNULLS keyLAST
                    pass
                    self._state.following.append(self.FOLLOW_keyNULLS_in_order_by_expr4842)
                    keyNULLS833 = self.keyNULLS()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyNULLS833.tree)


                    self._state.following.append(self.FOLLOW_keyLAST_in_order_by_expr4844)
                    keyLAST834 = self.keyLAST()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyLAST834.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 132, order_by_expr_StartIndex, success)


            pass
        return retval

    # $ANTLR end "order_by_expr"


    class for_update_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.for_update_clause_return, self).__init__()

            self.tree = None





    # $ANTLR start "for_update_clause"
    # ./output/PLSQL3.g:777:1: for_update_clause : 'FOR' 'UPDATE' ( 'OF' column_specs )? ( keyWAIT integer | 'NOWAIT' )? ;
    def for_update_clause(self, ):
        retval = self.for_update_clause_return()
        retval.start = self.input.LT(1)

        for_update_clause_StartIndex = self.input.index()

        root_0 = None

        string_literal835 = None
        string_literal836 = None
        string_literal837 = None
        string_literal841 = None
        column_specs838 = None

        keyWAIT839 = None

        integer840 = None


        string_literal835_tree = None
        string_literal836_tree = None
        string_literal837_tree = None
        string_literal841_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 133):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:778:2: ( 'FOR' 'UPDATE' ( 'OF' column_specs )? ( keyWAIT integer | 'NOWAIT' )? )
                # ./output/PLSQL3.g:778:4: 'FOR' 'UPDATE' ( 'OF' column_specs )? ( keyWAIT integer | 'NOWAIT' )?
                pass
                root_0 = self._adaptor.nil()


                string_literal835 = self.match(self.input, 92, self.FOLLOW_92_in_for_update_clause4857)
                if self._state.backtracking == 0:
                    string_literal835_tree = self._adaptor.createWithPayload(string_literal835)
                    self._adaptor.addChild(root_0, string_literal835_tree)



                string_literal836 = self.match(self.input, 159, self.FOLLOW_159_in_for_update_clause4859)
                if self._state.backtracking == 0:
                    string_literal836_tree = self._adaptor.createWithPayload(string_literal836)
                    self._adaptor.addChild(root_0, string_literal836_tree)



                # ./output/PLSQL3.g:778:19: ( 'OF' column_specs )?
                alt217 = 2
                LA217_0 = self.input.LA(1)

                if (LA217_0 == 125) :
                    alt217 = 1
                if alt217 == 1:
                    # ./output/PLSQL3.g:778:21: 'OF' column_specs
                    pass
                    string_literal837 = self.match(self.input, 125, self.FOLLOW_125_in_for_update_clause4863)
                    if self._state.backtracking == 0:
                        string_literal837_tree = self._adaptor.createWithPayload(string_literal837)
                        self._adaptor.addChild(root_0, string_literal837_tree)



                    self._state.following.append(self.FOLLOW_column_specs_in_for_update_clause4865)
                    column_specs838 = self.column_specs()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, column_specs838.tree)





                # ./output/PLSQL3.g:778:42: ( keyWAIT integer | 'NOWAIT' )?
                alt218 = 3
                LA218_0 = self.input.LA(1)

                if (LA218_0 == ID) :
                    alt218 = 1
                elif (LA218_0 == 119) :
                    alt218 = 2
                if alt218 == 1:
                    # ./output/PLSQL3.g:778:44: keyWAIT integer
                    pass
                    self._state.following.append(self.FOLLOW_keyWAIT_in_for_update_clause4872)
                    keyWAIT839 = self.keyWAIT()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyWAIT839.tree)


                    self._state.following.append(self.FOLLOW_integer_in_for_update_clause4874)
                    integer840 = self.integer()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, integer840.tree)



                elif alt218 == 2:
                    # ./output/PLSQL3.g:778:62: 'NOWAIT'
                    pass
                    string_literal841 = self.match(self.input, 119, self.FOLLOW_119_in_for_update_clause4878)
                    if self._state.backtracking == 0:
                        string_literal841_tree = self._adaptor.createWithPayload(string_literal841)
                        self._adaptor.addChild(root_0, string_literal841_tree)








                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 133, for_update_clause_StartIndex, success)


            pass
        return retval

    # $ANTLR end "for_update_clause"


    class where_condition_whole_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.where_condition_whole_return, self).__init__()

            self.tree = None





    # $ANTLR start "where_condition_whole"
    # ./output/PLSQL3.g:781:1: where_condition_whole : 'WHERE' sql_condition ;
    def where_condition_whole(self, ):
        retval = self.where_condition_whole_return()
        retval.start = self.input.LT(1)

        where_condition_whole_StartIndex = self.input.index()

        root_0 = None

        string_literal842 = None
        sql_condition843 = None


        string_literal842_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 134):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:782:2: ( 'WHERE' sql_condition )
                # ./output/PLSQL3.g:782:4: 'WHERE' sql_condition
                pass
                root_0 = self._adaptor.nil()


                string_literal842 = self.match(self.input, 165, self.FOLLOW_165_in_where_condition_whole4892)
                if self._state.backtracking == 0:
                    string_literal842_tree = self._adaptor.createWithPayload(string_literal842)
                    self._adaptor.addChild(root_0, string_literal842_tree)



                self._state.following.append(self.FOLLOW_sql_condition_in_where_condition_whole4894)
                sql_condition843 = self.sql_condition()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_condition843.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 134, where_condition_whole_StartIndex, success)


            pass
        return retval

    # $ANTLR end "where_condition_whole"


    class where_condition_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.where_condition_return, self).__init__()

            self.tree = None





    # $ANTLR start "where_condition"
    # ./output/PLSQL3.g:785:1: where_condition : sql_condition ;
    def where_condition(self, ):
        retval = self.where_condition_return()
        retval.start = self.input.LT(1)

        where_condition_StartIndex = self.input.index()

        root_0 = None

        sql_condition844 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 135):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:786:2: ( sql_condition )
                # ./output/PLSQL3.g:786:4: sql_condition
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_sql_condition_in_where_condition4905)
                sql_condition844 = self.sql_condition()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_condition844.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 135, where_condition_StartIndex, success)


            pass
        return retval

    # $ANTLR end "where_condition"


    class displayed_column_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.displayed_column_return, self).__init__()

            self.tree = None





    # $ANTLR start "displayed_column"
    # ./output/PLSQL3.g:789:1: displayed_column : ( column_spec DOT ASTERISK | sql_expression ) ( alias )? ;
    def displayed_column(self, ):
        retval = self.displayed_column_return()
        retval.start = self.input.LT(1)

        displayed_column_StartIndex = self.input.index()

        root_0 = None

        DOT846 = None
        ASTERISK847 = None
        column_spec845 = None

        sql_expression848 = None

        alias849 = None


        DOT846_tree = None
        ASTERISK847_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 136):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:790:2: ( ( column_spec DOT ASTERISK | sql_expression ) ( alias )? )
                # ./output/PLSQL3.g:790:4: ( column_spec DOT ASTERISK | sql_expression ) ( alias )?
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:790:4: ( column_spec DOT ASTERISK | sql_expression )
                alt219 = 2
                LA219 = self.input.LA(1)
                if LA219 == ID:
                    LA219_1 = self.input.LA(2)

                    if (LA219_1 == DOT) :
                        LA219 = self.input.LA(3)
                        if LA219 == ASTERISK:
                            alt219 = 1
                        elif LA219 == LPAREN or LA219 == MINUS or LA219 == NUMBER or LA219 == PLUS or LA219 == QUOTED_STRING or LA219 == 65 or LA219 == 79 or LA219 == 81 or LA219 == 88 or LA219 == 89 or LA219 == 118 or LA219 == 120 or LA219 == 134 or LA219 == 147 or LA219 == 151 or LA219 == 156:
                            alt219 = 2
                        elif LA219 == ID:
                            LA219_7 = self.input.LA(4)

                            if (LA219_7 == DOT) :
                                LA219 = self.input.LA(5)
                                if LA219 == ASTERISK:
                                    alt219 = 1
                                elif LA219 == LPAREN or LA219 == MINUS or LA219 == NUMBER or LA219 == PLUS or LA219 == QUOTED_STRING or LA219 == 65 or LA219 == 79 or LA219 == 81 or LA219 == 88 or LA219 == 89 or LA219 == 118 or LA219 == 120 or LA219 == 134 or LA219 == 147 or LA219 == 151 or LA219 == 156:
                                    alt219 = 2
                                elif LA219 == ID:
                                    LA219_11 = self.input.LA(6)

                                    if (LA219_11 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_11 == EOF or LA219_11 == ASTERISK or LA219_11 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_11 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_11 <= ISOPEN_ATTR) or LA219_11 == LEQ or (LPAREN <= LA219_11 <= MINUS) or (NOTFOUND_ATTR <= LA219_11 <= NOT_EQ) or LA219_11 == PLUS or LA219_11 == ROWCOUNT_ATTR or LA219_11 == 51 or LA219_11 == 53 or LA219_11 == 57 or LA219_11 == 93 or LA219_11 == 99 or (105 <= LA219_11 <= 107) or LA219_11 == 118 or LA219_11 == 127 or LA219_11 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 11, self.input)

                                        raise nvae


                                elif LA219 == 144:
                                    LA219_12 = self.input.LA(6)

                                    if (LA219_12 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_12 == EOF or LA219_12 == ASTERISK or LA219_12 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_12 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_12 <= ISOPEN_ATTR) or LA219_12 == LEQ or (LPAREN <= LA219_12 <= MINUS) or (NOTFOUND_ATTR <= LA219_12 <= NOT_EQ) or LA219_12 == PLUS or LA219_12 == ROWCOUNT_ATTR or LA219_12 == 51 or LA219_12 == 53 or LA219_12 == 57 or LA219_12 == 93 or LA219_12 == 99 or (105 <= LA219_12 <= 107) or LA219_12 == 118 or LA219_12 == 127 or LA219_12 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 12, self.input)

                                        raise nvae


                                elif LA219 == DOUBLEQUOTED_STRING:
                                    LA219_13 = self.input.LA(6)

                                    if (LA219_13 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_13 == EOF or LA219_13 == ASTERISK or LA219_13 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_13 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_13 <= ISOPEN_ATTR) or LA219_13 == LEQ or (LPAREN <= LA219_13 <= MINUS) or (NOTFOUND_ATTR <= LA219_13 <= NOT_EQ) or LA219_13 == PLUS or LA219_13 == ROWCOUNT_ATTR or LA219_13 == 51 or LA219_13 == 53 or LA219_13 == 57 or LA219_13 == 93 or LA219_13 == 99 or (105 <= LA219_13 <= 107) or LA219_13 == 118 or LA219_13 == 127 or LA219_13 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 13, self.input)

                                        raise nvae


                                else:
                                    if self._state.backtracking > 0:
                                        raise BacktrackingFailed


                                    nvae = NoViableAltException("", 219, 10, self.input)

                                    raise nvae


                            elif (LA219_7 == EOF or LA219_7 == ASTERISK or LA219_7 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_7 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_7 <= ISOPEN_ATTR) or LA219_7 == LEQ or (LPAREN <= LA219_7 <= MINUS) or (NOTFOUND_ATTR <= LA219_7 <= NOT_EQ) or LA219_7 == PLUS or LA219_7 == ROWCOUNT_ATTR or LA219_7 == 51 or LA219_7 == 53 or LA219_7 == 57 or LA219_7 == 93 or LA219_7 == 99 or (105 <= LA219_7 <= 107) or LA219_7 == 118 or LA219_7 == 127 or LA219_7 == 144) :
                                alt219 = 2
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 219, 7, self.input)

                                raise nvae


                        elif LA219 == 144:
                            LA219_8 = self.input.LA(4)

                            if (LA219_8 == DOT) :
                                LA219 = self.input.LA(5)
                                if LA219 == ASTERISK:
                                    alt219 = 1
                                elif LA219 == LPAREN or LA219 == MINUS or LA219 == NUMBER or LA219 == PLUS or LA219 == QUOTED_STRING or LA219 == 65 or LA219 == 79 or LA219 == 81 or LA219 == 88 or LA219 == 89 or LA219 == 118 or LA219 == 120 or LA219 == 134 or LA219 == 147 or LA219 == 151 or LA219 == 156:
                                    alt219 = 2
                                elif LA219 == ID:
                                    LA219_11 = self.input.LA(6)

                                    if (LA219_11 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_11 == EOF or LA219_11 == ASTERISK or LA219_11 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_11 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_11 <= ISOPEN_ATTR) or LA219_11 == LEQ or (LPAREN <= LA219_11 <= MINUS) or (NOTFOUND_ATTR <= LA219_11 <= NOT_EQ) or LA219_11 == PLUS or LA219_11 == ROWCOUNT_ATTR or LA219_11 == 51 or LA219_11 == 53 or LA219_11 == 57 or LA219_11 == 93 or LA219_11 == 99 or (105 <= LA219_11 <= 107) or LA219_11 == 118 or LA219_11 == 127 or LA219_11 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 11, self.input)

                                        raise nvae


                                elif LA219 == 144:
                                    LA219_12 = self.input.LA(6)

                                    if (LA219_12 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_12 == EOF or LA219_12 == ASTERISK or LA219_12 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_12 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_12 <= ISOPEN_ATTR) or LA219_12 == LEQ or (LPAREN <= LA219_12 <= MINUS) or (NOTFOUND_ATTR <= LA219_12 <= NOT_EQ) or LA219_12 == PLUS or LA219_12 == ROWCOUNT_ATTR or LA219_12 == 51 or LA219_12 == 53 or LA219_12 == 57 or LA219_12 == 93 or LA219_12 == 99 or (105 <= LA219_12 <= 107) or LA219_12 == 118 or LA219_12 == 127 or LA219_12 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 12, self.input)

                                        raise nvae


                                elif LA219 == DOUBLEQUOTED_STRING:
                                    LA219_13 = self.input.LA(6)

                                    if (LA219_13 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_13 == EOF or LA219_13 == ASTERISK or LA219_13 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_13 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_13 <= ISOPEN_ATTR) or LA219_13 == LEQ or (LPAREN <= LA219_13 <= MINUS) or (NOTFOUND_ATTR <= LA219_13 <= NOT_EQ) or LA219_13 == PLUS or LA219_13 == ROWCOUNT_ATTR or LA219_13 == 51 or LA219_13 == 53 or LA219_13 == 57 or LA219_13 == 93 or LA219_13 == 99 or (105 <= LA219_13 <= 107) or LA219_13 == 118 or LA219_13 == 127 or LA219_13 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 13, self.input)

                                        raise nvae


                                else:
                                    if self._state.backtracking > 0:
                                        raise BacktrackingFailed


                                    nvae = NoViableAltException("", 219, 10, self.input)

                                    raise nvae


                            elif (LA219_8 == EOF or LA219_8 == ASTERISK or LA219_8 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_8 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_8 <= ISOPEN_ATTR) or LA219_8 == LEQ or (LPAREN <= LA219_8 <= MINUS) or (NOTFOUND_ATTR <= LA219_8 <= NOT_EQ) or LA219_8 == PLUS or LA219_8 == ROWCOUNT_ATTR or LA219_8 == 51 or LA219_8 == 53 or LA219_8 == 57 or LA219_8 == 93 or LA219_8 == 99 or (105 <= LA219_8 <= 107) or LA219_8 == 118 or LA219_8 == 127 or LA219_8 == 144) :
                                alt219 = 2
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 219, 8, self.input)

                                raise nvae


                        elif LA219 == DOUBLEQUOTED_STRING:
                            LA219_9 = self.input.LA(4)

                            if (LA219_9 == DOT) :
                                LA219 = self.input.LA(5)
                                if LA219 == ASTERISK:
                                    alt219 = 1
                                elif LA219 == LPAREN or LA219 == MINUS or LA219 == NUMBER or LA219 == PLUS or LA219 == QUOTED_STRING or LA219 == 65 or LA219 == 79 or LA219 == 81 or LA219 == 88 or LA219 == 89 or LA219 == 118 or LA219 == 120 or LA219 == 134 or LA219 == 147 or LA219 == 151 or LA219 == 156:
                                    alt219 = 2
                                elif LA219 == ID:
                                    LA219_11 = self.input.LA(6)

                                    if (LA219_11 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_11 == EOF or LA219_11 == ASTERISK or LA219_11 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_11 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_11 <= ISOPEN_ATTR) or LA219_11 == LEQ or (LPAREN <= LA219_11 <= MINUS) or (NOTFOUND_ATTR <= LA219_11 <= NOT_EQ) or LA219_11 == PLUS or LA219_11 == ROWCOUNT_ATTR or LA219_11 == 51 or LA219_11 == 53 or LA219_11 == 57 or LA219_11 == 93 or LA219_11 == 99 or (105 <= LA219_11 <= 107) or LA219_11 == 118 or LA219_11 == 127 or LA219_11 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 11, self.input)

                                        raise nvae


                                elif LA219 == 144:
                                    LA219_12 = self.input.LA(6)

                                    if (LA219_12 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_12 == EOF or LA219_12 == ASTERISK or LA219_12 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_12 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_12 <= ISOPEN_ATTR) or LA219_12 == LEQ or (LPAREN <= LA219_12 <= MINUS) or (NOTFOUND_ATTR <= LA219_12 <= NOT_EQ) or LA219_12 == PLUS or LA219_12 == ROWCOUNT_ATTR or LA219_12 == 51 or LA219_12 == 53 or LA219_12 == 57 or LA219_12 == 93 or LA219_12 == 99 or (105 <= LA219_12 <= 107) or LA219_12 == 118 or LA219_12 == 127 or LA219_12 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 12, self.input)

                                        raise nvae


                                elif LA219 == DOUBLEQUOTED_STRING:
                                    LA219_13 = self.input.LA(6)

                                    if (LA219_13 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_13 == EOF or LA219_13 == ASTERISK or LA219_13 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_13 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_13 <= ISOPEN_ATTR) or LA219_13 == LEQ or (LPAREN <= LA219_13 <= MINUS) or (NOTFOUND_ATTR <= LA219_13 <= NOT_EQ) or LA219_13 == PLUS or LA219_13 == ROWCOUNT_ATTR or LA219_13 == 51 or LA219_13 == 53 or LA219_13 == 57 or LA219_13 == 93 or LA219_13 == 99 or (105 <= LA219_13 <= 107) or LA219_13 == 118 or LA219_13 == 127 or LA219_13 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 13, self.input)

                                        raise nvae


                                else:
                                    if self._state.backtracking > 0:
                                        raise BacktrackingFailed


                                    nvae = NoViableAltException("", 219, 10, self.input)

                                    raise nvae


                            elif (LA219_9 == EOF or LA219_9 == ASTERISK or LA219_9 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_9 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_9 <= ISOPEN_ATTR) or LA219_9 == LEQ or (LPAREN <= LA219_9 <= MINUS) or (NOTFOUND_ATTR <= LA219_9 <= NOT_EQ) or LA219_9 == PLUS or LA219_9 == ROWCOUNT_ATTR or LA219_9 == 51 or LA219_9 == 53 or LA219_9 == 57 or LA219_9 == 93 or LA219_9 == 99 or (105 <= LA219_9 <= 107) or LA219_9 == 118 or LA219_9 == 127 or LA219_9 == 144) :
                                alt219 = 2
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 219, 9, self.input)

                                raise nvae


                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 219, 5, self.input)

                            raise nvae


                    elif (LA219_1 == EOF or LA219_1 == ASTERISK or (COMMA <= LA219_1 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_1 <= DOUBLEVERTBAR) or LA219_1 == EXPONENT or LA219_1 == ID or LA219_1 == LPAREN or LA219_1 == MINUS or LA219_1 == PLUS or LA219_1 == 53 or LA219_1 == 93 or LA219_1 == 105 or LA219_1 == 144) :
                        alt219 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 219, 1, self.input)

                        raise nvae


                elif LA219 == 144:
                    LA219_2 = self.input.LA(2)

                    if (LA219_2 == DOT) :
                        LA219 = self.input.LA(3)
                        if LA219 == ASTERISK:
                            alt219 = 1
                        elif LA219 == LPAREN or LA219 == MINUS or LA219 == NUMBER or LA219 == PLUS or LA219 == QUOTED_STRING or LA219 == 65 or LA219 == 79 or LA219 == 81 or LA219 == 88 or LA219 == 89 or LA219 == 118 or LA219 == 120 or LA219 == 134 or LA219 == 147 or LA219 == 151 or LA219 == 156:
                            alt219 = 2
                        elif LA219 == ID:
                            LA219_7 = self.input.LA(4)

                            if (LA219_7 == DOT) :
                                LA219 = self.input.LA(5)
                                if LA219 == ASTERISK:
                                    alt219 = 1
                                elif LA219 == LPAREN or LA219 == MINUS or LA219 == NUMBER or LA219 == PLUS or LA219 == QUOTED_STRING or LA219 == 65 or LA219 == 79 or LA219 == 81 or LA219 == 88 or LA219 == 89 or LA219 == 118 or LA219 == 120 or LA219 == 134 or LA219 == 147 or LA219 == 151 or LA219 == 156:
                                    alt219 = 2
                                elif LA219 == ID:
                                    LA219_11 = self.input.LA(6)

                                    if (LA219_11 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_11 == EOF or LA219_11 == ASTERISK or LA219_11 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_11 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_11 <= ISOPEN_ATTR) or LA219_11 == LEQ or (LPAREN <= LA219_11 <= MINUS) or (NOTFOUND_ATTR <= LA219_11 <= NOT_EQ) or LA219_11 == PLUS or LA219_11 == ROWCOUNT_ATTR or LA219_11 == 51 or LA219_11 == 53 or LA219_11 == 57 or LA219_11 == 93 or LA219_11 == 99 or (105 <= LA219_11 <= 107) or LA219_11 == 118 or LA219_11 == 127 or LA219_11 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 11, self.input)

                                        raise nvae


                                elif LA219 == 144:
                                    LA219_12 = self.input.LA(6)

                                    if (LA219_12 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_12 == EOF or LA219_12 == ASTERISK or LA219_12 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_12 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_12 <= ISOPEN_ATTR) or LA219_12 == LEQ or (LPAREN <= LA219_12 <= MINUS) or (NOTFOUND_ATTR <= LA219_12 <= NOT_EQ) or LA219_12 == PLUS or LA219_12 == ROWCOUNT_ATTR or LA219_12 == 51 or LA219_12 == 53 or LA219_12 == 57 or LA219_12 == 93 or LA219_12 == 99 or (105 <= LA219_12 <= 107) or LA219_12 == 118 or LA219_12 == 127 or LA219_12 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 12, self.input)

                                        raise nvae


                                elif LA219 == DOUBLEQUOTED_STRING:
                                    LA219_13 = self.input.LA(6)

                                    if (LA219_13 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_13 == EOF or LA219_13 == ASTERISK or LA219_13 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_13 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_13 <= ISOPEN_ATTR) or LA219_13 == LEQ or (LPAREN <= LA219_13 <= MINUS) or (NOTFOUND_ATTR <= LA219_13 <= NOT_EQ) or LA219_13 == PLUS or LA219_13 == ROWCOUNT_ATTR or LA219_13 == 51 or LA219_13 == 53 or LA219_13 == 57 or LA219_13 == 93 or LA219_13 == 99 or (105 <= LA219_13 <= 107) or LA219_13 == 118 or LA219_13 == 127 or LA219_13 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 13, self.input)

                                        raise nvae


                                else:
                                    if self._state.backtracking > 0:
                                        raise BacktrackingFailed


                                    nvae = NoViableAltException("", 219, 10, self.input)

                                    raise nvae


                            elif (LA219_7 == EOF or LA219_7 == ASTERISK or LA219_7 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_7 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_7 <= ISOPEN_ATTR) or LA219_7 == LEQ or (LPAREN <= LA219_7 <= MINUS) or (NOTFOUND_ATTR <= LA219_7 <= NOT_EQ) or LA219_7 == PLUS or LA219_7 == ROWCOUNT_ATTR or LA219_7 == 51 or LA219_7 == 53 or LA219_7 == 57 or LA219_7 == 93 or LA219_7 == 99 or (105 <= LA219_7 <= 107) or LA219_7 == 118 or LA219_7 == 127 or LA219_7 == 144) :
                                alt219 = 2
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 219, 7, self.input)

                                raise nvae


                        elif LA219 == 144:
                            LA219_8 = self.input.LA(4)

                            if (LA219_8 == DOT) :
                                LA219 = self.input.LA(5)
                                if LA219 == ASTERISK:
                                    alt219 = 1
                                elif LA219 == LPAREN or LA219 == MINUS or LA219 == NUMBER or LA219 == PLUS or LA219 == QUOTED_STRING or LA219 == 65 or LA219 == 79 or LA219 == 81 or LA219 == 88 or LA219 == 89 or LA219 == 118 or LA219 == 120 or LA219 == 134 or LA219 == 147 or LA219 == 151 or LA219 == 156:
                                    alt219 = 2
                                elif LA219 == ID:
                                    LA219_11 = self.input.LA(6)

                                    if (LA219_11 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_11 == EOF or LA219_11 == ASTERISK or LA219_11 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_11 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_11 <= ISOPEN_ATTR) or LA219_11 == LEQ or (LPAREN <= LA219_11 <= MINUS) or (NOTFOUND_ATTR <= LA219_11 <= NOT_EQ) or LA219_11 == PLUS or LA219_11 == ROWCOUNT_ATTR or LA219_11 == 51 or LA219_11 == 53 or LA219_11 == 57 or LA219_11 == 93 or LA219_11 == 99 or (105 <= LA219_11 <= 107) or LA219_11 == 118 or LA219_11 == 127 or LA219_11 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 11, self.input)

                                        raise nvae


                                elif LA219 == 144:
                                    LA219_12 = self.input.LA(6)

                                    if (LA219_12 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_12 == EOF or LA219_12 == ASTERISK or LA219_12 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_12 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_12 <= ISOPEN_ATTR) or LA219_12 == LEQ or (LPAREN <= LA219_12 <= MINUS) or (NOTFOUND_ATTR <= LA219_12 <= NOT_EQ) or LA219_12 == PLUS or LA219_12 == ROWCOUNT_ATTR or LA219_12 == 51 or LA219_12 == 53 or LA219_12 == 57 or LA219_12 == 93 or LA219_12 == 99 or (105 <= LA219_12 <= 107) or LA219_12 == 118 or LA219_12 == 127 or LA219_12 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 12, self.input)

                                        raise nvae


                                elif LA219 == DOUBLEQUOTED_STRING:
                                    LA219_13 = self.input.LA(6)

                                    if (LA219_13 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_13 == EOF or LA219_13 == ASTERISK or LA219_13 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_13 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_13 <= ISOPEN_ATTR) or LA219_13 == LEQ or (LPAREN <= LA219_13 <= MINUS) or (NOTFOUND_ATTR <= LA219_13 <= NOT_EQ) or LA219_13 == PLUS or LA219_13 == ROWCOUNT_ATTR or LA219_13 == 51 or LA219_13 == 53 or LA219_13 == 57 or LA219_13 == 93 or LA219_13 == 99 or (105 <= LA219_13 <= 107) or LA219_13 == 118 or LA219_13 == 127 or LA219_13 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 13, self.input)

                                        raise nvae


                                else:
                                    if self._state.backtracking > 0:
                                        raise BacktrackingFailed


                                    nvae = NoViableAltException("", 219, 10, self.input)

                                    raise nvae


                            elif (LA219_8 == EOF or LA219_8 == ASTERISK or LA219_8 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_8 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_8 <= ISOPEN_ATTR) or LA219_8 == LEQ or (LPAREN <= LA219_8 <= MINUS) or (NOTFOUND_ATTR <= LA219_8 <= NOT_EQ) or LA219_8 == PLUS or LA219_8 == ROWCOUNT_ATTR or LA219_8 == 51 or LA219_8 == 53 or LA219_8 == 57 or LA219_8 == 93 or LA219_8 == 99 or (105 <= LA219_8 <= 107) or LA219_8 == 118 or LA219_8 == 127 or LA219_8 == 144) :
                                alt219 = 2
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 219, 8, self.input)

                                raise nvae


                        elif LA219 == DOUBLEQUOTED_STRING:
                            LA219_9 = self.input.LA(4)

                            if (LA219_9 == DOT) :
                                LA219 = self.input.LA(5)
                                if LA219 == ASTERISK:
                                    alt219 = 1
                                elif LA219 == LPAREN or LA219 == MINUS or LA219 == NUMBER or LA219 == PLUS or LA219 == QUOTED_STRING or LA219 == 65 or LA219 == 79 or LA219 == 81 or LA219 == 88 or LA219 == 89 or LA219 == 118 or LA219 == 120 or LA219 == 134 or LA219 == 147 or LA219 == 151 or LA219 == 156:
                                    alt219 = 2
                                elif LA219 == ID:
                                    LA219_11 = self.input.LA(6)

                                    if (LA219_11 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_11 == EOF or LA219_11 == ASTERISK or LA219_11 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_11 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_11 <= ISOPEN_ATTR) or LA219_11 == LEQ or (LPAREN <= LA219_11 <= MINUS) or (NOTFOUND_ATTR <= LA219_11 <= NOT_EQ) or LA219_11 == PLUS or LA219_11 == ROWCOUNT_ATTR or LA219_11 == 51 or LA219_11 == 53 or LA219_11 == 57 or LA219_11 == 93 or LA219_11 == 99 or (105 <= LA219_11 <= 107) or LA219_11 == 118 or LA219_11 == 127 or LA219_11 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 11, self.input)

                                        raise nvae


                                elif LA219 == 144:
                                    LA219_12 = self.input.LA(6)

                                    if (LA219_12 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_12 == EOF or LA219_12 == ASTERISK or LA219_12 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_12 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_12 <= ISOPEN_ATTR) or LA219_12 == LEQ or (LPAREN <= LA219_12 <= MINUS) or (NOTFOUND_ATTR <= LA219_12 <= NOT_EQ) or LA219_12 == PLUS or LA219_12 == ROWCOUNT_ATTR or LA219_12 == 51 or LA219_12 == 53 or LA219_12 == 57 or LA219_12 == 93 or LA219_12 == 99 or (105 <= LA219_12 <= 107) or LA219_12 == 118 or LA219_12 == 127 or LA219_12 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 12, self.input)

                                        raise nvae


                                elif LA219 == DOUBLEQUOTED_STRING:
                                    LA219_13 = self.input.LA(6)

                                    if (LA219_13 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_13 == EOF or LA219_13 == ASTERISK or LA219_13 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_13 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_13 <= ISOPEN_ATTR) or LA219_13 == LEQ or (LPAREN <= LA219_13 <= MINUS) or (NOTFOUND_ATTR <= LA219_13 <= NOT_EQ) or LA219_13 == PLUS or LA219_13 == ROWCOUNT_ATTR or LA219_13 == 51 or LA219_13 == 53 or LA219_13 == 57 or LA219_13 == 93 or LA219_13 == 99 or (105 <= LA219_13 <= 107) or LA219_13 == 118 or LA219_13 == 127 or LA219_13 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 13, self.input)

                                        raise nvae


                                else:
                                    if self._state.backtracking > 0:
                                        raise BacktrackingFailed


                                    nvae = NoViableAltException("", 219, 10, self.input)

                                    raise nvae


                            elif (LA219_9 == EOF or LA219_9 == ASTERISK or LA219_9 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_9 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_9 <= ISOPEN_ATTR) or LA219_9 == LEQ or (LPAREN <= LA219_9 <= MINUS) or (NOTFOUND_ATTR <= LA219_9 <= NOT_EQ) or LA219_9 == PLUS or LA219_9 == ROWCOUNT_ATTR or LA219_9 == 51 or LA219_9 == 53 or LA219_9 == 57 or LA219_9 == 93 or LA219_9 == 99 or (105 <= LA219_9 <= 107) or LA219_9 == 118 or LA219_9 == 127 or LA219_9 == 144) :
                                alt219 = 2
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 219, 9, self.input)

                                raise nvae


                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 219, 5, self.input)

                            raise nvae


                    elif (LA219_2 == EOF or LA219_2 == ASTERISK or (COMMA <= LA219_2 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_2 <= DOUBLEVERTBAR) or LA219_2 == EXPONENT or LA219_2 == ID or LA219_2 == LPAREN or LA219_2 == MINUS or LA219_2 == PLUS or LA219_2 == 53 or LA219_2 == 93 or LA219_2 == 105 or LA219_2 == 144) :
                        alt219 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 219, 2, self.input)

                        raise nvae


                elif LA219 == LPAREN or LA219 == MINUS or LA219 == NUMBER or LA219 == PLUS or LA219 == QUOTED_STRING or LA219 == 65 or LA219 == 81 or LA219 == 89 or LA219 == 120 or LA219 == 147 or LA219 == 151 or LA219 == 156:
                    alt219 = 2
                elif LA219 == DOUBLEQUOTED_STRING:
                    LA219_4 = self.input.LA(2)

                    if (LA219_4 == DOT) :
                        LA219 = self.input.LA(3)
                        if LA219 == ASTERISK:
                            alt219 = 1
                        elif LA219 == LPAREN or LA219 == MINUS or LA219 == NUMBER or LA219 == PLUS or LA219 == QUOTED_STRING or LA219 == 65 or LA219 == 79 or LA219 == 81 or LA219 == 88 or LA219 == 89 or LA219 == 118 or LA219 == 120 or LA219 == 134 or LA219 == 147 or LA219 == 151 or LA219 == 156:
                            alt219 = 2
                        elif LA219 == ID:
                            LA219_7 = self.input.LA(4)

                            if (LA219_7 == DOT) :
                                LA219 = self.input.LA(5)
                                if LA219 == ASTERISK:
                                    alt219 = 1
                                elif LA219 == LPAREN or LA219 == MINUS or LA219 == NUMBER or LA219 == PLUS or LA219 == QUOTED_STRING or LA219 == 65 or LA219 == 79 or LA219 == 81 or LA219 == 88 or LA219 == 89 or LA219 == 118 or LA219 == 120 or LA219 == 134 or LA219 == 147 or LA219 == 151 or LA219 == 156:
                                    alt219 = 2
                                elif LA219 == ID:
                                    LA219_11 = self.input.LA(6)

                                    if (LA219_11 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_11 == EOF or LA219_11 == ASTERISK or LA219_11 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_11 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_11 <= ISOPEN_ATTR) or LA219_11 == LEQ or (LPAREN <= LA219_11 <= MINUS) or (NOTFOUND_ATTR <= LA219_11 <= NOT_EQ) or LA219_11 == PLUS or LA219_11 == ROWCOUNT_ATTR or LA219_11 == 51 or LA219_11 == 53 or LA219_11 == 57 or LA219_11 == 93 or LA219_11 == 99 or (105 <= LA219_11 <= 107) or LA219_11 == 118 or LA219_11 == 127 or LA219_11 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 11, self.input)

                                        raise nvae


                                elif LA219 == 144:
                                    LA219_12 = self.input.LA(6)

                                    if (LA219_12 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_12 == EOF or LA219_12 == ASTERISK or LA219_12 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_12 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_12 <= ISOPEN_ATTR) or LA219_12 == LEQ or (LPAREN <= LA219_12 <= MINUS) or (NOTFOUND_ATTR <= LA219_12 <= NOT_EQ) or LA219_12 == PLUS or LA219_12 == ROWCOUNT_ATTR or LA219_12 == 51 or LA219_12 == 53 or LA219_12 == 57 or LA219_12 == 93 or LA219_12 == 99 or (105 <= LA219_12 <= 107) or LA219_12 == 118 or LA219_12 == 127 or LA219_12 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 12, self.input)

                                        raise nvae


                                elif LA219 == DOUBLEQUOTED_STRING:
                                    LA219_13 = self.input.LA(6)

                                    if (LA219_13 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_13 == EOF or LA219_13 == ASTERISK or LA219_13 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_13 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_13 <= ISOPEN_ATTR) or LA219_13 == LEQ or (LPAREN <= LA219_13 <= MINUS) or (NOTFOUND_ATTR <= LA219_13 <= NOT_EQ) or LA219_13 == PLUS or LA219_13 == ROWCOUNT_ATTR or LA219_13 == 51 or LA219_13 == 53 or LA219_13 == 57 or LA219_13 == 93 or LA219_13 == 99 or (105 <= LA219_13 <= 107) or LA219_13 == 118 or LA219_13 == 127 or LA219_13 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 13, self.input)

                                        raise nvae


                                else:
                                    if self._state.backtracking > 0:
                                        raise BacktrackingFailed


                                    nvae = NoViableAltException("", 219, 10, self.input)

                                    raise nvae


                            elif (LA219_7 == EOF or LA219_7 == ASTERISK or LA219_7 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_7 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_7 <= ISOPEN_ATTR) or LA219_7 == LEQ or (LPAREN <= LA219_7 <= MINUS) or (NOTFOUND_ATTR <= LA219_7 <= NOT_EQ) or LA219_7 == PLUS or LA219_7 == ROWCOUNT_ATTR or LA219_7 == 51 or LA219_7 == 53 or LA219_7 == 57 or LA219_7 == 93 or LA219_7 == 99 or (105 <= LA219_7 <= 107) or LA219_7 == 118 or LA219_7 == 127 or LA219_7 == 144) :
                                alt219 = 2
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 219, 7, self.input)

                                raise nvae


                        elif LA219 == 144:
                            LA219_8 = self.input.LA(4)

                            if (LA219_8 == DOT) :
                                LA219 = self.input.LA(5)
                                if LA219 == ASTERISK:
                                    alt219 = 1
                                elif LA219 == LPAREN or LA219 == MINUS or LA219 == NUMBER or LA219 == PLUS or LA219 == QUOTED_STRING or LA219 == 65 or LA219 == 79 or LA219 == 81 or LA219 == 88 or LA219 == 89 or LA219 == 118 or LA219 == 120 or LA219 == 134 or LA219 == 147 or LA219 == 151 or LA219 == 156:
                                    alt219 = 2
                                elif LA219 == ID:
                                    LA219_11 = self.input.LA(6)

                                    if (LA219_11 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_11 == EOF or LA219_11 == ASTERISK or LA219_11 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_11 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_11 <= ISOPEN_ATTR) or LA219_11 == LEQ or (LPAREN <= LA219_11 <= MINUS) or (NOTFOUND_ATTR <= LA219_11 <= NOT_EQ) or LA219_11 == PLUS or LA219_11 == ROWCOUNT_ATTR or LA219_11 == 51 or LA219_11 == 53 or LA219_11 == 57 or LA219_11 == 93 or LA219_11 == 99 or (105 <= LA219_11 <= 107) or LA219_11 == 118 or LA219_11 == 127 or LA219_11 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 11, self.input)

                                        raise nvae


                                elif LA219 == 144:
                                    LA219_12 = self.input.LA(6)

                                    if (LA219_12 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_12 == EOF or LA219_12 == ASTERISK or LA219_12 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_12 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_12 <= ISOPEN_ATTR) or LA219_12 == LEQ or (LPAREN <= LA219_12 <= MINUS) or (NOTFOUND_ATTR <= LA219_12 <= NOT_EQ) or LA219_12 == PLUS or LA219_12 == ROWCOUNT_ATTR or LA219_12 == 51 or LA219_12 == 53 or LA219_12 == 57 or LA219_12 == 93 or LA219_12 == 99 or (105 <= LA219_12 <= 107) or LA219_12 == 118 or LA219_12 == 127 or LA219_12 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 12, self.input)

                                        raise nvae


                                elif LA219 == DOUBLEQUOTED_STRING:
                                    LA219_13 = self.input.LA(6)

                                    if (LA219_13 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_13 == EOF or LA219_13 == ASTERISK or LA219_13 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_13 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_13 <= ISOPEN_ATTR) or LA219_13 == LEQ or (LPAREN <= LA219_13 <= MINUS) or (NOTFOUND_ATTR <= LA219_13 <= NOT_EQ) or LA219_13 == PLUS or LA219_13 == ROWCOUNT_ATTR or LA219_13 == 51 or LA219_13 == 53 or LA219_13 == 57 or LA219_13 == 93 or LA219_13 == 99 or (105 <= LA219_13 <= 107) or LA219_13 == 118 or LA219_13 == 127 or LA219_13 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 13, self.input)

                                        raise nvae


                                else:
                                    if self._state.backtracking > 0:
                                        raise BacktrackingFailed


                                    nvae = NoViableAltException("", 219, 10, self.input)

                                    raise nvae


                            elif (LA219_8 == EOF or LA219_8 == ASTERISK or LA219_8 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_8 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_8 <= ISOPEN_ATTR) or LA219_8 == LEQ or (LPAREN <= LA219_8 <= MINUS) or (NOTFOUND_ATTR <= LA219_8 <= NOT_EQ) or LA219_8 == PLUS or LA219_8 == ROWCOUNT_ATTR or LA219_8 == 51 or LA219_8 == 53 or LA219_8 == 57 or LA219_8 == 93 or LA219_8 == 99 or (105 <= LA219_8 <= 107) or LA219_8 == 118 or LA219_8 == 127 or LA219_8 == 144) :
                                alt219 = 2
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 219, 8, self.input)

                                raise nvae


                        elif LA219 == DOUBLEQUOTED_STRING:
                            LA219_9 = self.input.LA(4)

                            if (LA219_9 == DOT) :
                                LA219 = self.input.LA(5)
                                if LA219 == ASTERISK:
                                    alt219 = 1
                                elif LA219 == LPAREN or LA219 == MINUS or LA219 == NUMBER or LA219 == PLUS or LA219 == QUOTED_STRING or LA219 == 65 or LA219 == 79 or LA219 == 81 or LA219 == 88 or LA219 == 89 or LA219 == 118 or LA219 == 120 or LA219 == 134 or LA219 == 147 or LA219 == 151 or LA219 == 156:
                                    alt219 = 2
                                elif LA219 == ID:
                                    LA219_11 = self.input.LA(6)

                                    if (LA219_11 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_11 == EOF or LA219_11 == ASTERISK or LA219_11 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_11 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_11 <= ISOPEN_ATTR) or LA219_11 == LEQ or (LPAREN <= LA219_11 <= MINUS) or (NOTFOUND_ATTR <= LA219_11 <= NOT_EQ) or LA219_11 == PLUS or LA219_11 == ROWCOUNT_ATTR or LA219_11 == 51 or LA219_11 == 53 or LA219_11 == 57 or LA219_11 == 93 or LA219_11 == 99 or (105 <= LA219_11 <= 107) or LA219_11 == 118 or LA219_11 == 127 or LA219_11 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 11, self.input)

                                        raise nvae


                                elif LA219 == 144:
                                    LA219_12 = self.input.LA(6)

                                    if (LA219_12 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_12 == EOF or LA219_12 == ASTERISK or LA219_12 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_12 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_12 <= ISOPEN_ATTR) or LA219_12 == LEQ or (LPAREN <= LA219_12 <= MINUS) or (NOTFOUND_ATTR <= LA219_12 <= NOT_EQ) or LA219_12 == PLUS or LA219_12 == ROWCOUNT_ATTR or LA219_12 == 51 or LA219_12 == 53 or LA219_12 == 57 or LA219_12 == 93 or LA219_12 == 99 or (105 <= LA219_12 <= 107) or LA219_12 == 118 or LA219_12 == 127 or LA219_12 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 12, self.input)

                                        raise nvae


                                elif LA219 == DOUBLEQUOTED_STRING:
                                    LA219_13 = self.input.LA(6)

                                    if (LA219_13 == DOT) :
                                        LA219_14 = self.input.LA(7)

                                        if (LA219_14 == ASTERISK) :
                                            alt219 = 1
                                        elif (LA219_14 == DOUBLEQUOTED_STRING or LA219_14 == ID or LA219_14 == LPAREN or LA219_14 == MINUS or LA219_14 == NUMBER or LA219_14 == PLUS or LA219_14 == QUOTED_STRING or LA219_14 == 65 or LA219_14 == 79 or LA219_14 == 81 or (88 <= LA219_14 <= 89) or LA219_14 == 118 or LA219_14 == 120 or LA219_14 == 134 or LA219_14 == 144 or LA219_14 == 147 or LA219_14 == 151 or LA219_14 == 156) :
                                            alt219 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 219, 14, self.input)

                                            raise nvae


                                    elif (LA219_13 == EOF or LA219_13 == ASTERISK or LA219_13 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_13 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_13 <= ISOPEN_ATTR) or LA219_13 == LEQ or (LPAREN <= LA219_13 <= MINUS) or (NOTFOUND_ATTR <= LA219_13 <= NOT_EQ) or LA219_13 == PLUS or LA219_13 == ROWCOUNT_ATTR or LA219_13 == 51 or LA219_13 == 53 or LA219_13 == 57 or LA219_13 == 93 or LA219_13 == 99 or (105 <= LA219_13 <= 107) or LA219_13 == 118 or LA219_13 == 127 or LA219_13 == 144) :
                                        alt219 = 2
                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 219, 13, self.input)

                                        raise nvae


                                else:
                                    if self._state.backtracking > 0:
                                        raise BacktrackingFailed


                                    nvae = NoViableAltException("", 219, 10, self.input)

                                    raise nvae


                            elif (LA219_9 == EOF or LA219_9 == ASTERISK or LA219_9 == BULK_ROWCOUNT_ATTR or (COMMA <= LA219_9 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_9 <= ISOPEN_ATTR) or LA219_9 == LEQ or (LPAREN <= LA219_9 <= MINUS) or (NOTFOUND_ATTR <= LA219_9 <= NOT_EQ) or LA219_9 == PLUS or LA219_9 == ROWCOUNT_ATTR or LA219_9 == 51 or LA219_9 == 53 or LA219_9 == 57 or LA219_9 == 93 or LA219_9 == 99 or (105 <= LA219_9 <= 107) or LA219_9 == 118 or LA219_9 == 127 or LA219_9 == 144) :
                                alt219 = 2
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 219, 9, self.input)

                                raise nvae


                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 219, 5, self.input)

                            raise nvae


                    elif (LA219_4 == EOF or LA219_4 == ASTERISK or (COMMA <= LA219_4 <= DIVIDE) or (DOUBLEQUOTED_STRING <= LA219_4 <= DOUBLEVERTBAR) or LA219_4 == EXPONENT or LA219_4 == ID or LA219_4 == LPAREN or LA219_4 == MINUS or LA219_4 == PLUS or LA219_4 == 53 or LA219_4 == 93 or LA219_4 == 105 or LA219_4 == 144) :
                        alt219 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 219, 4, self.input)

                        raise nvae


                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 219, 0, self.input)

                    raise nvae


                if alt219 == 1:
                    # ./output/PLSQL3.g:790:6: column_spec DOT ASTERISK
                    pass
                    self._state.following.append(self.FOLLOW_column_spec_in_displayed_column4918)
                    column_spec845 = self.column_spec()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, column_spec845.tree)


                    DOT846 = self.match(self.input, DOT, self.FOLLOW_DOT_in_displayed_column4920)
                    if self._state.backtracking == 0:
                        DOT846_tree = self._adaptor.createWithPayload(DOT846)
                        self._adaptor.addChild(root_0, DOT846_tree)



                    ASTERISK847 = self.match(self.input, ASTERISK, self.FOLLOW_ASTERISK_in_displayed_column4922)
                    if self._state.backtracking == 0:
                        ASTERISK847_tree = self._adaptor.createWithPayload(ASTERISK847)
                        self._adaptor.addChild(root_0, ASTERISK847_tree)




                elif alt219 == 2:
                    # ./output/PLSQL3.g:793:5: sql_expression
                    pass
                    self._state.following.append(self.FOLLOW_sql_expression_in_displayed_column4930)
                    sql_expression848 = self.sql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expression848.tree)





                # ./output/PLSQL3.g:795:3: ( alias )?
                alt220 = 2
                LA220_0 = self.input.LA(1)

                if (LA220_0 == DOUBLEQUOTED_STRING or LA220_0 == 53 or LA220_0 == 144) :
                    alt220 = 1
                elif (LA220_0 == ID) :
                    LA220_2 = self.input.LA(2)

                    if (LA220_2 == EOF or LA220_2 == COMMA or LA220_2 == 93 or LA220_2 == 105) :
                        alt220 = 1
                    elif (LA220_2 == ID) :
                        LA220_4 = self.input.LA(3)

                        if (LA220_4 == ID) :
                            alt220 = 1
                if alt220 == 1:
                    # ./output/PLSQL3.g:795:5: alias
                    pass
                    self._state.following.append(self.FOLLOW_alias_in_displayed_column4940)
                    alias849 = self.alias()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, alias849.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 136, displayed_column_StartIndex, success)


            pass
        return retval

    # $ANTLR end "displayed_column"


    class schema_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.schema_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "schema_name"
    # ./output/PLSQL3.g:798:1: schema_name : sql_identifier ;
    def schema_name(self, ):
        retval = self.schema_name_return()
        retval.start = self.input.LT(1)

        schema_name_StartIndex = self.input.index()

        root_0 = None

        sql_identifier850 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 137):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:799:2: ( sql_identifier )
                # ./output/PLSQL3.g:799:4: sql_identifier
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_sql_identifier_in_schema_name4954)
                sql_identifier850 = self.sql_identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_identifier850.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 137, schema_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "schema_name"


    class table_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.table_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "table_name"
    # ./output/PLSQL3.g:802:1: table_name : sql_identifier ;
    def table_name(self, ):
        retval = self.table_name_return()
        retval.start = self.input.LT(1)

        table_name_StartIndex = self.input.index()

        root_0 = None

        sql_identifier851 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 138):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:803:2: ( sql_identifier )
                # ./output/PLSQL3.g:803:4: sql_identifier
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_sql_identifier_in_table_name4965)
                sql_identifier851 = self.sql_identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_identifier851.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 138, table_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "table_name"


    class nested_expressions_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.nested_expressions_return, self).__init__()

            self.tree = None





    # $ANTLR start "nested_expressions"
    # ./output/PLSQL3.g:806:1: nested_expressions : nested_expression ( COMMA nested_expression )* ;
    def nested_expressions(self, ):
        retval = self.nested_expressions_return()
        retval.start = self.input.LT(1)

        nested_expressions_StartIndex = self.input.index()

        root_0 = None

        COMMA853 = None
        nested_expression852 = None

        nested_expression854 = None


        COMMA853_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 139):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:807:2: ( nested_expression ( COMMA nested_expression )* )
                # ./output/PLSQL3.g:807:4: nested_expression ( COMMA nested_expression )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_nested_expression_in_nested_expressions4976)
                nested_expression852 = self.nested_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, nested_expression852.tree)


                # ./output/PLSQL3.g:807:22: ( COMMA nested_expression )*
                while True: #loop221
                    alt221 = 2
                    LA221_0 = self.input.LA(1)

                    if (LA221_0 == COMMA) :
                        alt221 = 1


                    if alt221 == 1:
                        # ./output/PLSQL3.g:807:24: COMMA nested_expression
                        pass
                        COMMA853 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_nested_expressions4980)
                        if self._state.backtracking == 0:
                            COMMA853_tree = self._adaptor.createWithPayload(COMMA853)
                            self._adaptor.addChild(root_0, COMMA853_tree)



                        self._state.following.append(self.FOLLOW_nested_expression_in_nested_expressions4982)
                        nested_expression854 = self.nested_expression()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, nested_expression854.tree)



                    else:
                        break #loop221




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 139, nested_expressions_StartIndex, success)


            pass
        return retval

    # $ANTLR end "nested_expressions"


    class nested_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.nested_expression_return, self).__init__()

            self.tree = None





    # $ANTLR start "nested_expression"
    # ./output/PLSQL3.g:810:1: nested_expression : ({...}? sql_expression |{...}? plsql_expression );
    def nested_expression(self, ):
        retval = self.nested_expression_return()
        retval.start = self.input.LT(1)

        nested_expression_StartIndex = self.input.index()

        root_0 = None

        sql_expression855 = None

        plsql_expression856 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 140):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:811:2: ({...}? sql_expression |{...}? plsql_expression )
                alt222 = 2
                LA222 = self.input.LA(1)
                if LA222 == MINUS or LA222 == PLUS:
                    LA222_1 = self.input.LA(2)

                    if (((((self.synpred355_PLSQL3()) and (self.synpred355_PLSQL3()))) and ((is_sql )))) :
                        alt222 = 1
                    elif ((not is_sql )) :
                        alt222 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 222, 1, self.input)

                        raise nvae


                elif LA222 == LPAREN:
                    LA222_2 = self.input.LA(2)

                    if (((((self.synpred355_PLSQL3()) and (self.synpred355_PLSQL3()))) and ((is_sql )))) :
                        alt222 = 1
                    elif ((not is_sql )) :
                        alt222 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 222, 2, self.input)

                        raise nvae


                elif LA222 == ID:
                    LA222_3 = self.input.LA(2)

                    if (((((self.synpred355_PLSQL3()) and (self.synpred355_PLSQL3()))) and ((is_sql )))) :
                        alt222 = 1
                    elif ((not is_sql )) :
                        alt222 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 222, 3, self.input)

                        raise nvae


                elif LA222 == 144:
                    LA222_4 = self.input.LA(2)

                    if (((((self.synpred355_PLSQL3()) and (self.synpred355_PLSQL3()))) and ((is_sql )))) :
                        alt222 = 1
                    elif ((not is_sql )) :
                        alt222 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 222, 4, self.input)

                        raise nvae


                elif LA222 == DOUBLEQUOTED_STRING:
                    LA222_5 = self.input.LA(2)

                    if (((((self.synpred355_PLSQL3()) and (self.synpred355_PLSQL3()))) and ((is_sql )))) :
                        alt222 = 1
                    elif ((not is_sql )) :
                        alt222 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 222, 5, self.input)

                        raise nvae


                elif LA222 == 81:
                    LA222_6 = self.input.LA(2)

                    if (((((((self.synpred355_PLSQL3()) and (self.synpred355_PLSQL3()))) and ((is_sql )))) and ((is_sql )))) :
                        alt222 = 1
                    elif ((((((is_sql )) and ((is_sql )))) and ((not is_sql )))) :
                        alt222 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 222, 6, self.input)

                        raise nvae


                elif LA222 == 65:
                    LA222_7 = self.input.LA(2)

                    if (((((self.synpred355_PLSQL3()) and (self.synpred355_PLSQL3()))) and ((is_sql )))) :
                        alt222 = 1
                    elif ((not is_sql )) :
                        alt222 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 222, 7, self.input)

                        raise nvae


                elif LA222 == 89 or LA222 == 156:
                    LA222_8 = self.input.LA(2)

                    if (((((self.synpred355_PLSQL3()) and (self.synpred355_PLSQL3()))) and ((is_sql )))) :
                        alt222 = 1
                    elif ((not is_sql )) :
                        alt222 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 222, 8, self.input)

                        raise nvae


                elif LA222 == 151:
                    LA222_9 = self.input.LA(2)

                    if (((((self.synpred355_PLSQL3()) and (self.synpred355_PLSQL3()))) and ((is_sql )))) :
                        alt222 = 1
                    elif ((not is_sql )) :
                        alt222 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 222, 9, self.input)

                        raise nvae


                elif LA222 == QUOTED_STRING:
                    LA222_10 = self.input.LA(2)

                    if (((((self.synpred355_PLSQL3()) and (self.synpred355_PLSQL3()))) and ((is_sql )))) :
                        alt222 = 1
                    elif ((not is_sql )) :
                        alt222 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 222, 10, self.input)

                        raise nvae


                elif LA222 == NUMBER:
                    LA222_11 = self.input.LA(2)

                    if (((((self.synpred355_PLSQL3()) and (self.synpred355_PLSQL3()))) and ((is_sql )))) :
                        alt222 = 1
                    elif ((not is_sql )) :
                        alt222 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 222, 11, self.input)

                        raise nvae


                elif LA222 == 120:
                    LA222_12 = self.input.LA(2)

                    if (((((self.synpred355_PLSQL3()) and (self.synpred355_PLSQL3()))) and ((is_sql )))) :
                        alt222 = 1
                    elif ((not is_sql )) :
                        alt222 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 222, 12, self.input)

                        raise nvae


                elif LA222 == 147:
                    LA222_13 = self.input.LA(2)

                    if (((((self.synpred355_PLSQL3()) and (self.synpred355_PLSQL3()))) and ((is_sql )))) :
                        alt222 = 1
                    elif ((not is_sql )) :
                        alt222 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 222, 13, self.input)

                        raise nvae


                elif LA222 == 118:
                    alt222 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 222, 0, self.input)

                    raise nvae


                if alt222 == 1:
                    # ./output/PLSQL3.g:811:4: {...}? sql_expression
                    pass
                    root_0 = self._adaptor.nil()


                    if not ((is_sql )):
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        raise FailedPredicateException(self.input, "nested_expression", "  is_sql ")


                    self._state.following.append(self.FOLLOW_sql_expression_in_nested_expression4998)
                    sql_expression855 = self.sql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expression855.tree)



                elif alt222 == 2:
                    # ./output/PLSQL3.g:812:4: {...}? plsql_expression
                    pass
                    root_0 = self._adaptor.nil()


                    if not ((not is_sql )):
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        raise FailedPredicateException(self.input, "nested_expression", " not is_sql ")


                    self._state.following.append(self.FOLLOW_plsql_expression_in_nested_expression5005)
                    plsql_expression856 = self.plsql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, plsql_expression856.tree)



                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 140, nested_expression_StartIndex, success)


            pass
        return retval

    # $ANTLR end "nested_expression"


    class plsql_condition_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.plsql_condition_return, self).__init__()

            self.tree = None





    # $ANTLR start "plsql_condition"
    # ./output/PLSQL3.g:814:1: plsql_condition : expr_bool ;
    def plsql_condition(self, ):
        retval = self.plsql_condition_return()
        retval.start = self.input.LT(1)

        plsql_condition_StartIndex = self.input.index()

        root_0 = None

        expr_bool857 = None



        is_sql = false;
        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 141):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:816:2: ( expr_bool )
                # ./output/PLSQL3.g:816:4: expr_bool
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_expr_bool_in_plsql_condition5022)
                expr_bool857 = self.expr_bool()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, expr_bool857.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 141, plsql_condition_StartIndex, success)


            pass
        return retval

    # $ANTLR end "plsql_condition"


    class plsql_expressions_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.plsql_expressions_return, self).__init__()

            self.tree = None





    # $ANTLR start "plsql_expressions"
    # ./output/PLSQL3.g:819:1: plsql_expressions : plsql_expression ( COMMA plsql_expression )* ;
    def plsql_expressions(self, ):
        retval = self.plsql_expressions_return()
        retval.start = self.input.LT(1)

        plsql_expressions_StartIndex = self.input.index()

        root_0 = None

        COMMA859 = None
        plsql_expression858 = None

        plsql_expression860 = None


        COMMA859_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 142):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:820:2: ( plsql_expression ( COMMA plsql_expression )* )
                # ./output/PLSQL3.g:820:4: plsql_expression ( COMMA plsql_expression )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_plsql_expression_in_plsql_expressions5033)
                plsql_expression858 = self.plsql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, plsql_expression858.tree)


                # ./output/PLSQL3.g:820:21: ( COMMA plsql_expression )*
                while True: #loop223
                    alt223 = 2
                    LA223_0 = self.input.LA(1)

                    if (LA223_0 == COMMA) :
                        alt223 = 1


                    if alt223 == 1:
                        # ./output/PLSQL3.g:820:23: COMMA plsql_expression
                        pass
                        COMMA859 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_plsql_expressions5037)
                        if self._state.backtracking == 0:
                            COMMA859_tree = self._adaptor.createWithPayload(COMMA859)
                            self._adaptor.addChild(root_0, COMMA859_tree)



                        self._state.following.append(self.FOLLOW_plsql_expression_in_plsql_expressions5039)
                        plsql_expression860 = self.plsql_expression()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, plsql_expression860.tree)



                    else:
                        break #loop223




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 142, plsql_expressions_StartIndex, success)


            pass
        return retval

    # $ANTLR end "plsql_expressions"


    class plsql_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.plsql_expression_return, self).__init__()

            self.tree = None





    # $ANTLR start "plsql_expression"
    # ./output/PLSQL3.g:823:1: plsql_expression : expr_bool ;
    def plsql_expression(self, ):
        retval = self.plsql_expression_return()
        retval.start = self.input.LT(1)

        plsql_expression_StartIndex = self.input.index()

        root_0 = None

        expr_bool861 = None



        is_sql = false;
        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 143):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:825:2: ( expr_bool )
                # ./output/PLSQL3.g:825:4: expr_bool
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_expr_bool_in_plsql_expression5060)
                expr_bool861 = self.expr_bool()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, expr_bool861.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 143, plsql_expression_StartIndex, success)


            pass
        return retval

    # $ANTLR end "plsql_expression"


    class expr_bool_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.expr_bool_return, self).__init__()

            self.tree = None





    # $ANTLR start "expr_bool"
    # ./output/PLSQL3.g:829:1: expr_bool : expr_or ( 'OR' expr_or )* ;
    def expr_bool(self, ):
        retval = self.expr_bool_return()
        retval.start = self.input.LT(1)

        expr_bool_StartIndex = self.input.index()

        root_0 = None

        string_literal863 = None
        expr_or862 = None

        expr_or864 = None


        string_literal863_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 144):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:830:2: ( expr_or ( 'OR' expr_or )* )
                # ./output/PLSQL3.g:830:4: expr_or ( 'OR' expr_or )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_expr_or_in_expr_bool5072)
                expr_or862 = self.expr_or()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, expr_or862.tree)


                # ./output/PLSQL3.g:830:12: ( 'OR' expr_or )*
                while True: #loop224
                    alt224 = 2
                    LA224_0 = self.input.LA(1)

                    if (LA224_0 == 127) :
                        LA224_2 = self.input.LA(2)

                        if (self.synpred357_PLSQL3()) :
                            alt224 = 1




                    if alt224 == 1:
                        # ./output/PLSQL3.g:830:14: 'OR' expr_or
                        pass
                        string_literal863 = self.match(self.input, 127, self.FOLLOW_127_in_expr_bool5076)
                        if self._state.backtracking == 0:
                            string_literal863_tree = self._adaptor.createWithPayload(string_literal863)
                            self._adaptor.addChild(root_0, string_literal863_tree)



                        self._state.following.append(self.FOLLOW_expr_or_in_expr_bool5078)
                        expr_or864 = self.expr_or()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, expr_or864.tree)



                    else:
                        break #loop224




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 144, expr_bool_StartIndex, success)


            pass
        return retval

    # $ANTLR end "expr_bool"


    class expr_or_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.expr_or_return, self).__init__()

            self.tree = None





    # $ANTLR start "expr_or"
    # ./output/PLSQL3.g:832:1: expr_or : expr_and ( 'AND' expr_and )* ;
    def expr_or(self, ):
        retval = self.expr_or_return()
        retval.start = self.input.LT(1)

        expr_or_StartIndex = self.input.index()

        root_0 = None

        string_literal866 = None
        expr_and865 = None

        expr_and867 = None


        string_literal866_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 145):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:833:2: ( expr_and ( 'AND' expr_and )* )
                # ./output/PLSQL3.g:833:4: expr_and ( 'AND' expr_and )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_expr_and_in_expr_or5091)
                expr_and865 = self.expr_and()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, expr_and865.tree)


                # ./output/PLSQL3.g:833:13: ( 'AND' expr_and )*
                while True: #loop225
                    alt225 = 2
                    LA225_0 = self.input.LA(1)

                    if (LA225_0 == 51) :
                        LA225_2 = self.input.LA(2)

                        if (self.synpred358_PLSQL3()) :
                            alt225 = 1




                    if alt225 == 1:
                        # ./output/PLSQL3.g:833:15: 'AND' expr_and
                        pass
                        string_literal866 = self.match(self.input, 51, self.FOLLOW_51_in_expr_or5095)
                        if self._state.backtracking == 0:
                            string_literal866_tree = self._adaptor.createWithPayload(string_literal866)
                            self._adaptor.addChild(root_0, string_literal866_tree)



                        self._state.following.append(self.FOLLOW_expr_and_in_expr_or5097)
                        expr_and867 = self.expr_and()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, expr_and867.tree)



                    else:
                        break #loop225




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 145, expr_or_StartIndex, success)


            pass
        return retval

    # $ANTLR end "expr_or"


    class expr_and_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.expr_and_return, self).__init__()

            self.tree = None





    # $ANTLR start "expr_and"
    # ./output/PLSQL3.g:835:1: expr_and : ( 'NOT' )? expr_not ;
    def expr_and(self, ):
        retval = self.expr_and_return()
        retval.start = self.input.LT(1)

        expr_and_StartIndex = self.input.index()

        root_0 = None

        string_literal868 = None
        expr_not869 = None


        string_literal868_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 146):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:836:2: ( ( 'NOT' )? expr_not )
                # ./output/PLSQL3.g:836:4: ( 'NOT' )? expr_not
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:836:4: ( 'NOT' )?
                alt226 = 2
                LA226_0 = self.input.LA(1)

                if (LA226_0 == 118) :
                    alt226 = 1
                if alt226 == 1:
                    # ./output/PLSQL3.g:836:6: 'NOT'
                    pass
                    string_literal868 = self.match(self.input, 118, self.FOLLOW_118_in_expr_and5112)
                    if self._state.backtracking == 0:
                        string_literal868_tree = self._adaptor.createWithPayload(string_literal868)
                        self._adaptor.addChild(root_0, string_literal868_tree)






                self._state.following.append(self.FOLLOW_expr_not_in_expr_and5117)
                expr_not869 = self.expr_not()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, expr_not869.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 146, expr_and_StartIndex, success)


            pass
        return retval

    # $ANTLR end "expr_and"


    class expr_not_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.expr_not_return, self).__init__()

            self.tree = None





    # $ANTLR start "expr_not"
    # ./output/PLSQL3.g:838:1: expr_not : expr_add ( relational_op expr_add | FOUND_ATTR | NOTFOUND_ATTR | ISOPEN_ATTR | ROWCOUNT_ATTR | BULK_ROWCOUNT_ATTR | 'IS' ( 'NOT' )? 'NULL' | ( 'NOT' )? 'LIKE' expr_add | ( 'NOT' )? 'BETWEEN' expr_add 'AND' expr_add | ( 'NOT' )? 'IN' LPAREN nested_expressions RPAREN )* ;
    def expr_not(self, ):
        retval = self.expr_not_return()
        retval.start = self.input.LT(1)

        expr_not_StartIndex = self.input.index()

        root_0 = None

        FOUND_ATTR873 = None
        NOTFOUND_ATTR874 = None
        ISOPEN_ATTR875 = None
        ROWCOUNT_ATTR876 = None
        BULK_ROWCOUNT_ATTR877 = None
        string_literal878 = None
        string_literal879 = None
        string_literal880 = None
        string_literal881 = None
        string_literal882 = None
        string_literal884 = None
        string_literal885 = None
        string_literal887 = None
        string_literal889 = None
        string_literal890 = None
        LPAREN891 = None
        RPAREN893 = None
        expr_add870 = None

        relational_op871 = None

        expr_add872 = None

        expr_add883 = None

        expr_add886 = None

        expr_add888 = None

        nested_expressions892 = None


        FOUND_ATTR873_tree = None
        NOTFOUND_ATTR874_tree = None
        ISOPEN_ATTR875_tree = None
        ROWCOUNT_ATTR876_tree = None
        BULK_ROWCOUNT_ATTR877_tree = None
        string_literal878_tree = None
        string_literal879_tree = None
        string_literal880_tree = None
        string_literal881_tree = None
        string_literal882_tree = None
        string_literal884_tree = None
        string_literal885_tree = None
        string_literal887_tree = None
        string_literal889_tree = None
        string_literal890_tree = None
        LPAREN891_tree = None
        RPAREN893_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 147):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:839:2: ( expr_add ( relational_op expr_add | FOUND_ATTR | NOTFOUND_ATTR | ISOPEN_ATTR | ROWCOUNT_ATTR | BULK_ROWCOUNT_ATTR | 'IS' ( 'NOT' )? 'NULL' | ( 'NOT' )? 'LIKE' expr_add | ( 'NOT' )? 'BETWEEN' expr_add 'AND' expr_add | ( 'NOT' )? 'IN' LPAREN nested_expressions RPAREN )* )
                # ./output/PLSQL3.g:839:4: expr_add ( relational_op expr_add | FOUND_ATTR | NOTFOUND_ATTR | ISOPEN_ATTR | ROWCOUNT_ATTR | BULK_ROWCOUNT_ATTR | 'IS' ( 'NOT' )? 'NULL' | ( 'NOT' )? 'LIKE' expr_add | ( 'NOT' )? 'BETWEEN' expr_add 'AND' expr_add | ( 'NOT' )? 'IN' LPAREN nested_expressions RPAREN )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_expr_add_in_expr_not5127)
                expr_add870 = self.expr_add()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, expr_add870.tree)


                # ./output/PLSQL3.g:840:3: ( relational_op expr_add | FOUND_ATTR | NOTFOUND_ATTR | ISOPEN_ATTR | ROWCOUNT_ATTR | BULK_ROWCOUNT_ATTR | 'IS' ( 'NOT' )? 'NULL' | ( 'NOT' )? 'LIKE' expr_add | ( 'NOT' )? 'BETWEEN' expr_add 'AND' expr_add | ( 'NOT' )? 'IN' LPAREN nested_expressions RPAREN )*
                while True: #loop231
                    alt231 = 11
                    LA231 = self.input.LA(1)
                    if LA231 == EQ:
                        LA231_2 = self.input.LA(2)

                        if (self.synpred360_PLSQL3()) :
                            alt231 = 1


                    elif LA231 == FOUND_ATTR:
                        LA231_3 = self.input.LA(2)

                        if (self.synpred361_PLSQL3()) :
                            alt231 = 2


                    elif LA231 == NOTFOUND_ATTR:
                        LA231_4 = self.input.LA(2)

                        if (self.synpred362_PLSQL3()) :
                            alt231 = 3


                    elif LA231 == ISOPEN_ATTR:
                        LA231_5 = self.input.LA(2)

                        if (self.synpred363_PLSQL3()) :
                            alt231 = 4


                    elif LA231 == ROWCOUNT_ATTR:
                        LA231_6 = self.input.LA(2)

                        if (self.synpred364_PLSQL3()) :
                            alt231 = 5


                    elif LA231 == BULK_ROWCOUNT_ATTR:
                        LA231_7 = self.input.LA(2)

                        if (self.synpred365_PLSQL3()) :
                            alt231 = 6


                    elif LA231 == 106:
                        LA231_8 = self.input.LA(2)

                        if (self.synpred367_PLSQL3()) :
                            alt231 = 7


                    elif LA231 == 118:
                        LA231_9 = self.input.LA(2)

                        if (self.synpred369_PLSQL3()) :
                            alt231 = 8
                        elif (self.synpred371_PLSQL3()) :
                            alt231 = 9
                        elif (self.synpred373_PLSQL3()) :
                            alt231 = 10


                    elif LA231 == 107:
                        LA231_10 = self.input.LA(2)

                        if (self.synpred369_PLSQL3()) :
                            alt231 = 8


                    elif LA231 == 57:
                        LA231_11 = self.input.LA(2)

                        if (self.synpred371_PLSQL3()) :
                            alt231 = 9


                    elif LA231 == 99:
                        LA231_12 = self.input.LA(2)

                        if (self.synpred373_PLSQL3()) :
                            alt231 = 10


                    elif LA231 == GEQ or LA231 == GTH or LA231 == LEQ or LA231 == LTH or LA231 == NOT_EQ:
                        LA231_13 = self.input.LA(2)

                        if (self.synpred360_PLSQL3()) :
                            alt231 = 1



                    if alt231 == 1:
                        # ./output/PLSQL3.g:840:5: relational_op expr_add
                        pass
                        self._state.following.append(self.FOLLOW_relational_op_in_expr_not5134)
                        relational_op871 = self.relational_op()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, relational_op871.tree)


                        self._state.following.append(self.FOLLOW_expr_add_in_expr_not5136)
                        expr_add872 = self.expr_add()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, expr_add872.tree)



                    elif alt231 == 2:
                        # ./output/PLSQL3.g:841:5: FOUND_ATTR
                        pass
                        FOUND_ATTR873 = self.match(self.input, FOUND_ATTR, self.FOLLOW_FOUND_ATTR_in_expr_not5142)
                        if self._state.backtracking == 0:
                            FOUND_ATTR873_tree = self._adaptor.createWithPayload(FOUND_ATTR873)
                            self._adaptor.addChild(root_0, FOUND_ATTR873_tree)




                    elif alt231 == 3:
                        # ./output/PLSQL3.g:841:18: NOTFOUND_ATTR
                        pass
                        NOTFOUND_ATTR874 = self.match(self.input, NOTFOUND_ATTR, self.FOLLOW_NOTFOUND_ATTR_in_expr_not5146)
                        if self._state.backtracking == 0:
                            NOTFOUND_ATTR874_tree = self._adaptor.createWithPayload(NOTFOUND_ATTR874)
                            self._adaptor.addChild(root_0, NOTFOUND_ATTR874_tree)




                    elif alt231 == 4:
                        # ./output/PLSQL3.g:841:34: ISOPEN_ATTR
                        pass
                        ISOPEN_ATTR875 = self.match(self.input, ISOPEN_ATTR, self.FOLLOW_ISOPEN_ATTR_in_expr_not5150)
                        if self._state.backtracking == 0:
                            ISOPEN_ATTR875_tree = self._adaptor.createWithPayload(ISOPEN_ATTR875)
                            self._adaptor.addChild(root_0, ISOPEN_ATTR875_tree)




                    elif alt231 == 5:
                        # ./output/PLSQL3.g:841:48: ROWCOUNT_ATTR
                        pass
                        ROWCOUNT_ATTR876 = self.match(self.input, ROWCOUNT_ATTR, self.FOLLOW_ROWCOUNT_ATTR_in_expr_not5154)
                        if self._state.backtracking == 0:
                            ROWCOUNT_ATTR876_tree = self._adaptor.createWithPayload(ROWCOUNT_ATTR876)
                            self._adaptor.addChild(root_0, ROWCOUNT_ATTR876_tree)




                    elif alt231 == 6:
                        # ./output/PLSQL3.g:841:64: BULK_ROWCOUNT_ATTR
                        pass
                        BULK_ROWCOUNT_ATTR877 = self.match(self.input, BULK_ROWCOUNT_ATTR, self.FOLLOW_BULK_ROWCOUNT_ATTR_in_expr_not5158)
                        if self._state.backtracking == 0:
                            BULK_ROWCOUNT_ATTR877_tree = self._adaptor.createWithPayload(BULK_ROWCOUNT_ATTR877)
                            self._adaptor.addChild(root_0, BULK_ROWCOUNT_ATTR877_tree)




                    elif alt231 == 7:
                        # ./output/PLSQL3.g:842:5: 'IS' ( 'NOT' )? 'NULL'
                        pass
                        string_literal878 = self.match(self.input, 106, self.FOLLOW_106_in_expr_not5164)
                        if self._state.backtracking == 0:
                            string_literal878_tree = self._adaptor.createWithPayload(string_literal878)
                            self._adaptor.addChild(root_0, string_literal878_tree)



                        # ./output/PLSQL3.g:842:10: ( 'NOT' )?
                        alt227 = 2
                        LA227_0 = self.input.LA(1)

                        if (LA227_0 == 118) :
                            alt227 = 1
                        if alt227 == 1:
                            # ./output/PLSQL3.g:842:12: 'NOT'
                            pass
                            string_literal879 = self.match(self.input, 118, self.FOLLOW_118_in_expr_not5168)
                            if self._state.backtracking == 0:
                                string_literal879_tree = self._adaptor.createWithPayload(string_literal879)
                                self._adaptor.addChild(root_0, string_literal879_tree)






                        string_literal880 = self.match(self.input, 120, self.FOLLOW_120_in_expr_not5173)
                        if self._state.backtracking == 0:
                            string_literal880_tree = self._adaptor.createWithPayload(string_literal880)
                            self._adaptor.addChild(root_0, string_literal880_tree)




                    elif alt231 == 8:
                        # ./output/PLSQL3.g:843:5: ( 'NOT' )? 'LIKE' expr_add
                        pass
                        # ./output/PLSQL3.g:843:5: ( 'NOT' )?
                        alt228 = 2
                        LA228_0 = self.input.LA(1)

                        if (LA228_0 == 118) :
                            alt228 = 1
                        if alt228 == 1:
                            # ./output/PLSQL3.g:843:7: 'NOT'
                            pass
                            string_literal881 = self.match(self.input, 118, self.FOLLOW_118_in_expr_not5181)
                            if self._state.backtracking == 0:
                                string_literal881_tree = self._adaptor.createWithPayload(string_literal881)
                                self._adaptor.addChild(root_0, string_literal881_tree)






                        string_literal882 = self.match(self.input, 107, self.FOLLOW_107_in_expr_not5186)
                        if self._state.backtracking == 0:
                            string_literal882_tree = self._adaptor.createWithPayload(string_literal882)
                            self._adaptor.addChild(root_0, string_literal882_tree)



                        self._state.following.append(self.FOLLOW_expr_add_in_expr_not5188)
                        expr_add883 = self.expr_add()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, expr_add883.tree)



                    elif alt231 == 9:
                        # ./output/PLSQL3.g:844:5: ( 'NOT' )? 'BETWEEN' expr_add 'AND' expr_add
                        pass
                        # ./output/PLSQL3.g:844:5: ( 'NOT' )?
                        alt229 = 2
                        LA229_0 = self.input.LA(1)

                        if (LA229_0 == 118) :
                            alt229 = 1
                        if alt229 == 1:
                            # ./output/PLSQL3.g:844:7: 'NOT'
                            pass
                            string_literal884 = self.match(self.input, 118, self.FOLLOW_118_in_expr_not5196)
                            if self._state.backtracking == 0:
                                string_literal884_tree = self._adaptor.createWithPayload(string_literal884)
                                self._adaptor.addChild(root_0, string_literal884_tree)






                        string_literal885 = self.match(self.input, 57, self.FOLLOW_57_in_expr_not5201)
                        if self._state.backtracking == 0:
                            string_literal885_tree = self._adaptor.createWithPayload(string_literal885)
                            self._adaptor.addChild(root_0, string_literal885_tree)



                        self._state.following.append(self.FOLLOW_expr_add_in_expr_not5203)
                        expr_add886 = self.expr_add()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, expr_add886.tree)


                        string_literal887 = self.match(self.input, 51, self.FOLLOW_51_in_expr_not5205)
                        if self._state.backtracking == 0:
                            string_literal887_tree = self._adaptor.createWithPayload(string_literal887)
                            self._adaptor.addChild(root_0, string_literal887_tree)



                        self._state.following.append(self.FOLLOW_expr_add_in_expr_not5207)
                        expr_add888 = self.expr_add()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, expr_add888.tree)



                    elif alt231 == 10:
                        # ./output/PLSQL3.g:845:5: ( 'NOT' )? 'IN' LPAREN nested_expressions RPAREN
                        pass
                        # ./output/PLSQL3.g:845:5: ( 'NOT' )?
                        alt230 = 2
                        LA230_0 = self.input.LA(1)

                        if (LA230_0 == 118) :
                            alt230 = 1
                        if alt230 == 1:
                            # ./output/PLSQL3.g:845:7: 'NOT'
                            pass
                            string_literal889 = self.match(self.input, 118, self.FOLLOW_118_in_expr_not5215)
                            if self._state.backtracking == 0:
                                string_literal889_tree = self._adaptor.createWithPayload(string_literal889)
                                self._adaptor.addChild(root_0, string_literal889_tree)






                        string_literal890 = self.match(self.input, 99, self.FOLLOW_99_in_expr_not5220)
                        if self._state.backtracking == 0:
                            string_literal890_tree = self._adaptor.createWithPayload(string_literal890)
                            self._adaptor.addChild(root_0, string_literal890_tree)



                        LPAREN891 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_expr_not5222)
                        if self._state.backtracking == 0:
                            LPAREN891_tree = self._adaptor.createWithPayload(LPAREN891)
                            self._adaptor.addChild(root_0, LPAREN891_tree)



                        self._state.following.append(self.FOLLOW_nested_expressions_in_expr_not5224)
                        nested_expressions892 = self.nested_expressions()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, nested_expressions892.tree)


                        RPAREN893 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_expr_not5226)
                        if self._state.backtracking == 0:
                            RPAREN893_tree = self._adaptor.createWithPayload(RPAREN893)
                            self._adaptor.addChild(root_0, RPAREN893_tree)




                    else:
                        break #loop231




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 147, expr_not_StartIndex, success)


            pass
        return retval

    # $ANTLR end "expr_not"


    class boolean_literal_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.boolean_literal_return, self).__init__()

            self.tree = None





    # $ANTLR start "boolean_literal"
    # ./output/PLSQL3.g:849:1: boolean_literal : ( 'TRUE' | 'FALSE' );
    def boolean_literal(self, ):
        retval = self.boolean_literal_return()
        retval.start = self.input.LT(1)

        boolean_literal_StartIndex = self.input.index()

        root_0 = None

        set894 = None

        set894_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 148):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:850:2: ( 'TRUE' | 'FALSE' )
                # ./output/PLSQL3.g:
                pass
                root_0 = self._adaptor.nil()


                set894 = self.input.LT(1)

                if self.input.LA(1) == 89 or self.input.LA(1) == 156:
                    self.input.consume()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set894))

                    self._state.errorRecovery = False


                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    mse = MismatchedSetException(None, self.input)
                    raise mse





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 148, boolean_literal_StartIndex, success)


            pass
        return retval

    # $ANTLR end "boolean_literal"


    class sql_expressions_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.sql_expressions_return, self).__init__()

            self.tree = None





    # $ANTLR start "sql_expressions"
    # ./output/PLSQL3.g:853:1: sql_expressions : sql_expression ( COMMA sql_expression )* ;
    def sql_expressions(self, ):
        retval = self.sql_expressions_return()
        retval.start = self.input.LT(1)

        sql_expressions_StartIndex = self.input.index()

        root_0 = None

        COMMA896 = None
        sql_expression895 = None

        sql_expression897 = None


        COMMA896_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 149):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:854:2: ( sql_expression ( COMMA sql_expression )* )
                # ./output/PLSQL3.g:854:4: sql_expression ( COMMA sql_expression )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_sql_expression_in_sql_expressions5257)
                sql_expression895 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression895.tree)


                # ./output/PLSQL3.g:854:19: ( COMMA sql_expression )*
                while True: #loop232
                    alt232 = 2
                    LA232_0 = self.input.LA(1)

                    if (LA232_0 == COMMA) :
                        LA232_2 = self.input.LA(2)

                        if (self.synpred375_PLSQL3()) :
                            alt232 = 1




                    if alt232 == 1:
                        # ./output/PLSQL3.g:854:21: COMMA sql_expression
                        pass
                        COMMA896 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_sql_expressions5261)
                        if self._state.backtracking == 0:
                            COMMA896_tree = self._adaptor.createWithPayload(COMMA896)
                            self._adaptor.addChild(root_0, COMMA896_tree)



                        self._state.following.append(self.FOLLOW_sql_expression_in_sql_expressions5263)
                        sql_expression897 = self.sql_expression()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, sql_expression897.tree)



                    else:
                        break #loop232




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 149, sql_expressions_StartIndex, success)


            pass
        return retval

    # $ANTLR end "sql_expressions"


    class sql_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.sql_expression_return, self).__init__()

            self.tree = None





    # $ANTLR start "sql_expression"
    # ./output/PLSQL3.g:856:1: sql_expression : expr_add ;
    def sql_expression(self, ):
        retval = self.sql_expression_return()
        retval.start = self.input.LT(1)

        sql_expression_StartIndex = self.input.index()

        root_0 = None

        expr_add898 = None



        is_sql = true;
        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 150):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:858:2: ( expr_add )
                # ./output/PLSQL3.g:858:4: expr_add
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_expr_add_in_sql_expression5283)
                expr_add898 = self.expr_add()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, expr_add898.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 150, sql_expression_StartIndex, success)


            pass
        return retval

    # $ANTLR end "sql_expression"


    class expr_add_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.expr_add_return, self).__init__()

            self.tree = None





    # $ANTLR start "expr_add"
    # ./output/PLSQL3.g:860:1: expr_add : expr_mul ( ( PLUS | MINUS | DOUBLEVERTBAR ) expr_mul )* ;
    def expr_add(self, ):
        retval = self.expr_add_return()
        retval.start = self.input.LT(1)

        expr_add_StartIndex = self.input.index()

        root_0 = None

        set900 = None
        expr_mul899 = None

        expr_mul901 = None


        set900_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 151):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:861:2: ( expr_mul ( ( PLUS | MINUS | DOUBLEVERTBAR ) expr_mul )* )
                # ./output/PLSQL3.g:861:4: expr_mul ( ( PLUS | MINUS | DOUBLEVERTBAR ) expr_mul )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_expr_mul_in_expr_add5293)
                expr_mul899 = self.expr_mul()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, expr_mul899.tree)


                # ./output/PLSQL3.g:861:13: ( ( PLUS | MINUS | DOUBLEVERTBAR ) expr_mul )*
                while True: #loop233
                    alt233 = 2
                    LA233_0 = self.input.LA(1)

                    if (LA233_0 == MINUS or LA233_0 == PLUS) :
                        LA233_2 = self.input.LA(2)

                        if (self.synpred378_PLSQL3()) :
                            alt233 = 1


                    elif (LA233_0 == DOUBLEVERTBAR) :
                        LA233_3 = self.input.LA(2)

                        if (self.synpred378_PLSQL3()) :
                            alt233 = 1




                    if alt233 == 1:
                        # ./output/PLSQL3.g:861:15: ( PLUS | MINUS | DOUBLEVERTBAR ) expr_mul
                        pass
                        set900 = self.input.LT(1)

                        if self.input.LA(1) == DOUBLEVERTBAR or self.input.LA(1) == MINUS or self.input.LA(1) == PLUS:
                            self.input.consume()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set900))

                            self._state.errorRecovery = False


                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            mse = MismatchedSetException(None, self.input)
                            raise mse



                        self._state.following.append(self.FOLLOW_expr_mul_in_expr_add5311)
                        expr_mul901 = self.expr_mul()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, expr_mul901.tree)



                    else:
                        break #loop233




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 151, expr_add_StartIndex, success)


            pass
        return retval

    # $ANTLR end "expr_add"


    class expr_mul_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.expr_mul_return, self).__init__()

            self.tree = None





    # $ANTLR start "expr_mul"
    # ./output/PLSQL3.g:863:1: expr_mul : expr_sign ( ( ASTERISK | DIVIDE ) expr_sign )* ;
    def expr_mul(self, ):
        retval = self.expr_mul_return()
        retval.start = self.input.LT(1)

        expr_mul_StartIndex = self.input.index()

        root_0 = None

        set903 = None
        expr_sign902 = None

        expr_sign904 = None


        set903_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 152):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:864:2: ( expr_sign ( ( ASTERISK | DIVIDE ) expr_sign )* )
                # ./output/PLSQL3.g:864:4: expr_sign ( ( ASTERISK | DIVIDE ) expr_sign )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_expr_sign_in_expr_mul5324)
                expr_sign902 = self.expr_sign()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, expr_sign902.tree)


                # ./output/PLSQL3.g:864:14: ( ( ASTERISK | DIVIDE ) expr_sign )*
                while True: #loop234
                    alt234 = 2
                    LA234_0 = self.input.LA(1)

                    if (LA234_0 == ASTERISK or LA234_0 == DIVIDE) :
                        LA234_2 = self.input.LA(2)

                        if (self.synpred380_PLSQL3()) :
                            alt234 = 1




                    if alt234 == 1:
                        # ./output/PLSQL3.g:864:16: ( ASTERISK | DIVIDE ) expr_sign
                        pass
                        set903 = self.input.LT(1)

                        if self.input.LA(1) == ASTERISK or self.input.LA(1) == DIVIDE:
                            self.input.consume()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set903))

                            self._state.errorRecovery = False


                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            mse = MismatchedSetException(None, self.input)
                            raise mse



                        self._state.following.append(self.FOLLOW_expr_sign_in_expr_mul5338)
                        expr_sign904 = self.expr_sign()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, expr_sign904.tree)



                    else:
                        break #loop234




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 152, expr_mul_StartIndex, success)


            pass
        return retval

    # $ANTLR end "expr_mul"


    class expr_sign_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.expr_sign_return, self).__init__()

            self.tree = None





    # $ANTLR start "expr_sign"
    # ./output/PLSQL3.g:866:1: expr_sign : ( PLUS | MINUS )? expr_pow ;
    def expr_sign(self, ):
        retval = self.expr_sign_return()
        retval.start = self.input.LT(1)

        expr_sign_StartIndex = self.input.index()

        root_0 = None

        set905 = None
        expr_pow906 = None


        set905_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 153):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:867:2: ( ( PLUS | MINUS )? expr_pow )
                # ./output/PLSQL3.g:867:4: ( PLUS | MINUS )? expr_pow
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:867:4: ( PLUS | MINUS )?
                alt235 = 2
                LA235_0 = self.input.LA(1)

                if (LA235_0 == MINUS or LA235_0 == PLUS) :
                    alt235 = 1
                if alt235 == 1:
                    # ./output/PLSQL3.g:
                    pass
                    set905 = self.input.LT(1)

                    if self.input.LA(1) == MINUS or self.input.LA(1) == PLUS:
                        self.input.consume()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set905))

                        self._state.errorRecovery = False


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        mse = MismatchedSetException(None, self.input)
                        raise mse






                self._state.following.append(self.FOLLOW_expr_pow_in_expr_sign5362)
                expr_pow906 = self.expr_pow()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, expr_pow906.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 153, expr_sign_StartIndex, success)


            pass
        return retval

    # $ANTLR end "expr_sign"


    class expr_pow_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.expr_pow_return, self).__init__()

            self.tree = None





    # $ANTLR start "expr_pow"
    # ./output/PLSQL3.g:869:1: expr_pow : expr_expr ( EXPONENT expr_expr )* ;
    def expr_pow(self, ):
        retval = self.expr_pow_return()
        retval.start = self.input.LT(1)

        expr_pow_StartIndex = self.input.index()

        root_0 = None

        EXPONENT908 = None
        expr_expr907 = None

        expr_expr909 = None


        EXPONENT908_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 154):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:870:2: ( expr_expr ( EXPONENT expr_expr )* )
                # ./output/PLSQL3.g:870:4: expr_expr ( EXPONENT expr_expr )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_expr_expr_in_expr_pow5372)
                expr_expr907 = self.expr_expr()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, expr_expr907.tree)


                # ./output/PLSQL3.g:870:14: ( EXPONENT expr_expr )*
                while True: #loop236
                    alt236 = 2
                    LA236_0 = self.input.LA(1)

                    if (LA236_0 == EXPONENT) :
                        LA236_2 = self.input.LA(2)

                        if (self.synpred383_PLSQL3()) :
                            alt236 = 1




                    if alt236 == 1:
                        # ./output/PLSQL3.g:870:16: EXPONENT expr_expr
                        pass
                        EXPONENT908 = self.match(self.input, EXPONENT, self.FOLLOW_EXPONENT_in_expr_pow5376)
                        if self._state.backtracking == 0:
                            EXPONENT908_tree = self._adaptor.createWithPayload(EXPONENT908)
                            self._adaptor.addChild(root_0, EXPONENT908_tree)



                        self._state.following.append(self.FOLLOW_expr_expr_in_expr_pow5378)
                        expr_expr909 = self.expr_expr()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, expr_expr909.tree)



                    else:
                        break #loop236




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 154, expr_pow_StartIndex, success)


            pass
        return retval

    # $ANTLR end "expr_pow"


    class expr_expr_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.expr_expr_return, self).__init__()

            self.tree = None





    # $ANTLR start "expr_expr"
    # ./output/PLSQL3.g:872:1: expr_expr : ( ( expr_paren )=> expr_paren | ( function_expression )=> function_expression | ( case_expression )=> case_expression | ( cursor_expression )=> cursor_expression | ( simple_expression )=> simple_expression | ( select_expression )=> select_expression );
    def expr_expr(self, ):
        retval = self.expr_expr_return()
        retval.start = self.input.LT(1)

        expr_expr_StartIndex = self.input.index()

        root_0 = None

        expr_paren910 = None

        function_expression911 = None

        case_expression912 = None

        cursor_expression913 = None

        simple_expression914 = None

        select_expression915 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 155):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:873:2: ( ( expr_paren )=> expr_paren | ( function_expression )=> function_expression | ( case_expression )=> case_expression | ( cursor_expression )=> cursor_expression | ( simple_expression )=> simple_expression | ( select_expression )=> select_expression )
                alt237 = 6
                LA237_0 = self.input.LA(1)

                if (LA237_0 == LPAREN) and (self.synpred384_PLSQL3()):
                    alt237 = 1
                elif (LA237_0 == ID) :
                    LA237_2 = self.input.LA(2)

                    if (LA237_2 == LPAREN) and (self.synpred387_PLSQL3()):
                        alt237 = 4
                    elif (self.synpred385_PLSQL3()) :
                        alt237 = 2
                    elif (self.synpred388_PLSQL3()) :
                        alt237 = 5
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 237, 2, self.input)

                        raise nvae


                elif (LA237_0 == 144) :
                    LA237_3 = self.input.LA(2)

                    if (self.synpred385_PLSQL3()) :
                        alt237 = 2
                    elif (self.synpred388_PLSQL3()) :
                        alt237 = 5
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 237, 3, self.input)

                        raise nvae


                elif (LA237_0 == DOUBLEQUOTED_STRING) :
                    LA237_4 = self.input.LA(2)

                    if (self.synpred385_PLSQL3()) :
                        alt237 = 2
                    elif (self.synpred388_PLSQL3()) :
                        alt237 = 5
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 237, 4, self.input)

                        raise nvae


                elif (LA237_0 == 81) and (self.synpred385_PLSQL3()):
                    alt237 = 2
                elif (LA237_0 == 65) and (self.synpred386_PLSQL3()):
                    alt237 = 3
                elif (LA237_0 == 89 or LA237_0 == 156) and (self.synpred388_PLSQL3()):
                    alt237 = 5
                elif (LA237_0 == 151) and (self.synpred388_PLSQL3()):
                    alt237 = 5
                elif (LA237_0 == QUOTED_STRING) and (self.synpred388_PLSQL3()):
                    alt237 = 5
                elif (LA237_0 == NUMBER) and (self.synpred388_PLSQL3()):
                    alt237 = 5
                elif (LA237_0 == 120) and (self.synpred388_PLSQL3()):
                    alt237 = 5
                elif (LA237_0 == 147) and (self.synpred389_PLSQL3()):
                    alt237 = 6
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 237, 0, self.input)

                    raise nvae


                if alt237 == 1:
                    # ./output/PLSQL3.g:873:4: ( expr_paren )=> expr_paren
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_expr_paren_in_expr_expr5399)
                    expr_paren910 = self.expr_paren()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, expr_paren910.tree)



                elif alt237 == 2:
                    # ./output/PLSQL3.g:874:4: ( function_expression )=> function_expression
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_function_expression_in_expr_expr5412)
                    function_expression911 = self.function_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, function_expression911.tree)



                elif alt237 == 3:
                    # ./output/PLSQL3.g:876:4: ( case_expression )=> case_expression
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_case_expression_in_expr_expr5426)
                    case_expression912 = self.case_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, case_expression912.tree)



                elif alt237 == 4:
                    # ./output/PLSQL3.g:877:4: ( cursor_expression )=> cursor_expression
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_cursor_expression_in_expr_expr5439)
                    cursor_expression913 = self.cursor_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, cursor_expression913.tree)



                elif alt237 == 5:
                    # ./output/PLSQL3.g:878:4: ( simple_expression )=> simple_expression
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_simple_expression_in_expr_expr5452)
                    simple_expression914 = self.simple_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, simple_expression914.tree)



                elif alt237 == 6:
                    # ./output/PLSQL3.g:879:4: ( select_expression )=> select_expression
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_select_expression_in_expr_expr5465)
                    select_expression915 = self.select_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, select_expression915.tree)



                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 155, expr_expr_StartIndex, success)


            pass
        return retval

    # $ANTLR end "expr_expr"


    class simple_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.simple_expression_return, self).__init__()

            self.tree = None





    # $ANTLR start "simple_expression"
    # ./output/PLSQL3.g:890:1: simple_expression : ( boolean_literal | 'SQL' ( FOUND_ATTR | NOTFOUND_ATTR | ISOPEN_ATTR | ROWCOUNT_ATTR | BULK_ROWCOUNT_ATTR ) | ( column_spec )=> column_spec | QUOTED_STRING | NUMBER | 'NULL' );
    def simple_expression(self, ):
        retval = self.simple_expression_return()
        retval.start = self.input.LT(1)

        simple_expression_StartIndex = self.input.index()

        root_0 = None

        string_literal917 = None
        set918 = None
        QUOTED_STRING920 = None
        NUMBER921 = None
        string_literal922 = None
        boolean_literal916 = None

        column_spec919 = None


        string_literal917_tree = None
        set918_tree = None
        QUOTED_STRING920_tree = None
        NUMBER921_tree = None
        string_literal922_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 156):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:891:2: ( boolean_literal | 'SQL' ( FOUND_ATTR | NOTFOUND_ATTR | ISOPEN_ATTR | ROWCOUNT_ATTR | BULK_ROWCOUNT_ATTR ) | ( column_spec )=> column_spec | QUOTED_STRING | NUMBER | 'NULL' )
                alt238 = 6
                LA238_0 = self.input.LA(1)

                if (LA238_0 == 89 or LA238_0 == 156) :
                    alt238 = 1
                elif (LA238_0 == 151) :
                    alt238 = 2
                elif (LA238_0 == DOUBLEQUOTED_STRING or LA238_0 == ID) and (self.synpred396_PLSQL3()):
                    alt238 = 3
                elif (LA238_0 == 144) and (self.synpred396_PLSQL3()):
                    alt238 = 3
                elif (LA238_0 == QUOTED_STRING) :
                    alt238 = 4
                elif (LA238_0 == NUMBER) :
                    alt238 = 5
                elif (LA238_0 == 120) :
                    alt238 = 6
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 238, 0, self.input)

                    raise nvae


                if alt238 == 1:
                    # ./output/PLSQL3.g:891:4: boolean_literal
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_boolean_literal_in_simple_expression5484)
                    boolean_literal916 = self.boolean_literal()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, boolean_literal916.tree)



                elif alt238 == 2:
                    # ./output/PLSQL3.g:892:4: 'SQL' ( FOUND_ATTR | NOTFOUND_ATTR | ISOPEN_ATTR | ROWCOUNT_ATTR | BULK_ROWCOUNT_ATTR )
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal917 = self.match(self.input, 151, self.FOLLOW_151_in_simple_expression5489)
                    if self._state.backtracking == 0:
                        string_literal917_tree = self._adaptor.createWithPayload(string_literal917)
                        self._adaptor.addChild(root_0, string_literal917_tree)



                    set918 = self.input.LT(1)

                    if self.input.LA(1) == BULK_ROWCOUNT_ATTR or self.input.LA(1) == FOUND_ATTR or self.input.LA(1) == ISOPEN_ATTR or self.input.LA(1) == NOTFOUND_ATTR or self.input.LA(1) == ROWCOUNT_ATTR:
                        self.input.consume()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set918))

                        self._state.errorRecovery = False


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        mse = MismatchedSetException(None, self.input)
                        raise mse




                elif alt238 == 3:
                    # ./output/PLSQL3.g:893:4: ( column_spec )=> column_spec
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_column_spec_in_simple_expression5524)
                    column_spec919 = self.column_spec()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, column_spec919.tree)



                elif alt238 == 4:
                    # ./output/PLSQL3.g:894:4: QUOTED_STRING
                    pass
                    root_0 = self._adaptor.nil()


                    QUOTED_STRING920 = self.match(self.input, QUOTED_STRING, self.FOLLOW_QUOTED_STRING_in_simple_expression5529)
                    if self._state.backtracking == 0:
                        QUOTED_STRING920_tree = self._adaptor.createWithPayload(QUOTED_STRING920)
                        self._adaptor.addChild(root_0, QUOTED_STRING920_tree)




                elif alt238 == 5:
                    # ./output/PLSQL3.g:895:4: NUMBER
                    pass
                    root_0 = self._adaptor.nil()


                    NUMBER921 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_simple_expression5534)
                    if self._state.backtracking == 0:
                        NUMBER921_tree = self._adaptor.createWithPayload(NUMBER921)
                        self._adaptor.addChild(root_0, NUMBER921_tree)




                elif alt238 == 6:
                    # ./output/PLSQL3.g:899:4: 'NULL'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal922 = self.match(self.input, 120, self.FOLLOW_120_in_simple_expression5542)
                    if self._state.backtracking == 0:
                        string_literal922_tree = self._adaptor.createWithPayload(string_literal922)
                        self._adaptor.addChild(root_0, string_literal922_tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 156, simple_expression_StartIndex, success)


            pass
        return retval

    # $ANTLR end "simple_expression"


    class compound_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.compound_expression_return, self).__init__()

            self.tree = None





    # $ANTLR start "compound_expression"
    # ./output/PLSQL3.g:901:1: compound_expression : expr_prior ;
    def compound_expression(self, ):
        retval = self.compound_expression_return()
        retval.start = self.input.LT(1)

        compound_expression_StartIndex = self.input.index()

        root_0 = None

        expr_prior923 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 157):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:904:2: ( expr_prior )
                # ./output/PLSQL3.g:904:4: expr_prior
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_expr_prior_in_compound_expression5554)
                expr_prior923 = self.expr_prior()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, expr_prior923.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 157, compound_expression_StartIndex, success)


            pass
        return retval

    # $ANTLR end "compound_expression"


    class expr_paren_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.expr_paren_return, self).__init__()

            self.tree = None





    # $ANTLR start "expr_paren"
    # ./output/PLSQL3.g:908:1: expr_paren : LPAREN nested_expression RPAREN ;
    def expr_paren(self, ):
        retval = self.expr_paren_return()
        retval.start = self.input.LT(1)

        expr_paren_StartIndex = self.input.index()

        root_0 = None

        LPAREN924 = None
        RPAREN926 = None
        nested_expression925 = None


        LPAREN924_tree = None
        RPAREN926_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 158):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:909:2: ( LPAREN nested_expression RPAREN )
                # ./output/PLSQL3.g:909:4: LPAREN nested_expression RPAREN
                pass
                root_0 = self._adaptor.nil()


                LPAREN924 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_expr_paren5566)
                if self._state.backtracking == 0:
                    LPAREN924_tree = self._adaptor.createWithPayload(LPAREN924)
                    self._adaptor.addChild(root_0, LPAREN924_tree)



                self._state.following.append(self.FOLLOW_nested_expression_in_expr_paren5568)
                nested_expression925 = self.nested_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, nested_expression925.tree)


                RPAREN926 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_expr_paren5570)
                if self._state.backtracking == 0:
                    RPAREN926_tree = self._adaptor.createWithPayload(RPAREN926)
                    self._adaptor.addChild(root_0, RPAREN926_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 158, expr_paren_StartIndex, success)


            pass
        return retval

    # $ANTLR end "expr_paren"


    class expr_prior_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.expr_prior_return, self).__init__()

            self.tree = None





    # $ANTLR start "expr_prior"
    # ./output/PLSQL3.g:911:1: expr_prior : 'PRIOR' expr_add ;
    def expr_prior(self, ):
        retval = self.expr_prior_return()
        retval.start = self.input.LT(1)

        expr_prior_StartIndex = self.input.index()

        root_0 = None

        string_literal927 = None
        expr_add928 = None


        string_literal927_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 159):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:912:2: ( 'PRIOR' expr_add )
                # ./output/PLSQL3.g:912:4: 'PRIOR' expr_add
                pass
                root_0 = self._adaptor.nil()


                string_literal927 = self.match(self.input, 134, self.FOLLOW_134_in_expr_prior5580)
                if self._state.backtracking == 0:
                    string_literal927_tree = self._adaptor.createWithPayload(string_literal927)
                    self._adaptor.addChild(root_0, string_literal927_tree)



                self._state.following.append(self.FOLLOW_expr_add_in_expr_prior5582)
                expr_add928 = self.expr_add()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, expr_add928.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 159, expr_prior_StartIndex, success)


            pass
        return retval

    # $ANTLR end "expr_prior"


    class case_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.case_expression_return, self).__init__()

            self.tree = None





    # $ANTLR start "case_expression"
    # ./output/PLSQL3.g:914:1: case_expression : 'CASE' ( simple_case_expression | searched_case_expression ) ( else_case_expression )? 'END' ;
    def case_expression(self, ):
        retval = self.case_expression_return()
        retval.start = self.input.LT(1)

        case_expression_StartIndex = self.input.index()

        root_0 = None

        string_literal929 = None
        string_literal933 = None
        simple_case_expression930 = None

        searched_case_expression931 = None

        else_case_expression932 = None


        string_literal929_tree = None
        string_literal933_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 160):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:915:2: ( 'CASE' ( simple_case_expression | searched_case_expression ) ( else_case_expression )? 'END' )
                # ./output/PLSQL3.g:915:4: 'CASE' ( simple_case_expression | searched_case_expression ) ( else_case_expression )? 'END'
                pass
                root_0 = self._adaptor.nil()


                string_literal929 = self.match(self.input, 65, self.FOLLOW_65_in_case_expression5592)
                if self._state.backtracking == 0:
                    string_literal929_tree = self._adaptor.createWithPayload(string_literal929)
                    self._adaptor.addChild(root_0, string_literal929_tree)



                # ./output/PLSQL3.g:915:11: ( simple_case_expression | searched_case_expression )
                alt239 = 2
                LA239_0 = self.input.LA(1)

                if (LA239_0 == DOUBLEQUOTED_STRING or LA239_0 == ID or LA239_0 == LPAREN or LA239_0 == MINUS or LA239_0 == NUMBER or LA239_0 == PLUS or LA239_0 == QUOTED_STRING or LA239_0 == 65 or LA239_0 == 81 or LA239_0 == 89 or LA239_0 == 118 or LA239_0 == 120 or LA239_0 == 144 or LA239_0 == 147 or LA239_0 == 151 or LA239_0 == 156) :
                    alt239 = 1
                elif (LA239_0 == 164) :
                    alt239 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 239, 0, self.input)

                    raise nvae


                if alt239 == 1:
                    # ./output/PLSQL3.g:915:13: simple_case_expression
                    pass
                    self._state.following.append(self.FOLLOW_simple_case_expression_in_case_expression5596)
                    simple_case_expression930 = self.simple_case_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, simple_case_expression930.tree)



                elif alt239 == 2:
                    # ./output/PLSQL3.g:915:38: searched_case_expression
                    pass
                    self._state.following.append(self.FOLLOW_searched_case_expression_in_case_expression5600)
                    searched_case_expression931 = self.searched_case_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, searched_case_expression931.tree)





                # ./output/PLSQL3.g:915:65: ( else_case_expression )?
                alt240 = 2
                LA240_0 = self.input.LA(1)

                if (LA240_0 == 83) :
                    alt240 = 1
                if alt240 == 1:
                    # ./output/PLSQL3.g:915:67: else_case_expression
                    pass
                    self._state.following.append(self.FOLLOW_else_case_expression_in_case_expression5606)
                    else_case_expression932 = self.else_case_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, else_case_expression932.tree)





                string_literal933 = self.match(self.input, 85, self.FOLLOW_85_in_case_expression5611)
                if self._state.backtracking == 0:
                    string_literal933_tree = self._adaptor.createWithPayload(string_literal933)
                    self._adaptor.addChild(root_0, string_literal933_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 160, case_expression_StartIndex, success)


            pass
        return retval

    # $ANTLR end "case_expression"


    class simple_case_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.simple_case_expression_return, self).__init__()

            self.tree = None





    # $ANTLR start "simple_case_expression"
    # ./output/PLSQL3.g:917:1: simple_case_expression : nested_expression ( 'WHEN' nested_expression 'THEN' nested_expression )+ ;
    def simple_case_expression(self, ):
        retval = self.simple_case_expression_return()
        retval.start = self.input.LT(1)

        simple_case_expression_StartIndex = self.input.index()

        root_0 = None

        string_literal935 = None
        string_literal937 = None
        nested_expression934 = None

        nested_expression936 = None

        nested_expression938 = None


        string_literal935_tree = None
        string_literal937_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 161):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:918:2: ( nested_expression ( 'WHEN' nested_expression 'THEN' nested_expression )+ )
                # ./output/PLSQL3.g:918:4: nested_expression ( 'WHEN' nested_expression 'THEN' nested_expression )+
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_nested_expression_in_simple_case_expression5621)
                nested_expression934 = self.nested_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, nested_expression934.tree)


                # ./output/PLSQL3.g:918:22: ( 'WHEN' nested_expression 'THEN' nested_expression )+
                cnt241 = 0
                while True: #loop241
                    alt241 = 2
                    LA241_0 = self.input.LA(1)

                    if (LA241_0 == 164) :
                        alt241 = 1


                    if alt241 == 1:
                        # ./output/PLSQL3.g:918:24: 'WHEN' nested_expression 'THEN' nested_expression
                        pass
                        string_literal935 = self.match(self.input, 164, self.FOLLOW_164_in_simple_case_expression5625)
                        if self._state.backtracking == 0:
                            string_literal935_tree = self._adaptor.createWithPayload(string_literal935)
                            self._adaptor.addChild(root_0, string_literal935_tree)



                        self._state.following.append(self.FOLLOW_nested_expression_in_simple_case_expression5627)
                        nested_expression936 = self.nested_expression()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, nested_expression936.tree)


                        string_literal937 = self.match(self.input, 154, self.FOLLOW_154_in_simple_case_expression5629)
                        if self._state.backtracking == 0:
                            string_literal937_tree = self._adaptor.createWithPayload(string_literal937)
                            self._adaptor.addChild(root_0, string_literal937_tree)



                        self._state.following.append(self.FOLLOW_nested_expression_in_simple_case_expression5631)
                        nested_expression938 = self.nested_expression()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, nested_expression938.tree)



                    else:
                        if cnt241 >= 1:
                            break #loop241

                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        eee = EarlyExitException(241, self.input)
                        raise eee

                    cnt241 += 1




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 161, simple_case_expression_StartIndex, success)


            pass
        return retval

    # $ANTLR end "simple_case_expression"


    class searched_case_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.searched_case_expression_return, self).__init__()

            self.tree = None





    # $ANTLR start "searched_case_expression"
    # ./output/PLSQL3.g:920:1: searched_case_expression : ( 'WHEN' nested_condition 'THEN' nested_expression )+ ;
    def searched_case_expression(self, ):
        retval = self.searched_case_expression_return()
        retval.start = self.input.LT(1)

        searched_case_expression_StartIndex = self.input.index()

        root_0 = None

        string_literal939 = None
        string_literal941 = None
        nested_condition940 = None

        nested_expression942 = None


        string_literal939_tree = None
        string_literal941_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 162):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:921:2: ( ( 'WHEN' nested_condition 'THEN' nested_expression )+ )
                # ./output/PLSQL3.g:921:4: ( 'WHEN' nested_condition 'THEN' nested_expression )+
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:921:4: ( 'WHEN' nested_condition 'THEN' nested_expression )+
                cnt242 = 0
                while True: #loop242
                    alt242 = 2
                    LA242_0 = self.input.LA(1)

                    if (LA242_0 == 164) :
                        alt242 = 1


                    if alt242 == 1:
                        # ./output/PLSQL3.g:921:6: 'WHEN' nested_condition 'THEN' nested_expression
                        pass
                        string_literal939 = self.match(self.input, 164, self.FOLLOW_164_in_searched_case_expression5646)
                        if self._state.backtracking == 0:
                            string_literal939_tree = self._adaptor.createWithPayload(string_literal939)
                            self._adaptor.addChild(root_0, string_literal939_tree)



                        self._state.following.append(self.FOLLOW_nested_condition_in_searched_case_expression5648)
                        nested_condition940 = self.nested_condition()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, nested_condition940.tree)


                        string_literal941 = self.match(self.input, 154, self.FOLLOW_154_in_searched_case_expression5650)
                        if self._state.backtracking == 0:
                            string_literal941_tree = self._adaptor.createWithPayload(string_literal941)
                            self._adaptor.addChild(root_0, string_literal941_tree)



                        self._state.following.append(self.FOLLOW_nested_expression_in_searched_case_expression5652)
                        nested_expression942 = self.nested_expression()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, nested_expression942.tree)



                    else:
                        if cnt242 >= 1:
                            break #loop242

                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        eee = EarlyExitException(242, self.input)
                        raise eee

                    cnt242 += 1




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 162, searched_case_expression_StartIndex, success)


            pass
        return retval

    # $ANTLR end "searched_case_expression"


    class else_case_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.else_case_expression_return, self).__init__()

            self.tree = None





    # $ANTLR start "else_case_expression"
    # ./output/PLSQL3.g:923:1: else_case_expression : 'ELSE' nested_expression ;
    def else_case_expression(self, ):
        retval = self.else_case_expression_return()
        retval.start = self.input.LT(1)

        else_case_expression_StartIndex = self.input.index()

        root_0 = None

        string_literal943 = None
        nested_expression944 = None


        string_literal943_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 163):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:924:2: ( 'ELSE' nested_expression )
                # ./output/PLSQL3.g:924:4: 'ELSE' nested_expression
                pass
                root_0 = self._adaptor.nil()


                string_literal943 = self.match(self.input, 83, self.FOLLOW_83_in_else_case_expression5665)
                if self._state.backtracking == 0:
                    string_literal943_tree = self._adaptor.createWithPayload(string_literal943)
                    self._adaptor.addChild(root_0, string_literal943_tree)



                self._state.following.append(self.FOLLOW_nested_expression_in_else_case_expression5667)
                nested_expression944 = self.nested_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, nested_expression944.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 163, else_case_expression_StartIndex, success)


            pass
        return retval

    # $ANTLR end "else_case_expression"


    class case_statement_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.case_statement_return, self).__init__()

            self.tree = None





    # $ANTLR start "case_statement"
    # ./output/PLSQL3.g:926:1: case_statement : ( label_name )? 'CASE' ^ ( simple_case_statement | searched_case_statement ) ( else_case_statement )? 'END' 'CASE' ( label_name )? ;
    def case_statement(self, ):
        retval = self.case_statement_return()
        retval.start = self.input.LT(1)

        case_statement_StartIndex = self.input.index()

        root_0 = None

        string_literal946 = None
        string_literal950 = None
        string_literal951 = None
        label_name945 = None

        simple_case_statement947 = None

        searched_case_statement948 = None

        else_case_statement949 = None

        label_name952 = None


        string_literal946_tree = None
        string_literal950_tree = None
        string_literal951_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 164):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:927:2: ( ( label_name )? 'CASE' ^ ( simple_case_statement | searched_case_statement ) ( else_case_statement )? 'END' 'CASE' ( label_name )? )
                # ./output/PLSQL3.g:927:4: ( label_name )? 'CASE' ^ ( simple_case_statement | searched_case_statement ) ( else_case_statement )? 'END' 'CASE' ( label_name )?
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:927:4: ( label_name )?
                alt243 = 2
                LA243_0 = self.input.LA(1)

                if (LA243_0 == DOUBLEQUOTED_STRING or LA243_0 == ID) :
                    alt243 = 1
                if alt243 == 1:
                    # ./output/PLSQL3.g:927:6: label_name
                    pass
                    self._state.following.append(self.FOLLOW_label_name_in_case_statement5679)
                    label_name945 = self.label_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, label_name945.tree)





                string_literal946 = self.match(self.input, 65, self.FOLLOW_65_in_case_statement5684)
                if self._state.backtracking == 0:
                    string_literal946_tree = self._adaptor.createWithPayload(string_literal946)
                    root_0 = self._adaptor.becomeRoot(string_literal946_tree, root_0)



                # ./output/PLSQL3.g:927:28: ( simple_case_statement | searched_case_statement )
                alt244 = 2
                LA244_0 = self.input.LA(1)

                if (LA244_0 == DOUBLEQUOTED_STRING or LA244_0 == ID or LA244_0 == LPAREN or LA244_0 == MINUS or LA244_0 == NUMBER or LA244_0 == PLUS or LA244_0 == QUOTED_STRING or LA244_0 == 65 or LA244_0 == 81 or LA244_0 == 89 or LA244_0 == 118 or LA244_0 == 120 or LA244_0 == 144 or LA244_0 == 147 or LA244_0 == 151 or LA244_0 == 156) :
                    alt244 = 1
                elif (LA244_0 == 164) :
                    alt244 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 244, 0, self.input)

                    raise nvae


                if alt244 == 1:
                    # ./output/PLSQL3.g:927:30: simple_case_statement
                    pass
                    self._state.following.append(self.FOLLOW_simple_case_statement_in_case_statement5689)
                    simple_case_statement947 = self.simple_case_statement()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, simple_case_statement947.tree)



                elif alt244 == 2:
                    # ./output/PLSQL3.g:927:54: searched_case_statement
                    pass
                    self._state.following.append(self.FOLLOW_searched_case_statement_in_case_statement5693)
                    searched_case_statement948 = self.searched_case_statement()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, searched_case_statement948.tree)





                # ./output/PLSQL3.g:927:80: ( else_case_statement )?
                alt245 = 2
                LA245_0 = self.input.LA(1)

                if (LA245_0 == 83) :
                    alt245 = 1
                if alt245 == 1:
                    # ./output/PLSQL3.g:927:82: else_case_statement
                    pass
                    self._state.following.append(self.FOLLOW_else_case_statement_in_case_statement5699)
                    else_case_statement949 = self.else_case_statement()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, else_case_statement949.tree)





                string_literal950 = self.match(self.input, 85, self.FOLLOW_85_in_case_statement5704)
                if self._state.backtracking == 0:
                    string_literal950_tree = self._adaptor.createWithPayload(string_literal950)
                    self._adaptor.addChild(root_0, string_literal950_tree)



                string_literal951 = self.match(self.input, 65, self.FOLLOW_65_in_case_statement5706)
                if self._state.backtracking == 0:
                    string_literal951_tree = self._adaptor.createWithPayload(string_literal951)
                    self._adaptor.addChild(root_0, string_literal951_tree)



                # ./output/PLSQL3.g:927:118: ( label_name )?
                alt246 = 2
                LA246_0 = self.input.LA(1)

                if (LA246_0 == DOUBLEQUOTED_STRING or LA246_0 == ID) :
                    alt246 = 1
                if alt246 == 1:
                    # ./output/PLSQL3.g:927:120: label_name
                    pass
                    self._state.following.append(self.FOLLOW_label_name_in_case_statement5710)
                    label_name952 = self.label_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, label_name952.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 164, case_statement_StartIndex, success)


            pass
        return retval

    # $ANTLR end "case_statement"


    class simple_case_statement_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.simple_case_statement_return, self).__init__()

            self.tree = None





    # $ANTLR start "simple_case_statement"
    # ./output/PLSQL3.g:929:1: simple_case_statement : plsql_expression ( 'WHEN' plsql_expression 'THEN' seq_of_statements )+ ;
    def simple_case_statement(self, ):
        retval = self.simple_case_statement_return()
        retval.start = self.input.LT(1)

        simple_case_statement_StartIndex = self.input.index()

        root_0 = None

        string_literal954 = None
        string_literal956 = None
        plsql_expression953 = None

        plsql_expression955 = None

        seq_of_statements957 = None


        string_literal954_tree = None
        string_literal956_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 165):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:930:2: ( plsql_expression ( 'WHEN' plsql_expression 'THEN' seq_of_statements )+ )
                # ./output/PLSQL3.g:930:4: plsql_expression ( 'WHEN' plsql_expression 'THEN' seq_of_statements )+
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_plsql_expression_in_simple_case_statement5723)
                plsql_expression953 = self.plsql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, plsql_expression953.tree)


                # ./output/PLSQL3.g:930:21: ( 'WHEN' plsql_expression 'THEN' seq_of_statements )+
                cnt247 = 0
                while True: #loop247
                    alt247 = 2
                    LA247_0 = self.input.LA(1)

                    if (LA247_0 == 164) :
                        alt247 = 1


                    if alt247 == 1:
                        # ./output/PLSQL3.g:930:23: 'WHEN' plsql_expression 'THEN' seq_of_statements
                        pass
                        string_literal954 = self.match(self.input, 164, self.FOLLOW_164_in_simple_case_statement5727)
                        if self._state.backtracking == 0:
                            string_literal954_tree = self._adaptor.createWithPayload(string_literal954)
                            self._adaptor.addChild(root_0, string_literal954_tree)



                        self._state.following.append(self.FOLLOW_plsql_expression_in_simple_case_statement5729)
                        plsql_expression955 = self.plsql_expression()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, plsql_expression955.tree)


                        string_literal956 = self.match(self.input, 154, self.FOLLOW_154_in_simple_case_statement5731)
                        if self._state.backtracking == 0:
                            string_literal956_tree = self._adaptor.createWithPayload(string_literal956)
                            self._adaptor.addChild(root_0, string_literal956_tree)



                        self._state.following.append(self.FOLLOW_seq_of_statements_in_simple_case_statement5733)
                        seq_of_statements957 = self.seq_of_statements()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, seq_of_statements957.tree)



                    else:
                        if cnt247 >= 1:
                            break #loop247

                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        eee = EarlyExitException(247, self.input)
                        raise eee

                    cnt247 += 1




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 165, simple_case_statement_StartIndex, success)


            pass
        return retval

    # $ANTLR end "simple_case_statement"


    class searched_case_statement_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.searched_case_statement_return, self).__init__()

            self.tree = None





    # $ANTLR start "searched_case_statement"
    # ./output/PLSQL3.g:932:1: searched_case_statement : ( 'WHEN' plsql_expression 'THEN' seq_of_statements )+ ;
    def searched_case_statement(self, ):
        retval = self.searched_case_statement_return()
        retval.start = self.input.LT(1)

        searched_case_statement_StartIndex = self.input.index()

        root_0 = None

        string_literal958 = None
        string_literal960 = None
        plsql_expression959 = None

        seq_of_statements961 = None


        string_literal958_tree = None
        string_literal960_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 166):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:933:2: ( ( 'WHEN' plsql_expression 'THEN' seq_of_statements )+ )
                # ./output/PLSQL3.g:933:4: ( 'WHEN' plsql_expression 'THEN' seq_of_statements )+
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:933:4: ( 'WHEN' plsql_expression 'THEN' seq_of_statements )+
                cnt248 = 0
                while True: #loop248
                    alt248 = 2
                    LA248_0 = self.input.LA(1)

                    if (LA248_0 == 164) :
                        alt248 = 1


                    if alt248 == 1:
                        # ./output/PLSQL3.g:933:6: 'WHEN' plsql_expression 'THEN' seq_of_statements
                        pass
                        string_literal958 = self.match(self.input, 164, self.FOLLOW_164_in_searched_case_statement5748)
                        if self._state.backtracking == 0:
                            string_literal958_tree = self._adaptor.createWithPayload(string_literal958)
                            self._adaptor.addChild(root_0, string_literal958_tree)



                        self._state.following.append(self.FOLLOW_plsql_expression_in_searched_case_statement5750)
                        plsql_expression959 = self.plsql_expression()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, plsql_expression959.tree)


                        string_literal960 = self.match(self.input, 154, self.FOLLOW_154_in_searched_case_statement5752)
                        if self._state.backtracking == 0:
                            string_literal960_tree = self._adaptor.createWithPayload(string_literal960)
                            self._adaptor.addChild(root_0, string_literal960_tree)



                        self._state.following.append(self.FOLLOW_seq_of_statements_in_searched_case_statement5754)
                        seq_of_statements961 = self.seq_of_statements()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, seq_of_statements961.tree)



                    else:
                        if cnt248 >= 1:
                            break #loop248

                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        eee = EarlyExitException(248, self.input)
                        raise eee

                    cnt248 += 1




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 166, searched_case_statement_StartIndex, success)


            pass
        return retval

    # $ANTLR end "searched_case_statement"


    class else_case_statement_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.else_case_statement_return, self).__init__()

            self.tree = None





    # $ANTLR start "else_case_statement"
    # ./output/PLSQL3.g:935:1: else_case_statement : 'ELSE' seq_of_statements ;
    def else_case_statement(self, ):
        retval = self.else_case_statement_return()
        retval.start = self.input.LT(1)

        else_case_statement_StartIndex = self.input.index()

        root_0 = None

        string_literal962 = None
        seq_of_statements963 = None


        string_literal962_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 167):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:936:2: ( 'ELSE' seq_of_statements )
                # ./output/PLSQL3.g:936:4: 'ELSE' seq_of_statements
                pass
                root_0 = self._adaptor.nil()


                string_literal962 = self.match(self.input, 83, self.FOLLOW_83_in_else_case_statement5767)
                if self._state.backtracking == 0:
                    string_literal962_tree = self._adaptor.createWithPayload(string_literal962)
                    self._adaptor.addChild(root_0, string_literal962_tree)



                self._state.following.append(self.FOLLOW_seq_of_statements_in_else_case_statement5769)
                seq_of_statements963 = self.seq_of_statements()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, seq_of_statements963.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 167, else_case_statement_StartIndex, success)


            pass
        return retval

    # $ANTLR end "else_case_statement"


    class cursor_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.cursor_expression_return, self).__init__()

            self.tree = None





    # $ANTLR start "cursor_expression"
    # ./output/PLSQL3.g:938:1: cursor_expression : keyCURSOR LPAREN subquery RPAREN ;
    def cursor_expression(self, ):
        retval = self.cursor_expression_return()
        retval.start = self.input.LT(1)

        cursor_expression_StartIndex = self.input.index()

        root_0 = None

        LPAREN965 = None
        RPAREN967 = None
        keyCURSOR964 = None

        subquery966 = None


        LPAREN965_tree = None
        RPAREN967_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 168):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:939:2: ( keyCURSOR LPAREN subquery RPAREN )
                # ./output/PLSQL3.g:939:4: keyCURSOR LPAREN subquery RPAREN
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyCURSOR_in_cursor_expression5779)
                keyCURSOR964 = self.keyCURSOR()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyCURSOR964.tree)


                LPAREN965 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_cursor_expression5781)
                if self._state.backtracking == 0:
                    LPAREN965_tree = self._adaptor.createWithPayload(LPAREN965)
                    self._adaptor.addChild(root_0, LPAREN965_tree)



                self._state.following.append(self.FOLLOW_subquery_in_cursor_expression5783)
                subquery966 = self.subquery()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, subquery966.tree)


                RPAREN967 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_cursor_expression5785)
                if self._state.backtracking == 0:
                    RPAREN967_tree = self._adaptor.createWithPayload(RPAREN967)
                    self._adaptor.addChild(root_0, RPAREN967_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 168, cursor_expression_StartIndex, success)


            pass
        return retval

    # $ANTLR end "cursor_expression"


    class datetime_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.datetime_expression_return, self).__init__()

            self.tree = None





    # $ANTLR start "datetime_expression"
    # ./output/PLSQL3.g:941:1: datetime_expression : sql_expression 'AT' ( keyLOCAL | keyTIME keyZONE ( keyDBTIMEZONE | keySESSIONTIMEZONE | sql_expression ) ) ;
    def datetime_expression(self, ):
        retval = self.datetime_expression_return()
        retval.start = self.input.LT(1)

        datetime_expression_StartIndex = self.input.index()

        root_0 = None

        string_literal969 = None
        sql_expression968 = None

        keyLOCAL970 = None

        keyTIME971 = None

        keyZONE972 = None

        keyDBTIMEZONE973 = None

        keySESSIONTIMEZONE974 = None

        sql_expression975 = None


        string_literal969_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 169):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:942:2: ( sql_expression 'AT' ( keyLOCAL | keyTIME keyZONE ( keyDBTIMEZONE | keySESSIONTIMEZONE | sql_expression ) ) )
                # ./output/PLSQL3.g:942:4: sql_expression 'AT' ( keyLOCAL | keyTIME keyZONE ( keyDBTIMEZONE | keySESSIONTIMEZONE | sql_expression ) )
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_sql_expression_in_datetime_expression5795)
                sql_expression968 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression968.tree)


                string_literal969 = self.match(self.input, 55, self.FOLLOW_55_in_datetime_expression5797)
                if self._state.backtracking == 0:
                    string_literal969_tree = self._adaptor.createWithPayload(string_literal969)
                    self._adaptor.addChild(root_0, string_literal969_tree)



                # ./output/PLSQL3.g:943:3: ( keyLOCAL | keyTIME keyZONE ( keyDBTIMEZONE | keySESSIONTIMEZONE | sql_expression ) )
                alt250 = 2
                LA250_0 = self.input.LA(1)

                if (LA250_0 == ID) :
                    LA250_1 = self.input.LA(2)

                    if (LA250_1 == EOF) :
                        alt250 = 1
                    elif (LA250_1 == ID) :
                        alt250 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 250, 1, self.input)

                        raise nvae


                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 250, 0, self.input)

                    raise nvae


                if alt250 == 1:
                    # ./output/PLSQL3.g:943:5: keyLOCAL
                    pass
                    self._state.following.append(self.FOLLOW_keyLOCAL_in_datetime_expression5803)
                    keyLOCAL970 = self.keyLOCAL()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyLOCAL970.tree)



                elif alt250 == 2:
                    # ./output/PLSQL3.g:944:5: keyTIME keyZONE ( keyDBTIMEZONE | keySESSIONTIMEZONE | sql_expression )
                    pass
                    self._state.following.append(self.FOLLOW_keyTIME_in_datetime_expression5809)
                    keyTIME971 = self.keyTIME()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyTIME971.tree)


                    self._state.following.append(self.FOLLOW_keyZONE_in_datetime_expression5811)
                    keyZONE972 = self.keyZONE()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyZONE972.tree)


                    # ./output/PLSQL3.g:944:21: ( keyDBTIMEZONE | keySESSIONTIMEZONE | sql_expression )
                    alt249 = 3
                    LA249_0 = self.input.LA(1)

                    if (LA249_0 == ID) :
                        LA249_1 = self.input.LA(2)

                        if (((((((self.input).LT(1).text.upper() == "DBTIMEZONE")) and (((this.input).LT(1).text.upper() == "DBTIMEZONE")))) and (self.synpred410_PLSQL3()))) :
                            alt249 = 1
                        elif (((((((self.input).LT(1).text.upper() == "SESSIONTIMEZONE")) and (((this.input).LT(1).text.upper() == "SESSIONTIMEZONE")))) and (self.synpred411_PLSQL3()))) :
                            alt249 = 2
                        elif (True) :
                            alt249 = 3
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 249, 1, self.input)

                            raise nvae


                    elif (LA249_0 == DOUBLEQUOTED_STRING or LA249_0 == LPAREN or LA249_0 == MINUS or LA249_0 == NUMBER or LA249_0 == PLUS or LA249_0 == QUOTED_STRING or LA249_0 == 65 or LA249_0 == 81 or LA249_0 == 89 or LA249_0 == 120 or LA249_0 == 144 or LA249_0 == 147 or LA249_0 == 151 or LA249_0 == 156) :
                        alt249 = 3
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 249, 0, self.input)

                        raise nvae


                    if alt249 == 1:
                        # ./output/PLSQL3.g:944:23: keyDBTIMEZONE
                        pass
                        self._state.following.append(self.FOLLOW_keyDBTIMEZONE_in_datetime_expression5815)
                        keyDBTIMEZONE973 = self.keyDBTIMEZONE()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyDBTIMEZONE973.tree)



                    elif alt249 == 2:
                        # ./output/PLSQL3.g:944:39: keySESSIONTIMEZONE
                        pass
                        self._state.following.append(self.FOLLOW_keySESSIONTIMEZONE_in_datetime_expression5819)
                        keySESSIONTIMEZONE974 = self.keySESSIONTIMEZONE()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keySESSIONTIMEZONE974.tree)



                    elif alt249 == 3:
                        # ./output/PLSQL3.g:944:60: sql_expression
                        pass
                        self._state.following.append(self.FOLLOW_sql_expression_in_datetime_expression5823)
                        sql_expression975 = self.sql_expression()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, sql_expression975.tree)










                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 169, datetime_expression_StartIndex, success)


            pass
        return retval

    # $ANTLR end "datetime_expression"


    class function_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.function_expression_return, self).__init__()

            self.tree = None





    # $ANTLR start "function_expression"
    # ./output/PLSQL3.g:947:1: function_expression : ( function_call ( DOT nested_expression )? |{...}? ( keyCOUNT LPAREN ( ASTERISK | nested_expression ) RPAREN | 'DISTINCT' ( LPAREN nested_expression RPAREN | nested_expression ) ) );
    def function_expression(self, ):
        retval = self.function_expression_return()
        retval.start = self.input.LT(1)

        function_expression_StartIndex = self.input.index()

        root_0 = None

        DOT977 = None
        LPAREN980 = None
        ASTERISK981 = None
        RPAREN983 = None
        string_literal984 = None
        LPAREN985 = None
        RPAREN987 = None
        function_call976 = None

        nested_expression978 = None

        keyCOUNT979 = None

        nested_expression982 = None

        nested_expression986 = None

        nested_expression988 = None


        DOT977_tree = None
        LPAREN980_tree = None
        ASTERISK981_tree = None
        RPAREN983_tree = None
        string_literal984_tree = None
        LPAREN985_tree = None
        RPAREN987_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 170):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:948:2: ( function_call ( DOT nested_expression )? |{...}? ( keyCOUNT LPAREN ( ASTERISK | nested_expression ) RPAREN | 'DISTINCT' ( LPAREN nested_expression RPAREN | nested_expression ) ) )
                alt255 = 2
                LA255 = self.input.LA(1)
                if LA255 == ID:
                    LA255_1 = self.input.LA(2)

                    if (self.synpred413_PLSQL3()) :
                        alt255 = 1
                    elif (((((((self.input).LT(1).text.upper() == "COUNT")) and (((this.input).LT(1).text.upper() == "COUNT")))) and ((is_sql )))) :
                        alt255 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 255, 1, self.input)

                        raise nvae


                elif LA255 == DOUBLEQUOTED_STRING or LA255 == 144:
                    alt255 = 1
                elif LA255 == 81:
                    alt255 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 255, 0, self.input)

                    raise nvae


                if alt255 == 1:
                    # ./output/PLSQL3.g:948:4: function_call ( DOT nested_expression )?
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_function_call_in_function_expression5839)
                    function_call976 = self.function_call()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, function_call976.tree)


                    # ./output/PLSQL3.g:948:18: ( DOT nested_expression )?
                    alt251 = 2
                    LA251_0 = self.input.LA(1)

                    if (LA251_0 == DOT) :
                        alt251 = 1
                    if alt251 == 1:
                        # ./output/PLSQL3.g:948:20: DOT nested_expression
                        pass
                        DOT977 = self.match(self.input, DOT, self.FOLLOW_DOT_in_function_expression5843)
                        if self._state.backtracking == 0:
                            DOT977_tree = self._adaptor.createWithPayload(DOT977)
                            self._adaptor.addChild(root_0, DOT977_tree)



                        self._state.following.append(self.FOLLOW_nested_expression_in_function_expression5845)
                        nested_expression978 = self.nested_expression()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, nested_expression978.tree)






                elif alt255 == 2:
                    # ./output/PLSQL3.g:949:4: {...}? ( keyCOUNT LPAREN ( ASTERISK | nested_expression ) RPAREN | 'DISTINCT' ( LPAREN nested_expression RPAREN | nested_expression ) )
                    pass
                    root_0 = self._adaptor.nil()


                    if not ((is_sql )):
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        raise FailedPredicateException(self.input, "function_expression", " is_sql ")


                    # ./output/PLSQL3.g:950:3: ( keyCOUNT LPAREN ( ASTERISK | nested_expression ) RPAREN | 'DISTINCT' ( LPAREN nested_expression RPAREN | nested_expression ) )
                    alt254 = 2
                    LA254_0 = self.input.LA(1)

                    if (LA254_0 == ID) :
                        alt254 = 1
                    elif (LA254_0 == 81) :
                        alt254 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 254, 0, self.input)

                        raise nvae


                    if alt254 == 1:
                        # ./output/PLSQL3.g:950:5: keyCOUNT LPAREN ( ASTERISK | nested_expression ) RPAREN
                        pass
                        self._state.following.append(self.FOLLOW_keyCOUNT_in_function_expression5859)
                        keyCOUNT979 = self.keyCOUNT()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyCOUNT979.tree)


                        LPAREN980 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_function_expression5861)
                        if self._state.backtracking == 0:
                            LPAREN980_tree = self._adaptor.createWithPayload(LPAREN980)
                            self._adaptor.addChild(root_0, LPAREN980_tree)



                        # ./output/PLSQL3.g:950:21: ( ASTERISK | nested_expression )
                        alt252 = 2
                        LA252_0 = self.input.LA(1)

                        if (LA252_0 == ASTERISK) :
                            alt252 = 1
                        elif (LA252_0 == DOUBLEQUOTED_STRING or LA252_0 == ID or LA252_0 == LPAREN or LA252_0 == MINUS or LA252_0 == NUMBER or LA252_0 == PLUS or LA252_0 == QUOTED_STRING or LA252_0 == 65 or LA252_0 == 81 or LA252_0 == 89 or LA252_0 == 118 or LA252_0 == 120 or LA252_0 == 144 or LA252_0 == 147 or LA252_0 == 151 or LA252_0 == 156) :
                            alt252 = 2
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 252, 0, self.input)

                            raise nvae


                        if alt252 == 1:
                            # ./output/PLSQL3.g:950:23: ASTERISK
                            pass
                            ASTERISK981 = self.match(self.input, ASTERISK, self.FOLLOW_ASTERISK_in_function_expression5865)
                            if self._state.backtracking == 0:
                                ASTERISK981_tree = self._adaptor.createWithPayload(ASTERISK981)
                                self._adaptor.addChild(root_0, ASTERISK981_tree)




                        elif alt252 == 2:
                            # ./output/PLSQL3.g:950:34: nested_expression
                            pass
                            self._state.following.append(self.FOLLOW_nested_expression_in_function_expression5869)
                            nested_expression982 = self.nested_expression()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, nested_expression982.tree)





                        RPAREN983 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_function_expression5873)
                        if self._state.backtracking == 0:
                            RPAREN983_tree = self._adaptor.createWithPayload(RPAREN983)
                            self._adaptor.addChild(root_0, RPAREN983_tree)




                    elif alt254 == 2:
                        # ./output/PLSQL3.g:951:5: 'DISTINCT' ( LPAREN nested_expression RPAREN | nested_expression )
                        pass
                        string_literal984 = self.match(self.input, 81, self.FOLLOW_81_in_function_expression5879)
                        if self._state.backtracking == 0:
                            string_literal984_tree = self._adaptor.createWithPayload(string_literal984)
                            self._adaptor.addChild(root_0, string_literal984_tree)



                        # ./output/PLSQL3.g:951:16: ( LPAREN nested_expression RPAREN | nested_expression )
                        alt253 = 2
                        LA253_0 = self.input.LA(1)

                        if (LA253_0 == LPAREN) :
                            LA253_1 = self.input.LA(2)

                            if (self.synpred416_PLSQL3()) :
                                alt253 = 1
                            elif (((not is_sql ) or (is_sql ))) :
                                alt253 = 2
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 253, 1, self.input)

                                raise nvae


                        elif (LA253_0 == DOUBLEQUOTED_STRING or LA253_0 == ID or LA253_0 == MINUS or LA253_0 == NUMBER or LA253_0 == PLUS or LA253_0 == QUOTED_STRING or LA253_0 == 65 or LA253_0 == 81 or LA253_0 == 89 or LA253_0 == 118 or LA253_0 == 120 or LA253_0 == 144 or LA253_0 == 147 or LA253_0 == 151 or LA253_0 == 156) :
                            alt253 = 2
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 253, 0, self.input)

                            raise nvae


                        if alt253 == 1:
                            # ./output/PLSQL3.g:951:18: LPAREN nested_expression RPAREN
                            pass
                            LPAREN985 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_function_expression5883)
                            if self._state.backtracking == 0:
                                LPAREN985_tree = self._adaptor.createWithPayload(LPAREN985)
                                self._adaptor.addChild(root_0, LPAREN985_tree)



                            self._state.following.append(self.FOLLOW_nested_expression_in_function_expression5885)
                            nested_expression986 = self.nested_expression()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, nested_expression986.tree)


                            RPAREN987 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_function_expression5887)
                            if self._state.backtracking == 0:
                                RPAREN987_tree = self._adaptor.createWithPayload(RPAREN987)
                                self._adaptor.addChild(root_0, RPAREN987_tree)




                        elif alt253 == 2:
                            # ./output/PLSQL3.g:951:52: nested_expression
                            pass
                            self._state.following.append(self.FOLLOW_nested_expression_in_function_expression5891)
                            nested_expression988 = self.nested_expression()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, nested_expression988.tree)









                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 170, function_expression_StartIndex, success)


            pass
        return retval

    # $ANTLR end "function_expression"


    class special_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.special_expression_return, self).__init__()

            self.tree = None





    # $ANTLR start "special_expression"
    # ./output/PLSQL3.g:954:1: special_expression :{...}? ( keyCOUNT LPAREN ( ASTERISK | nested_expression ) RPAREN | 'DISTINCT' LPAREN nested_expression RPAREN ) ;
    def special_expression(self, ):
        retval = self.special_expression_return()
        retval.start = self.input.LT(1)

        special_expression_StartIndex = self.input.index()

        root_0 = None

        LPAREN990 = None
        ASTERISK991 = None
        RPAREN993 = None
        string_literal994 = None
        LPAREN995 = None
        RPAREN997 = None
        keyCOUNT989 = None

        nested_expression992 = None

        nested_expression996 = None


        LPAREN990_tree = None
        ASTERISK991_tree = None
        RPAREN993_tree = None
        string_literal994_tree = None
        LPAREN995_tree = None
        RPAREN997_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 171):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:955:2: ({...}? ( keyCOUNT LPAREN ( ASTERISK | nested_expression ) RPAREN | 'DISTINCT' LPAREN nested_expression RPAREN ) )
                # ./output/PLSQL3.g:955:4: {...}? ( keyCOUNT LPAREN ( ASTERISK | nested_expression ) RPAREN | 'DISTINCT' LPAREN nested_expression RPAREN )
                pass
                root_0 = self._adaptor.nil()


                if not ((is_sql )):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "special_expression", " is_sql ")


                # ./output/PLSQL3.g:956:3: ( keyCOUNT LPAREN ( ASTERISK | nested_expression ) RPAREN | 'DISTINCT' LPAREN nested_expression RPAREN )
                alt257 = 2
                LA257_0 = self.input.LA(1)

                if (LA257_0 == ID) :
                    alt257 = 1
                elif (LA257_0 == 81) :
                    alt257 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 257, 0, self.input)

                    raise nvae


                if alt257 == 1:
                    # ./output/PLSQL3.g:956:5: keyCOUNT LPAREN ( ASTERISK | nested_expression ) RPAREN
                    pass
                    self._state.following.append(self.FOLLOW_keyCOUNT_in_special_expression5913)
                    keyCOUNT989 = self.keyCOUNT()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyCOUNT989.tree)


                    LPAREN990 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_special_expression5915)
                    if self._state.backtracking == 0:
                        LPAREN990_tree = self._adaptor.createWithPayload(LPAREN990)
                        self._adaptor.addChild(root_0, LPAREN990_tree)



                    # ./output/PLSQL3.g:956:21: ( ASTERISK | nested_expression )
                    alt256 = 2
                    LA256_0 = self.input.LA(1)

                    if (LA256_0 == ASTERISK) :
                        alt256 = 1
                    elif (LA256_0 == DOUBLEQUOTED_STRING or LA256_0 == ID or LA256_0 == LPAREN or LA256_0 == MINUS or LA256_0 == NUMBER or LA256_0 == PLUS or LA256_0 == QUOTED_STRING or LA256_0 == 65 or LA256_0 == 81 or LA256_0 == 89 or LA256_0 == 118 or LA256_0 == 120 or LA256_0 == 144 or LA256_0 == 147 or LA256_0 == 151 or LA256_0 == 156) :
                        alt256 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 256, 0, self.input)

                        raise nvae


                    if alt256 == 1:
                        # ./output/PLSQL3.g:956:23: ASTERISK
                        pass
                        ASTERISK991 = self.match(self.input, ASTERISK, self.FOLLOW_ASTERISK_in_special_expression5919)
                        if self._state.backtracking == 0:
                            ASTERISK991_tree = self._adaptor.createWithPayload(ASTERISK991)
                            self._adaptor.addChild(root_0, ASTERISK991_tree)




                    elif alt256 == 2:
                        # ./output/PLSQL3.g:956:34: nested_expression
                        pass
                        self._state.following.append(self.FOLLOW_nested_expression_in_special_expression5923)
                        nested_expression992 = self.nested_expression()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, nested_expression992.tree)





                    RPAREN993 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_special_expression5927)
                    if self._state.backtracking == 0:
                        RPAREN993_tree = self._adaptor.createWithPayload(RPAREN993)
                        self._adaptor.addChild(root_0, RPAREN993_tree)




                elif alt257 == 2:
                    # ./output/PLSQL3.g:957:5: 'DISTINCT' LPAREN nested_expression RPAREN
                    pass
                    string_literal994 = self.match(self.input, 81, self.FOLLOW_81_in_special_expression5933)
                    if self._state.backtracking == 0:
                        string_literal994_tree = self._adaptor.createWithPayload(string_literal994)
                        self._adaptor.addChild(root_0, string_literal994_tree)



                    LPAREN995 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_special_expression5935)
                    if self._state.backtracking == 0:
                        LPAREN995_tree = self._adaptor.createWithPayload(LPAREN995)
                        self._adaptor.addChild(root_0, LPAREN995_tree)



                    self._state.following.append(self.FOLLOW_nested_expression_in_special_expression5937)
                    nested_expression996 = self.nested_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, nested_expression996.tree)


                    RPAREN997 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_special_expression5939)
                    if self._state.backtracking == 0:
                        RPAREN997_tree = self._adaptor.createWithPayload(RPAREN997)
                        self._adaptor.addChild(root_0, RPAREN997_tree)








                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 171, special_expression_StartIndex, success)


            pass
        return retval

    # $ANTLR end "special_expression"


    class interval_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.interval_expression_return, self).__init__()

            self.tree = None





    # $ANTLR start "interval_expression"
    # ./output/PLSQL3.g:960:1: interval_expression : sql_expression ( keyDAY ( LPAREN leading_field_precision RPAREN )? 'TO' keySECOND ( LPAREN fractional_second_precision RPAREN )? | keyYEAR ( LPAREN leading_field_precision RPAREN )? 'TO' keyMONTH ) ;
    def interval_expression(self, ):
        retval = self.interval_expression_return()
        retval.start = self.input.LT(1)

        interval_expression_StartIndex = self.input.index()

        root_0 = None

        LPAREN1000 = None
        RPAREN1002 = None
        string_literal1003 = None
        LPAREN1005 = None
        RPAREN1007 = None
        LPAREN1009 = None
        RPAREN1011 = None
        string_literal1012 = None
        sql_expression998 = None

        keyDAY999 = None

        leading_field_precision1001 = None

        keySECOND1004 = None

        fractional_second_precision1006 = None

        keyYEAR1008 = None

        leading_field_precision1010 = None

        keyMONTH1013 = None


        LPAREN1000_tree = None
        RPAREN1002_tree = None
        string_literal1003_tree = None
        LPAREN1005_tree = None
        RPAREN1007_tree = None
        LPAREN1009_tree = None
        RPAREN1011_tree = None
        string_literal1012_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 172):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:961:2: ( sql_expression ( keyDAY ( LPAREN leading_field_precision RPAREN )? 'TO' keySECOND ( LPAREN fractional_second_precision RPAREN )? | keyYEAR ( LPAREN leading_field_precision RPAREN )? 'TO' keyMONTH ) )
                # ./output/PLSQL3.g:961:4: sql_expression ( keyDAY ( LPAREN leading_field_precision RPAREN )? 'TO' keySECOND ( LPAREN fractional_second_precision RPAREN )? | keyYEAR ( LPAREN leading_field_precision RPAREN )? 'TO' keyMONTH )
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_sql_expression_in_interval_expression5953)
                sql_expression998 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression998.tree)


                # ./output/PLSQL3.g:962:3: ( keyDAY ( LPAREN leading_field_precision RPAREN )? 'TO' keySECOND ( LPAREN fractional_second_precision RPAREN )? | keyYEAR ( LPAREN leading_field_precision RPAREN )? 'TO' keyMONTH )
                alt261 = 2
                LA261_0 = self.input.LA(1)

                if (LA261_0 == ID) :
                    LA261_1 = self.input.LA(2)

                    if (LA261_1 == LPAREN) :
                        LA261_2 = self.input.LA(3)

                        if (LA261_2 == NUMBER) :
                            LA261_4 = self.input.LA(4)

                            if (LA261_4 == RPAREN) :
                                LA261_6 = self.input.LA(5)

                                if (LA261_6 == 155) :
                                    LA261_3 = self.input.LA(6)

                                    if (LA261_3 == ID) :
                                        LA261_5 = self.input.LA(7)

                                        if (((((((self.input).LT(1).text.upper() == "DAY")) and (((this.input).LT(1).text.upper() == "DAY")))) and (self.synpred421_PLSQL3()))) :
                                            alt261 = 1
                                        elif (((self.input).LT(1).text.upper() == "YEAR")) :
                                            alt261 = 2
                                        else:
                                            if self._state.backtracking > 0:
                                                raise BacktrackingFailed


                                            nvae = NoViableAltException("", 261, 5, self.input)

                                            raise nvae


                                    else:
                                        if self._state.backtracking > 0:
                                            raise BacktrackingFailed


                                        nvae = NoViableAltException("", 261, 3, self.input)

                                        raise nvae


                                else:
                                    if self._state.backtracking > 0:
                                        raise BacktrackingFailed


                                    nvae = NoViableAltException("", 261, 6, self.input)

                                    raise nvae


                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 261, 4, self.input)

                                raise nvae


                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 261, 2, self.input)

                            raise nvae


                    elif (LA261_1 == 155) :
                        LA261_3 = self.input.LA(3)

                        if (LA261_3 == ID) :
                            LA261_5 = self.input.LA(4)

                            if (((((((self.input).LT(1).text.upper() == "DAY")) and (((this.input).LT(1).text.upper() == "DAY")))) and (self.synpred421_PLSQL3()))) :
                                alt261 = 1
                            elif (((self.input).LT(1).text.upper() == "YEAR")) :
                                alt261 = 2
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 261, 5, self.input)

                                raise nvae


                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 261, 3, self.input)

                            raise nvae


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 261, 1, self.input)

                        raise nvae


                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 261, 0, self.input)

                    raise nvae


                if alt261 == 1:
                    # ./output/PLSQL3.g:962:5: keyDAY ( LPAREN leading_field_precision RPAREN )? 'TO' keySECOND ( LPAREN fractional_second_precision RPAREN )?
                    pass
                    self._state.following.append(self.FOLLOW_keyDAY_in_interval_expression5959)
                    keyDAY999 = self.keyDAY()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyDAY999.tree)


                    # ./output/PLSQL3.g:962:12: ( LPAREN leading_field_precision RPAREN )?
                    alt258 = 2
                    LA258_0 = self.input.LA(1)

                    if (LA258_0 == LPAREN) :
                        alt258 = 1
                    if alt258 == 1:
                        # ./output/PLSQL3.g:962:14: LPAREN leading_field_precision RPAREN
                        pass
                        LPAREN1000 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_interval_expression5963)
                        if self._state.backtracking == 0:
                            LPAREN1000_tree = self._adaptor.createWithPayload(LPAREN1000)
                            self._adaptor.addChild(root_0, LPAREN1000_tree)



                        self._state.following.append(self.FOLLOW_leading_field_precision_in_interval_expression5965)
                        leading_field_precision1001 = self.leading_field_precision()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, leading_field_precision1001.tree)


                        RPAREN1002 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_interval_expression5967)
                        if self._state.backtracking == 0:
                            RPAREN1002_tree = self._adaptor.createWithPayload(RPAREN1002)
                            self._adaptor.addChild(root_0, RPAREN1002_tree)






                    string_literal1003 = self.match(self.input, 155, self.FOLLOW_155_in_interval_expression5972)
                    if self._state.backtracking == 0:
                        string_literal1003_tree = self._adaptor.createWithPayload(string_literal1003)
                        self._adaptor.addChild(root_0, string_literal1003_tree)



                    self._state.following.append(self.FOLLOW_keySECOND_in_interval_expression5974)
                    keySECOND1004 = self.keySECOND()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keySECOND1004.tree)


                    # ./output/PLSQL3.g:962:70: ( LPAREN fractional_second_precision RPAREN )?
                    alt259 = 2
                    LA259_0 = self.input.LA(1)

                    if (LA259_0 == LPAREN) :
                        alt259 = 1
                    if alt259 == 1:
                        # ./output/PLSQL3.g:962:72: LPAREN fractional_second_precision RPAREN
                        pass
                        LPAREN1005 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_interval_expression5978)
                        if self._state.backtracking == 0:
                            LPAREN1005_tree = self._adaptor.createWithPayload(LPAREN1005)
                            self._adaptor.addChild(root_0, LPAREN1005_tree)



                        self._state.following.append(self.FOLLOW_fractional_second_precision_in_interval_expression5980)
                        fractional_second_precision1006 = self.fractional_second_precision()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, fractional_second_precision1006.tree)


                        RPAREN1007 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_interval_expression5982)
                        if self._state.backtracking == 0:
                            RPAREN1007_tree = self._adaptor.createWithPayload(RPAREN1007)
                            self._adaptor.addChild(root_0, RPAREN1007_tree)







                elif alt261 == 2:
                    # ./output/PLSQL3.g:963:5: keyYEAR ( LPAREN leading_field_precision RPAREN )? 'TO' keyMONTH
                    pass
                    self._state.following.append(self.FOLLOW_keyYEAR_in_interval_expression5991)
                    keyYEAR1008 = self.keyYEAR()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyYEAR1008.tree)


                    # ./output/PLSQL3.g:963:13: ( LPAREN leading_field_precision RPAREN )?
                    alt260 = 2
                    LA260_0 = self.input.LA(1)

                    if (LA260_0 == LPAREN) :
                        alt260 = 1
                    if alt260 == 1:
                        # ./output/PLSQL3.g:963:15: LPAREN leading_field_precision RPAREN
                        pass
                        LPAREN1009 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_interval_expression5995)
                        if self._state.backtracking == 0:
                            LPAREN1009_tree = self._adaptor.createWithPayload(LPAREN1009)
                            self._adaptor.addChild(root_0, LPAREN1009_tree)



                        self._state.following.append(self.FOLLOW_leading_field_precision_in_interval_expression5997)
                        leading_field_precision1010 = self.leading_field_precision()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, leading_field_precision1010.tree)


                        RPAREN1011 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_interval_expression5999)
                        if self._state.backtracking == 0:
                            RPAREN1011_tree = self._adaptor.createWithPayload(RPAREN1011)
                            self._adaptor.addChild(root_0, RPAREN1011_tree)






                    string_literal1012 = self.match(self.input, 155, self.FOLLOW_155_in_interval_expression6004)
                    if self._state.backtracking == 0:
                        string_literal1012_tree = self._adaptor.createWithPayload(string_literal1012)
                        self._adaptor.addChild(root_0, string_literal1012_tree)



                    self._state.following.append(self.FOLLOW_keyMONTH_in_interval_expression6006)
                    keyMONTH1013 = self.keyMONTH()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyMONTH1013.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 172, interval_expression_StartIndex, success)


            pass
        return retval

    # $ANTLR end "interval_expression"


    class leading_field_precision_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.leading_field_precision_return, self).__init__()

            self.tree = None





    # $ANTLR start "leading_field_precision"
    # ./output/PLSQL3.g:966:1: leading_field_precision : integer ;
    def leading_field_precision(self, ):
        retval = self.leading_field_precision_return()
        retval.start = self.input.LT(1)

        leading_field_precision_StartIndex = self.input.index()

        root_0 = None

        integer1014 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 173):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:967:2: ( integer )
                # ./output/PLSQL3.g:967:4: integer
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_integer_in_leading_field_precision6020)
                integer1014 = self.integer()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, integer1014.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 173, leading_field_precision_StartIndex, success)


            pass
        return retval

    # $ANTLR end "leading_field_precision"


    class fractional_second_precision_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.fractional_second_precision_return, self).__init__()

            self.tree = None





    # $ANTLR start "fractional_second_precision"
    # ./output/PLSQL3.g:969:1: fractional_second_precision : integer ;
    def fractional_second_precision(self, ):
        retval = self.fractional_second_precision_return()
        retval.start = self.input.LT(1)

        fractional_second_precision_StartIndex = self.input.index()

        root_0 = None

        integer1015 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 174):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:970:2: ( integer )
                # ./output/PLSQL3.g:970:4: integer
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_integer_in_fractional_second_precision6031)
                integer1015 = self.integer()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, integer1015.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 174, fractional_second_precision_StartIndex, success)


            pass
        return retval

    # $ANTLR end "fractional_second_precision"


    class object_access_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.object_access_expression_return, self).__init__()

            self.tree = None





    # $ANTLR start "object_access_expression"
    # ./output/PLSQL3.g:972:1: object_access_expression :;
    def object_access_expression(self, ):
        retval = self.object_access_expression_return()
        retval.start = self.input.LT(1)

        object_access_expression_StartIndex = self.input.index()

        root_0 = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 175):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:973:2: ()
                # ./output/PLSQL3.g:974:2:
                pass
                root_0 = self._adaptor.nil()




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            finally:
                pass

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 175, object_access_expression_StartIndex, success)


            pass
        return retval

    # $ANTLR end "object_access_expression"


    class scalar_subquery_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.scalar_subquery_expression_return, self).__init__()

            self.tree = None





    # $ANTLR start "scalar_subquery_expression"
    # ./output/PLSQL3.g:975:1: scalar_subquery_expression :;
    def scalar_subquery_expression(self, ):
        retval = self.scalar_subquery_expression_return()
        retval.start = self.input.LT(1)

        scalar_subquery_expression_StartIndex = self.input.index()

        root_0 = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 176):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:976:2: ()
                # ./output/PLSQL3.g:977:2:
                pass
                root_0 = self._adaptor.nil()




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            finally:
                pass

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 176, scalar_subquery_expression_StartIndex, success)


            pass
        return retval

    # $ANTLR end "scalar_subquery_expression"


    class model_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.model_expression_return, self).__init__()

            self.tree = None





    # $ANTLR start "model_expression"
    # ./output/PLSQL3.g:978:1: model_expression :;
    def model_expression(self, ):
        retval = self.model_expression_return()
        retval.start = self.input.LT(1)

        model_expression_StartIndex = self.input.index()

        root_0 = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 177):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:979:2: ()
                # ./output/PLSQL3.g:980:2:
                pass
                root_0 = self._adaptor.nil()




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            finally:
                pass

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 177, model_expression_StartIndex, success)


            pass
        return retval

    # $ANTLR end "model_expression"


    class type_constructor_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.type_constructor_expression_return, self).__init__()

            self.tree = None





    # $ANTLR start "type_constructor_expression"
    # ./output/PLSQL3.g:981:1: type_constructor_expression :;
    def type_constructor_expression(self, ):
        retval = self.type_constructor_expression_return()
        retval.start = self.input.LT(1)

        type_constructor_expression_StartIndex = self.input.index()

        root_0 = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 178):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:982:2: ()
                # ./output/PLSQL3.g:983:2:
                pass
                root_0 = self._adaptor.nil()




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            finally:
                pass

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 178, type_constructor_expression_StartIndex, success)


            pass
        return retval

    # $ANTLR end "type_constructor_expression"


    class variable_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.variable_expression_return, self).__init__()

            self.tree = None





    # $ANTLR start "variable_expression"
    # ./output/PLSQL3.g:984:1: variable_expression :;
    def variable_expression(self, ):
        retval = self.variable_expression_return()
        retval.start = self.input.LT(1)

        variable_expression_StartIndex = self.input.index()

        root_0 = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 179):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:985:2: ()
                # ./output/PLSQL3.g:986:2:
                pass
                root_0 = self._adaptor.nil()




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            finally:
                pass

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 179, variable_expression_StartIndex, success)


            pass
        return retval

    # $ANTLR end "variable_expression"


    class sequence_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.sequence_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "sequence_name"
    # ./output/PLSQL3.g:987:1: sequence_name : identifier ;
    def sequence_name(self, ):
        retval = self.sequence_name_return()
        retval.start = self.input.LT(1)

        sequence_name_StartIndex = self.input.index()

        root_0 = None

        identifier1016 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 180):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:988:2: ( identifier )
                # ./output/PLSQL3.g:988:4: identifier
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_identifier_in_sequence_name6082)
                identifier1016 = self.identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, identifier1016.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 180, sequence_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "sequence_name"


    class integer_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.integer_return, self).__init__()

            self.tree = None





    # $ANTLR start "integer"
    # ./output/PLSQL3.g:990:1: integer : NUMBER ;
    def integer(self, ):
        retval = self.integer_return()
        retval.start = self.input.LT(1)

        integer_StartIndex = self.input.index()

        root_0 = None

        NUMBER1017 = None

        NUMBER1017_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 181):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:991:2: ( NUMBER )
                # ./output/PLSQL3.g:991:4: NUMBER
                pass
                root_0 = self._adaptor.nil()


                NUMBER1017 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_integer6092)
                if self._state.backtracking == 0:
                    NUMBER1017_tree = self._adaptor.createWithPayload(NUMBER1017)
                    self._adaptor.addChild(root_0, NUMBER1017_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 181, integer_StartIndex, success)


            pass
        return retval

    # $ANTLR end "integer"


    class alias_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.alias_return, self).__init__()

            self.tree = None





    # $ANTLR start "alias"
    # ./output/PLSQL3.g:995:1: alias : ( 'AS' )? sql_identifier ;
    def alias(self, ):
        retval = self.alias_return()
        retval.start = self.input.LT(1)

        alias_StartIndex = self.input.index()

        root_0 = None

        string_literal1018 = None
        sql_identifier1019 = None


        string_literal1018_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 182):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:996:2: ( ( 'AS' )? sql_identifier )
                # ./output/PLSQL3.g:996:4: ( 'AS' )? sql_identifier
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:996:4: ( 'AS' )?
                alt262 = 2
                LA262_0 = self.input.LA(1)

                if (LA262_0 == 53) :
                    alt262 = 1
                if alt262 == 1:
                    # ./output/PLSQL3.g:996:6: 'AS'
                    pass
                    string_literal1018 = self.match(self.input, 53, self.FOLLOW_53_in_alias6106)
                    if self._state.backtracking == 0:
                        string_literal1018_tree = self._adaptor.createWithPayload(string_literal1018)
                        self._adaptor.addChild(root_0, string_literal1018_tree)






                self._state.following.append(self.FOLLOW_sql_identifier_in_alias6111)
                sql_identifier1019 = self.sql_identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_identifier1019.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 182, alias_StartIndex, success)


            pass
        return retval

    # $ANTLR end "alias"


    class column_specs_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.column_specs_return, self).__init__()

            self.tree = None





    # $ANTLR start "column_specs"
    # ./output/PLSQL3.g:999:1: column_specs : column_spec ( COMMA column_spec )* ;
    def column_specs(self, ):
        retval = self.column_specs_return()
        retval.start = self.input.LT(1)

        column_specs_StartIndex = self.input.index()

        root_0 = None

        COMMA1021 = None
        column_spec1020 = None

        column_spec1022 = None


        COMMA1021_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 183):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1000:2: ( column_spec ( COMMA column_spec )* )
                # ./output/PLSQL3.g:1000:4: column_spec ( COMMA column_spec )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_column_spec_in_column_specs6122)
                column_spec1020 = self.column_spec()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, column_spec1020.tree)


                # ./output/PLSQL3.g:1000:16: ( COMMA column_spec )*
                while True: #loop263
                    alt263 = 2
                    LA263_0 = self.input.LA(1)

                    if (LA263_0 == COMMA) :
                        alt263 = 1


                    if alt263 == 1:
                        # ./output/PLSQL3.g:1000:18: COMMA column_spec
                        pass
                        COMMA1021 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_column_specs6126)
                        if self._state.backtracking == 0:
                            COMMA1021_tree = self._adaptor.createWithPayload(COMMA1021)
                            self._adaptor.addChild(root_0, COMMA1021_tree)



                        self._state.following.append(self.FOLLOW_column_spec_in_column_specs6128)
                        column_spec1022 = self.column_spec()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, column_spec1022.tree)



                    else:
                        break #loop263




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 183, column_specs_StartIndex, success)


            pass
        return retval

    # $ANTLR end "column_specs"


    class column_spec_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.column_spec_return, self).__init__()

            self.tree = None





    # $ANTLR start "column_spec"
    # ./output/PLSQL3.g:1003:1: column_spec : sql_identifier ( DOT sql_identifier ( DOT sql_identifier )? )? ;
    def column_spec(self, ):
        retval = self.column_spec_return()
        retval.start = self.input.LT(1)

        column_spec_StartIndex = self.input.index()

        root_0 = None

        DOT1024 = None
        DOT1026 = None
        sql_identifier1023 = None

        sql_identifier1025 = None

        sql_identifier1027 = None


        DOT1024_tree = None
        DOT1026_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 184):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1004:2: ( sql_identifier ( DOT sql_identifier ( DOT sql_identifier )? )? )
                # ./output/PLSQL3.g:1004:4: sql_identifier ( DOT sql_identifier ( DOT sql_identifier )? )?
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_sql_identifier_in_column_spec6142)
                sql_identifier1023 = self.sql_identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_identifier1023.tree)


                # ./output/PLSQL3.g:1004:19: ( DOT sql_identifier ( DOT sql_identifier )? )?
                alt265 = 2
                LA265_0 = self.input.LA(1)

                if (LA265_0 == DOT) :
                    LA265_1 = self.input.LA(2)

                    if (LA265_1 == DOUBLEQUOTED_STRING or LA265_1 == ID or LA265_1 == 144) :
                        alt265 = 1
                if alt265 == 1:
                    # ./output/PLSQL3.g:1004:21: DOT sql_identifier ( DOT sql_identifier )?
                    pass
                    DOT1024 = self.match(self.input, DOT, self.FOLLOW_DOT_in_column_spec6146)
                    if self._state.backtracking == 0:
                        DOT1024_tree = self._adaptor.createWithPayload(DOT1024)
                        self._adaptor.addChild(root_0, DOT1024_tree)



                    self._state.following.append(self.FOLLOW_sql_identifier_in_column_spec6148)
                    sql_identifier1025 = self.sql_identifier()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_identifier1025.tree)


                    # ./output/PLSQL3.g:1004:40: ( DOT sql_identifier )?
                    alt264 = 2
                    LA264_0 = self.input.LA(1)

                    if (LA264_0 == DOT) :
                        LA264_1 = self.input.LA(2)

                        if (LA264_1 == DOUBLEQUOTED_STRING or LA264_1 == ID or LA264_1 == 144) :
                            alt264 = 1
                    if alt264 == 1:
                        # ./output/PLSQL3.g:1004:42: DOT sql_identifier
                        pass
                        DOT1026 = self.match(self.input, DOT, self.FOLLOW_DOT_in_column_spec6152)
                        if self._state.backtracking == 0:
                            DOT1026_tree = self._adaptor.createWithPayload(DOT1026)
                            self._adaptor.addChild(root_0, DOT1026_tree)



                        self._state.following.append(self.FOLLOW_sql_identifier_in_column_spec6154)
                        sql_identifier1027 = self.sql_identifier()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, sql_identifier1027.tree)










                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 184, column_spec_StartIndex, success)


            pass
        return retval

    # $ANTLR end "column_spec"


    class column_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.column_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "column_name"
    # ./output/PLSQL3.g:1012:1: column_name : sql_identifier ;
    def column_name(self, ):
        retval = self.column_name_return()
        retval.start = self.input.LT(1)

        column_name_StartIndex = self.input.index()

        root_0 = None

        sql_identifier1028 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 185):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1013:2: ( sql_identifier )
                # ./output/PLSQL3.g:1013:4: sql_identifier
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_sql_identifier_in_column_name6176)
                sql_identifier1028 = self.sql_identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_identifier1028.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 185, column_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "column_name"


    class nested_table_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.nested_table_return, self).__init__()

            self.tree = None





    # $ANTLR start "nested_table"
    # ./output/PLSQL3.g:1015:1: nested_table : sql_identifier ;
    def nested_table(self, ):
        retval = self.nested_table_return()
        retval.start = self.input.LT(1)

        nested_table_StartIndex = self.input.index()

        root_0 = None

        sql_identifier1029 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 186):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1016:2: ( sql_identifier )
                # ./output/PLSQL3.g:1016:4: sql_identifier
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_sql_identifier_in_nested_table6186)
                sql_identifier1029 = self.sql_identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_identifier1029.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 186, nested_table_StartIndex, success)


            pass
        return retval

    # $ANTLR end "nested_table"


    class nested_table_column_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.nested_table_column_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "nested_table_column_name"
    # ./output/PLSQL3.g:1018:1: nested_table_column_name : ( schema_name DOT )? table_name DOT nested_table DOT column_name ;
    def nested_table_column_name(self, ):
        retval = self.nested_table_column_name_return()
        retval.start = self.input.LT(1)

        nested_table_column_name_StartIndex = self.input.index()

        root_0 = None

        DOT1031 = None
        DOT1033 = None
        DOT1035 = None
        schema_name1030 = None

        table_name1032 = None

        nested_table1034 = None

        column_name1036 = None


        DOT1031_tree = None
        DOT1033_tree = None
        DOT1035_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 187):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1019:2: ( ( schema_name DOT )? table_name DOT nested_table DOT column_name )
                # ./output/PLSQL3.g:1019:4: ( schema_name DOT )? table_name DOT nested_table DOT column_name
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:1019:4: ( schema_name DOT )?
                alt266 = 2
                LA266_0 = self.input.LA(1)

                if (LA266_0 == DOUBLEQUOTED_STRING or LA266_0 == ID) :
                    LA266_1 = self.input.LA(2)

                    if (LA266_1 == DOT) :
                        LA266_3 = self.input.LA(3)

                        if (LA266_3 == DOUBLEQUOTED_STRING or LA266_3 == ID) :
                            LA266_4 = self.input.LA(4)

                            if (LA266_4 == DOT) :
                                LA266_6 = self.input.LA(5)

                                if (LA266_6 == DOUBLEQUOTED_STRING or LA266_6 == ID) :
                                    LA266_7 = self.input.LA(6)

                                    if (LA266_7 == DOT) :
                                        alt266 = 1
                                elif (LA266_6 == 144) :
                                    LA266_8 = self.input.LA(6)

                                    if (LA266_8 == DOT) :
                                        alt266 = 1
                        elif (LA266_3 == 144) :
                            LA266_5 = self.input.LA(4)

                            if (LA266_5 == DOT) :
                                LA266_6 = self.input.LA(5)

                                if (LA266_6 == DOUBLEQUOTED_STRING or LA266_6 == ID) :
                                    LA266_7 = self.input.LA(6)

                                    if (LA266_7 == DOT) :
                                        alt266 = 1
                                elif (LA266_6 == 144) :
                                    LA266_8 = self.input.LA(6)

                                    if (LA266_8 == DOT) :
                                        alt266 = 1
                elif (LA266_0 == 144) :
                    LA266_2 = self.input.LA(2)

                    if (LA266_2 == DOT) :
                        LA266_3 = self.input.LA(3)

                        if (LA266_3 == DOUBLEQUOTED_STRING or LA266_3 == ID) :
                            LA266_4 = self.input.LA(4)

                            if (LA266_4 == DOT) :
                                LA266_6 = self.input.LA(5)

                                if (LA266_6 == DOUBLEQUOTED_STRING or LA266_6 == ID) :
                                    LA266_7 = self.input.LA(6)

                                    if (LA266_7 == DOT) :
                                        alt266 = 1
                                elif (LA266_6 == 144) :
                                    LA266_8 = self.input.LA(6)

                                    if (LA266_8 == DOT) :
                                        alt266 = 1
                        elif (LA266_3 == 144) :
                            LA266_5 = self.input.LA(4)

                            if (LA266_5 == DOT) :
                                LA266_6 = self.input.LA(5)

                                if (LA266_6 == DOUBLEQUOTED_STRING or LA266_6 == ID) :
                                    LA266_7 = self.input.LA(6)

                                    if (LA266_7 == DOT) :
                                        alt266 = 1
                                elif (LA266_6 == 144) :
                                    LA266_8 = self.input.LA(6)

                                    if (LA266_8 == DOT) :
                                        alt266 = 1
                if alt266 == 1:
                    # ./output/PLSQL3.g:1019:6: schema_name DOT
                    pass
                    self._state.following.append(self.FOLLOW_schema_name_in_nested_table_column_name6198)
                    schema_name1030 = self.schema_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, schema_name1030.tree)


                    DOT1031 = self.match(self.input, DOT, self.FOLLOW_DOT_in_nested_table_column_name6200)
                    if self._state.backtracking == 0:
                        DOT1031_tree = self._adaptor.createWithPayload(DOT1031)
                        self._adaptor.addChild(root_0, DOT1031_tree)






                self._state.following.append(self.FOLLOW_table_name_in_nested_table_column_name6205)
                table_name1032 = self.table_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, table_name1032.tree)


                DOT1033 = self.match(self.input, DOT, self.FOLLOW_DOT_in_nested_table_column_name6207)
                if self._state.backtracking == 0:
                    DOT1033_tree = self._adaptor.createWithPayload(DOT1033)
                    self._adaptor.addChild(root_0, DOT1033_tree)



                self._state.following.append(self.FOLLOW_nested_table_in_nested_table_column_name6209)
                nested_table1034 = self.nested_table()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, nested_table1034.tree)


                DOT1035 = self.match(self.input, DOT, self.FOLLOW_DOT_in_nested_table_column_name6211)
                if self._state.backtracking == 0:
                    DOT1035_tree = self._adaptor.createWithPayload(DOT1035)
                    self._adaptor.addChild(root_0, DOT1035_tree)



                self._state.following.append(self.FOLLOW_column_name_in_nested_table_column_name6213)
                column_name1036 = self.column_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, column_name1036.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 187, nested_table_column_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "nested_table_column_name"


    class user_defined_function_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.user_defined_function_return, self).__init__()

            self.tree = None





    # $ANTLR start "user_defined_function"
    # ./output/PLSQL3.g:1022:1: user_defined_function : sql_identifier ( DOT sql_identifier )* ( DOT ( 'EXISTS' | 'PRIOR' | 'DELETE' ) )? ;
    def user_defined_function(self, ):
        retval = self.user_defined_function_return()
        retval.start = self.input.LT(1)

        user_defined_function_StartIndex = self.input.index()

        root_0 = None

        DOT1038 = None
        DOT1040 = None
        set1041 = None
        sql_identifier1037 = None

        sql_identifier1039 = None


        DOT1038_tree = None
        DOT1040_tree = None
        set1041_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 188):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1023:2: ( sql_identifier ( DOT sql_identifier )* ( DOT ( 'EXISTS' | 'PRIOR' | 'DELETE' ) )? )
                # ./output/PLSQL3.g:1023:4: sql_identifier ( DOT sql_identifier )* ( DOT ( 'EXISTS' | 'PRIOR' | 'DELETE' ) )?
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_sql_identifier_in_user_defined_function6224)
                sql_identifier1037 = self.sql_identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_identifier1037.tree)


                # ./output/PLSQL3.g:1023:19: ( DOT sql_identifier )*
                while True: #loop267
                    alt267 = 2
                    LA267_0 = self.input.LA(1)

                    if (LA267_0 == DOT) :
                        LA267 = self.input.LA(2)
                        if LA267 == ID:
                            LA267_3 = self.input.LA(3)

                            if (self.synpred428_PLSQL3()) :
                                alt267 = 1


                        elif LA267 == 144:
                            LA267_4 = self.input.LA(3)

                            if (self.synpred428_PLSQL3()) :
                                alt267 = 1


                        elif LA267 == DOUBLEQUOTED_STRING:
                            LA267_5 = self.input.LA(3)

                            if (self.synpred428_PLSQL3()) :
                                alt267 = 1





                    if alt267 == 1:
                        # ./output/PLSQL3.g:1023:21: DOT sql_identifier
                        pass
                        DOT1038 = self.match(self.input, DOT, self.FOLLOW_DOT_in_user_defined_function6228)
                        if self._state.backtracking == 0:
                            DOT1038_tree = self._adaptor.createWithPayload(DOT1038)
                            self._adaptor.addChild(root_0, DOT1038_tree)



                        self._state.following.append(self.FOLLOW_sql_identifier_in_user_defined_function6230)
                        sql_identifier1039 = self.sql_identifier()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, sql_identifier1039.tree)



                    else:
                        break #loop267


                # ./output/PLSQL3.g:1023:43: ( DOT ( 'EXISTS' | 'PRIOR' | 'DELETE' ) )?
                alt268 = 2
                LA268_0 = self.input.LA(1)

                if (LA268_0 == DOT) :
                    LA268_1 = self.input.LA(2)

                    if (LA268_1 == 79 or LA268_1 == 88 or LA268_1 == 134) :
                        alt268 = 1
                if alt268 == 1:
                    # ./output/PLSQL3.g:1023:45: DOT ( 'EXISTS' | 'PRIOR' | 'DELETE' )
                    pass
                    DOT1040 = self.match(self.input, DOT, self.FOLLOW_DOT_in_user_defined_function6237)
                    if self._state.backtracking == 0:
                        DOT1040_tree = self._adaptor.createWithPayload(DOT1040)
                        self._adaptor.addChild(root_0, DOT1040_tree)



                    set1041 = self.input.LT(1)

                    if self.input.LA(1) == 79 or self.input.LA(1) == 88 or self.input.LA(1) == 134:
                        self.input.consume()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set1041))

                        self._state.errorRecovery = False


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        mse = MismatchedSetException(None, self.input)
                        raise mse








                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 188, user_defined_function_StartIndex, success)


            pass
        return retval

    # $ANTLR end "user_defined_function"


    class selected_table_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.selected_table_return, self).__init__()

            self.tree = None





    # $ANTLR start "selected_table"
    # ./output/PLSQL3.g:1035:1: selected_table : ( table_spec | ( 'TABLE' | keyTHE )? subquery ) ( alias )? ;
    def selected_table(self, ):
        retval = self.selected_table_return()
        retval.start = self.input.LT(1)

        selected_table_StartIndex = self.input.index()

        root_0 = None

        string_literal1043 = None
        table_spec1042 = None

        keyTHE1044 = None

        subquery1045 = None

        alias1046 = None


        string_literal1043_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 189):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1036:2: ( ( table_spec | ( 'TABLE' | keyTHE )? subquery ) ( alias )? )
                # ./output/PLSQL3.g:1036:4: ( table_spec | ( 'TABLE' | keyTHE )? subquery ) ( alias )?
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:1036:4: ( table_spec | ( 'TABLE' | keyTHE )? subquery )
                alt270 = 2
                LA270 = self.input.LA(1)
                if LA270 == ID:
                    LA270_1 = self.input.LA(2)

                    if (self.synpred432_PLSQL3()) :
                        alt270 = 1
                    elif (((self.input).LT(1).text.upper() == "THE")) :
                        alt270 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 270, 1, self.input)

                        raise nvae


                elif LA270 == DOUBLEQUOTED_STRING or LA270 == 144:
                    alt270 = 1
                elif LA270 == LPAREN or LA270 == 153:
                    alt270 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 270, 0, self.input)

                    raise nvae


                if alt270 == 1:
                    # ./output/PLSQL3.g:1036:6: table_spec
                    pass
                    self._state.following.append(self.FOLLOW_table_spec_in_selected_table6277)
                    table_spec1042 = self.table_spec()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, table_spec1042.tree)



                elif alt270 == 2:
                    # ./output/PLSQL3.g:1036:19: ( 'TABLE' | keyTHE )? subquery
                    pass
                    # ./output/PLSQL3.g:1036:19: ( 'TABLE' | keyTHE )?
                    alt269 = 3
                    LA269_0 = self.input.LA(1)

                    if (LA269_0 == 153) :
                        alt269 = 1
                    elif (LA269_0 == ID) :
                        alt269 = 2
                    if alt269 == 1:
                        # ./output/PLSQL3.g:1036:21: 'TABLE'
                        pass
                        string_literal1043 = self.match(self.input, 153, self.FOLLOW_153_in_selected_table6283)
                        if self._state.backtracking == 0:
                            string_literal1043_tree = self._adaptor.createWithPayload(string_literal1043)
                            self._adaptor.addChild(root_0, string_literal1043_tree)




                    elif alt269 == 2:
                        # ./output/PLSQL3.g:1036:31: keyTHE
                        pass
                        self._state.following.append(self.FOLLOW_keyTHE_in_selected_table6287)
                        keyTHE1044 = self.keyTHE()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyTHE1044.tree)





                    self._state.following.append(self.FOLLOW_subquery_in_selected_table6292)
                    subquery1045 = self.subquery()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, subquery1045.tree)





                # ./output/PLSQL3.g:1036:52: ( alias )?
                alt271 = 2
                LA271 = self.input.LA(1)
                if LA271 == 53:
                    LA271_1 = self.input.LA(2)

                    if (LA271_1 == DOUBLEQUOTED_STRING or LA271_1 == ID) :
                        LA271_6 = self.input.LA(3)

                        if (self.synpred435_PLSQL3()) :
                            alt271 = 1
                    elif (LA271_1 == 144) :
                        LA271_7 = self.input.LA(3)

                        if (self.synpred435_PLSQL3()) :
                            alt271 = 1
                elif LA271 == ID:
                    LA271_2 = self.input.LA(2)

                    if (self.synpred435_PLSQL3()) :
                        alt271 = 1
                elif LA271 == 144:
                    LA271_3 = self.input.LA(2)

                    if (self.synpred435_PLSQL3()) :
                        alt271 = 1
                elif LA271 == DOUBLEQUOTED_STRING:
                    LA271_5 = self.input.LA(2)

                    if (self.synpred435_PLSQL3()) :
                        alt271 = 1
                if alt271 == 1:
                    # ./output/PLSQL3.g:1036:54: alias
                    pass
                    self._state.following.append(self.FOLLOW_alias_in_selected_table6298)
                    alias1046 = self.alias()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, alias1046.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 189, selected_table_StartIndex, success)


            pass
        return retval

    # $ANTLR end "selected_table"


    class table_spec_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.table_spec_return, self).__init__()

            self.tree = None





    # $ANTLR start "table_spec"
    # ./output/PLSQL3.g:1039:1: table_spec : ( schema_name DOT )? table_name ( AT_SIGN link_name )? ;
    def table_spec(self, ):
        retval = self.table_spec_return()
        retval.start = self.input.LT(1)

        table_spec_StartIndex = self.input.index()

        root_0 = None

        DOT1048 = None
        AT_SIGN1050 = None
        schema_name1047 = None

        table_name1049 = None

        link_name1051 = None


        DOT1048_tree = None
        AT_SIGN1050_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 190):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1040:2: ( ( schema_name DOT )? table_name ( AT_SIGN link_name )? )
                # ./output/PLSQL3.g:1040:4: ( schema_name DOT )? table_name ( AT_SIGN link_name )?
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:1040:4: ( schema_name DOT )?
                alt272 = 2
                LA272_0 = self.input.LA(1)

                if (LA272_0 == DOUBLEQUOTED_STRING or LA272_0 == ID) :
                    LA272_1 = self.input.LA(2)

                    if (LA272_1 == DOT) :
                        alt272 = 1
                elif (LA272_0 == 144) :
                    LA272_2 = self.input.LA(2)

                    if (LA272_2 == DOT) :
                        alt272 = 1
                if alt272 == 1:
                    # ./output/PLSQL3.g:1040:6: schema_name DOT
                    pass
                    self._state.following.append(self.FOLLOW_schema_name_in_table_spec6314)
                    schema_name1047 = self.schema_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, schema_name1047.tree)


                    DOT1048 = self.match(self.input, DOT, self.FOLLOW_DOT_in_table_spec6316)
                    if self._state.backtracking == 0:
                        DOT1048_tree = self._adaptor.createWithPayload(DOT1048)
                        self._adaptor.addChild(root_0, DOT1048_tree)






                self._state.following.append(self.FOLLOW_table_name_in_table_spec6321)
                table_name1049 = self.table_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, table_name1049.tree)


                # ./output/PLSQL3.g:1040:36: ( AT_SIGN link_name )?
                alt273 = 2
                LA273_0 = self.input.LA(1)

                if (LA273_0 == AT_SIGN) :
                    alt273 = 1
                if alt273 == 1:
                    # ./output/PLSQL3.g:1040:38: AT_SIGN link_name
                    pass
                    AT_SIGN1050 = self.match(self.input, AT_SIGN, self.FOLLOW_AT_SIGN_in_table_spec6325)
                    if self._state.backtracking == 0:
                        AT_SIGN1050_tree = self._adaptor.createWithPayload(AT_SIGN1050)
                        self._adaptor.addChild(root_0, AT_SIGN1050_tree)



                    self._state.following.append(self.FOLLOW_link_name_in_table_spec6327)
                    link_name1051 = self.link_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, link_name1051.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 190, table_spec_StartIndex, success)


            pass
        return retval

    # $ANTLR end "table_spec"


    class table_alias_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.table_alias_return, self).__init__()

            self.tree = None





    # $ANTLR start "table_alias"
    # ./output/PLSQL3.g:1043:1: table_alias : ( schema_name DOT )? table_name ( AT_SIGN link_name )? ( alias )? ;
    def table_alias(self, ):
        retval = self.table_alias_return()
        retval.start = self.input.LT(1)

        table_alias_StartIndex = self.input.index()

        root_0 = None

        DOT1053 = None
        AT_SIGN1055 = None
        schema_name1052 = None

        table_name1054 = None

        link_name1056 = None

        alias1057 = None


        DOT1053_tree = None
        AT_SIGN1055_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 191):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1044:2: ( ( schema_name DOT )? table_name ( AT_SIGN link_name )? ( alias )? )
                # ./output/PLSQL3.g:1044:4: ( schema_name DOT )? table_name ( AT_SIGN link_name )? ( alias )?
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:1044:4: ( schema_name DOT )?
                alt274 = 2
                LA274_0 = self.input.LA(1)

                if (LA274_0 == DOUBLEQUOTED_STRING or LA274_0 == ID) :
                    LA274_1 = self.input.LA(2)

                    if (LA274_1 == DOT) :
                        alt274 = 1
                elif (LA274_0 == 144) :
                    LA274_2 = self.input.LA(2)

                    if (LA274_2 == DOT) :
                        alt274 = 1
                if alt274 == 1:
                    # ./output/PLSQL3.g:1044:6: schema_name DOT
                    pass
                    self._state.following.append(self.FOLLOW_schema_name_in_table_alias6343)
                    schema_name1052 = self.schema_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, schema_name1052.tree)


                    DOT1053 = self.match(self.input, DOT, self.FOLLOW_DOT_in_table_alias6345)
                    if self._state.backtracking == 0:
                        DOT1053_tree = self._adaptor.createWithPayload(DOT1053)
                        self._adaptor.addChild(root_0, DOT1053_tree)






                self._state.following.append(self.FOLLOW_table_name_in_table_alias6350)
                table_name1054 = self.table_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, table_name1054.tree)


                # ./output/PLSQL3.g:1044:36: ( AT_SIGN link_name )?
                alt275 = 2
                LA275_0 = self.input.LA(1)

                if (LA275_0 == AT_SIGN) :
                    alt275 = 1
                if alt275 == 1:
                    # ./output/PLSQL3.g:1044:38: AT_SIGN link_name
                    pass
                    AT_SIGN1055 = self.match(self.input, AT_SIGN, self.FOLLOW_AT_SIGN_in_table_alias6354)
                    if self._state.backtracking == 0:
                        AT_SIGN1055_tree = self._adaptor.createWithPayload(AT_SIGN1055)
                        self._adaptor.addChild(root_0, AT_SIGN1055_tree)



                    self._state.following.append(self.FOLLOW_link_name_in_table_alias6356)
                    link_name1056 = self.link_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, link_name1056.tree)





                # ./output/PLSQL3.g:1044:59: ( alias )?
                alt276 = 2
                LA276_0 = self.input.LA(1)

                if (LA276_0 == DOUBLEQUOTED_STRING or LA276_0 == ID or LA276_0 == 53 or LA276_0 == 144) :
                    alt276 = 1
                if alt276 == 1:
                    # ./output/PLSQL3.g:1044:61: alias
                    pass
                    self._state.following.append(self.FOLLOW_alias_in_table_alias6363)
                    alias1057 = self.alias()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, alias1057.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 191, table_alias_StartIndex, success)


            pass
        return retval

    # $ANTLR end "table_alias"


    class link_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.link_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "link_name"
    # ./output/PLSQL3.g:1047:1: link_name : sql_identifier ;
    def link_name(self, ):
        retval = self.link_name_return()
        retval.start = self.input.LT(1)

        link_name_StartIndex = self.input.index()

        root_0 = None

        sql_identifier1058 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 192):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1048:2: ( sql_identifier )
                # ./output/PLSQL3.g:1048:4: sql_identifier
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_sql_identifier_in_link_name6377)
                sql_identifier1058 = self.sql_identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_identifier1058.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 192, link_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "link_name"


    class nested_condition_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.nested_condition_return, self).__init__()

            self.tree = None





    # $ANTLR start "nested_condition"
    # ./output/PLSQL3.g:1050:1: nested_condition : ({...}? condition_or |{...}? expr_bool );
    def nested_condition(self, ):
        retval = self.nested_condition_return()
        retval.start = self.input.LT(1)

        nested_condition_StartIndex = self.input.index()

        root_0 = None

        condition_or1059 = None

        expr_bool1060 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 193):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1051:2: ({...}? condition_or |{...}? expr_bool )
                alt277 = 2
                LA277 = self.input.LA(1)
                if LA277 == 118:
                    LA277_1 = self.input.LA(2)

                    if (((((self.synpred441_PLSQL3()) and (self.synpred441_PLSQL3()))) and ((is_sql )))) :
                        alt277 = 1
                    elif ((not is_sql )) :
                        alt277 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 277, 1, self.input)

                        raise nvae


                elif LA277 == 52 or LA277 == 88 or LA277 == 134:
                    alt277 = 1
                elif LA277 == MINUS or LA277 == PLUS:
                    LA277_3 = self.input.LA(2)

                    if (((((self.synpred441_PLSQL3()) and (self.synpred441_PLSQL3()))) and ((is_sql )))) :
                        alt277 = 1
                    elif ((not is_sql )) :
                        alt277 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 277, 3, self.input)

                        raise nvae


                elif LA277 == LPAREN:
                    LA277_4 = self.input.LA(2)

                    if (((((self.synpred441_PLSQL3()) and (self.synpred441_PLSQL3()))) and ((is_sql )))) :
                        alt277 = 1
                    elif ((not is_sql )) :
                        alt277 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 277, 4, self.input)

                        raise nvae


                elif LA277 == ID:
                    LA277_5 = self.input.LA(2)

                    if (((((self.synpred441_PLSQL3()) and (self.synpred441_PLSQL3()))) and ((is_sql )))) :
                        alt277 = 1
                    elif ((not is_sql )) :
                        alt277 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 277, 5, self.input)

                        raise nvae


                elif LA277 == 144:
                    LA277_6 = self.input.LA(2)

                    if (((((self.synpred441_PLSQL3()) and (self.synpred441_PLSQL3()))) and ((is_sql )))) :
                        alt277 = 1
                    elif ((not is_sql )) :
                        alt277 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 277, 6, self.input)

                        raise nvae


                elif LA277 == DOUBLEQUOTED_STRING:
                    LA277_7 = self.input.LA(2)

                    if (((((self.synpred441_PLSQL3()) and (self.synpred441_PLSQL3()))) and ((is_sql )))) :
                        alt277 = 1
                    elif ((not is_sql )) :
                        alt277 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 277, 7, self.input)

                        raise nvae


                elif LA277 == 81:
                    LA277_8 = self.input.LA(2)

                    if ((((((((is_sql )) and ((is_sql )))) and (self.synpred441_PLSQL3()))) and ((is_sql )))) :
                        alt277 = 1
                    elif ((((((is_sql )) and ((is_sql )))) and ((not is_sql )))) :
                        alt277 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 277, 8, self.input)

                        raise nvae


                elif LA277 == 65:
                    LA277_9 = self.input.LA(2)

                    if (((((self.synpred441_PLSQL3()) and (self.synpred441_PLSQL3()))) and ((is_sql )))) :
                        alt277 = 1
                    elif ((not is_sql )) :
                        alt277 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 277, 9, self.input)

                        raise nvae


                elif LA277 == 89 or LA277 == 156:
                    LA277_10 = self.input.LA(2)

                    if (((((self.synpred441_PLSQL3()) and (self.synpred441_PLSQL3()))) and ((is_sql )))) :
                        alt277 = 1
                    elif ((not is_sql )) :
                        alt277 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 277, 10, self.input)

                        raise nvae


                elif LA277 == 151:
                    LA277_11 = self.input.LA(2)

                    if (((((self.synpred441_PLSQL3()) and (self.synpred441_PLSQL3()))) and ((is_sql )))) :
                        alt277 = 1
                    elif ((not is_sql )) :
                        alt277 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 277, 11, self.input)

                        raise nvae


                elif LA277 == QUOTED_STRING:
                    LA277_12 = self.input.LA(2)

                    if (((((self.synpred441_PLSQL3()) and (self.synpred441_PLSQL3()))) and ((is_sql )))) :
                        alt277 = 1
                    elif ((not is_sql )) :
                        alt277 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 277, 12, self.input)

                        raise nvae


                elif LA277 == NUMBER:
                    LA277_13 = self.input.LA(2)

                    if (((((self.synpred441_PLSQL3()) and (self.synpred441_PLSQL3()))) and ((is_sql )))) :
                        alt277 = 1
                    elif ((not is_sql )) :
                        alt277 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 277, 13, self.input)

                        raise nvae


                elif LA277 == 120:
                    LA277_14 = self.input.LA(2)

                    if (((((self.synpred441_PLSQL3()) and (self.synpred441_PLSQL3()))) and ((is_sql )))) :
                        alt277 = 1
                    elif ((not is_sql )) :
                        alt277 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 277, 14, self.input)

                        raise nvae


                elif LA277 == 147:
                    LA277_15 = self.input.LA(2)

                    if (((((self.synpred441_PLSQL3()) and (self.synpred441_PLSQL3()))) and ((is_sql )))) :
                        alt277 = 1
                    elif ((not is_sql )) :
                        alt277 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 277, 15, self.input)

                        raise nvae


                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 277, 0, self.input)

                    raise nvae


                if alt277 == 1:
                    # ./output/PLSQL3.g:1051:4: {...}? condition_or
                    pass
                    root_0 = self._adaptor.nil()


                    if not ((is_sql )):
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        raise FailedPredicateException(self.input, "nested_condition", "  is_sql ")


                    self._state.following.append(self.FOLLOW_condition_or_in_nested_condition6389)
                    condition_or1059 = self.condition_or()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_or1059.tree)



                elif alt277 == 2:
                    # ./output/PLSQL3.g:1052:4: {...}? expr_bool
                    pass
                    root_0 = self._adaptor.nil()


                    if not ((not is_sql )):
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        raise FailedPredicateException(self.input, "nested_condition", " not is_sql ")


                    self._state.following.append(self.FOLLOW_expr_bool_in_nested_condition6396)
                    expr_bool1060 = self.expr_bool()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, expr_bool1060.tree)



                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 193, nested_condition_StartIndex, success)


            pass
        return retval

    # $ANTLR end "nested_condition"


    class sql_condition_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.sql_condition_return, self).__init__()

            self.tree = None





    # $ANTLR start "sql_condition"
    # ./output/PLSQL3.g:1054:1: sql_condition : condition_or ;
    def sql_condition(self, ):
        retval = self.sql_condition_return()
        retval.start = self.input.LT(1)

        sql_condition_StartIndex = self.input.index()

        root_0 = None

        condition_or1061 = None



        is_sql = true;
        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 194):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1056:2: ( condition_or )
                # ./output/PLSQL3.g:1056:4: condition_or
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_condition_or_in_sql_condition6413)
                condition_or1061 = self.condition_or()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, condition_or1061.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 194, sql_condition_StartIndex, success)


            pass
        return retval

    # $ANTLR end "sql_condition"


    class condition_paren_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_paren_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_paren"
    # ./output/PLSQL3.g:1059:1: condition_paren : LPAREN sql_condition RPAREN ;
    def condition_paren(self, ):
        retval = self.condition_paren_return()
        retval.start = self.input.LT(1)

        condition_paren_StartIndex = self.input.index()

        root_0 = None

        LPAREN1062 = None
        RPAREN1064 = None
        sql_condition1063 = None


        LPAREN1062_tree = None
        RPAREN1064_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 195):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1060:2: ( LPAREN sql_condition RPAREN )
                # ./output/PLSQL3.g:1060:4: LPAREN sql_condition RPAREN
                pass
                root_0 = self._adaptor.nil()


                LPAREN1062 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_paren6424)
                if self._state.backtracking == 0:
                    LPAREN1062_tree = self._adaptor.createWithPayload(LPAREN1062)
                    self._adaptor.addChild(root_0, LPAREN1062_tree)



                self._state.following.append(self.FOLLOW_sql_condition_in_condition_paren6426)
                sql_condition1063 = self.sql_condition()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_condition1063.tree)


                RPAREN1064 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_paren6428)
                if self._state.backtracking == 0:
                    RPAREN1064_tree = self._adaptor.createWithPayload(RPAREN1064)
                    self._adaptor.addChild(root_0, RPAREN1064_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 195, condition_paren_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_paren"


    class condition_or_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_or_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_or"
    # ./output/PLSQL3.g:1062:1: condition_or : condition_and ( 'OR' condition_and )* ;
    def condition_or(self, ):
        retval = self.condition_or_return()
        retval.start = self.input.LT(1)

        condition_or_StartIndex = self.input.index()

        root_0 = None

        string_literal1066 = None
        condition_and1065 = None

        condition_and1067 = None


        string_literal1066_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 196):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1063:2: ( condition_and ( 'OR' condition_and )* )
                # ./output/PLSQL3.g:1063:4: condition_and ( 'OR' condition_and )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_condition_and_in_condition_or6438)
                condition_and1065 = self.condition_and()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, condition_and1065.tree)


                # ./output/PLSQL3.g:1063:18: ( 'OR' condition_and )*
                while True: #loop278
                    alt278 = 2
                    LA278_0 = self.input.LA(1)

                    if (LA278_0 == 127) :
                        LA278_2 = self.input.LA(2)

                        if (self.synpred442_PLSQL3()) :
                            alt278 = 1




                    if alt278 == 1:
                        # ./output/PLSQL3.g:1063:20: 'OR' condition_and
                        pass
                        string_literal1066 = self.match(self.input, 127, self.FOLLOW_127_in_condition_or6442)
                        if self._state.backtracking == 0:
                            string_literal1066_tree = self._adaptor.createWithPayload(string_literal1066)
                            self._adaptor.addChild(root_0, string_literal1066_tree)



                        self._state.following.append(self.FOLLOW_condition_and_in_condition_or6444)
                        condition_and1067 = self.condition_and()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, condition_and1067.tree)



                    else:
                        break #loop278




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 196, condition_or_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_or"


    class condition_and_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_and_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_and"
    # ./output/PLSQL3.g:1065:1: condition_and : condition_not ( 'AND' condition_not )* ;
    def condition_and(self, ):
        retval = self.condition_and_return()
        retval.start = self.input.LT(1)

        condition_and_StartIndex = self.input.index()

        root_0 = None

        string_literal1069 = None
        condition_not1068 = None

        condition_not1070 = None


        string_literal1069_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 197):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1066:2: ( condition_not ( 'AND' condition_not )* )
                # ./output/PLSQL3.g:1066:4: condition_not ( 'AND' condition_not )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_condition_not_in_condition_and6457)
                condition_not1068 = self.condition_not()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, condition_not1068.tree)


                # ./output/PLSQL3.g:1066:18: ( 'AND' condition_not )*
                while True: #loop279
                    alt279 = 2
                    LA279_0 = self.input.LA(1)

                    if (LA279_0 == 51) :
                        LA279_2 = self.input.LA(2)

                        if (self.synpred443_PLSQL3()) :
                            alt279 = 1




                    if alt279 == 1:
                        # ./output/PLSQL3.g:1066:20: 'AND' condition_not
                        pass
                        string_literal1069 = self.match(self.input, 51, self.FOLLOW_51_in_condition_and6461)
                        if self._state.backtracking == 0:
                            string_literal1069_tree = self._adaptor.createWithPayload(string_literal1069)
                            self._adaptor.addChild(root_0, string_literal1069_tree)



                        self._state.following.append(self.FOLLOW_condition_not_in_condition_and6463)
                        condition_not1070 = self.condition_not()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, condition_not1070.tree)



                    else:
                        break #loop279




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 197, condition_and_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_and"


    class condition_not_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_not_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_not"
    # ./output/PLSQL3.g:1068:1: condition_not : ( 'NOT' condition_expr | condition_expr );
    def condition_not(self, ):
        retval = self.condition_not_return()
        retval.start = self.input.LT(1)

        condition_not_StartIndex = self.input.index()

        root_0 = None

        string_literal1071 = None
        condition_expr1072 = None

        condition_expr1073 = None


        string_literal1071_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 198):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1069:2: ( 'NOT' condition_expr | condition_expr )
                alt280 = 2
                LA280_0 = self.input.LA(1)

                if (LA280_0 == 118) :
                    alt280 = 1
                elif (LA280_0 == DOUBLEQUOTED_STRING or LA280_0 == ID or LA280_0 == LPAREN or LA280_0 == MINUS or LA280_0 == NUMBER or LA280_0 == PLUS or LA280_0 == QUOTED_STRING or LA280_0 == 52 or LA280_0 == 65 or LA280_0 == 81 or (88 <= LA280_0 <= 89) or LA280_0 == 120 or LA280_0 == 134 or LA280_0 == 144 or LA280_0 == 147 or LA280_0 == 151 or LA280_0 == 156) :
                    alt280 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 280, 0, self.input)

                    raise nvae


                if alt280 == 1:
                    # ./output/PLSQL3.g:1069:4: 'NOT' condition_expr
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal1071 = self.match(self.input, 118, self.FOLLOW_118_in_condition_not6476)
                    if self._state.backtracking == 0:
                        string_literal1071_tree = self._adaptor.createWithPayload(string_literal1071)
                        self._adaptor.addChild(root_0, string_literal1071_tree)



                    self._state.following.append(self.FOLLOW_condition_expr_in_condition_not6478)
                    condition_expr1072 = self.condition_expr()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_expr1072.tree)



                elif alt280 == 2:
                    # ./output/PLSQL3.g:1070:4: condition_expr
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_condition_expr_in_condition_not6483)
                    condition_expr1073 = self.condition_expr()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_expr1073.tree)



                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 198, condition_not_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_not"


    class condition_expr_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_expr_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_expr"
    # ./output/PLSQL3.g:1072:1: condition_expr : ( condition_exists | condition_is | condition_comparison | condition_group_comparison | condition_in | condition_is_a_set | condition_is_any | condition_is_empty | condition_is_of_type | condition_is_present | condition_like | condition_memeber | condition_between | condition_regexp_like | condition_submultiset | condition_equals_path | condition_under_path | condition_paren );
    def condition_expr(self, ):
        retval = self.condition_expr_return()
        retval.start = self.input.LT(1)

        condition_expr_StartIndex = self.input.index()

        root_0 = None

        condition_exists1074 = None

        condition_is1075 = None

        condition_comparison1076 = None

        condition_group_comparison1077 = None

        condition_in1078 = None

        condition_is_a_set1079 = None

        condition_is_any1080 = None

        condition_is_empty1081 = None

        condition_is_of_type1082 = None

        condition_is_present1083 = None

        condition_like1084 = None

        condition_memeber1085 = None

        condition_between1086 = None

        condition_regexp_like1087 = None

        condition_submultiset1088 = None

        condition_equals_path1089 = None

        condition_under_path1090 = None

        condition_paren1091 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 199):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1073:2: ( condition_exists | condition_is | condition_comparison | condition_group_comparison | condition_in | condition_is_a_set | condition_is_any | condition_is_empty | condition_is_of_type | condition_is_present | condition_like | condition_memeber | condition_between | condition_regexp_like | condition_submultiset | condition_equals_path | condition_under_path | condition_paren )
                alt281 = 18
                LA281 = self.input.LA(1)
                if LA281 == 88:
                    alt281 = 1
                elif LA281 == MINUS or LA281 == PLUS:
                    LA281_2 = self.input.LA(2)

                    if (self.synpred446_PLSQL3()) :
                        alt281 = 2
                    elif (self.synpred447_PLSQL3()) :
                        alt281 = 3
                    elif (self.synpred448_PLSQL3()) :
                        alt281 = 4
                    elif (self.synpred449_PLSQL3()) :
                        alt281 = 5
                    elif (self.synpred453_PLSQL3()) :
                        alt281 = 9
                    elif (self.synpred455_PLSQL3()) :
                        alt281 = 11
                    elif (self.synpred456_PLSQL3()) :
                        alt281 = 12
                    elif (self.synpred457_PLSQL3()) :
                        alt281 = 13
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 281, 2, self.input)

                        raise nvae


                elif LA281 == LPAREN:
                    LA281_3 = self.input.LA(2)

                    if (self.synpred446_PLSQL3()) :
                        alt281 = 2
                    elif (self.synpred447_PLSQL3()) :
                        alt281 = 3
                    elif (self.synpred448_PLSQL3()) :
                        alt281 = 4
                    elif (self.synpred449_PLSQL3()) :
                        alt281 = 5
                    elif (self.synpred453_PLSQL3()) :
                        alt281 = 9
                    elif (self.synpred455_PLSQL3()) :
                        alt281 = 11
                    elif (self.synpred456_PLSQL3()) :
                        alt281 = 12
                    elif (self.synpred457_PLSQL3()) :
                        alt281 = 13
                    elif (True) :
                        alt281 = 18
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 281, 3, self.input)

                        raise nvae


                elif LA281 == ID:
                    LA281_4 = self.input.LA(2)

                    if (self.synpred446_PLSQL3()) :
                        alt281 = 2
                    elif (self.synpred447_PLSQL3()) :
                        alt281 = 3
                    elif (self.synpred448_PLSQL3()) :
                        alt281 = 4
                    elif (self.synpred449_PLSQL3()) :
                        alt281 = 5
                    elif (self.synpred450_PLSQL3()) :
                        alt281 = 6
                    elif (self.synpred451_PLSQL3()) :
                        alt281 = 7
                    elif (self.synpred452_PLSQL3()) :
                        alt281 = 8
                    elif (self.synpred453_PLSQL3()) :
                        alt281 = 9
                    elif (self.synpred454_PLSQL3()) :
                        alt281 = 10
                    elif (self.synpred455_PLSQL3()) :
                        alt281 = 11
                    elif (self.synpred456_PLSQL3()) :
                        alt281 = 12
                    elif (self.synpred457_PLSQL3()) :
                        alt281 = 13
                    elif (((((((self.input).LT(1).text.upper() == "REGEXP_LIKE")) and (((this.input).LT(1).text.upper() == "REGEXP_LIKE")))) and (self.synpred458_PLSQL3()))) :
                        alt281 = 14
                    elif (self.synpred459_PLSQL3()) :
                        alt281 = 15
                    elif (((((self.synpred460_PLSQL3()) and (self.synpred460_PLSQL3()))) and (((self.input).LT(1).text.upper() == "EQUALS_PATH")))) :
                        alt281 = 16
                    elif (((((self.synpred461_PLSQL3()) and (self.synpred461_PLSQL3()))) and (((self.input).LT(1).text.upper() == "UNDER_PATH")))) :
                        alt281 = 17
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 281, 4, self.input)

                        raise nvae


                elif LA281 == 144:
                    LA281_5 = self.input.LA(2)

                    if (self.synpred446_PLSQL3()) :
                        alt281 = 2
                    elif (self.synpred447_PLSQL3()) :
                        alt281 = 3
                    elif (self.synpred448_PLSQL3()) :
                        alt281 = 4
                    elif (self.synpred449_PLSQL3()) :
                        alt281 = 5
                    elif (self.synpred450_PLSQL3()) :
                        alt281 = 6
                    elif (self.synpred451_PLSQL3()) :
                        alt281 = 7
                    elif (self.synpred452_PLSQL3()) :
                        alt281 = 8
                    elif (self.synpred453_PLSQL3()) :
                        alt281 = 9
                    elif (self.synpred454_PLSQL3()) :
                        alt281 = 10
                    elif (self.synpred455_PLSQL3()) :
                        alt281 = 11
                    elif (self.synpred456_PLSQL3()) :
                        alt281 = 12
                    elif (self.synpred457_PLSQL3()) :
                        alt281 = 13
                    elif (self.synpred459_PLSQL3()) :
                        alt281 = 15
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 281, 5, self.input)

                        raise nvae


                elif LA281 == DOUBLEQUOTED_STRING:
                    LA281_6 = self.input.LA(2)

                    if (self.synpred446_PLSQL3()) :
                        alt281 = 2
                    elif (self.synpred447_PLSQL3()) :
                        alt281 = 3
                    elif (self.synpred448_PLSQL3()) :
                        alt281 = 4
                    elif (self.synpred449_PLSQL3()) :
                        alt281 = 5
                    elif (self.synpred450_PLSQL3()) :
                        alt281 = 6
                    elif (self.synpred451_PLSQL3()) :
                        alt281 = 7
                    elif (self.synpred452_PLSQL3()) :
                        alt281 = 8
                    elif (self.synpred453_PLSQL3()) :
                        alt281 = 9
                    elif (self.synpred454_PLSQL3()) :
                        alt281 = 10
                    elif (self.synpred455_PLSQL3()) :
                        alt281 = 11
                    elif (self.synpred456_PLSQL3()) :
                        alt281 = 12
                    elif (self.synpred457_PLSQL3()) :
                        alt281 = 13
                    elif (self.synpred459_PLSQL3()) :
                        alt281 = 15
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 281, 6, self.input)

                        raise nvae


                elif LA281 == 81:
                    LA281_7 = self.input.LA(2)

                    if ((((((is_sql )) and ((is_sql )))) and (self.synpred446_PLSQL3()))) :
                        alt281 = 2
                    elif ((((((is_sql )) and ((is_sql )))) and (self.synpred447_PLSQL3()))) :
                        alt281 = 3
                    elif ((((((is_sql )) and ((is_sql )))) and (self.synpred448_PLSQL3()))) :
                        alt281 = 4
                    elif ((((((is_sql )) and ((is_sql )))) and (self.synpred449_PLSQL3()))) :
                        alt281 = 5
                    elif (((((self.synpred453_PLSQL3()) and (self.synpred453_PLSQL3()))) and ((is_sql )))) :
                        alt281 = 9
                    elif (((((self.synpred455_PLSQL3()) and (self.synpred455_PLSQL3()))) and ((is_sql )))) :
                        alt281 = 11
                    elif ((((((is_sql )) and ((is_sql )))) and (self.synpred456_PLSQL3()))) :
                        alt281 = 12
                    elif (((((self.synpred457_PLSQL3()) and (self.synpred457_PLSQL3()))) and ((is_sql )))) :
                        alt281 = 13
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 281, 7, self.input)

                        raise nvae


                elif LA281 == 65:
                    LA281_8 = self.input.LA(2)

                    if (self.synpred446_PLSQL3()) :
                        alt281 = 2
                    elif (self.synpred447_PLSQL3()) :
                        alt281 = 3
                    elif (self.synpred448_PLSQL3()) :
                        alt281 = 4
                    elif (self.synpred449_PLSQL3()) :
                        alt281 = 5
                    elif (self.synpred453_PLSQL3()) :
                        alt281 = 9
                    elif (self.synpred455_PLSQL3()) :
                        alt281 = 11
                    elif (self.synpred456_PLSQL3()) :
                        alt281 = 12
                    elif (self.synpred457_PLSQL3()) :
                        alt281 = 13
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 281, 8, self.input)

                        raise nvae


                elif LA281 == 89 or LA281 == 156:
                    LA281_9 = self.input.LA(2)

                    if (self.synpred446_PLSQL3()) :
                        alt281 = 2
                    elif (self.synpred447_PLSQL3()) :
                        alt281 = 3
                    elif (self.synpred448_PLSQL3()) :
                        alt281 = 4
                    elif (self.synpred449_PLSQL3()) :
                        alt281 = 5
                    elif (self.synpred453_PLSQL3()) :
                        alt281 = 9
                    elif (self.synpred455_PLSQL3()) :
                        alt281 = 11
                    elif (self.synpred456_PLSQL3()) :
                        alt281 = 12
                    elif (self.synpred457_PLSQL3()) :
                        alt281 = 13
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 281, 9, self.input)

                        raise nvae


                elif LA281 == 151:
                    LA281_10 = self.input.LA(2)

                    if (self.synpred446_PLSQL3()) :
                        alt281 = 2
                    elif (self.synpred447_PLSQL3()) :
                        alt281 = 3
                    elif (self.synpred448_PLSQL3()) :
                        alt281 = 4
                    elif (self.synpred449_PLSQL3()) :
                        alt281 = 5
                    elif (self.synpred453_PLSQL3()) :
                        alt281 = 9
                    elif (self.synpred455_PLSQL3()) :
                        alt281 = 11
                    elif (self.synpred456_PLSQL3()) :
                        alt281 = 12
                    elif (self.synpred457_PLSQL3()) :
                        alt281 = 13
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 281, 10, self.input)

                        raise nvae


                elif LA281 == QUOTED_STRING:
                    LA281_11 = self.input.LA(2)

                    if (self.synpred446_PLSQL3()) :
                        alt281 = 2
                    elif (self.synpred447_PLSQL3()) :
                        alt281 = 3
                    elif (self.synpred448_PLSQL3()) :
                        alt281 = 4
                    elif (self.synpred449_PLSQL3()) :
                        alt281 = 5
                    elif (self.synpred453_PLSQL3()) :
                        alt281 = 9
                    elif (self.synpred455_PLSQL3()) :
                        alt281 = 11
                    elif (self.synpred456_PLSQL3()) :
                        alt281 = 12
                    elif (self.synpred457_PLSQL3()) :
                        alt281 = 13
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 281, 11, self.input)

                        raise nvae


                elif LA281 == NUMBER:
                    LA281_12 = self.input.LA(2)

                    if (self.synpred446_PLSQL3()) :
                        alt281 = 2
                    elif (self.synpred447_PLSQL3()) :
                        alt281 = 3
                    elif (self.synpred448_PLSQL3()) :
                        alt281 = 4
                    elif (self.synpred449_PLSQL3()) :
                        alt281 = 5
                    elif (self.synpred453_PLSQL3()) :
                        alt281 = 9
                    elif (self.synpred455_PLSQL3()) :
                        alt281 = 11
                    elif (self.synpred456_PLSQL3()) :
                        alt281 = 12
                    elif (self.synpred457_PLSQL3()) :
                        alt281 = 13
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 281, 12, self.input)

                        raise nvae


                elif LA281 == 120:
                    LA281_13 = self.input.LA(2)

                    if (self.synpred446_PLSQL3()) :
                        alt281 = 2
                    elif (self.synpred447_PLSQL3()) :
                        alt281 = 3
                    elif (self.synpred448_PLSQL3()) :
                        alt281 = 4
                    elif (self.synpred449_PLSQL3()) :
                        alt281 = 5
                    elif (self.synpred453_PLSQL3()) :
                        alt281 = 9
                    elif (self.synpred455_PLSQL3()) :
                        alt281 = 11
                    elif (self.synpred456_PLSQL3()) :
                        alt281 = 12
                    elif (self.synpred457_PLSQL3()) :
                        alt281 = 13
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 281, 13, self.input)

                        raise nvae


                elif LA281 == 147:
                    LA281_14 = self.input.LA(2)

                    if (self.synpred446_PLSQL3()) :
                        alt281 = 2
                    elif (self.synpred447_PLSQL3()) :
                        alt281 = 3
                    elif (self.synpred448_PLSQL3()) :
                        alt281 = 4
                    elif (self.synpred449_PLSQL3()) :
                        alt281 = 5
                    elif (self.synpred453_PLSQL3()) :
                        alt281 = 9
                    elif (self.synpred455_PLSQL3()) :
                        alt281 = 11
                    elif (self.synpred456_PLSQL3()) :
                        alt281 = 12
                    elif (self.synpred457_PLSQL3()) :
                        alt281 = 13
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 281, 14, self.input)

                        raise nvae


                elif LA281 == 134:
                    alt281 = 3
                elif LA281 == 52:
                    alt281 = 7
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 281, 0, self.input)

                    raise nvae


                if alt281 == 1:
                    # ./output/PLSQL3.g:1073:4: condition_exists
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_condition_exists_in_condition_expr6493)
                    condition_exists1074 = self.condition_exists()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_exists1074.tree)



                elif alt281 == 2:
                    # ./output/PLSQL3.g:1074:4: condition_is
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_condition_is_in_condition_expr6498)
                    condition_is1075 = self.condition_is()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_is1075.tree)



                elif alt281 == 3:
                    # ./output/PLSQL3.g:1075:4: condition_comparison
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_condition_comparison_in_condition_expr6503)
                    condition_comparison1076 = self.condition_comparison()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_comparison1076.tree)



                elif alt281 == 4:
                    # ./output/PLSQL3.g:1076:4: condition_group_comparison
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_condition_group_comparison_in_condition_expr6508)
                    condition_group_comparison1077 = self.condition_group_comparison()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_group_comparison1077.tree)



                elif alt281 == 5:
                    # ./output/PLSQL3.g:1077:4: condition_in
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_condition_in_in_condition_expr6513)
                    condition_in1078 = self.condition_in()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_in1078.tree)



                elif alt281 == 6:
                    # ./output/PLSQL3.g:1078:4: condition_is_a_set
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_condition_is_a_set_in_condition_expr6518)
                    condition_is_a_set1079 = self.condition_is_a_set()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_is_a_set1079.tree)



                elif alt281 == 7:
                    # ./output/PLSQL3.g:1079:4: condition_is_any
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_condition_is_any_in_condition_expr6523)
                    condition_is_any1080 = self.condition_is_any()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_is_any1080.tree)



                elif alt281 == 8:
                    # ./output/PLSQL3.g:1080:4: condition_is_empty
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_condition_is_empty_in_condition_expr6528)
                    condition_is_empty1081 = self.condition_is_empty()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_is_empty1081.tree)



                elif alt281 == 9:
                    # ./output/PLSQL3.g:1081:4: condition_is_of_type
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_condition_is_of_type_in_condition_expr6533)
                    condition_is_of_type1082 = self.condition_is_of_type()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_is_of_type1082.tree)



                elif alt281 == 10:
                    # ./output/PLSQL3.g:1082:4: condition_is_present
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_condition_is_present_in_condition_expr6538)
                    condition_is_present1083 = self.condition_is_present()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_is_present1083.tree)



                elif alt281 == 11:
                    # ./output/PLSQL3.g:1083:4: condition_like
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_condition_like_in_condition_expr6543)
                    condition_like1084 = self.condition_like()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_like1084.tree)



                elif alt281 == 12:
                    # ./output/PLSQL3.g:1084:4: condition_memeber
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_condition_memeber_in_condition_expr6548)
                    condition_memeber1085 = self.condition_memeber()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_memeber1085.tree)



                elif alt281 == 13:
                    # ./output/PLSQL3.g:1085:4: condition_between
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_condition_between_in_condition_expr6553)
                    condition_between1086 = self.condition_between()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_between1086.tree)



                elif alt281 == 14:
                    # ./output/PLSQL3.g:1086:4: condition_regexp_like
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_condition_regexp_like_in_condition_expr6558)
                    condition_regexp_like1087 = self.condition_regexp_like()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_regexp_like1087.tree)



                elif alt281 == 15:
                    # ./output/PLSQL3.g:1087:4: condition_submultiset
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_condition_submultiset_in_condition_expr6563)
                    condition_submultiset1088 = self.condition_submultiset()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_submultiset1088.tree)



                elif alt281 == 16:
                    # ./output/PLSQL3.g:1088:4: condition_equals_path
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_condition_equals_path_in_condition_expr6568)
                    condition_equals_path1089 = self.condition_equals_path()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_equals_path1089.tree)



                elif alt281 == 17:
                    # ./output/PLSQL3.g:1089:4: condition_under_path
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_condition_under_path_in_condition_expr6573)
                    condition_under_path1090 = self.condition_under_path()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_under_path1090.tree)



                elif alt281 == 18:
                    # ./output/PLSQL3.g:1090:4: condition_paren
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_condition_paren_in_condition_expr6578)
                    condition_paren1091 = self.condition_paren()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_paren1091.tree)



                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 199, condition_expr_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_expr"


    class condition_exists_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_exists_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_exists"
    # ./output/PLSQL3.g:1092:1: condition_exists : 'EXISTS' LPAREN select_command RPAREN ;
    def condition_exists(self, ):
        retval = self.condition_exists_return()
        retval.start = self.input.LT(1)

        condition_exists_StartIndex = self.input.index()

        root_0 = None

        string_literal1092 = None
        LPAREN1093 = None
        RPAREN1095 = None
        select_command1094 = None


        string_literal1092_tree = None
        LPAREN1093_tree = None
        RPAREN1095_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 200):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1093:2: ( 'EXISTS' LPAREN select_command RPAREN )
                # ./output/PLSQL3.g:1093:4: 'EXISTS' LPAREN select_command RPAREN
                pass
                root_0 = self._adaptor.nil()


                string_literal1092 = self.match(self.input, 88, self.FOLLOW_88_in_condition_exists6588)
                if self._state.backtracking == 0:
                    string_literal1092_tree = self._adaptor.createWithPayload(string_literal1092)
                    self._adaptor.addChild(root_0, string_literal1092_tree)



                LPAREN1093 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_exists6590)
                if self._state.backtracking == 0:
                    LPAREN1093_tree = self._adaptor.createWithPayload(LPAREN1093)
                    self._adaptor.addChild(root_0, LPAREN1093_tree)



                self._state.following.append(self.FOLLOW_select_command_in_condition_exists6592)
                select_command1094 = self.select_command()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, select_command1094.tree)


                RPAREN1095 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_exists6594)
                if self._state.backtracking == 0:
                    RPAREN1095_tree = self._adaptor.createWithPayload(RPAREN1095)
                    self._adaptor.addChild(root_0, RPAREN1095_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 200, condition_exists_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_exists"


    class condition_is_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_is_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_is"
    # ./output/PLSQL3.g:1095:1: condition_is : sql_expression 'IS' ( 'NOT' )? ( keyNAN | keyINFINITE | 'NULL' ) ;
    def condition_is(self, ):
        retval = self.condition_is_return()
        retval.start = self.input.LT(1)

        condition_is_StartIndex = self.input.index()

        root_0 = None

        string_literal1097 = None
        string_literal1098 = None
        string_literal1101 = None
        sql_expression1096 = None

        keyNAN1099 = None

        keyINFINITE1100 = None


        string_literal1097_tree = None
        string_literal1098_tree = None
        string_literal1101_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 201):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1096:2: ( sql_expression 'IS' ( 'NOT' )? ( keyNAN | keyINFINITE | 'NULL' ) )
                # ./output/PLSQL3.g:1096:4: sql_expression 'IS' ( 'NOT' )? ( keyNAN | keyINFINITE | 'NULL' )
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_sql_expression_in_condition_is6604)
                sql_expression1096 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression1096.tree)


                string_literal1097 = self.match(self.input, 106, self.FOLLOW_106_in_condition_is6606)
                if self._state.backtracking == 0:
                    string_literal1097_tree = self._adaptor.createWithPayload(string_literal1097)
                    self._adaptor.addChild(root_0, string_literal1097_tree)



                # ./output/PLSQL3.g:1096:24: ( 'NOT' )?
                alt282 = 2
                LA282_0 = self.input.LA(1)

                if (LA282_0 == 118) :
                    alt282 = 1
                if alt282 == 1:
                    # ./output/PLSQL3.g:1096:26: 'NOT'
                    pass
                    string_literal1098 = self.match(self.input, 118, self.FOLLOW_118_in_condition_is6610)
                    if self._state.backtracking == 0:
                        string_literal1098_tree = self._adaptor.createWithPayload(string_literal1098)
                        self._adaptor.addChild(root_0, string_literal1098_tree)






                # ./output/PLSQL3.g:1096:35: ( keyNAN | keyINFINITE | 'NULL' )
                alt283 = 3
                LA283_0 = self.input.LA(1)

                if (LA283_0 == ID) :
                    LA283_1 = self.input.LA(2)

                    if (((((self.synpred463_PLSQL3()) and (self.synpred463_PLSQL3()))) and (((self.input).LT(1).text.upper() == "NAN")))) :
                        alt283 = 1
                    elif (((((self.synpred464_PLSQL3()) and (self.synpred464_PLSQL3()))) and (((self.input).LT(1).text.upper() == "INFINITE")))) :
                        alt283 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 283, 1, self.input)

                        raise nvae


                elif (LA283_0 == 120) :
                    alt283 = 3
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 283, 0, self.input)

                    raise nvae


                if alt283 == 1:
                    # ./output/PLSQL3.g:1096:37: keyNAN
                    pass
                    self._state.following.append(self.FOLLOW_keyNAN_in_condition_is6617)
                    keyNAN1099 = self.keyNAN()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyNAN1099.tree)



                elif alt283 == 2:
                    # ./output/PLSQL3.g:1096:46: keyINFINITE
                    pass
                    self._state.following.append(self.FOLLOW_keyINFINITE_in_condition_is6621)
                    keyINFINITE1100 = self.keyINFINITE()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyINFINITE1100.tree)



                elif alt283 == 3:
                    # ./output/PLSQL3.g:1096:60: 'NULL'
                    pass
                    string_literal1101 = self.match(self.input, 120, self.FOLLOW_120_in_condition_is6625)
                    if self._state.backtracking == 0:
                        string_literal1101_tree = self._adaptor.createWithPayload(string_literal1101)
                        self._adaptor.addChild(root_0, string_literal1101_tree)








                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 201, condition_is_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_is"


    class condition_comparison_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_comparison_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_comparison"
    # ./output/PLSQL3.g:1098:1: condition_comparison : ( LPAREN sql_expressions RPAREN ( outer_join_sign )? ( EQ | NOT_EQ ) LPAREN select_command RPAREN ( outer_join_sign )? | ( 'PRIOR' )? sql_expression ( outer_join_sign )? ( EQ | NOT_EQ | GTH | GEQ | LTH | LEQ ) ( 'PRIOR' )? ( sql_expression | LPAREN select_command RPAREN ) ( outer_join_sign )? );
    def condition_comparison(self, ):
        retval = self.condition_comparison_return()
        retval.start = self.input.LT(1)

        condition_comparison_StartIndex = self.input.index()

        root_0 = None

        LPAREN1102 = None
        RPAREN1104 = None
        set1106 = None
        LPAREN1107 = None
        RPAREN1109 = None
        string_literal1111 = None
        set1114 = None
        string_literal1115 = None
        LPAREN1117 = None
        RPAREN1119 = None
        sql_expressions1103 = None

        outer_join_sign1105 = None

        select_command1108 = None

        outer_join_sign1110 = None

        sql_expression1112 = None

        outer_join_sign1113 = None

        sql_expression1116 = None

        select_command1118 = None

        outer_join_sign1120 = None


        LPAREN1102_tree = None
        RPAREN1104_tree = None
        set1106_tree = None
        LPAREN1107_tree = None
        RPAREN1109_tree = None
        string_literal1111_tree = None
        set1114_tree = None
        string_literal1115_tree = None
        LPAREN1117_tree = None
        RPAREN1119_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 202):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1099:2: ( LPAREN sql_expressions RPAREN ( outer_join_sign )? ( EQ | NOT_EQ ) LPAREN select_command RPAREN ( outer_join_sign )? | ( 'PRIOR' )? sql_expression ( outer_join_sign )? ( EQ | NOT_EQ | GTH | GEQ | LTH | LEQ ) ( 'PRIOR' )? ( sql_expression | LPAREN select_command RPAREN ) ( outer_join_sign )? )
                alt291 = 2
                LA291_0 = self.input.LA(1)

                if (LA291_0 == LPAREN) :
                    LA291_1 = self.input.LA(2)

                    if (self.synpred468_PLSQL3()) :
                        alt291 = 1
                    elif (True) :
                        alt291 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 291, 1, self.input)

                        raise nvae


                elif (LA291_0 == DOUBLEQUOTED_STRING or LA291_0 == ID or LA291_0 == MINUS or LA291_0 == NUMBER or LA291_0 == PLUS or LA291_0 == QUOTED_STRING or LA291_0 == 65 or LA291_0 == 81 or LA291_0 == 89 or LA291_0 == 120 or LA291_0 == 134 or LA291_0 == 144 or LA291_0 == 147 or LA291_0 == 151 or LA291_0 == 156) :
                    alt291 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 291, 0, self.input)

                    raise nvae


                if alt291 == 1:
                    # ./output/PLSQL3.g:1099:4: LPAREN sql_expressions RPAREN ( outer_join_sign )? ( EQ | NOT_EQ ) LPAREN select_command RPAREN ( outer_join_sign )?
                    pass
                    root_0 = self._adaptor.nil()


                    LPAREN1102 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_comparison6637)
                    if self._state.backtracking == 0:
                        LPAREN1102_tree = self._adaptor.createWithPayload(LPAREN1102)
                        self._adaptor.addChild(root_0, LPAREN1102_tree)



                    self._state.following.append(self.FOLLOW_sql_expressions_in_condition_comparison6639)
                    sql_expressions1103 = self.sql_expressions()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expressions1103.tree)


                    RPAREN1104 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_comparison6641)
                    if self._state.backtracking == 0:
                        RPAREN1104_tree = self._adaptor.createWithPayload(RPAREN1104)
                        self._adaptor.addChild(root_0, RPAREN1104_tree)



                    # ./output/PLSQL3.g:1099:34: ( outer_join_sign )?
                    alt284 = 2
                    LA284_0 = self.input.LA(1)

                    if (LA284_0 == LPAREN) :
                        alt284 = 1
                    if alt284 == 1:
                        # ./output/PLSQL3.g:1099:36: outer_join_sign
                        pass
                        self._state.following.append(self.FOLLOW_outer_join_sign_in_condition_comparison6645)
                        outer_join_sign1105 = self.outer_join_sign()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, outer_join_sign1105.tree)





                    set1106 = self.input.LT(1)

                    if self.input.LA(1) == EQ or self.input.LA(1) == NOT_EQ:
                        self.input.consume()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set1106))

                        self._state.errorRecovery = False


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        mse = MismatchedSetException(None, self.input)
                        raise mse



                    LPAREN1107 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_comparison6660)
                    if self._state.backtracking == 0:
                        LPAREN1107_tree = self._adaptor.createWithPayload(LPAREN1107)
                        self._adaptor.addChild(root_0, LPAREN1107_tree)



                    self._state.following.append(self.FOLLOW_select_command_in_condition_comparison6662)
                    select_command1108 = self.select_command()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, select_command1108.tree)


                    RPAREN1109 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_comparison6664)
                    if self._state.backtracking == 0:
                        RPAREN1109_tree = self._adaptor.createWithPayload(RPAREN1109)
                        self._adaptor.addChild(root_0, RPAREN1109_tree)



                    # ./output/PLSQL3.g:1099:100: ( outer_join_sign )?
                    alt285 = 2
                    LA285_0 = self.input.LA(1)

                    if (LA285_0 == LPAREN) :
                        LA285_1 = self.input.LA(2)

                        if (LA285_1 == PLUS) :
                            LA285_3 = self.input.LA(3)

                            if (LA285_3 == RPAREN) :
                                LA285_4 = self.input.LA(4)

                                if (self.synpred467_PLSQL3()) :
                                    alt285 = 1
                    if alt285 == 1:
                        # ./output/PLSQL3.g:1099:102: outer_join_sign
                        pass
                        self._state.following.append(self.FOLLOW_outer_join_sign_in_condition_comparison6668)
                        outer_join_sign1110 = self.outer_join_sign()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, outer_join_sign1110.tree)






                elif alt291 == 2:
                    # ./output/PLSQL3.g:1100:4: ( 'PRIOR' )? sql_expression ( outer_join_sign )? ( EQ | NOT_EQ | GTH | GEQ | LTH | LEQ ) ( 'PRIOR' )? ( sql_expression | LPAREN select_command RPAREN ) ( outer_join_sign )?
                    pass
                    root_0 = self._adaptor.nil()


                    # ./output/PLSQL3.g:1100:4: ( 'PRIOR' )?
                    alt286 = 2
                    LA286_0 = self.input.LA(1)

                    if (LA286_0 == 134) :
                        alt286 = 1
                    if alt286 == 1:
                        # ./output/PLSQL3.g:1100:6: 'PRIOR'
                        pass
                        string_literal1111 = self.match(self.input, 134, self.FOLLOW_134_in_condition_comparison6678)
                        if self._state.backtracking == 0:
                            string_literal1111_tree = self._adaptor.createWithPayload(string_literal1111)
                            self._adaptor.addChild(root_0, string_literal1111_tree)






                    self._state.following.append(self.FOLLOW_sql_expression_in_condition_comparison6683)
                    sql_expression1112 = self.sql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expression1112.tree)


                    # ./output/PLSQL3.g:1100:32: ( outer_join_sign )?
                    alt287 = 2
                    LA287_0 = self.input.LA(1)

                    if (LA287_0 == LPAREN) :
                        alt287 = 1
                    if alt287 == 1:
                        # ./output/PLSQL3.g:1100:34: outer_join_sign
                        pass
                        self._state.following.append(self.FOLLOW_outer_join_sign_in_condition_comparison6687)
                        outer_join_sign1113 = self.outer_join_sign()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, outer_join_sign1113.tree)





                    set1114 = self.input.LT(1)

                    if self.input.LA(1) == EQ or (GEQ <= self.input.LA(1) <= GTH) or self.input.LA(1) == LEQ or self.input.LA(1) == LTH or self.input.LA(1) == NOT_EQ:
                        self.input.consume()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set1114))

                        self._state.errorRecovery = False


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        mse = MismatchedSetException(None, self.input)
                        raise mse



                    # ./output/PLSQL3.g:1100:93: ( 'PRIOR' )?
                    alt288 = 2
                    LA288_0 = self.input.LA(1)

                    if (LA288_0 == 134) :
                        alt288 = 1
                    if alt288 == 1:
                        # ./output/PLSQL3.g:1100:95: 'PRIOR'
                        pass
                        string_literal1115 = self.match(self.input, 134, self.FOLLOW_134_in_condition_comparison6720)
                        if self._state.backtracking == 0:
                            string_literal1115_tree = self._adaptor.createWithPayload(string_literal1115)
                            self._adaptor.addChild(root_0, string_literal1115_tree)






                    # ./output/PLSQL3.g:1100:106: ( sql_expression | LPAREN select_command RPAREN )
                    alt289 = 2
                    LA289_0 = self.input.LA(1)

                    if (LA289_0 == DOUBLEQUOTED_STRING or LA289_0 == ID or LA289_0 == MINUS or LA289_0 == NUMBER or LA289_0 == PLUS or LA289_0 == QUOTED_STRING or LA289_0 == 65 or LA289_0 == 81 or LA289_0 == 89 or LA289_0 == 120 or LA289_0 == 144 or LA289_0 == 147 or LA289_0 == 151 or LA289_0 == 156) :
                        alt289 = 1
                    elif (LA289_0 == LPAREN) :
                        LA289_2 = self.input.LA(2)

                        if (self.synpred477_PLSQL3()) :
                            alt289 = 1
                        elif (True) :
                            alt289 = 2
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 289, 2, self.input)

                            raise nvae


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 289, 0, self.input)

                        raise nvae


                    if alt289 == 1:
                        # ./output/PLSQL3.g:1100:108: sql_expression
                        pass
                        self._state.following.append(self.FOLLOW_sql_expression_in_condition_comparison6727)
                        sql_expression1116 = self.sql_expression()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, sql_expression1116.tree)



                    elif alt289 == 2:
                        # ./output/PLSQL3.g:1100:125: LPAREN select_command RPAREN
                        pass
                        LPAREN1117 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_comparison6731)
                        if self._state.backtracking == 0:
                            LPAREN1117_tree = self._adaptor.createWithPayload(LPAREN1117)
                            self._adaptor.addChild(root_0, LPAREN1117_tree)



                        self._state.following.append(self.FOLLOW_select_command_in_condition_comparison6733)
                        select_command1118 = self.select_command()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, select_command1118.tree)


                        RPAREN1119 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_comparison6735)
                        if self._state.backtracking == 0:
                            RPAREN1119_tree = self._adaptor.createWithPayload(RPAREN1119)
                            self._adaptor.addChild(root_0, RPAREN1119_tree)






                    # ./output/PLSQL3.g:1100:156: ( outer_join_sign )?
                    alt290 = 2
                    LA290_0 = self.input.LA(1)

                    if (LA290_0 == LPAREN) :
                        LA290_1 = self.input.LA(2)

                        if (self.synpred478_PLSQL3()) :
                            alt290 = 1
                    if alt290 == 1:
                        # ./output/PLSQL3.g:1100:158: outer_join_sign
                        pass
                        self._state.following.append(self.FOLLOW_outer_join_sign_in_condition_comparison6741)
                        outer_join_sign1120 = self.outer_join_sign()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, outer_join_sign1120.tree)






                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 202, condition_comparison_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_comparison"


    class condition_group_comparison_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_group_comparison_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_group_comparison"
    # ./output/PLSQL3.g:1102:1: condition_group_comparison : ( LPAREN sql_expressions RPAREN ( EQ | NOT_EQ ) ( 'ANY' | keySOME | 'ALL' ) LPAREN ( grouping_expression_list | select_command ) RPAREN | sql_expression ( EQ | NOT_EQ | GTH | GEQ | LTH | LEQ ) ( 'ANY' | keySOME | 'ALL' ) LPAREN ( sql_expressions | select_command ) RPAREN );
    def condition_group_comparison(self, ):
        retval = self.condition_group_comparison_return()
        retval.start = self.input.LT(1)

        condition_group_comparison_StartIndex = self.input.index()

        root_0 = None

        LPAREN1121 = None
        RPAREN1123 = None
        set1124 = None
        string_literal1125 = None
        string_literal1127 = None
        LPAREN1128 = None
        RPAREN1131 = None
        set1133 = None
        string_literal1134 = None
        string_literal1136 = None
        LPAREN1137 = None
        RPAREN1140 = None
        sql_expressions1122 = None

        keySOME1126 = None

        grouping_expression_list1129 = None

        select_command1130 = None

        sql_expression1132 = None

        keySOME1135 = None

        sql_expressions1138 = None

        select_command1139 = None


        LPAREN1121_tree = None
        RPAREN1123_tree = None
        set1124_tree = None
        string_literal1125_tree = None
        string_literal1127_tree = None
        LPAREN1128_tree = None
        RPAREN1131_tree = None
        set1133_tree = None
        string_literal1134_tree = None
        string_literal1136_tree = None
        LPAREN1137_tree = None
        RPAREN1140_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 203):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1103:2: ( LPAREN sql_expressions RPAREN ( EQ | NOT_EQ ) ( 'ANY' | keySOME | 'ALL' ) LPAREN ( grouping_expression_list | select_command ) RPAREN | sql_expression ( EQ | NOT_EQ | GTH | GEQ | LTH | LEQ ) ( 'ANY' | keySOME | 'ALL' ) LPAREN ( sql_expressions | select_command ) RPAREN )
                alt296 = 2
                LA296_0 = self.input.LA(1)

                if (LA296_0 == LPAREN) :
                    LA296_1 = self.input.LA(2)

                    if (self.synpred483_PLSQL3()) :
                        alt296 = 1
                    elif (True) :
                        alt296 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 296, 1, self.input)

                        raise nvae


                elif (LA296_0 == DOUBLEQUOTED_STRING or LA296_0 == ID or LA296_0 == MINUS or LA296_0 == NUMBER or LA296_0 == PLUS or LA296_0 == QUOTED_STRING or LA296_0 == 65 or LA296_0 == 81 or LA296_0 == 89 or LA296_0 == 120 or LA296_0 == 144 or LA296_0 == 147 or LA296_0 == 151 or LA296_0 == 156) :
                    alt296 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 296, 0, self.input)

                    raise nvae


                if alt296 == 1:
                    # ./output/PLSQL3.g:1103:4: LPAREN sql_expressions RPAREN ( EQ | NOT_EQ ) ( 'ANY' | keySOME | 'ALL' ) LPAREN ( grouping_expression_list | select_command ) RPAREN
                    pass
                    root_0 = self._adaptor.nil()


                    LPAREN1121 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_group_comparison6754)
                    if self._state.backtracking == 0:
                        LPAREN1121_tree = self._adaptor.createWithPayload(LPAREN1121)
                        self._adaptor.addChild(root_0, LPAREN1121_tree)



                    self._state.following.append(self.FOLLOW_sql_expressions_in_condition_group_comparison6756)
                    sql_expressions1122 = self.sql_expressions()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expressions1122.tree)


                    RPAREN1123 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_group_comparison6758)
                    if self._state.backtracking == 0:
                        RPAREN1123_tree = self._adaptor.createWithPayload(RPAREN1123)
                        self._adaptor.addChild(root_0, RPAREN1123_tree)



                    set1124 = self.input.LT(1)

                    if self.input.LA(1) == EQ or self.input.LA(1) == NOT_EQ:
                        self.input.consume()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set1124))

                        self._state.errorRecovery = False


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        mse = MismatchedSetException(None, self.input)
                        raise mse



                    # ./output/PLSQL3.g:1103:50: ( 'ANY' | keySOME | 'ALL' )
                    alt292 = 3
                    LA292 = self.input.LA(1)
                    if LA292 == 52:
                        alt292 = 1
                    elif LA292 == ID:
                        alt292 = 2
                    elif LA292 == 50:
                        alt292 = 3
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 292, 0, self.input)

                        raise nvae


                    if alt292 == 1:
                        # ./output/PLSQL3.g:1103:52: 'ANY'
                        pass
                        string_literal1125 = self.match(self.input, 52, self.FOLLOW_52_in_condition_group_comparison6772)
                        if self._state.backtracking == 0:
                            string_literal1125_tree = self._adaptor.createWithPayload(string_literal1125)
                            self._adaptor.addChild(root_0, string_literal1125_tree)




                    elif alt292 == 2:
                        # ./output/PLSQL3.g:1103:60: keySOME
                        pass
                        self._state.following.append(self.FOLLOW_keySOME_in_condition_group_comparison6776)
                        keySOME1126 = self.keySOME()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keySOME1126.tree)



                    elif alt292 == 3:
                        # ./output/PLSQL3.g:1103:70: 'ALL'
                        pass
                        string_literal1127 = self.match(self.input, 50, self.FOLLOW_50_in_condition_group_comparison6780)
                        if self._state.backtracking == 0:
                            string_literal1127_tree = self._adaptor.createWithPayload(string_literal1127)
                            self._adaptor.addChild(root_0, string_literal1127_tree)






                    LPAREN1128 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_group_comparison6784)
                    if self._state.backtracking == 0:
                        LPAREN1128_tree = self._adaptor.createWithPayload(LPAREN1128)
                        self._adaptor.addChild(root_0, LPAREN1128_tree)



                    # ./output/PLSQL3.g:1103:85: ( grouping_expression_list | select_command )
                    alt293 = 2
                    LA293_0 = self.input.LA(1)

                    if (LA293_0 == DOUBLEQUOTED_STRING or LA293_0 == ID or LA293_0 == LPAREN or LA293_0 == MINUS or LA293_0 == NUMBER or LA293_0 == PLUS or LA293_0 == QUOTED_STRING or LA293_0 == 65 or LA293_0 == 81 or LA293_0 == 89 or LA293_0 == 120 or LA293_0 == 144 or LA293_0 == 151 or LA293_0 == 156) :
                        alt293 = 1
                    elif (LA293_0 == 147) :
                        LA293_13 = self.input.LA(2)

                        if (self.synpred482_PLSQL3()) :
                            alt293 = 1
                        elif (True) :
                            alt293 = 2
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 293, 13, self.input)

                            raise nvae


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 293, 0, self.input)

                        raise nvae


                    if alt293 == 1:
                        # ./output/PLSQL3.g:1103:87: grouping_expression_list
                        pass
                        self._state.following.append(self.FOLLOW_grouping_expression_list_in_condition_group_comparison6788)
                        grouping_expression_list1129 = self.grouping_expression_list()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, grouping_expression_list1129.tree)



                    elif alt293 == 2:
                        # ./output/PLSQL3.g:1103:114: select_command
                        pass
                        self._state.following.append(self.FOLLOW_select_command_in_condition_group_comparison6792)
                        select_command1130 = self.select_command()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, select_command1130.tree)





                    RPAREN1131 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_group_comparison6796)
                    if self._state.backtracking == 0:
                        RPAREN1131_tree = self._adaptor.createWithPayload(RPAREN1131)
                        self._adaptor.addChild(root_0, RPAREN1131_tree)




                elif alt296 == 2:
                    # ./output/PLSQL3.g:1104:4: sql_expression ( EQ | NOT_EQ | GTH | GEQ | LTH | LEQ ) ( 'ANY' | keySOME | 'ALL' ) LPAREN ( sql_expressions | select_command ) RPAREN
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_sql_expression_in_condition_group_comparison6801)
                    sql_expression1132 = self.sql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expression1132.tree)


                    set1133 = self.input.LT(1)

                    if self.input.LA(1) == EQ or (GEQ <= self.input.LA(1) <= GTH) or self.input.LA(1) == LEQ or self.input.LA(1) == LTH or self.input.LA(1) == NOT_EQ:
                        self.input.consume()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set1133))

                        self._state.errorRecovery = False


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        mse = MismatchedSetException(None, self.input)
                        raise mse



                    # ./output/PLSQL3.g:1104:59: ( 'ANY' | keySOME | 'ALL' )
                    alt294 = 3
                    LA294 = self.input.LA(1)
                    if LA294 == 52:
                        alt294 = 1
                    elif LA294 == ID:
                        alt294 = 2
                    elif LA294 == 50:
                        alt294 = 3
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 294, 0, self.input)

                        raise nvae


                    if alt294 == 1:
                        # ./output/PLSQL3.g:1104:61: 'ANY'
                        pass
                        string_literal1134 = self.match(self.input, 52, self.FOLLOW_52_in_condition_group_comparison6831)
                        if self._state.backtracking == 0:
                            string_literal1134_tree = self._adaptor.createWithPayload(string_literal1134)
                            self._adaptor.addChild(root_0, string_literal1134_tree)




                    elif alt294 == 2:
                        # ./output/PLSQL3.g:1104:69: keySOME
                        pass
                        self._state.following.append(self.FOLLOW_keySOME_in_condition_group_comparison6835)
                        keySOME1135 = self.keySOME()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keySOME1135.tree)



                    elif alt294 == 3:
                        # ./output/PLSQL3.g:1104:79: 'ALL'
                        pass
                        string_literal1136 = self.match(self.input, 50, self.FOLLOW_50_in_condition_group_comparison6839)
                        if self._state.backtracking == 0:
                            string_literal1136_tree = self._adaptor.createWithPayload(string_literal1136)
                            self._adaptor.addChild(root_0, string_literal1136_tree)






                    LPAREN1137 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_group_comparison6843)
                    if self._state.backtracking == 0:
                        LPAREN1137_tree = self._adaptor.createWithPayload(LPAREN1137)
                        self._adaptor.addChild(root_0, LPAREN1137_tree)



                    # ./output/PLSQL3.g:1104:94: ( sql_expressions | select_command )
                    alt295 = 2
                    LA295_0 = self.input.LA(1)

                    if (LA295_0 == DOUBLEQUOTED_STRING or LA295_0 == ID or LA295_0 == LPAREN or LA295_0 == MINUS or LA295_0 == NUMBER or LA295_0 == PLUS or LA295_0 == QUOTED_STRING or LA295_0 == 65 or LA295_0 == 81 or LA295_0 == 89 or LA295_0 == 120 or LA295_0 == 144 or LA295_0 == 151 or LA295_0 == 156) :
                        alt295 = 1
                    elif (LA295_0 == 147) :
                        LA295_13 = self.input.LA(2)

                        if (self.synpred491_PLSQL3()) :
                            alt295 = 1
                        elif (True) :
                            alt295 = 2
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 295, 13, self.input)

                            raise nvae


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 295, 0, self.input)

                        raise nvae


                    if alt295 == 1:
                        # ./output/PLSQL3.g:1104:96: sql_expressions
                        pass
                        self._state.following.append(self.FOLLOW_sql_expressions_in_condition_group_comparison6847)
                        sql_expressions1138 = self.sql_expressions()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, sql_expressions1138.tree)



                    elif alt295 == 2:
                        # ./output/PLSQL3.g:1104:114: select_command
                        pass
                        self._state.following.append(self.FOLLOW_select_command_in_condition_group_comparison6851)
                        select_command1139 = self.select_command()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, select_command1139.tree)





                    RPAREN1140 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_group_comparison6855)
                    if self._state.backtracking == 0:
                        RPAREN1140_tree = self._adaptor.createWithPayload(RPAREN1140)
                        self._adaptor.addChild(root_0, RPAREN1140_tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 203, condition_group_comparison_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_group_comparison"


    class condition_in_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_in_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_in"
    # ./output/PLSQL3.g:1106:1: condition_in : ( LPAREN sql_expressions RPAREN ( 'NOT' )? 'IN' LPAREN ( grouping_expression_list | select_command ) RPAREN | sql_expression ( 'NOT' )? 'IN' LPAREN ( expression_list | select_command ) RPAREN );
    def condition_in(self, ):
        retval = self.condition_in_return()
        retval.start = self.input.LT(1)

        condition_in_StartIndex = self.input.index()

        root_0 = None

        LPAREN1141 = None
        RPAREN1143 = None
        string_literal1144 = None
        string_literal1145 = None
        LPAREN1146 = None
        RPAREN1149 = None
        string_literal1151 = None
        string_literal1152 = None
        LPAREN1153 = None
        RPAREN1156 = None
        sql_expressions1142 = None

        grouping_expression_list1147 = None

        select_command1148 = None

        sql_expression1150 = None

        expression_list1154 = None

        select_command1155 = None


        LPAREN1141_tree = None
        RPAREN1143_tree = None
        string_literal1144_tree = None
        string_literal1145_tree = None
        LPAREN1146_tree = None
        RPAREN1149_tree = None
        string_literal1151_tree = None
        string_literal1152_tree = None
        LPAREN1153_tree = None
        RPAREN1156_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 204):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1107:2: ( LPAREN sql_expressions RPAREN ( 'NOT' )? 'IN' LPAREN ( grouping_expression_list | select_command ) RPAREN | sql_expression ( 'NOT' )? 'IN' LPAREN ( expression_list | select_command ) RPAREN )
                alt301 = 2
                LA301_0 = self.input.LA(1)

                if (LA301_0 == LPAREN) :
                    LA301_1 = self.input.LA(2)

                    if (self.synpred494_PLSQL3()) :
                        alt301 = 1
                    elif (True) :
                        alt301 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 301, 1, self.input)

                        raise nvae


                elif (LA301_0 == DOUBLEQUOTED_STRING or LA301_0 == ID or LA301_0 == MINUS or LA301_0 == NUMBER or LA301_0 == PLUS or LA301_0 == QUOTED_STRING or LA301_0 == 65 or LA301_0 == 81 or LA301_0 == 89 or LA301_0 == 120 or LA301_0 == 144 or LA301_0 == 147 or LA301_0 == 151 or LA301_0 == 156) :
                    alt301 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 301, 0, self.input)

                    raise nvae


                if alt301 == 1:
                    # ./output/PLSQL3.g:1107:4: LPAREN sql_expressions RPAREN ( 'NOT' )? 'IN' LPAREN ( grouping_expression_list | select_command ) RPAREN
                    pass
                    root_0 = self._adaptor.nil()


                    LPAREN1141 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_in6865)
                    if self._state.backtracking == 0:
                        LPAREN1141_tree = self._adaptor.createWithPayload(LPAREN1141)
                        self._adaptor.addChild(root_0, LPAREN1141_tree)



                    self._state.following.append(self.FOLLOW_sql_expressions_in_condition_in6867)
                    sql_expressions1142 = self.sql_expressions()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expressions1142.tree)


                    RPAREN1143 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_in6869)
                    if self._state.backtracking == 0:
                        RPAREN1143_tree = self._adaptor.createWithPayload(RPAREN1143)
                        self._adaptor.addChild(root_0, RPAREN1143_tree)



                    # ./output/PLSQL3.g:1107:34: ( 'NOT' )?
                    alt297 = 2
                    LA297_0 = self.input.LA(1)

                    if (LA297_0 == 118) :
                        alt297 = 1
                    if alt297 == 1:
                        # ./output/PLSQL3.g:1107:36: 'NOT'
                        pass
                        string_literal1144 = self.match(self.input, 118, self.FOLLOW_118_in_condition_in6873)
                        if self._state.backtracking == 0:
                            string_literal1144_tree = self._adaptor.createWithPayload(string_literal1144)
                            self._adaptor.addChild(root_0, string_literal1144_tree)






                    string_literal1145 = self.match(self.input, 99, self.FOLLOW_99_in_condition_in6878)
                    if self._state.backtracking == 0:
                        string_literal1145_tree = self._adaptor.createWithPayload(string_literal1145)
                        self._adaptor.addChild(root_0, string_literal1145_tree)



                    LPAREN1146 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_in6880)
                    if self._state.backtracking == 0:
                        LPAREN1146_tree = self._adaptor.createWithPayload(LPAREN1146)
                        self._adaptor.addChild(root_0, LPAREN1146_tree)



                    # ./output/PLSQL3.g:1107:57: ( grouping_expression_list | select_command )
                    alt298 = 2
                    LA298_0 = self.input.LA(1)

                    if (LA298_0 == DOUBLEQUOTED_STRING or LA298_0 == ID or LA298_0 == LPAREN or LA298_0 == MINUS or LA298_0 == NUMBER or LA298_0 == PLUS or LA298_0 == QUOTED_STRING or LA298_0 == 65 or LA298_0 == 81 or LA298_0 == 89 or LA298_0 == 120 or LA298_0 == 144 or LA298_0 == 151 or LA298_0 == 156) :
                        alt298 = 1
                    elif (LA298_0 == 147) :
                        LA298_13 = self.input.LA(2)

                        if (self.synpred493_PLSQL3()) :
                            alt298 = 1
                        elif (True) :
                            alt298 = 2
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 298, 13, self.input)

                            raise nvae


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 298, 0, self.input)

                        raise nvae


                    if alt298 == 1:
                        # ./output/PLSQL3.g:1107:59: grouping_expression_list
                        pass
                        self._state.following.append(self.FOLLOW_grouping_expression_list_in_condition_in6884)
                        grouping_expression_list1147 = self.grouping_expression_list()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, grouping_expression_list1147.tree)



                    elif alt298 == 2:
                        # ./output/PLSQL3.g:1107:86: select_command
                        pass
                        self._state.following.append(self.FOLLOW_select_command_in_condition_in6888)
                        select_command1148 = self.select_command()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, select_command1148.tree)





                    RPAREN1149 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_in6892)
                    if self._state.backtracking == 0:
                        RPAREN1149_tree = self._adaptor.createWithPayload(RPAREN1149)
                        self._adaptor.addChild(root_0, RPAREN1149_tree)




                elif alt301 == 2:
                    # ./output/PLSQL3.g:1108:4: sql_expression ( 'NOT' )? 'IN' LPAREN ( expression_list | select_command ) RPAREN
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_sql_expression_in_condition_in6897)
                    sql_expression1150 = self.sql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expression1150.tree)


                    # ./output/PLSQL3.g:1108:19: ( 'NOT' )?
                    alt299 = 2
                    LA299_0 = self.input.LA(1)

                    if (LA299_0 == 118) :
                        alt299 = 1
                    if alt299 == 1:
                        # ./output/PLSQL3.g:1108:21: 'NOT'
                        pass
                        string_literal1151 = self.match(self.input, 118, self.FOLLOW_118_in_condition_in6901)
                        if self._state.backtracking == 0:
                            string_literal1151_tree = self._adaptor.createWithPayload(string_literal1151)
                            self._adaptor.addChild(root_0, string_literal1151_tree)






                    string_literal1152 = self.match(self.input, 99, self.FOLLOW_99_in_condition_in6906)
                    if self._state.backtracking == 0:
                        string_literal1152_tree = self._adaptor.createWithPayload(string_literal1152)
                        self._adaptor.addChild(root_0, string_literal1152_tree)



                    LPAREN1153 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_in6908)
                    if self._state.backtracking == 0:
                        LPAREN1153_tree = self._adaptor.createWithPayload(LPAREN1153)
                        self._adaptor.addChild(root_0, LPAREN1153_tree)



                    # ./output/PLSQL3.g:1108:42: ( expression_list | select_command )
                    alt300 = 2
                    LA300_0 = self.input.LA(1)

                    if (LA300_0 == DOUBLEQUOTED_STRING or LA300_0 == ID or LA300_0 == LPAREN or LA300_0 == MINUS or LA300_0 == NUMBER or LA300_0 == PLUS or LA300_0 == QUOTED_STRING or LA300_0 == 65 or LA300_0 == 81 or LA300_0 == 89 or LA300_0 == 120 or LA300_0 == 144 or LA300_0 == 151 or LA300_0 == 156) :
                        alt300 = 1
                    elif (LA300_0 == 147) :
                        LA300_13 = self.input.LA(2)

                        if (self.synpred496_PLSQL3()) :
                            alt300 = 1
                        elif (True) :
                            alt300 = 2
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 300, 13, self.input)

                            raise nvae


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 300, 0, self.input)

                        raise nvae


                    if alt300 == 1:
                        # ./output/PLSQL3.g:1108:44: expression_list
                        pass
                        self._state.following.append(self.FOLLOW_expression_list_in_condition_in6912)
                        expression_list1154 = self.expression_list()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, expression_list1154.tree)



                    elif alt300 == 2:
                        # ./output/PLSQL3.g:1108:62: select_command
                        pass
                        self._state.following.append(self.FOLLOW_select_command_in_condition_in6916)
                        select_command1155 = self.select_command()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, select_command1155.tree)





                    RPAREN1156 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_in6920)
                    if self._state.backtracking == 0:
                        RPAREN1156_tree = self._adaptor.createWithPayload(RPAREN1156)
                        self._adaptor.addChild(root_0, RPAREN1156_tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 204, condition_in_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_in"


    class condition_is_a_set_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_is_a_set_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_is_a_set"
    # ./output/PLSQL3.g:1110:1: condition_is_a_set : nested_table_column_name 'IS' ( 'NOT' )? keyA 'SET' ;
    def condition_is_a_set(self, ):
        retval = self.condition_is_a_set_return()
        retval.start = self.input.LT(1)

        condition_is_a_set_StartIndex = self.input.index()

        root_0 = None

        string_literal1158 = None
        string_literal1159 = None
        string_literal1161 = None
        nested_table_column_name1157 = None

        keyA1160 = None


        string_literal1158_tree = None
        string_literal1159_tree = None
        string_literal1161_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 205):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1111:2: ( nested_table_column_name 'IS' ( 'NOT' )? keyA 'SET' )
                # ./output/PLSQL3.g:1111:4: nested_table_column_name 'IS' ( 'NOT' )? keyA 'SET'
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_nested_table_column_name_in_condition_is_a_set6930)
                nested_table_column_name1157 = self.nested_table_column_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, nested_table_column_name1157.tree)


                string_literal1158 = self.match(self.input, 106, self.FOLLOW_106_in_condition_is_a_set6932)
                if self._state.backtracking == 0:
                    string_literal1158_tree = self._adaptor.createWithPayload(string_literal1158)
                    self._adaptor.addChild(root_0, string_literal1158_tree)



                # ./output/PLSQL3.g:1111:34: ( 'NOT' )?
                alt302 = 2
                LA302_0 = self.input.LA(1)

                if (LA302_0 == 118) :
                    alt302 = 1
                if alt302 == 1:
                    # ./output/PLSQL3.g:1111:36: 'NOT'
                    pass
                    string_literal1159 = self.match(self.input, 118, self.FOLLOW_118_in_condition_is_a_set6936)
                    if self._state.backtracking == 0:
                        string_literal1159_tree = self._adaptor.createWithPayload(string_literal1159)
                        self._adaptor.addChild(root_0, string_literal1159_tree)






                self._state.following.append(self.FOLLOW_keyA_in_condition_is_a_set6941)
                keyA1160 = self.keyA()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyA1160.tree)


                string_literal1161 = self.match(self.input, 148, self.FOLLOW_148_in_condition_is_a_set6943)
                if self._state.backtracking == 0:
                    string_literal1161_tree = self._adaptor.createWithPayload(string_literal1161)
                    self._adaptor.addChild(root_0, string_literal1161_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 205, condition_is_a_set_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_is_a_set"


    class condition_is_any_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_is_any_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_is_any"
    # ./output/PLSQL3.g:1113:1: condition_is_any : ( column_name 'IS' )? 'ANY' ;
    def condition_is_any(self, ):
        retval = self.condition_is_any_return()
        retval.start = self.input.LT(1)

        condition_is_any_StartIndex = self.input.index()

        root_0 = None

        string_literal1163 = None
        string_literal1164 = None
        column_name1162 = None


        string_literal1163_tree = None
        string_literal1164_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 206):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1114:2: ( ( column_name 'IS' )? 'ANY' )
                # ./output/PLSQL3.g:1114:4: ( column_name 'IS' )? 'ANY'
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:1114:4: ( column_name 'IS' )?
                alt303 = 2
                LA303_0 = self.input.LA(1)

                if (LA303_0 == DOUBLEQUOTED_STRING or LA303_0 == ID or LA303_0 == 144) :
                    alt303 = 1
                if alt303 == 1:
                    # ./output/PLSQL3.g:1114:6: column_name 'IS'
                    pass
                    self._state.following.append(self.FOLLOW_column_name_in_condition_is_any6955)
                    column_name1162 = self.column_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, column_name1162.tree)


                    string_literal1163 = self.match(self.input, 106, self.FOLLOW_106_in_condition_is_any6957)
                    if self._state.backtracking == 0:
                        string_literal1163_tree = self._adaptor.createWithPayload(string_literal1163)
                        self._adaptor.addChild(root_0, string_literal1163_tree)






                string_literal1164 = self.match(self.input, 52, self.FOLLOW_52_in_condition_is_any6962)
                if self._state.backtracking == 0:
                    string_literal1164_tree = self._adaptor.createWithPayload(string_literal1164)
                    self._adaptor.addChild(root_0, string_literal1164_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 206, condition_is_any_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_is_any"


    class condition_is_empty_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_is_empty_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_is_empty"
    # ./output/PLSQL3.g:1116:1: condition_is_empty : nested_table_column_name 'IS' ( 'NOT' )? keyEMPTY ;
    def condition_is_empty(self, ):
        retval = self.condition_is_empty_return()
        retval.start = self.input.LT(1)

        condition_is_empty_StartIndex = self.input.index()

        root_0 = None

        string_literal1166 = None
        string_literal1167 = None
        nested_table_column_name1165 = None

        keyEMPTY1168 = None


        string_literal1166_tree = None
        string_literal1167_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 207):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1117:2: ( nested_table_column_name 'IS' ( 'NOT' )? keyEMPTY )
                # ./output/PLSQL3.g:1117:4: nested_table_column_name 'IS' ( 'NOT' )? keyEMPTY
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_nested_table_column_name_in_condition_is_empty6972)
                nested_table_column_name1165 = self.nested_table_column_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, nested_table_column_name1165.tree)


                string_literal1166 = self.match(self.input, 106, self.FOLLOW_106_in_condition_is_empty6974)
                if self._state.backtracking == 0:
                    string_literal1166_tree = self._adaptor.createWithPayload(string_literal1166)
                    self._adaptor.addChild(root_0, string_literal1166_tree)



                # ./output/PLSQL3.g:1117:34: ( 'NOT' )?
                alt304 = 2
                LA304_0 = self.input.LA(1)

                if (LA304_0 == 118) :
                    alt304 = 1
                if alt304 == 1:
                    # ./output/PLSQL3.g:1117:36: 'NOT'
                    pass
                    string_literal1167 = self.match(self.input, 118, self.FOLLOW_118_in_condition_is_empty6978)
                    if self._state.backtracking == 0:
                        string_literal1167_tree = self._adaptor.createWithPayload(string_literal1167)
                        self._adaptor.addChild(root_0, string_literal1167_tree)






                self._state.following.append(self.FOLLOW_keyEMPTY_in_condition_is_empty6983)
                keyEMPTY1168 = self.keyEMPTY()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyEMPTY1168.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 207, condition_is_empty_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_is_empty"


    class condition_is_of_type_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_is_of_type_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_is_of_type"
    # ./output/PLSQL3.g:1119:1: condition_is_of_type : sql_expression 'IS' ( 'NOT' )? 'OF' ( keyTYPE )? LPAREN type_name RPAREN ;
    def condition_is_of_type(self, ):
        retval = self.condition_is_of_type_return()
        retval.start = self.input.LT(1)

        condition_is_of_type_StartIndex = self.input.index()

        root_0 = None

        string_literal1170 = None
        string_literal1171 = None
        string_literal1172 = None
        LPAREN1174 = None
        RPAREN1176 = None
        sql_expression1169 = None

        keyTYPE1173 = None

        type_name1175 = None


        string_literal1170_tree = None
        string_literal1171_tree = None
        string_literal1172_tree = None
        LPAREN1174_tree = None
        RPAREN1176_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 208):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1120:2: ( sql_expression 'IS' ( 'NOT' )? 'OF' ( keyTYPE )? LPAREN type_name RPAREN )
                # ./output/PLSQL3.g:1120:4: sql_expression 'IS' ( 'NOT' )? 'OF' ( keyTYPE )? LPAREN type_name RPAREN
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_sql_expression_in_condition_is_of_type6993)
                sql_expression1169 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression1169.tree)


                string_literal1170 = self.match(self.input, 106, self.FOLLOW_106_in_condition_is_of_type6995)
                if self._state.backtracking == 0:
                    string_literal1170_tree = self._adaptor.createWithPayload(string_literal1170)
                    self._adaptor.addChild(root_0, string_literal1170_tree)



                # ./output/PLSQL3.g:1120:24: ( 'NOT' )?
                alt305 = 2
                LA305_0 = self.input.LA(1)

                if (LA305_0 == 118) :
                    alt305 = 1
                if alt305 == 1:
                    # ./output/PLSQL3.g:1120:26: 'NOT'
                    pass
                    string_literal1171 = self.match(self.input, 118, self.FOLLOW_118_in_condition_is_of_type6999)
                    if self._state.backtracking == 0:
                        string_literal1171_tree = self._adaptor.createWithPayload(string_literal1171)
                        self._adaptor.addChild(root_0, string_literal1171_tree)






                string_literal1172 = self.match(self.input, 125, self.FOLLOW_125_in_condition_is_of_type7004)
                if self._state.backtracking == 0:
                    string_literal1172_tree = self._adaptor.createWithPayload(string_literal1172)
                    self._adaptor.addChild(root_0, string_literal1172_tree)



                # ./output/PLSQL3.g:1120:40: ( keyTYPE )?
                alt306 = 2
                LA306_0 = self.input.LA(1)

                if (LA306_0 == ID) :
                    alt306 = 1
                if alt306 == 1:
                    # ./output/PLSQL3.g:1120:42: keyTYPE
                    pass
                    self._state.following.append(self.FOLLOW_keyTYPE_in_condition_is_of_type7008)
                    keyTYPE1173 = self.keyTYPE()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyTYPE1173.tree)





                LPAREN1174 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_is_of_type7013)
                if self._state.backtracking == 0:
                    LPAREN1174_tree = self._adaptor.createWithPayload(LPAREN1174)
                    self._adaptor.addChild(root_0, LPAREN1174_tree)



                self._state.following.append(self.FOLLOW_type_name_in_condition_is_of_type7015)
                type_name1175 = self.type_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, type_name1175.tree)


                RPAREN1176 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_is_of_type7017)
                if self._state.backtracking == 0:
                    RPAREN1176_tree = self._adaptor.createWithPayload(RPAREN1176)
                    self._adaptor.addChild(root_0, RPAREN1176_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 208, condition_is_of_type_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_is_of_type"


    class condition_is_of_type_names_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_is_of_type_names_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_is_of_type_names"
    # ./output/PLSQL3.g:1122:1: condition_is_of_type_names : condition_is_of_type_name ( COMMA condition_is_of_type_name )* ;
    def condition_is_of_type_names(self, ):
        retval = self.condition_is_of_type_names_return()
        retval.start = self.input.LT(1)

        condition_is_of_type_names_StartIndex = self.input.index()

        root_0 = None

        COMMA1178 = None
        condition_is_of_type_name1177 = None

        condition_is_of_type_name1179 = None


        COMMA1178_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 209):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1123:2: ( condition_is_of_type_name ( COMMA condition_is_of_type_name )* )
                # ./output/PLSQL3.g:1123:4: condition_is_of_type_name ( COMMA condition_is_of_type_name )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_condition_is_of_type_name_in_condition_is_of_type_names7027)
                condition_is_of_type_name1177 = self.condition_is_of_type_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, condition_is_of_type_name1177.tree)


                # ./output/PLSQL3.g:1123:30: ( COMMA condition_is_of_type_name )*
                while True: #loop307
                    alt307 = 2
                    LA307_0 = self.input.LA(1)

                    if (LA307_0 == COMMA) :
                        alt307 = 1


                    if alt307 == 1:
                        # ./output/PLSQL3.g:1123:32: COMMA condition_is_of_type_name
                        pass
                        COMMA1178 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_condition_is_of_type_names7031)
                        if self._state.backtracking == 0:
                            COMMA1178_tree = self._adaptor.createWithPayload(COMMA1178)
                            self._adaptor.addChild(root_0, COMMA1178_tree)



                        self._state.following.append(self.FOLLOW_condition_is_of_type_name_in_condition_is_of_type_names7033)
                        condition_is_of_type_name1179 = self.condition_is_of_type_name()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, condition_is_of_type_name1179.tree)



                    else:
                        break #loop307




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 209, condition_is_of_type_names_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_is_of_type_names"


    class condition_is_of_type_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_is_of_type_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_is_of_type_name"
    # ./output/PLSQL3.g:1125:1: condition_is_of_type_name : ( keyONLY )? type_name ;
    def condition_is_of_type_name(self, ):
        retval = self.condition_is_of_type_name_return()
        retval.start = self.input.LT(1)

        condition_is_of_type_name_StartIndex = self.input.index()

        root_0 = None

        keyONLY1180 = None

        type_name1181 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 210):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1126:2: ( ( keyONLY )? type_name )
                # ./output/PLSQL3.g:1126:4: ( keyONLY )? type_name
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:1126:4: ( keyONLY )?
                alt308 = 2
                LA308_0 = self.input.LA(1)

                if (LA308_0 == ID) :
                    LA308_1 = self.input.LA(2)

                    if (LA308_1 == DOUBLEQUOTED_STRING or LA308_1 == ID) :
                        alt308 = 1
                if alt308 == 1:
                    # ./output/PLSQL3.g:1126:6: keyONLY
                    pass
                    self._state.following.append(self.FOLLOW_keyONLY_in_condition_is_of_type_name7048)
                    keyONLY1180 = self.keyONLY()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyONLY1180.tree)





                self._state.following.append(self.FOLLOW_type_name_in_condition_is_of_type_name7053)
                type_name1181 = self.type_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, type_name1181.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 210, condition_is_of_type_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_is_of_type_name"


    class condition_is_present_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_is_present_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_is_present"
    # ./output/PLSQL3.g:1128:1: condition_is_present : cell_reference 'IS' keyPRESENT ;
    def condition_is_present(self, ):
        retval = self.condition_is_present_return()
        retval.start = self.input.LT(1)

        condition_is_present_StartIndex = self.input.index()

        root_0 = None

        string_literal1183 = None
        cell_reference1182 = None

        keyPRESENT1184 = None


        string_literal1183_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 211):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1129:2: ( cell_reference 'IS' keyPRESENT )
                # ./output/PLSQL3.g:1129:4: cell_reference 'IS' keyPRESENT
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_cell_reference_in_condition_is_present7063)
                cell_reference1182 = self.cell_reference()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, cell_reference1182.tree)


                string_literal1183 = self.match(self.input, 106, self.FOLLOW_106_in_condition_is_present7065)
                if self._state.backtracking == 0:
                    string_literal1183_tree = self._adaptor.createWithPayload(string_literal1183)
                    self._adaptor.addChild(root_0, string_literal1183_tree)



                self._state.following.append(self.FOLLOW_keyPRESENT_in_condition_is_present7067)
                keyPRESENT1184 = self.keyPRESENT()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyPRESENT1184.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 211, condition_is_present_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_is_present"


    class condition_like_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_like_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_like"
    # ./output/PLSQL3.g:1131:1: condition_like : sql_expression ( 'NOT' )? ( 'LIKE' | keyLIKEC | keyLIKE2 | keyLIKE4 ) sql_expression ( keyESCAPE sql_expression )? ;
    def condition_like(self, ):
        retval = self.condition_like_return()
        retval.start = self.input.LT(1)

        condition_like_StartIndex = self.input.index()

        root_0 = None

        string_literal1186 = None
        string_literal1187 = None
        sql_expression1185 = None

        keyLIKEC1188 = None

        keyLIKE21189 = None

        keyLIKE41190 = None

        sql_expression1191 = None

        keyESCAPE1192 = None

        sql_expression1193 = None


        string_literal1186_tree = None
        string_literal1187_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 212):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1132:2: ( sql_expression ( 'NOT' )? ( 'LIKE' | keyLIKEC | keyLIKE2 | keyLIKE4 ) sql_expression ( keyESCAPE sql_expression )? )
                # ./output/PLSQL3.g:1132:4: sql_expression ( 'NOT' )? ( 'LIKE' | keyLIKEC | keyLIKE2 | keyLIKE4 ) sql_expression ( keyESCAPE sql_expression )?
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_sql_expression_in_condition_like7077)
                sql_expression1185 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression1185.tree)


                # ./output/PLSQL3.g:1132:19: ( 'NOT' )?
                alt309 = 2
                LA309_0 = self.input.LA(1)

                if (LA309_0 == 118) :
                    alt309 = 1
                if alt309 == 1:
                    # ./output/PLSQL3.g:1132:21: 'NOT'
                    pass
                    string_literal1186 = self.match(self.input, 118, self.FOLLOW_118_in_condition_like7081)
                    if self._state.backtracking == 0:
                        string_literal1186_tree = self._adaptor.createWithPayload(string_literal1186)
                        self._adaptor.addChild(root_0, string_literal1186_tree)






                # ./output/PLSQL3.g:1132:30: ( 'LIKE' | keyLIKEC | keyLIKE2 | keyLIKE4 )
                alt310 = 4
                LA310_0 = self.input.LA(1)

                if (LA310_0 == 107) :
                    alt310 = 1
                elif (LA310_0 == ID) :
                    LA310_2 = self.input.LA(2)

                    if (((((((self.input).LT(1).text.upper() == "LIKEC")) and (((this.input).LT(1).text.upper() == "LIKEC")))) and (self.synpred506_PLSQL3()))) :
                        alt310 = 2
                    elif (((((((self.input).LT(1).text.upper() == "LIKE2")) and (((this.input).LT(1).text.upper() == "LIKE2")))) and (self.synpred507_PLSQL3()))) :
                        alt310 = 3
                    elif (((self.input).LT(1).text.upper() == "LIKE4")) :
                        alt310 = 4
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 310, 2, self.input)

                        raise nvae


                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 310, 0, self.input)

                    raise nvae


                if alt310 == 1:
                    # ./output/PLSQL3.g:1132:32: 'LIKE'
                    pass
                    string_literal1187 = self.match(self.input, 107, self.FOLLOW_107_in_condition_like7088)
                    if self._state.backtracking == 0:
                        string_literal1187_tree = self._adaptor.createWithPayload(string_literal1187)
                        self._adaptor.addChild(root_0, string_literal1187_tree)




                elif alt310 == 2:
                    # ./output/PLSQL3.g:1132:41: keyLIKEC
                    pass
                    self._state.following.append(self.FOLLOW_keyLIKEC_in_condition_like7092)
                    keyLIKEC1188 = self.keyLIKEC()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyLIKEC1188.tree)



                elif alt310 == 3:
                    # ./output/PLSQL3.g:1132:52: keyLIKE2
                    pass
                    self._state.following.append(self.FOLLOW_keyLIKE2_in_condition_like7096)
                    keyLIKE21189 = self.keyLIKE2()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyLIKE21189.tree)



                elif alt310 == 4:
                    # ./output/PLSQL3.g:1132:63: keyLIKE4
                    pass
                    self._state.following.append(self.FOLLOW_keyLIKE4_in_condition_like7100)
                    keyLIKE41190 = self.keyLIKE4()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyLIKE41190.tree)





                self._state.following.append(self.FOLLOW_sql_expression_in_condition_like7104)
                sql_expression1191 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression1191.tree)


                # ./output/PLSQL3.g:1132:89: ( keyESCAPE sql_expression )?
                alt311 = 2
                LA311_0 = self.input.LA(1)

                if (LA311_0 == ID) :
                    LA311_1 = self.input.LA(2)

                    if (((((((self.input).LT(1).text.upper() == "ESCAPE")) and (((this.input).LT(1).text.upper() == "ESCAPE")))) and (self.synpred508_PLSQL3()))) :
                        alt311 = 1
                if alt311 == 1:
                    # ./output/PLSQL3.g:1132:91: keyESCAPE sql_expression
                    pass
                    self._state.following.append(self.FOLLOW_keyESCAPE_in_condition_like7108)
                    keyESCAPE1192 = self.keyESCAPE()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyESCAPE1192.tree)


                    self._state.following.append(self.FOLLOW_sql_expression_in_condition_like7110)
                    sql_expression1193 = self.sql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expression1193.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 212, condition_like_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_like"


    class condition_memeber_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_memeber_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_memeber"
    # ./output/PLSQL3.g:1134:1: condition_memeber : sql_expression ( 'NOT' )? keyMEMBER ( 'OF' )? nested_table_column_name ;
    def condition_memeber(self, ):
        retval = self.condition_memeber_return()
        retval.start = self.input.LT(1)

        condition_memeber_StartIndex = self.input.index()

        root_0 = None

        string_literal1195 = None
        string_literal1197 = None
        sql_expression1194 = None

        keyMEMBER1196 = None

        nested_table_column_name1198 = None


        string_literal1195_tree = None
        string_literal1197_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 213):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1135:2: ( sql_expression ( 'NOT' )? keyMEMBER ( 'OF' )? nested_table_column_name )
                # ./output/PLSQL3.g:1135:4: sql_expression ( 'NOT' )? keyMEMBER ( 'OF' )? nested_table_column_name
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_sql_expression_in_condition_memeber7123)
                sql_expression1194 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression1194.tree)


                # ./output/PLSQL3.g:1135:19: ( 'NOT' )?
                alt312 = 2
                LA312_0 = self.input.LA(1)

                if (LA312_0 == 118) :
                    alt312 = 1
                if alt312 == 1:
                    # ./output/PLSQL3.g:1135:21: 'NOT'
                    pass
                    string_literal1195 = self.match(self.input, 118, self.FOLLOW_118_in_condition_memeber7127)
                    if self._state.backtracking == 0:
                        string_literal1195_tree = self._adaptor.createWithPayload(string_literal1195)
                        self._adaptor.addChild(root_0, string_literal1195_tree)






                self._state.following.append(self.FOLLOW_keyMEMBER_in_condition_memeber7132)
                keyMEMBER1196 = self.keyMEMBER()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyMEMBER1196.tree)


                # ./output/PLSQL3.g:1135:40: ( 'OF' )?
                alt313 = 2
                LA313_0 = self.input.LA(1)

                if (LA313_0 == 125) :
                    alt313 = 1
                if alt313 == 1:
                    # ./output/PLSQL3.g:1135:42: 'OF'
                    pass
                    string_literal1197 = self.match(self.input, 125, self.FOLLOW_125_in_condition_memeber7136)
                    if self._state.backtracking == 0:
                        string_literal1197_tree = self._adaptor.createWithPayload(string_literal1197)
                        self._adaptor.addChild(root_0, string_literal1197_tree)






                self._state.following.append(self.FOLLOW_nested_table_column_name_in_condition_memeber7141)
                nested_table_column_name1198 = self.nested_table_column_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, nested_table_column_name1198.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 213, condition_memeber_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_memeber"


    class condition_between_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_between_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_between"
    # ./output/PLSQL3.g:1137:1: condition_between : sql_expression ( 'NOT' )? 'BETWEEN' sql_expression 'AND' sql_expression ;
    def condition_between(self, ):
        retval = self.condition_between_return()
        retval.start = self.input.LT(1)

        condition_between_StartIndex = self.input.index()

        root_0 = None

        string_literal1200 = None
        string_literal1201 = None
        string_literal1203 = None
        sql_expression1199 = None

        sql_expression1202 = None

        sql_expression1204 = None


        string_literal1200_tree = None
        string_literal1201_tree = None
        string_literal1203_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 214):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1138:2: ( sql_expression ( 'NOT' )? 'BETWEEN' sql_expression 'AND' sql_expression )
                # ./output/PLSQL3.g:1138:4: sql_expression ( 'NOT' )? 'BETWEEN' sql_expression 'AND' sql_expression
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_sql_expression_in_condition_between7151)
                sql_expression1199 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression1199.tree)


                # ./output/PLSQL3.g:1138:19: ( 'NOT' )?
                alt314 = 2
                LA314_0 = self.input.LA(1)

                if (LA314_0 == 118) :
                    alt314 = 1
                if alt314 == 1:
                    # ./output/PLSQL3.g:1138:21: 'NOT'
                    pass
                    string_literal1200 = self.match(self.input, 118, self.FOLLOW_118_in_condition_between7155)
                    if self._state.backtracking == 0:
                        string_literal1200_tree = self._adaptor.createWithPayload(string_literal1200)
                        self._adaptor.addChild(root_0, string_literal1200_tree)






                string_literal1201 = self.match(self.input, 57, self.FOLLOW_57_in_condition_between7160)
                if self._state.backtracking == 0:
                    string_literal1201_tree = self._adaptor.createWithPayload(string_literal1201)
                    self._adaptor.addChild(root_0, string_literal1201_tree)



                self._state.following.append(self.FOLLOW_sql_expression_in_condition_between7162)
                sql_expression1202 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression1202.tree)


                string_literal1203 = self.match(self.input, 51, self.FOLLOW_51_in_condition_between7164)
                if self._state.backtracking == 0:
                    string_literal1203_tree = self._adaptor.createWithPayload(string_literal1203)
                    self._adaptor.addChild(root_0, string_literal1203_tree)



                self._state.following.append(self.FOLLOW_sql_expression_in_condition_between7166)
                sql_expression1204 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression1204.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 214, condition_between_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_between"


    class condition_regexp_like_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_regexp_like_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_regexp_like"
    # ./output/PLSQL3.g:1140:1: condition_regexp_like : keyREGEXP_LIKE LPAREN call_parameters RPAREN ;
    def condition_regexp_like(self, ):
        retval = self.condition_regexp_like_return()
        retval.start = self.input.LT(1)

        condition_regexp_like_StartIndex = self.input.index()

        root_0 = None

        LPAREN1206 = None
        RPAREN1208 = None
        keyREGEXP_LIKE1205 = None

        call_parameters1207 = None


        LPAREN1206_tree = None
        RPAREN1208_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 215):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1141:2: ( keyREGEXP_LIKE LPAREN call_parameters RPAREN )
                # ./output/PLSQL3.g:1141:4: keyREGEXP_LIKE LPAREN call_parameters RPAREN
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyREGEXP_LIKE_in_condition_regexp_like7176)
                keyREGEXP_LIKE1205 = self.keyREGEXP_LIKE()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyREGEXP_LIKE1205.tree)


                LPAREN1206 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_regexp_like7178)
                if self._state.backtracking == 0:
                    LPAREN1206_tree = self._adaptor.createWithPayload(LPAREN1206)
                    self._adaptor.addChild(root_0, LPAREN1206_tree)



                self._state.following.append(self.FOLLOW_call_parameters_in_condition_regexp_like7180)
                call_parameters1207 = self.call_parameters()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, call_parameters1207.tree)


                RPAREN1208 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_regexp_like7182)
                if self._state.backtracking == 0:
                    RPAREN1208_tree = self._adaptor.createWithPayload(RPAREN1208)
                    self._adaptor.addChild(root_0, RPAREN1208_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 215, condition_regexp_like_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_regexp_like"


    class condition_submultiset_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_submultiset_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_submultiset"
    # ./output/PLSQL3.g:1143:1: condition_submultiset : nested_table_column_name ( 'NOT' )? keySUBMULTISET ( 'OF' )? nested_table_column_name ;
    def condition_submultiset(self, ):
        retval = self.condition_submultiset_return()
        retval.start = self.input.LT(1)

        condition_submultiset_StartIndex = self.input.index()

        root_0 = None

        string_literal1210 = None
        string_literal1212 = None
        nested_table_column_name1209 = None

        keySUBMULTISET1211 = None

        nested_table_column_name1213 = None


        string_literal1210_tree = None
        string_literal1212_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 216):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1144:2: ( nested_table_column_name ( 'NOT' )? keySUBMULTISET ( 'OF' )? nested_table_column_name )
                # ./output/PLSQL3.g:1144:4: nested_table_column_name ( 'NOT' )? keySUBMULTISET ( 'OF' )? nested_table_column_name
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_nested_table_column_name_in_condition_submultiset7192)
                nested_table_column_name1209 = self.nested_table_column_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, nested_table_column_name1209.tree)


                # ./output/PLSQL3.g:1144:29: ( 'NOT' )?
                alt315 = 2
                LA315_0 = self.input.LA(1)

                if (LA315_0 == 118) :
                    alt315 = 1
                if alt315 == 1:
                    # ./output/PLSQL3.g:1144:31: 'NOT'
                    pass
                    string_literal1210 = self.match(self.input, 118, self.FOLLOW_118_in_condition_submultiset7196)
                    if self._state.backtracking == 0:
                        string_literal1210_tree = self._adaptor.createWithPayload(string_literal1210)
                        self._adaptor.addChild(root_0, string_literal1210_tree)






                self._state.following.append(self.FOLLOW_keySUBMULTISET_in_condition_submultiset7201)
                keySUBMULTISET1211 = self.keySUBMULTISET()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keySUBMULTISET1211.tree)


                # ./output/PLSQL3.g:1144:55: ( 'OF' )?
                alt316 = 2
                LA316_0 = self.input.LA(1)

                if (LA316_0 == 125) :
                    alt316 = 1
                if alt316 == 1:
                    # ./output/PLSQL3.g:1144:57: 'OF'
                    pass
                    string_literal1212 = self.match(self.input, 125, self.FOLLOW_125_in_condition_submultiset7205)
                    if self._state.backtracking == 0:
                        string_literal1212_tree = self._adaptor.createWithPayload(string_literal1212)
                        self._adaptor.addChild(root_0, string_literal1212_tree)






                self._state.following.append(self.FOLLOW_nested_table_column_name_in_condition_submultiset7210)
                nested_table_column_name1213 = self.nested_table_column_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, nested_table_column_name1213.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 216, condition_submultiset_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_submultiset"


    class condition_equals_path_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_equals_path_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_equals_path"
    # ./output/PLSQL3.g:1146:1: condition_equals_path : keyEQUALS_PATH LPAREN column_name COMMA path_string ( COMMA correlation_integer )? RPAREN ;
    def condition_equals_path(self, ):
        retval = self.condition_equals_path_return()
        retval.start = self.input.LT(1)

        condition_equals_path_StartIndex = self.input.index()

        root_0 = None

        LPAREN1215 = None
        COMMA1217 = None
        COMMA1219 = None
        RPAREN1221 = None
        keyEQUALS_PATH1214 = None

        column_name1216 = None

        path_string1218 = None

        correlation_integer1220 = None


        LPAREN1215_tree = None
        COMMA1217_tree = None
        COMMA1219_tree = None
        RPAREN1221_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 217):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1147:2: ( keyEQUALS_PATH LPAREN column_name COMMA path_string ( COMMA correlation_integer )? RPAREN )
                # ./output/PLSQL3.g:1147:4: keyEQUALS_PATH LPAREN column_name COMMA path_string ( COMMA correlation_integer )? RPAREN
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyEQUALS_PATH_in_condition_equals_path7220)
                keyEQUALS_PATH1214 = self.keyEQUALS_PATH()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyEQUALS_PATH1214.tree)


                LPAREN1215 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_equals_path7222)
                if self._state.backtracking == 0:
                    LPAREN1215_tree = self._adaptor.createWithPayload(LPAREN1215)
                    self._adaptor.addChild(root_0, LPAREN1215_tree)



                self._state.following.append(self.FOLLOW_column_name_in_condition_equals_path7224)
                column_name1216 = self.column_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, column_name1216.tree)


                COMMA1217 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_condition_equals_path7226)
                if self._state.backtracking == 0:
                    COMMA1217_tree = self._adaptor.createWithPayload(COMMA1217)
                    self._adaptor.addChild(root_0, COMMA1217_tree)



                self._state.following.append(self.FOLLOW_path_string_in_condition_equals_path7228)
                path_string1218 = self.path_string()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, path_string1218.tree)


                # ./output/PLSQL3.g:1147:56: ( COMMA correlation_integer )?
                alt317 = 2
                LA317_0 = self.input.LA(1)

                if (LA317_0 == COMMA) :
                    alt317 = 1
                if alt317 == 1:
                    # ./output/PLSQL3.g:1147:58: COMMA correlation_integer
                    pass
                    COMMA1219 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_condition_equals_path7232)
                    if self._state.backtracking == 0:
                        COMMA1219_tree = self._adaptor.createWithPayload(COMMA1219)
                        self._adaptor.addChild(root_0, COMMA1219_tree)



                    self._state.following.append(self.FOLLOW_correlation_integer_in_condition_equals_path7234)
                    correlation_integer1220 = self.correlation_integer()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, correlation_integer1220.tree)





                RPAREN1221 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_equals_path7239)
                if self._state.backtracking == 0:
                    RPAREN1221_tree = self._adaptor.createWithPayload(RPAREN1221)
                    self._adaptor.addChild(root_0, RPAREN1221_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 217, condition_equals_path_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_equals_path"


    class condition_under_path_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.condition_under_path_return, self).__init__()

            self.tree = None





    # $ANTLR start "condition_under_path"
    # ./output/PLSQL3.g:1149:1: condition_under_path : keyUNDER_PATH LPAREN column_name ( COMMA levels )? COMMA path_string ( COMMA correlation_integer )? RPAREN ;
    def condition_under_path(self, ):
        retval = self.condition_under_path_return()
        retval.start = self.input.LT(1)

        condition_under_path_StartIndex = self.input.index()

        root_0 = None

        LPAREN1223 = None
        COMMA1225 = None
        COMMA1227 = None
        COMMA1229 = None
        RPAREN1231 = None
        keyUNDER_PATH1222 = None

        column_name1224 = None

        levels1226 = None

        path_string1228 = None

        correlation_integer1230 = None


        LPAREN1223_tree = None
        COMMA1225_tree = None
        COMMA1227_tree = None
        COMMA1229_tree = None
        RPAREN1231_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 218):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1150:2: ( keyUNDER_PATH LPAREN column_name ( COMMA levels )? COMMA path_string ( COMMA correlation_integer )? RPAREN )
                # ./output/PLSQL3.g:1150:4: keyUNDER_PATH LPAREN column_name ( COMMA levels )? COMMA path_string ( COMMA correlation_integer )? RPAREN
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyUNDER_PATH_in_condition_under_path7249)
                keyUNDER_PATH1222 = self.keyUNDER_PATH()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyUNDER_PATH1222.tree)


                LPAREN1223 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_under_path7251)
                if self._state.backtracking == 0:
                    LPAREN1223_tree = self._adaptor.createWithPayload(LPAREN1223)
                    self._adaptor.addChild(root_0, LPAREN1223_tree)



                self._state.following.append(self.FOLLOW_column_name_in_condition_under_path7253)
                column_name1224 = self.column_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, column_name1224.tree)


                # ./output/PLSQL3.g:1150:37: ( COMMA levels )?
                alt318 = 2
                LA318_0 = self.input.LA(1)

                if (LA318_0 == COMMA) :
                    LA318_1 = self.input.LA(2)

                    if (LA318_1 == NUMBER) :
                        alt318 = 1
                if alt318 == 1:
                    # ./output/PLSQL3.g:1150:39: COMMA levels
                    pass
                    COMMA1225 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_condition_under_path7257)
                    if self._state.backtracking == 0:
                        COMMA1225_tree = self._adaptor.createWithPayload(COMMA1225)
                        self._adaptor.addChild(root_0, COMMA1225_tree)



                    self._state.following.append(self.FOLLOW_levels_in_condition_under_path7259)
                    levels1226 = self.levels()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, levels1226.tree)





                COMMA1227 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_condition_under_path7264)
                if self._state.backtracking == 0:
                    COMMA1227_tree = self._adaptor.createWithPayload(COMMA1227)
                    self._adaptor.addChild(root_0, COMMA1227_tree)



                self._state.following.append(self.FOLLOW_path_string_in_condition_under_path7266)
                path_string1228 = self.path_string()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, path_string1228.tree)


                # ./output/PLSQL3.g:1150:73: ( COMMA correlation_integer )?
                alt319 = 2
                LA319_0 = self.input.LA(1)

                if (LA319_0 == COMMA) :
                    alt319 = 1
                if alt319 == 1:
                    # ./output/PLSQL3.g:1150:75: COMMA correlation_integer
                    pass
                    COMMA1229 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_condition_under_path7270)
                    if self._state.backtracking == 0:
                        COMMA1229_tree = self._adaptor.createWithPayload(COMMA1229)
                        self._adaptor.addChild(root_0, COMMA1229_tree)



                    self._state.following.append(self.FOLLOW_correlation_integer_in_condition_under_path7272)
                    correlation_integer1230 = self.correlation_integer()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, correlation_integer1230.tree)





                RPAREN1231 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_under_path7277)
                if self._state.backtracking == 0:
                    RPAREN1231_tree = self._adaptor.createWithPayload(RPAREN1231)
                    self._adaptor.addChild(root_0, RPAREN1231_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 218, condition_under_path_StartIndex, success)


            pass
        return retval

    # $ANTLR end "condition_under_path"


    class levels_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.levels_return, self).__init__()

            self.tree = None





    # $ANTLR start "levels"
    # ./output/PLSQL3.g:1152:1: levels : integer ;
    def levels(self, ):
        retval = self.levels_return()
        retval.start = self.input.LT(1)

        levels_StartIndex = self.input.index()

        root_0 = None

        integer1232 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 219):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1153:2: ( integer )
                # ./output/PLSQL3.g:1153:4: integer
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_integer_in_levels7287)
                integer1232 = self.integer()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, integer1232.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 219, levels_StartIndex, success)


            pass
        return retval

    # $ANTLR end "levels"


    class correlation_integer_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.correlation_integer_return, self).__init__()

            self.tree = None





    # $ANTLR start "correlation_integer"
    # ./output/PLSQL3.g:1155:1: correlation_integer : integer ;
    def correlation_integer(self, ):
        retval = self.correlation_integer_return()
        retval.start = self.input.LT(1)

        correlation_integer_StartIndex = self.input.index()

        root_0 = None

        integer1233 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 220):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1156:2: ( integer )
                # ./output/PLSQL3.g:1156:4: integer
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_integer_in_correlation_integer7297)
                integer1233 = self.integer()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, integer1233.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 220, correlation_integer_StartIndex, success)


            pass
        return retval

    # $ANTLR end "correlation_integer"


    class path_string_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.path_string_return, self).__init__()

            self.tree = None





    # $ANTLR start "path_string"
    # ./output/PLSQL3.g:1158:1: path_string : QUOTED_STRING ;
    def path_string(self, ):
        retval = self.path_string_return()
        retval.start = self.input.LT(1)

        path_string_StartIndex = self.input.index()

        root_0 = None

        QUOTED_STRING1234 = None

        QUOTED_STRING1234_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 221):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1159:2: ( QUOTED_STRING )
                # ./output/PLSQL3.g:1159:4: QUOTED_STRING
                pass
                root_0 = self._adaptor.nil()


                QUOTED_STRING1234 = self.match(self.input, QUOTED_STRING, self.FOLLOW_QUOTED_STRING_in_path_string7307)
                if self._state.backtracking == 0:
                    QUOTED_STRING1234_tree = self._adaptor.createWithPayload(QUOTED_STRING1234)
                    self._adaptor.addChild(root_0, QUOTED_STRING1234_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 221, path_string_StartIndex, success)


            pass
        return retval

    # $ANTLR end "path_string"


    class grouping_expression_list_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.grouping_expression_list_return, self).__init__()

            self.tree = None





    # $ANTLR start "grouping_expression_list"
    # ./output/PLSQL3.g:1161:1: grouping_expression_list : expression_list ( COMMA expression_list )* ;
    def grouping_expression_list(self, ):
        retval = self.grouping_expression_list_return()
        retval.start = self.input.LT(1)

        grouping_expression_list_StartIndex = self.input.index()

        root_0 = None

        COMMA1236 = None
        expression_list1235 = None

        expression_list1237 = None


        COMMA1236_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 222):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1162:2: ( expression_list ( COMMA expression_list )* )
                # ./output/PLSQL3.g:1162:4: expression_list ( COMMA expression_list )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_expression_list_in_grouping_expression_list7317)
                expression_list1235 = self.expression_list()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, expression_list1235.tree)


                # ./output/PLSQL3.g:1162:20: ( COMMA expression_list )*
                while True: #loop320
                    alt320 = 2
                    LA320_0 = self.input.LA(1)

                    if (LA320_0 == COMMA) :
                        LA320_1 = self.input.LA(2)

                        if (self.synpred517_PLSQL3()) :
                            alt320 = 1




                    if alt320 == 1:
                        # ./output/PLSQL3.g:1162:22: COMMA expression_list
                        pass
                        COMMA1236 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_grouping_expression_list7321)
                        if self._state.backtracking == 0:
                            COMMA1236_tree = self._adaptor.createWithPayload(COMMA1236)
                            self._adaptor.addChild(root_0, COMMA1236_tree)



                        self._state.following.append(self.FOLLOW_expression_list_in_grouping_expression_list7323)
                        expression_list1237 = self.expression_list()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, expression_list1237.tree)



                    else:
                        break #loop320




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 222, grouping_expression_list_StartIndex, success)


            pass
        return retval

    # $ANTLR end "grouping_expression_list"


    class expression_list_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.expression_list_return, self).__init__()

            self.tree = None





    # $ANTLR start "expression_list"
    # ./output/PLSQL3.g:1164:1: expression_list : ( LPAREN sql_expressions RPAREN | sql_expressions );
    def expression_list(self, ):
        retval = self.expression_list_return()
        retval.start = self.input.LT(1)

        expression_list_StartIndex = self.input.index()

        root_0 = None

        LPAREN1238 = None
        RPAREN1240 = None
        sql_expressions1239 = None

        sql_expressions1241 = None


        LPAREN1238_tree = None
        RPAREN1240_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 223):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1165:2: ( LPAREN sql_expressions RPAREN | sql_expressions )
                alt321 = 2
                LA321_0 = self.input.LA(1)

                if (LA321_0 == LPAREN) :
                    LA321_1 = self.input.LA(2)

                    if (self.synpred518_PLSQL3()) :
                        alt321 = 1
                    elif (True) :
                        alt321 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 321, 1, self.input)

                        raise nvae


                elif (LA321_0 == DOUBLEQUOTED_STRING or LA321_0 == ID or LA321_0 == MINUS or LA321_0 == NUMBER or LA321_0 == PLUS or LA321_0 == QUOTED_STRING or LA321_0 == 65 or LA321_0 == 81 or LA321_0 == 89 or LA321_0 == 120 or LA321_0 == 144 or LA321_0 == 147 or LA321_0 == 151 or LA321_0 == 156) :
                    alt321 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 321, 0, self.input)

                    raise nvae


                if alt321 == 1:
                    # ./output/PLSQL3.g:1165:4: LPAREN sql_expressions RPAREN
                    pass
                    root_0 = self._adaptor.nil()


                    LPAREN1238 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_expression_list7336)
                    if self._state.backtracking == 0:
                        LPAREN1238_tree = self._adaptor.createWithPayload(LPAREN1238)
                        self._adaptor.addChild(root_0, LPAREN1238_tree)



                    self._state.following.append(self.FOLLOW_sql_expressions_in_expression_list7338)
                    sql_expressions1239 = self.sql_expressions()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expressions1239.tree)


                    RPAREN1240 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_expression_list7340)
                    if self._state.backtracking == 0:
                        RPAREN1240_tree = self._adaptor.createWithPayload(RPAREN1240)
                        self._adaptor.addChild(root_0, RPAREN1240_tree)




                elif alt321 == 2:
                    # ./output/PLSQL3.g:1166:4: sql_expressions
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_sql_expressions_in_expression_list7345)
                    sql_expressions1241 = self.sql_expressions()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expressions1241.tree)



                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 223, expression_list_StartIndex, success)


            pass
        return retval

    # $ANTLR end "expression_list"


    class cell_reference_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.cell_reference_return, self).__init__()

            self.tree = None





    # $ANTLR start "cell_reference"
    # ./output/PLSQL3.g:1168:1: cell_reference : sql_identifier ;
    def cell_reference(self, ):
        retval = self.cell_reference_return()
        retval.start = self.input.LT(1)

        cell_reference_StartIndex = self.input.index()

        root_0 = None

        sql_identifier1242 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 224):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1169:2: ( sql_identifier )
                # ./output/PLSQL3.g:1169:4: sql_identifier
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_sql_identifier_in_cell_reference7355)
                sql_identifier1242 = self.sql_identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_identifier1242.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 224, cell_reference_StartIndex, success)


            pass
        return retval

    # $ANTLR end "cell_reference"


    class call_parameters_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.call_parameters_return, self).__init__()

            self.tree = None





    # $ANTLR start "call_parameters"
    # ./output/PLSQL3.g:1171:1: call_parameters : call_parameter ( COMMA call_parameter )* ;
    def call_parameters(self, ):
        retval = self.call_parameters_return()
        retval.start = self.input.LT(1)

        call_parameters_StartIndex = self.input.index()

        root_0 = None

        COMMA1244 = None
        call_parameter1243 = None

        call_parameter1245 = None


        COMMA1244_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 225):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1172:2: ( call_parameter ( COMMA call_parameter )* )
                # ./output/PLSQL3.g:1172:4: call_parameter ( COMMA call_parameter )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_call_parameter_in_call_parameters7365)
                call_parameter1243 = self.call_parameter()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, call_parameter1243.tree)


                # ./output/PLSQL3.g:1172:19: ( COMMA call_parameter )*
                while True: #loop322
                    alt322 = 2
                    LA322_0 = self.input.LA(1)

                    if (LA322_0 == COMMA) :
                        alt322 = 1


                    if alt322 == 1:
                        # ./output/PLSQL3.g:1172:21: COMMA call_parameter
                        pass
                        COMMA1244 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_call_parameters7369)
                        if self._state.backtracking == 0:
                            COMMA1244_tree = self._adaptor.createWithPayload(COMMA1244)
                            self._adaptor.addChild(root_0, COMMA1244_tree)



                        self._state.following.append(self.FOLLOW_call_parameter_in_call_parameters7371)
                        call_parameter1245 = self.call_parameter()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, call_parameter1245.tree)



                    else:
                        break #loop322




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 225, call_parameters_StartIndex, success)


            pass
        return retval

    # $ANTLR end "call_parameters"


    class call_parameter_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.call_parameter_return, self).__init__()

            self.tree = None





    # $ANTLR start "call_parameter"
    # ./output/PLSQL3.g:1174:1: call_parameter : ( parameter_name ARROW )? nested_expression ;
    def call_parameter(self, ):
        retval = self.call_parameter_return()
        retval.start = self.input.LT(1)

        call_parameter_StartIndex = self.input.index()

        root_0 = None

        ARROW1247 = None
        parameter_name1246 = None

        nested_expression1248 = None


        ARROW1247_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 226):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1175:2: ( ( parameter_name ARROW )? nested_expression )
                # ./output/PLSQL3.g:1175:4: ( parameter_name ARROW )? nested_expression
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:1175:4: ( parameter_name ARROW )?
                alt323 = 2
                LA323_0 = self.input.LA(1)

                if (LA323_0 == ID) :
                    LA323_1 = self.input.LA(2)

                    if (LA323_1 == ARROW) :
                        alt323 = 1
                elif (LA323_0 == DOUBLEQUOTED_STRING) :
                    LA323_3 = self.input.LA(2)

                    if (LA323_3 == ARROW) :
                        alt323 = 1
                if alt323 == 1:
                    # ./output/PLSQL3.g:1175:6: parameter_name ARROW
                    pass
                    self._state.following.append(self.FOLLOW_parameter_name_in_call_parameter7386)
                    parameter_name1246 = self.parameter_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, parameter_name1246.tree)


                    ARROW1247 = self.match(self.input, ARROW, self.FOLLOW_ARROW_in_call_parameter7388)
                    if self._state.backtracking == 0:
                        ARROW1247_tree = self._adaptor.createWithPayload(ARROW1247)
                        self._adaptor.addChild(root_0, ARROW1247_tree)






                self._state.following.append(self.FOLLOW_nested_expression_in_call_parameter7393)
                nested_expression1248 = self.nested_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, nested_expression1248.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 226, call_parameter_StartIndex, success)


            pass
        return retval

    # $ANTLR end "call_parameter"


    class relational_op_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.relational_op_return, self).__init__()

            self.tree = None





    # $ANTLR start "relational_op"
    # ./output/PLSQL3.g:1178:1: relational_op : ( EQ | LTH | GTH | NOT_EQ | LEQ | GEQ );
    def relational_op(self, ):
        retval = self.relational_op_return()
        retval.start = self.input.LT(1)

        relational_op_StartIndex = self.input.index()

        root_0 = None

        set1249 = None

        set1249_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 227):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1179:2: ( EQ | LTH | GTH | NOT_EQ | LEQ | GEQ )
                # ./output/PLSQL3.g:
                pass
                root_0 = self._adaptor.nil()


                set1249 = self.input.LT(1)

                if self.input.LA(1) == EQ or (GEQ <= self.input.LA(1) <= GTH) or self.input.LA(1) == LEQ or self.input.LA(1) == LTH or self.input.LA(1) == NOT_EQ:
                    self.input.consume()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set1249))

                    self._state.errorRecovery = False


                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    mse = MismatchedSetException(None, self.input)
                    raise mse





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 227, relational_op_StartIndex, success)


            pass
        return retval

    # $ANTLR end "relational_op"


    class exp_set_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.exp_set_return, self).__init__()

            self.tree = None





    # $ANTLR start "exp_set"
    # ./output/PLSQL3.g:1182:1: exp_set : ( ( sql_expression )=> sql_expression | subquery );
    def exp_set(self, ):
        retval = self.exp_set_return()
        retval.start = self.input.LT(1)

        exp_set_StartIndex = self.input.index()

        root_0 = None

        sql_expression1250 = None

        subquery1251 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 228):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1183:2: ( ( sql_expression )=> sql_expression | subquery )
                alt324 = 2
                LA324_0 = self.input.LA(1)

                if (LA324_0 == MINUS or LA324_0 == PLUS) and (self.synpred526_PLSQL3()):
                    alt324 = 1
                elif (LA324_0 == LPAREN) :
                    LA324_2 = self.input.LA(2)

                    if (self.synpred526_PLSQL3()) :
                        alt324 = 1
                    elif (True) :
                        alt324 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 324, 2, self.input)

                        raise nvae


                elif (LA324_0 == ID) and (self.synpred526_PLSQL3()):
                    alt324 = 1
                elif (LA324_0 == 144) and (self.synpred526_PLSQL3()):
                    alt324 = 1
                elif (LA324_0 == DOUBLEQUOTED_STRING) and (self.synpred526_PLSQL3()):
                    alt324 = 1
                elif (LA324_0 == 81) and (self.synpred526_PLSQL3()):
                    alt324 = 1
                elif (LA324_0 == 65) and (self.synpred526_PLSQL3()):
                    alt324 = 1
                elif (LA324_0 == 89 or LA324_0 == 156) and (self.synpred526_PLSQL3()):
                    alt324 = 1
                elif (LA324_0 == 151) and (self.synpred526_PLSQL3()):
                    alt324 = 1
                elif (LA324_0 == QUOTED_STRING) and (self.synpred526_PLSQL3()):
                    alt324 = 1
                elif (LA324_0 == NUMBER) and (self.synpred526_PLSQL3()):
                    alt324 = 1
                elif (LA324_0 == 120) and (self.synpred526_PLSQL3()):
                    alt324 = 1
                elif (LA324_0 == 147) and (self.synpred526_PLSQL3()):
                    alt324 = 1
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 324, 0, self.input)

                    raise nvae


                if alt324 == 1:
                    # ./output/PLSQL3.g:1183:4: ( sql_expression )=> sql_expression
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_sql_expression_in_exp_set7443)
                    sql_expression1250 = self.sql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expression1250.tree)



                elif alt324 == 2:
                    # ./output/PLSQL3.g:1184:4: subquery
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_subquery_in_exp_set7448)
                    subquery1251 = self.subquery()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, subquery1251.tree)



                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 228, exp_set_StartIndex, success)


            pass
        return retval

    # $ANTLR end "exp_set"


    class subquery_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.subquery_return, self).__init__()

            self.tree = None





    # $ANTLR start "subquery"
    # ./output/PLSQL3.g:1187:1: subquery : LPAREN select_command RPAREN ;
    def subquery(self, ):
        retval = self.subquery_return()
        retval.start = self.input.LT(1)

        subquery_StartIndex = self.input.index()

        root_0 = None

        LPAREN1252 = None
        RPAREN1254 = None
        select_command1253 = None


        LPAREN1252_tree = None
        RPAREN1254_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 229):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1188:2: ( LPAREN select_command RPAREN )
                # ./output/PLSQL3.g:1188:4: LPAREN select_command RPAREN
                pass
                root_0 = self._adaptor.nil()


                LPAREN1252 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_subquery7459)
                if self._state.backtracking == 0:
                    LPAREN1252_tree = self._adaptor.createWithPayload(LPAREN1252)
                    self._adaptor.addChild(root_0, LPAREN1252_tree)



                self._state.following.append(self.FOLLOW_select_command_in_subquery7461)
                select_command1253 = self.select_command()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, select_command1253.tree)


                RPAREN1254 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_subquery7463)
                if self._state.backtracking == 0:
                    RPAREN1254_tree = self._adaptor.createWithPayload(RPAREN1254)
                    self._adaptor.addChild(root_0, RPAREN1254_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 229, subquery_StartIndex, success)


            pass
        return retval

    # $ANTLR end "subquery"


    class connect_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.connect_clause_return, self).__init__()

            self.tree = None





    # $ANTLR start "connect_clause"
    # ./output/PLSQL3.g:1191:1: connect_clause : ( 'START' 'WITH' sql_condition )? 'CONNECT' 'BY' ( 'PRIOR' sql_expression relational_op sql_expression | sql_expression relational_op sql_expression 'PRIOR' ) ( ( ( 'PRIOR' )? sql_condition )=> ( 'PRIOR' )? sql_condition | sql_expression relational_op ( 'PRIOR' )? sql_expression ( 'AND' sql_condition )? ) ( 'START' 'WITH' sql_condition )? ;
    def connect_clause(self, ):
        retval = self.connect_clause_return()
        retval.start = self.input.LT(1)

        connect_clause_StartIndex = self.input.index()

        root_0 = None

        string_literal1255 = None
        string_literal1256 = None
        string_literal1258 = None
        string_literal1259 = None
        string_literal1260 = None
        string_literal1267 = None
        string_literal1268 = None
        string_literal1272 = None
        string_literal1274 = None
        string_literal1276 = None
        string_literal1277 = None
        sql_condition1257 = None

        sql_expression1261 = None

        relational_op1262 = None

        sql_expression1263 = None

        sql_expression1264 = None

        relational_op1265 = None

        sql_expression1266 = None

        sql_condition1269 = None

        sql_expression1270 = None

        relational_op1271 = None

        sql_expression1273 = None

        sql_condition1275 = None

        sql_condition1278 = None


        string_literal1255_tree = None
        string_literal1256_tree = None
        string_literal1258_tree = None
        string_literal1259_tree = None
        string_literal1260_tree = None
        string_literal1267_tree = None
        string_literal1268_tree = None
        string_literal1272_tree = None
        string_literal1274_tree = None
        string_literal1276_tree = None
        string_literal1277_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 230):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1192:2: ( ( 'START' 'WITH' sql_condition )? 'CONNECT' 'BY' ( 'PRIOR' sql_expression relational_op sql_expression | sql_expression relational_op sql_expression 'PRIOR' ) ( ( ( 'PRIOR' )? sql_condition )=> ( 'PRIOR' )? sql_condition | sql_expression relational_op ( 'PRIOR' )? sql_expression ( 'AND' sql_condition )? ) ( 'START' 'WITH' sql_condition )? )
                # ./output/PLSQL3.g:1192:4: ( 'START' 'WITH' sql_condition )? 'CONNECT' 'BY' ( 'PRIOR' sql_expression relational_op sql_expression | sql_expression relational_op sql_expression 'PRIOR' ) ( ( ( 'PRIOR' )? sql_condition )=> ( 'PRIOR' )? sql_condition | sql_expression relational_op ( 'PRIOR' )? sql_expression ( 'AND' sql_condition )? ) ( 'START' 'WITH' sql_condition )?
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:1192:4: ( 'START' 'WITH' sql_condition )?
                alt325 = 2
                LA325_0 = self.input.LA(1)

                if (LA325_0 == 152) :
                    alt325 = 1
                if alt325 == 1:
                    # ./output/PLSQL3.g:1192:6: 'START' 'WITH' sql_condition
                    pass
                    string_literal1255 = self.match(self.input, 152, self.FOLLOW_152_in_connect_clause7476)
                    if self._state.backtracking == 0:
                        string_literal1255_tree = self._adaptor.createWithPayload(string_literal1255)
                        self._adaptor.addChild(root_0, string_literal1255_tree)



                    string_literal1256 = self.match(self.input, 167, self.FOLLOW_167_in_connect_clause7478)
                    if self._state.backtracking == 0:
                        string_literal1256_tree = self._adaptor.createWithPayload(string_literal1256)
                        self._adaptor.addChild(root_0, string_literal1256_tree)



                    self._state.following.append(self.FOLLOW_sql_condition_in_connect_clause7480)
                    sql_condition1257 = self.sql_condition()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_condition1257.tree)





                string_literal1258 = self.match(self.input, 71, self.FOLLOW_71_in_connect_clause7487)
                if self._state.backtracking == 0:
                    string_literal1258_tree = self._adaptor.createWithPayload(string_literal1258)
                    self._adaptor.addChild(root_0, string_literal1258_tree)



                string_literal1259 = self.match(self.input, 64, self.FOLLOW_64_in_connect_clause7489)
                if self._state.backtracking == 0:
                    string_literal1259_tree = self._adaptor.createWithPayload(string_literal1259)
                    self._adaptor.addChild(root_0, string_literal1259_tree)



                # ./output/PLSQL3.g:1194:3: ( 'PRIOR' sql_expression relational_op sql_expression | sql_expression relational_op sql_expression 'PRIOR' )
                alt326 = 2
                LA326_0 = self.input.LA(1)

                if (LA326_0 == 134) :
                    alt326 = 1
                elif (LA326_0 == DOUBLEQUOTED_STRING or LA326_0 == ID or LA326_0 == LPAREN or LA326_0 == MINUS or LA326_0 == NUMBER or LA326_0 == PLUS or LA326_0 == QUOTED_STRING or LA326_0 == 65 or LA326_0 == 81 or LA326_0 == 89 or LA326_0 == 120 or LA326_0 == 144 or LA326_0 == 147 or LA326_0 == 151 or LA326_0 == 156) :
                    alt326 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 326, 0, self.input)

                    raise nvae


                if alt326 == 1:
                    # ./output/PLSQL3.g:1194:5: 'PRIOR' sql_expression relational_op sql_expression
                    pass
                    string_literal1260 = self.match(self.input, 134, self.FOLLOW_134_in_connect_clause7496)
                    if self._state.backtracking == 0:
                        string_literal1260_tree = self._adaptor.createWithPayload(string_literal1260)
                        self._adaptor.addChild(root_0, string_literal1260_tree)



                    self._state.following.append(self.FOLLOW_sql_expression_in_connect_clause7498)
                    sql_expression1261 = self.sql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expression1261.tree)


                    self._state.following.append(self.FOLLOW_relational_op_in_connect_clause7500)
                    relational_op1262 = self.relational_op()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, relational_op1262.tree)


                    self._state.following.append(self.FOLLOW_sql_expression_in_connect_clause7502)
                    sql_expression1263 = self.sql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expression1263.tree)



                elif alt326 == 2:
                    # ./output/PLSQL3.g:1195:5: sql_expression relational_op sql_expression 'PRIOR'
                    pass
                    self._state.following.append(self.FOLLOW_sql_expression_in_connect_clause7508)
                    sql_expression1264 = self.sql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expression1264.tree)


                    self._state.following.append(self.FOLLOW_relational_op_in_connect_clause7510)
                    relational_op1265 = self.relational_op()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, relational_op1265.tree)


                    self._state.following.append(self.FOLLOW_sql_expression_in_connect_clause7512)
                    sql_expression1266 = self.sql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expression1266.tree)


                    string_literal1267 = self.match(self.input, 134, self.FOLLOW_134_in_connect_clause7514)
                    if self._state.backtracking == 0:
                        string_literal1267_tree = self._adaptor.createWithPayload(string_literal1267)
                        self._adaptor.addChild(root_0, string_literal1267_tree)






                # ./output/PLSQL3.g:1197:3: ( ( ( 'PRIOR' )? sql_condition )=> ( 'PRIOR' )? sql_condition | sql_expression relational_op ( 'PRIOR' )? sql_expression ( 'AND' sql_condition )? )
                alt330 = 2
                LA330_0 = self.input.LA(1)

                if (LA330_0 == 134) and (self.synpred530_PLSQL3()):
                    alt330 = 1
                elif (LA330_0 == 118) and (self.synpred530_PLSQL3()):
                    alt330 = 1
                elif (LA330_0 == 88) and (self.synpred530_PLSQL3()):
                    alt330 = 1
                elif (LA330_0 == MINUS or LA330_0 == PLUS) :
                    LA330_4 = self.input.LA(2)

                    if (self.synpred530_PLSQL3()) :
                        alt330 = 1
                    elif (True) :
                        alt330 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 330, 4, self.input)

                        raise nvae


                elif (LA330_0 == LPAREN) :
                    LA330_5 = self.input.LA(2)

                    if (self.synpred530_PLSQL3()) :
                        alt330 = 1
                    elif (True) :
                        alt330 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 330, 5, self.input)

                        raise nvae


                elif (LA330_0 == ID) :
                    LA330_6 = self.input.LA(2)

                    if (self.synpred530_PLSQL3()) :
                        alt330 = 1
                    elif (True) :
                        alt330 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 330, 6, self.input)

                        raise nvae


                elif (LA330_0 == 144) :
                    LA330_7 = self.input.LA(2)

                    if (self.synpred530_PLSQL3()) :
                        alt330 = 1
                    elif (True) :
                        alt330 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 330, 7, self.input)

                        raise nvae


                elif (LA330_0 == DOUBLEQUOTED_STRING) :
                    LA330_8 = self.input.LA(2)

                    if (self.synpred530_PLSQL3()) :
                        alt330 = 1
                    elif (True) :
                        alt330 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 330, 8, self.input)

                        raise nvae


                elif (LA330_0 == 81) :
                    LA330_9 = self.input.LA(2)

                    if ((((((is_sql )) and ((is_sql )))) and (self.synpred530_PLSQL3()))) :
                        alt330 = 1
                    elif ((is_sql )) :
                        alt330 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 330, 9, self.input)

                        raise nvae


                elif (LA330_0 == 65) :
                    LA330_10 = self.input.LA(2)

                    if (self.synpred530_PLSQL3()) :
                        alt330 = 1
                    elif (True) :
                        alt330 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 330, 10, self.input)

                        raise nvae


                elif (LA330_0 == 89 or LA330_0 == 156) :
                    LA330_11 = self.input.LA(2)

                    if (self.synpred530_PLSQL3()) :
                        alt330 = 1
                    elif (True) :
                        alt330 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 330, 11, self.input)

                        raise nvae


                elif (LA330_0 == 151) :
                    LA330_12 = self.input.LA(2)

                    if (self.synpred530_PLSQL3()) :
                        alt330 = 1
                    elif (True) :
                        alt330 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 330, 12, self.input)

                        raise nvae


                elif (LA330_0 == QUOTED_STRING) :
                    LA330_13 = self.input.LA(2)

                    if (self.synpred530_PLSQL3()) :
                        alt330 = 1
                    elif (True) :
                        alt330 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 330, 13, self.input)

                        raise nvae


                elif (LA330_0 == NUMBER) :
                    LA330_14 = self.input.LA(2)

                    if (self.synpred530_PLSQL3()) :
                        alt330 = 1
                    elif (True) :
                        alt330 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 330, 14, self.input)

                        raise nvae


                elif (LA330_0 == 120) :
                    LA330_15 = self.input.LA(2)

                    if (self.synpred530_PLSQL3()) :
                        alt330 = 1
                    elif (True) :
                        alt330 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 330, 15, self.input)

                        raise nvae


                elif (LA330_0 == 147) :
                    LA330_16 = self.input.LA(2)

                    if (self.synpred530_PLSQL3()) :
                        alt330 = 1
                    elif (True) :
                        alt330 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 330, 16, self.input)

                        raise nvae


                elif (LA330_0 == 52) and (self.synpred530_PLSQL3()):
                    alt330 = 1
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 330, 0, self.input)

                    raise nvae


                if alt330 == 1:
                    # ./output/PLSQL3.g:1197:5: ( ( 'PRIOR' )? sql_condition )=> ( 'PRIOR' )? sql_condition
                    pass
                    # ./output/PLSQL3.g:1197:39: ( 'PRIOR' )?
                    alt327 = 2
                    LA327_0 = self.input.LA(1)

                    if (LA327_0 == 134) :
                        LA327_1 = self.input.LA(2)

                        if (self.synpred531_PLSQL3()) :
                            alt327 = 1
                    if alt327 == 1:
                        # ./output/PLSQL3.g:1197:40: 'PRIOR'
                        pass
                        string_literal1268 = self.match(self.input, 134, self.FOLLOW_134_in_connect_clause7540)
                        if self._state.backtracking == 0:
                            string_literal1268_tree = self._adaptor.createWithPayload(string_literal1268)
                            self._adaptor.addChild(root_0, string_literal1268_tree)






                    self._state.following.append(self.FOLLOW_sql_condition_in_connect_clause7544)
                    sql_condition1269 = self.sql_condition()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_condition1269.tree)



                elif alt330 == 2:
                    # ./output/PLSQL3.g:1198:5: sql_expression relational_op ( 'PRIOR' )? sql_expression ( 'AND' sql_condition )?
                    pass
                    self._state.following.append(self.FOLLOW_sql_expression_in_connect_clause7550)
                    sql_expression1270 = self.sql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expression1270.tree)


                    self._state.following.append(self.FOLLOW_relational_op_in_connect_clause7552)
                    relational_op1271 = self.relational_op()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, relational_op1271.tree)


                    # ./output/PLSQL3.g:1198:34: ( 'PRIOR' )?
                    alt328 = 2
                    LA328_0 = self.input.LA(1)

                    if (LA328_0 == 134) :
                        alt328 = 1
                    if alt328 == 1:
                        # ./output/PLSQL3.g:1198:36: 'PRIOR'
                        pass
                        string_literal1272 = self.match(self.input, 134, self.FOLLOW_134_in_connect_clause7556)
                        if self._state.backtracking == 0:
                            string_literal1272_tree = self._adaptor.createWithPayload(string_literal1272)
                            self._adaptor.addChild(root_0, string_literal1272_tree)






                    self._state.following.append(self.FOLLOW_sql_expression_in_connect_clause7561)
                    sql_expression1273 = self.sql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expression1273.tree)


                    # ./output/PLSQL3.g:1198:62: ( 'AND' sql_condition )?
                    alt329 = 2
                    LA329_0 = self.input.LA(1)

                    if (LA329_0 == 51) :
                        alt329 = 1
                    if alt329 == 1:
                        # ./output/PLSQL3.g:1198:64: 'AND' sql_condition
                        pass
                        string_literal1274 = self.match(self.input, 51, self.FOLLOW_51_in_connect_clause7565)
                        if self._state.backtracking == 0:
                            string_literal1274_tree = self._adaptor.createWithPayload(string_literal1274)
                            self._adaptor.addChild(root_0, string_literal1274_tree)



                        self._state.following.append(self.FOLLOW_sql_condition_in_connect_clause7567)
                        sql_condition1275 = self.sql_condition()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, sql_condition1275.tree)








                # ./output/PLSQL3.g:1200:3: ( 'START' 'WITH' sql_condition )?
                alt331 = 2
                LA331_0 = self.input.LA(1)

                if (LA331_0 == 152) :
                    alt331 = 1
                if alt331 == 1:
                    # ./output/PLSQL3.g:1200:5: 'START' 'WITH' sql_condition
                    pass
                    string_literal1276 = self.match(self.input, 152, self.FOLLOW_152_in_connect_clause7580)
                    if self._state.backtracking == 0:
                        string_literal1276_tree = self._adaptor.createWithPayload(string_literal1276)
                        self._adaptor.addChild(root_0, string_literal1276_tree)



                    string_literal1277 = self.match(self.input, 167, self.FOLLOW_167_in_connect_clause7582)
                    if self._state.backtracking == 0:
                        string_literal1277_tree = self._adaptor.createWithPayload(string_literal1277)
                        self._adaptor.addChild(root_0, string_literal1277_tree)



                    self._state.following.append(self.FOLLOW_sql_condition_in_connect_clause7584)
                    sql_condition1278 = self.sql_condition()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_condition1278.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 230, connect_clause_StartIndex, success)


            pass
        return retval

    # $ANTLR end "connect_clause"


    class group_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.group_clause_return, self).__init__()

            self.tree = None





    # $ANTLR start "group_clause"
    # ./output/PLSQL3.g:1203:1: group_clause : 'GROUP' 'BY' sql_expression ( COMMA sql_expression )* ( 'HAVING' sql_condition )? ;
    def group_clause(self, ):
        retval = self.group_clause_return()
        retval.start = self.input.LT(1)

        group_clause_StartIndex = self.input.index()

        root_0 = None

        string_literal1279 = None
        string_literal1280 = None
        COMMA1282 = None
        string_literal1284 = None
        sql_expression1281 = None

        sql_expression1283 = None

        sql_condition1285 = None


        string_literal1279_tree = None
        string_literal1280_tree = None
        COMMA1282_tree = None
        string_literal1284_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 231):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1204:2: ( 'GROUP' 'BY' sql_expression ( COMMA sql_expression )* ( 'HAVING' sql_condition )? )
                # ./output/PLSQL3.g:1204:4: 'GROUP' 'BY' sql_expression ( COMMA sql_expression )* ( 'HAVING' sql_condition )?
                pass
                root_0 = self._adaptor.nil()


                string_literal1279 = self.match(self.input, 96, self.FOLLOW_96_in_group_clause7598)
                if self._state.backtracking == 0:
                    string_literal1279_tree = self._adaptor.createWithPayload(string_literal1279)
                    self._adaptor.addChild(root_0, string_literal1279_tree)



                string_literal1280 = self.match(self.input, 64, self.FOLLOW_64_in_group_clause7600)
                if self._state.backtracking == 0:
                    string_literal1280_tree = self._adaptor.createWithPayload(string_literal1280)
                    self._adaptor.addChild(root_0, string_literal1280_tree)



                self._state.following.append(self.FOLLOW_sql_expression_in_group_clause7602)
                sql_expression1281 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression1281.tree)


                # ./output/PLSQL3.g:1204:32: ( COMMA sql_expression )*
                while True: #loop332
                    alt332 = 2
                    LA332_0 = self.input.LA(1)

                    if (LA332_0 == COMMA) :
                        alt332 = 1


                    if alt332 == 1:
                        # ./output/PLSQL3.g:1204:34: COMMA sql_expression
                        pass
                        COMMA1282 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_group_clause7606)
                        if self._state.backtracking == 0:
                            COMMA1282_tree = self._adaptor.createWithPayload(COMMA1282)
                            self._adaptor.addChild(root_0, COMMA1282_tree)



                        self._state.following.append(self.FOLLOW_sql_expression_in_group_clause7608)
                        sql_expression1283 = self.sql_expression()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, sql_expression1283.tree)



                    else:
                        break #loop332


                # ./output/PLSQL3.g:1204:58: ( 'HAVING' sql_condition )?
                alt333 = 2
                LA333_0 = self.input.LA(1)

                if (LA333_0 == 97) :
                    alt333 = 1
                if alt333 == 1:
                    # ./output/PLSQL3.g:1204:60: 'HAVING' sql_condition
                    pass
                    string_literal1284 = self.match(self.input, 97, self.FOLLOW_97_in_group_clause7615)
                    if self._state.backtracking == 0:
                        string_literal1284_tree = self._adaptor.createWithPayload(string_literal1284)
                        self._adaptor.addChild(root_0, string_literal1284_tree)



                    self._state.following.append(self.FOLLOW_sql_condition_in_group_clause7617)
                    sql_condition1285 = self.sql_condition()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_condition1285.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 231, group_clause_StartIndex, success)


            pass
        return retval

    # $ANTLR end "group_clause"


    class set_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.set_clause_return, self).__init__()

            self.tree = None





    # $ANTLR start "set_clause"
    # ./output/PLSQL3.g:1207:1: set_clause : ( ( 'UNION' 'ALL' ) | 'INTERSECT' | 'MINUS' ) select_command ;
    def set_clause(self, ):
        retval = self.set_clause_return()
        retval.start = self.input.LT(1)

        set_clause_StartIndex = self.input.index()

        root_0 = None

        string_literal1286 = None
        string_literal1287 = None
        string_literal1288 = None
        string_literal1289 = None
        select_command1290 = None


        string_literal1286_tree = None
        string_literal1287_tree = None
        string_literal1288_tree = None
        string_literal1289_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 232):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1208:2: ( ( ( 'UNION' 'ALL' ) | 'INTERSECT' | 'MINUS' ) select_command )
                # ./output/PLSQL3.g:1208:4: ( ( 'UNION' 'ALL' ) | 'INTERSECT' | 'MINUS' ) select_command
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:1208:4: ( ( 'UNION' 'ALL' ) | 'INTERSECT' | 'MINUS' )
                alt334 = 3
                LA334 = self.input.LA(1)
                if LA334 == 157:
                    alt334 = 1
                elif LA334 == 104:
                    alt334 = 2
                elif LA334 == 111:
                    alt334 = 3
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 334, 0, self.input)

                    raise nvae


                if alt334 == 1:
                    # ./output/PLSQL3.g:1208:6: ( 'UNION' 'ALL' )
                    pass
                    # ./output/PLSQL3.g:1208:6: ( 'UNION' 'ALL' )
                    # ./output/PLSQL3.g:1208:8: 'UNION' 'ALL'
                    pass
                    string_literal1286 = self.match(self.input, 157, self.FOLLOW_157_in_set_clause7635)
                    if self._state.backtracking == 0:
                        string_literal1286_tree = self._adaptor.createWithPayload(string_literal1286)
                        self._adaptor.addChild(root_0, string_literal1286_tree)



                    string_literal1287 = self.match(self.input, 50, self.FOLLOW_50_in_set_clause7637)
                    if self._state.backtracking == 0:
                        string_literal1287_tree = self._adaptor.createWithPayload(string_literal1287)
                        self._adaptor.addChild(root_0, string_literal1287_tree)







                elif alt334 == 2:
                    # ./output/PLSQL3.g:1208:26: 'INTERSECT'
                    pass
                    string_literal1288 = self.match(self.input, 104, self.FOLLOW_104_in_set_clause7643)
                    if self._state.backtracking == 0:
                        string_literal1288_tree = self._adaptor.createWithPayload(string_literal1288)
                        self._adaptor.addChild(root_0, string_literal1288_tree)




                elif alt334 == 3:
                    # ./output/PLSQL3.g:1208:40: 'MINUS'
                    pass
                    string_literal1289 = self.match(self.input, 111, self.FOLLOW_111_in_set_clause7647)
                    if self._state.backtracking == 0:
                        string_literal1289_tree = self._adaptor.createWithPayload(string_literal1289)
                        self._adaptor.addChild(root_0, string_literal1289_tree)






                self._state.following.append(self.FOLLOW_select_command_in_set_clause7651)
                select_command1290 = self.select_command()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, select_command1290.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 232, set_clause_StartIndex, success)


            pass
        return retval

    # $ANTLR end "set_clause"


    class order_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.order_clause_return, self).__init__()

            self.tree = None





    # $ANTLR start "order_clause"
    # ./output/PLSQL3.g:1211:1: order_clause : 'ORDER' 'BY' sorted_def ( COMMA sorted_def )* ;
    def order_clause(self, ):
        retval = self.order_clause_return()
        retval.start = self.input.LT(1)

        order_clause_StartIndex = self.input.index()

        root_0 = None

        string_literal1291 = None
        string_literal1292 = None
        COMMA1294 = None
        sorted_def1293 = None

        sorted_def1295 = None


        string_literal1291_tree = None
        string_literal1292_tree = None
        COMMA1294_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 233):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1212:2: ( 'ORDER' 'BY' sorted_def ( COMMA sorted_def )* )
                # ./output/PLSQL3.g:1212:4: 'ORDER' 'BY' sorted_def ( COMMA sorted_def )*
                pass
                root_0 = self._adaptor.nil()


                string_literal1291 = self.match(self.input, 128, self.FOLLOW_128_in_order_clause7663)
                if self._state.backtracking == 0:
                    string_literal1291_tree = self._adaptor.createWithPayload(string_literal1291)
                    self._adaptor.addChild(root_0, string_literal1291_tree)



                string_literal1292 = self.match(self.input, 64, self.FOLLOW_64_in_order_clause7665)
                if self._state.backtracking == 0:
                    string_literal1292_tree = self._adaptor.createWithPayload(string_literal1292)
                    self._adaptor.addChild(root_0, string_literal1292_tree)



                self._state.following.append(self.FOLLOW_sorted_def_in_order_clause7667)
                sorted_def1293 = self.sorted_def()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sorted_def1293.tree)


                # ./output/PLSQL3.g:1212:28: ( COMMA sorted_def )*
                while True: #loop335
                    alt335 = 2
                    LA335_0 = self.input.LA(1)

                    if (LA335_0 == COMMA) :
                        alt335 = 1


                    if alt335 == 1:
                        # ./output/PLSQL3.g:1212:30: COMMA sorted_def
                        pass
                        COMMA1294 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_order_clause7671)
                        if self._state.backtracking == 0:
                            COMMA1294_tree = self._adaptor.createWithPayload(COMMA1294)
                            self._adaptor.addChild(root_0, COMMA1294_tree)



                        self._state.following.append(self.FOLLOW_sorted_def_in_order_clause7673)
                        sorted_def1295 = self.sorted_def()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, sorted_def1295.tree)



                    else:
                        break #loop335




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 233, order_clause_StartIndex, success)


            pass
        return retval

    # $ANTLR end "order_clause"


    class sorted_def_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.sorted_def_return, self).__init__()

            self.tree = None





    # $ANTLR start "sorted_def"
    # ./output/PLSQL3.g:1215:1: sorted_def : ( ( sql_expression )=> sql_expression | ( NUMBER )=> NUMBER ) ( 'ASC' | 'DESC' )? ;
    def sorted_def(self, ):
        retval = self.sorted_def_return()
        retval.start = self.input.LT(1)

        sorted_def_StartIndex = self.input.index()

        root_0 = None

        NUMBER1297 = None
        set1298 = None
        sql_expression1296 = None


        NUMBER1297_tree = None
        set1298_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 234):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1216:2: ( ( ( sql_expression )=> sql_expression | ( NUMBER )=> NUMBER ) ( 'ASC' | 'DESC' )? )
                # ./output/PLSQL3.g:1216:4: ( ( sql_expression )=> sql_expression | ( NUMBER )=> NUMBER ) ( 'ASC' | 'DESC' )?
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:1216:4: ( ( sql_expression )=> sql_expression | ( NUMBER )=> NUMBER )
                alt336 = 2
                LA336_0 = self.input.LA(1)

                if (LA336_0 == MINUS or LA336_0 == PLUS) and (self.synpred540_PLSQL3()):
                    alt336 = 1
                elif (LA336_0 == LPAREN) and (self.synpred540_PLSQL3()):
                    alt336 = 1
                elif (LA336_0 == ID) and (self.synpred540_PLSQL3()):
                    alt336 = 1
                elif (LA336_0 == 144) and (self.synpred540_PLSQL3()):
                    alt336 = 1
                elif (LA336_0 == DOUBLEQUOTED_STRING) and (self.synpred540_PLSQL3()):
                    alt336 = 1
                elif (LA336_0 == 81) and (self.synpred540_PLSQL3()):
                    alt336 = 1
                elif (LA336_0 == 65) and (self.synpred540_PLSQL3()):
                    alt336 = 1
                elif (LA336_0 == 89 or LA336_0 == 156) and (self.synpred540_PLSQL3()):
                    alt336 = 1
                elif (LA336_0 == 151) and (self.synpred540_PLSQL3()):
                    alt336 = 1
                elif (LA336_0 == QUOTED_STRING) and (self.synpred540_PLSQL3()):
                    alt336 = 1
                elif (LA336_0 == NUMBER) :
                    LA336_11 = self.input.LA(2)

                    if (self.synpred540_PLSQL3()) :
                        alt336 = 1
                    elif (self.synpred541_PLSQL3()) :
                        alt336 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 336, 11, self.input)

                        raise nvae


                elif (LA336_0 == 120) and (self.synpred540_PLSQL3()):
                    alt336 = 1
                elif (LA336_0 == 147) and (self.synpred540_PLSQL3()):
                    alt336 = 1
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 336, 0, self.input)

                    raise nvae


                if alt336 == 1:
                    # ./output/PLSQL3.g:1216:6: ( sql_expression )=> sql_expression
                    pass
                    self._state.following.append(self.FOLLOW_sql_expression_in_sorted_def7697)
                    sql_expression1296 = self.sql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expression1296.tree)



                elif alt336 == 2:
                    # ./output/PLSQL3.g:1216:45: ( NUMBER )=> NUMBER
                    pass
                    NUMBER1297 = self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_sorted_def7709)
                    if self._state.backtracking == 0:
                        NUMBER1297_tree = self._adaptor.createWithPayload(NUMBER1297)
                        self._adaptor.addChild(root_0, NUMBER1297_tree)






                # ./output/PLSQL3.g:1216:68: ( 'ASC' | 'DESC' )?
                alt337 = 2
                LA337_0 = self.input.LA(1)

                if (LA337_0 == 54 or LA337_0 == 80) :
                    alt337 = 1
                if alt337 == 1:
                    # ./output/PLSQL3.g:
                    pass
                    set1298 = self.input.LT(1)

                    if self.input.LA(1) == 54 or self.input.LA(1) == 80:
                        self.input.consume()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set1298))

                        self._state.errorRecovery = False


                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        mse = MismatchedSetException(None, self.input)
                        raise mse








                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 234, sorted_def_StartIndex, success)


            pass
        return retval

    # $ANTLR end "sorted_def"


    class update_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.update_clause_return, self).__init__()

            self.tree = None





    # $ANTLR start "update_clause"
    # ./output/PLSQL3.g:1219:1: update_clause : 'FOR' 'UPDATE' ( 'OF' column_name ( COMMA column_name )* )? ( 'NOWAIT' )? ;
    def update_clause(self, ):
        retval = self.update_clause_return()
        retval.start = self.input.LT(1)

        update_clause_StartIndex = self.input.index()

        root_0 = None

        string_literal1299 = None
        string_literal1300 = None
        string_literal1301 = None
        COMMA1303 = None
        string_literal1305 = None
        column_name1302 = None

        column_name1304 = None


        string_literal1299_tree = None
        string_literal1300_tree = None
        string_literal1301_tree = None
        COMMA1303_tree = None
        string_literal1305_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 235):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1220:2: ( 'FOR' 'UPDATE' ( 'OF' column_name ( COMMA column_name )* )? ( 'NOWAIT' )? )
                # ./output/PLSQL3.g:1220:4: 'FOR' 'UPDATE' ( 'OF' column_name ( COMMA column_name )* )? ( 'NOWAIT' )?
                pass
                root_0 = self._adaptor.nil()


                string_literal1299 = self.match(self.input, 92, self.FOLLOW_92_in_update_clause7733)
                if self._state.backtracking == 0:
                    string_literal1299_tree = self._adaptor.createWithPayload(string_literal1299)
                    self._adaptor.addChild(root_0, string_literal1299_tree)



                string_literal1300 = self.match(self.input, 159, self.FOLLOW_159_in_update_clause7735)
                if self._state.backtracking == 0:
                    string_literal1300_tree = self._adaptor.createWithPayload(string_literal1300)
                    self._adaptor.addChild(root_0, string_literal1300_tree)



                # ./output/PLSQL3.g:1220:19: ( 'OF' column_name ( COMMA column_name )* )?
                alt339 = 2
                LA339_0 = self.input.LA(1)

                if (LA339_0 == 125) :
                    alt339 = 1
                if alt339 == 1:
                    # ./output/PLSQL3.g:1220:21: 'OF' column_name ( COMMA column_name )*
                    pass
                    string_literal1301 = self.match(self.input, 125, self.FOLLOW_125_in_update_clause7739)
                    if self._state.backtracking == 0:
                        string_literal1301_tree = self._adaptor.createWithPayload(string_literal1301)
                        self._adaptor.addChild(root_0, string_literal1301_tree)



                    self._state.following.append(self.FOLLOW_column_name_in_update_clause7741)
                    column_name1302 = self.column_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, column_name1302.tree)


                    # ./output/PLSQL3.g:1220:38: ( COMMA column_name )*
                    while True: #loop338
                        alt338 = 2
                        LA338_0 = self.input.LA(1)

                        if (LA338_0 == COMMA) :
                            alt338 = 1


                        if alt338 == 1:
                            # ./output/PLSQL3.g:1220:40: COMMA column_name
                            pass
                            COMMA1303 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_update_clause7745)
                            if self._state.backtracking == 0:
                                COMMA1303_tree = self._adaptor.createWithPayload(COMMA1303)
                                self._adaptor.addChild(root_0, COMMA1303_tree)



                            self._state.following.append(self.FOLLOW_column_name_in_update_clause7747)
                            column_name1304 = self.column_name()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, column_name1304.tree)



                        else:
                            break #loop338





                # ./output/PLSQL3.g:1220:64: ( 'NOWAIT' )?
                alt340 = 2
                LA340_0 = self.input.LA(1)

                if (LA340_0 == 119) :
                    alt340 = 1
                if alt340 == 1:
                    # ./output/PLSQL3.g:1220:66: 'NOWAIT'
                    pass
                    string_literal1305 = self.match(self.input, 119, self.FOLLOW_119_in_update_clause7757)
                    if self._state.backtracking == 0:
                        string_literal1305_tree = self._adaptor.createWithPayload(string_literal1305)
                        self._adaptor.addChild(root_0, string_literal1305_tree)








                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 235, update_clause_StartIndex, success)


            pass
        return retval

    # $ANTLR end "update_clause"


    class insert_command_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.insert_command_return, self).__init__()

            self.tree = None





    # $ANTLR start "insert_command"
    # ./output/PLSQL3.g:1223:1: insert_command : 'INSERT' 'INTO' table_reference_list ( LPAREN column_specs RPAREN )? ( 'VALUES' LPAREN plsql_expressions RPAREN | select_statement ) ( returning_clause )? ;
    def insert_command(self, ):
        retval = self.insert_command_return()
        retval.start = self.input.LT(1)

        insert_command_StartIndex = self.input.index()

        root_0 = None

        string_literal1306 = None
        string_literal1307 = None
        LPAREN1309 = None
        RPAREN1311 = None
        string_literal1312 = None
        LPAREN1313 = None
        RPAREN1315 = None
        table_reference_list1308 = None

        column_specs1310 = None

        plsql_expressions1314 = None

        select_statement1316 = None

        returning_clause1317 = None


        string_literal1306_tree = None
        string_literal1307_tree = None
        LPAREN1309_tree = None
        RPAREN1311_tree = None
        string_literal1312_tree = None
        LPAREN1313_tree = None
        RPAREN1315_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 236):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1224:2: ( 'INSERT' 'INTO' table_reference_list ( LPAREN column_specs RPAREN )? ( 'VALUES' LPAREN plsql_expressions RPAREN | select_statement ) ( returning_clause )? )
                # ./output/PLSQL3.g:1224:4: 'INSERT' 'INTO' table_reference_list ( LPAREN column_specs RPAREN )? ( 'VALUES' LPAREN plsql_expressions RPAREN | select_statement ) ( returning_clause )?
                pass
                root_0 = self._adaptor.nil()


                string_literal1306 = self.match(self.input, 101, self.FOLLOW_101_in_insert_command7771)
                if self._state.backtracking == 0:
                    string_literal1306_tree = self._adaptor.createWithPayload(string_literal1306)
                    self._adaptor.addChild(root_0, string_literal1306_tree)



                string_literal1307 = self.match(self.input, 105, self.FOLLOW_105_in_insert_command7773)
                if self._state.backtracking == 0:
                    string_literal1307_tree = self._adaptor.createWithPayload(string_literal1307)
                    self._adaptor.addChild(root_0, string_literal1307_tree)



                self._state.following.append(self.FOLLOW_table_reference_list_in_insert_command7775)
                table_reference_list1308 = self.table_reference_list()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, table_reference_list1308.tree)


                # ./output/PLSQL3.g:1225:3: ( LPAREN column_specs RPAREN )?
                alt341 = 2
                LA341_0 = self.input.LA(1)

                if (LA341_0 == LPAREN) :
                    alt341 = 1
                if alt341 == 1:
                    # ./output/PLSQL3.g:1225:5: LPAREN column_specs RPAREN
                    pass
                    LPAREN1309 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_insert_command7781)
                    if self._state.backtracking == 0:
                        LPAREN1309_tree = self._adaptor.createWithPayload(LPAREN1309)
                        self._adaptor.addChild(root_0, LPAREN1309_tree)



                    self._state.following.append(self.FOLLOW_column_specs_in_insert_command7783)
                    column_specs1310 = self.column_specs()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, column_specs1310.tree)


                    RPAREN1311 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_insert_command7785)
                    if self._state.backtracking == 0:
                        RPAREN1311_tree = self._adaptor.createWithPayload(RPAREN1311)
                        self._adaptor.addChild(root_0, RPAREN1311_tree)






                # ./output/PLSQL3.g:1226:3: ( 'VALUES' LPAREN plsql_expressions RPAREN | select_statement )
                alt342 = 2
                LA342_0 = self.input.LA(1)

                if (LA342_0 == 161) :
                    alt342 = 1
                elif (LA342_0 == 147) :
                    alt342 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 342, 0, self.input)

                    raise nvae


                if alt342 == 1:
                    # ./output/PLSQL3.g:1226:5: 'VALUES' LPAREN plsql_expressions RPAREN
                    pass
                    string_literal1312 = self.match(self.input, 161, self.FOLLOW_161_in_insert_command7794)
                    if self._state.backtracking == 0:
                        string_literal1312_tree = self._adaptor.createWithPayload(string_literal1312)
                        self._adaptor.addChild(root_0, string_literal1312_tree)



                    LPAREN1313 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_insert_command7796)
                    if self._state.backtracking == 0:
                        LPAREN1313_tree = self._adaptor.createWithPayload(LPAREN1313)
                        self._adaptor.addChild(root_0, LPAREN1313_tree)



                    self._state.following.append(self.FOLLOW_plsql_expressions_in_insert_command7798)
                    plsql_expressions1314 = self.plsql_expressions()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, plsql_expressions1314.tree)


                    RPAREN1315 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_insert_command7800)
                    if self._state.backtracking == 0:
                        RPAREN1315_tree = self._adaptor.createWithPayload(RPAREN1315)
                        self._adaptor.addChild(root_0, RPAREN1315_tree)




                elif alt342 == 2:
                    # ./output/PLSQL3.g:1227:5: select_statement
                    pass
                    self._state.following.append(self.FOLLOW_select_statement_in_insert_command7806)
                    select_statement1316 = self.select_statement()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, select_statement1316.tree)





                # ./output/PLSQL3.g:1229:3: ( returning_clause )?
                alt343 = 2
                LA343_0 = self.input.LA(1)

                if ((140 <= LA343_0 <= 141)) :
                    alt343 = 1
                if alt343 == 1:
                    # ./output/PLSQL3.g:1229:5: returning_clause
                    pass
                    self._state.following.append(self.FOLLOW_returning_clause_in_insert_command7816)
                    returning_clause1317 = self.returning_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, returning_clause1317.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 236, insert_command_StartIndex, success)


            pass
        return retval

    # $ANTLR end "insert_command"


    class update_command_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.update_command_return, self).__init__()

            self.tree = None





    # $ANTLR start "update_command"
    # ./output/PLSQL3.g:1232:1: update_command : 'UPDATE' selected_table 'SET' ( update_nested_column_specs | update_column_specs ) ( 'WHERE' ( keyCURRENT_OF cursor_name | sql_condition ) )? ( returning_clause )? ;
    def update_command(self, ):
        retval = self.update_command_return()
        retval.start = self.input.LT(1)

        update_command_StartIndex = self.input.index()

        root_0 = None

        string_literal1318 = None
        string_literal1320 = None
        string_literal1323 = None
        selected_table1319 = None

        update_nested_column_specs1321 = None

        update_column_specs1322 = None

        keyCURRENT_OF1324 = None

        cursor_name1325 = None

        sql_condition1326 = None

        returning_clause1327 = None


        string_literal1318_tree = None
        string_literal1320_tree = None
        string_literal1323_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 237):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1233:2: ( 'UPDATE' selected_table 'SET' ( update_nested_column_specs | update_column_specs ) ( 'WHERE' ( keyCURRENT_OF cursor_name | sql_condition ) )? ( returning_clause )? )
                # ./output/PLSQL3.g:1233:4: 'UPDATE' selected_table 'SET' ( update_nested_column_specs | update_column_specs ) ( 'WHERE' ( keyCURRENT_OF cursor_name | sql_condition ) )? ( returning_clause )?
                pass
                root_0 = self._adaptor.nil()


                string_literal1318 = self.match(self.input, 159, self.FOLLOW_159_in_update_command7830)
                if self._state.backtracking == 0:
                    string_literal1318_tree = self._adaptor.createWithPayload(string_literal1318)
                    self._adaptor.addChild(root_0, string_literal1318_tree)



                self._state.following.append(self.FOLLOW_selected_table_in_update_command7832)
                selected_table1319 = self.selected_table()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, selected_table1319.tree)


                string_literal1320 = self.match(self.input, 148, self.FOLLOW_148_in_update_command7836)
                if self._state.backtracking == 0:
                    string_literal1320_tree = self._adaptor.createWithPayload(string_literal1320)
                    self._adaptor.addChild(root_0, string_literal1320_tree)



                # ./output/PLSQL3.g:1235:3: ( update_nested_column_specs | update_column_specs )
                alt344 = 2
                LA344_0 = self.input.LA(1)

                if (LA344_0 == LPAREN) :
                    alt344 = 1
                elif (LA344_0 == DOUBLEQUOTED_STRING or LA344_0 == ID or LA344_0 == 144) :
                    alt344 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 344, 0, self.input)

                    raise nvae


                if alt344 == 1:
                    # ./output/PLSQL3.g:1235:5: update_nested_column_specs
                    pass
                    self._state.following.append(self.FOLLOW_update_nested_column_specs_in_update_command7843)
                    update_nested_column_specs1321 = self.update_nested_column_specs()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, update_nested_column_specs1321.tree)



                elif alt344 == 2:
                    # ./output/PLSQL3.g:1236:5: update_column_specs
                    pass
                    self._state.following.append(self.FOLLOW_update_column_specs_in_update_command7849)
                    update_column_specs1322 = self.update_column_specs()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, update_column_specs1322.tree)





                # ./output/PLSQL3.g:1238:3: ( 'WHERE' ( keyCURRENT_OF cursor_name | sql_condition ) )?
                alt346 = 2
                LA346_0 = self.input.LA(1)

                if (LA346_0 == 165) :
                    alt346 = 1
                if alt346 == 1:
                    # ./output/PLSQL3.g:1238:5: 'WHERE' ( keyCURRENT_OF cursor_name | sql_condition )
                    pass
                    string_literal1323 = self.match(self.input, 165, self.FOLLOW_165_in_update_command7859)
                    if self._state.backtracking == 0:
                        string_literal1323_tree = self._adaptor.createWithPayload(string_literal1323)
                        self._adaptor.addChild(root_0, string_literal1323_tree)



                    # ./output/PLSQL3.g:1239:4: ( keyCURRENT_OF cursor_name | sql_condition )
                    alt345 = 2
                    LA345_0 = self.input.LA(1)

                    if (LA345_0 == ID) :
                        LA345 = self.input.LA(2)
                        if LA345 == ID:
                            LA345_3 = self.input.LA(3)

                            if (LA345_3 == EOF or LA345_3 == SEMI or (140 <= LA345_3 <= 141)) :
                                alt345 = 1
                            elif (LA345_3 == DOUBLEQUOTED_STRING or LA345_3 == ID or LA345_3 == LPAREN or LA345_3 == MINUS or LA345_3 == NUMBER or LA345_3 == PLUS or LA345_3 == QUOTED_STRING or LA345_3 == 65 or LA345_3 == 81 or LA345_3 == 89 or LA345_3 == 120 or LA345_3 == 125 or LA345_3 == 144 or LA345_3 == 147 or LA345_3 == 151 or LA345_3 == 156) :
                                alt345 = 2
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 345, 3, self.input)

                                raise nvae


                        elif LA345 == ASTERISK or LA345 == DIVIDE or LA345 == DOT or LA345 == DOUBLEVERTBAR or LA345 == EQ or LA345 == EXPONENT or LA345 == GEQ or LA345 == GTH or LA345 == LEQ or LA345 == LPAREN or LA345 == LTH or LA345 == MINUS or LA345 == NOT_EQ or LA345 == PLUS or LA345 == 57 or LA345 == 99 or LA345 == 106 or LA345 == 107 or LA345 == 118:
                            alt345 = 2
                        elif LA345 == DOUBLEQUOTED_STRING:
                            alt345 = 1
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 345, 1, self.input)

                            raise nvae


                    elif (LA345_0 == DOUBLEQUOTED_STRING or LA345_0 == LPAREN or LA345_0 == MINUS or LA345_0 == NUMBER or LA345_0 == PLUS or LA345_0 == QUOTED_STRING or LA345_0 == 52 or LA345_0 == 65 or LA345_0 == 81 or (88 <= LA345_0 <= 89) or LA345_0 == 118 or LA345_0 == 120 or LA345_0 == 134 or LA345_0 == 144 or LA345_0 == 147 or LA345_0 == 151 or LA345_0 == 156) :
                        alt345 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 345, 0, self.input)

                        raise nvae


                    if alt345 == 1:
                        # ./output/PLSQL3.g:1239:6: keyCURRENT_OF cursor_name
                        pass
                        self._state.following.append(self.FOLLOW_keyCURRENT_OF_in_update_command7866)
                        keyCURRENT_OF1324 = self.keyCURRENT_OF()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyCURRENT_OF1324.tree)


                        self._state.following.append(self.FOLLOW_cursor_name_in_update_command7868)
                        cursor_name1325 = self.cursor_name()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, cursor_name1325.tree)



                    elif alt345 == 2:
                        # ./output/PLSQL3.g:1240:6: sql_condition
                        pass
                        self._state.following.append(self.FOLLOW_sql_condition_in_update_command7875)
                        sql_condition1326 = self.sql_condition()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, sql_condition1326.tree)








                # ./output/PLSQL3.g:1243:3: ( returning_clause )?
                alt347 = 2
                LA347_0 = self.input.LA(1)

                if ((140 <= LA347_0 <= 141)) :
                    alt347 = 1
                if alt347 == 1:
                    # ./output/PLSQL3.g:1243:5: returning_clause
                    pass
                    self._state.following.append(self.FOLLOW_returning_clause_in_update_command7891)
                    returning_clause1327 = self.returning_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, returning_clause1327.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 237, update_command_StartIndex, success)


            pass
        return retval

    # $ANTLR end "update_command"


    class update_column_specs_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.update_column_specs_return, self).__init__()

            self.tree = None





    # $ANTLR start "update_column_specs"
    # ./output/PLSQL3.g:1246:1: update_column_specs : update_column_spec ( COMMA update_column_spec )* ;
    def update_column_specs(self, ):
        retval = self.update_column_specs_return()
        retval.start = self.input.LT(1)

        update_column_specs_StartIndex = self.input.index()

        root_0 = None

        COMMA1329 = None
        update_column_spec1328 = None

        update_column_spec1330 = None


        COMMA1329_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 238):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1247:2: ( update_column_spec ( COMMA update_column_spec )* )
                # ./output/PLSQL3.g:1247:4: update_column_spec ( COMMA update_column_spec )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_update_column_spec_in_update_column_specs7905)
                update_column_spec1328 = self.update_column_spec()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, update_column_spec1328.tree)


                # ./output/PLSQL3.g:1247:23: ( COMMA update_column_spec )*
                while True: #loop348
                    alt348 = 2
                    LA348_0 = self.input.LA(1)

                    if (LA348_0 == COMMA) :
                        alt348 = 1


                    if alt348 == 1:
                        # ./output/PLSQL3.g:1247:25: COMMA update_column_spec
                        pass
                        COMMA1329 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_update_column_specs7909)
                        if self._state.backtracking == 0:
                            COMMA1329_tree = self._adaptor.createWithPayload(COMMA1329)
                            self._adaptor.addChild(root_0, COMMA1329_tree)



                        self._state.following.append(self.FOLLOW_update_column_spec_in_update_column_specs7911)
                        update_column_spec1330 = self.update_column_spec()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, update_column_spec1330.tree)



                    else:
                        break #loop348




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 238, update_column_specs_StartIndex, success)


            pass
        return retval

    # $ANTLR end "update_column_specs"


    class update_column_spec_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.update_column_spec_return, self).__init__()

            self.tree = None





    # $ANTLR start "update_column_spec"
    # ./output/PLSQL3.g:1250:1: update_column_spec : column_spec EQ sql_expression ;
    def update_column_spec(self, ):
        retval = self.update_column_spec_return()
        retval.start = self.input.LT(1)

        update_column_spec_StartIndex = self.input.index()

        root_0 = None

        EQ1332 = None
        column_spec1331 = None

        sql_expression1333 = None


        EQ1332_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 239):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1251:2: ( column_spec EQ sql_expression )
                # ./output/PLSQL3.g:1251:4: column_spec EQ sql_expression
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_column_spec_in_update_column_spec7925)
                column_spec1331 = self.column_spec()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, column_spec1331.tree)


                EQ1332 = self.match(self.input, EQ, self.FOLLOW_EQ_in_update_column_spec7927)
                if self._state.backtracking == 0:
                    EQ1332_tree = self._adaptor.createWithPayload(EQ1332)
                    self._adaptor.addChild(root_0, EQ1332_tree)



                self._state.following.append(self.FOLLOW_sql_expression_in_update_column_spec7929)
                sql_expression1333 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression1333.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 239, update_column_spec_StartIndex, success)


            pass
        return retval

    # $ANTLR end "update_column_spec"


    class update_nested_column_specs_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.update_nested_column_specs_return, self).__init__()

            self.tree = None





    # $ANTLR start "update_nested_column_specs"
    # ./output/PLSQL3.g:1254:1: update_nested_column_specs : update_nested_column_spec ( COMMA update_nested_column_spec )* ;
    def update_nested_column_specs(self, ):
        retval = self.update_nested_column_specs_return()
        retval.start = self.input.LT(1)

        update_nested_column_specs_StartIndex = self.input.index()

        root_0 = None

        COMMA1335 = None
        update_nested_column_spec1334 = None

        update_nested_column_spec1336 = None


        COMMA1335_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 240):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1255:2: ( update_nested_column_spec ( COMMA update_nested_column_spec )* )
                # ./output/PLSQL3.g:1255:4: update_nested_column_spec ( COMMA update_nested_column_spec )*
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_update_nested_column_spec_in_update_nested_column_specs7940)
                update_nested_column_spec1334 = self.update_nested_column_spec()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, update_nested_column_spec1334.tree)


                # ./output/PLSQL3.g:1255:30: ( COMMA update_nested_column_spec )*
                while True: #loop349
                    alt349 = 2
                    LA349_0 = self.input.LA(1)

                    if (LA349_0 == COMMA) :
                        alt349 = 1


                    if alt349 == 1:
                        # ./output/PLSQL3.g:1255:32: COMMA update_nested_column_spec
                        pass
                        COMMA1335 = self.match(self.input, COMMA, self.FOLLOW_COMMA_in_update_nested_column_specs7944)
                        if self._state.backtracking == 0:
                            COMMA1335_tree = self._adaptor.createWithPayload(COMMA1335)
                            self._adaptor.addChild(root_0, COMMA1335_tree)



                        self._state.following.append(self.FOLLOW_update_nested_column_spec_in_update_nested_column_specs7946)
                        update_nested_column_spec1336 = self.update_nested_column_spec()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, update_nested_column_spec1336.tree)



                    else:
                        break #loop349




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 240, update_nested_column_specs_StartIndex, success)


            pass
        return retval

    # $ANTLR end "update_nested_column_specs"


    class update_nested_column_spec_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.update_nested_column_spec_return, self).__init__()

            self.tree = None





    # $ANTLR start "update_nested_column_spec"
    # ./output/PLSQL3.g:1258:1: update_nested_column_spec : LPAREN column_specs RPAREN EQ subquery ;
    def update_nested_column_spec(self, ):
        retval = self.update_nested_column_spec_return()
        retval.start = self.input.LT(1)

        update_nested_column_spec_StartIndex = self.input.index()

        root_0 = None

        LPAREN1337 = None
        RPAREN1339 = None
        EQ1340 = None
        column_specs1338 = None

        subquery1341 = None


        LPAREN1337_tree = None
        RPAREN1339_tree = None
        EQ1340_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 241):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1259:2: ( LPAREN column_specs RPAREN EQ subquery )
                # ./output/PLSQL3.g:1259:4: LPAREN column_specs RPAREN EQ subquery
                pass
                root_0 = self._adaptor.nil()


                LPAREN1337 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_update_nested_column_spec7960)
                if self._state.backtracking == 0:
                    LPAREN1337_tree = self._adaptor.createWithPayload(LPAREN1337)
                    self._adaptor.addChild(root_0, LPAREN1337_tree)



                self._state.following.append(self.FOLLOW_column_specs_in_update_nested_column_spec7962)
                column_specs1338 = self.column_specs()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, column_specs1338.tree)


                RPAREN1339 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_update_nested_column_spec7964)
                if self._state.backtracking == 0:
                    RPAREN1339_tree = self._adaptor.createWithPayload(RPAREN1339)
                    self._adaptor.addChild(root_0, RPAREN1339_tree)



                EQ1340 = self.match(self.input, EQ, self.FOLLOW_EQ_in_update_nested_column_spec7966)
                if self._state.backtracking == 0:
                    EQ1340_tree = self._adaptor.createWithPayload(EQ1340)
                    self._adaptor.addChild(root_0, EQ1340_tree)



                self._state.following.append(self.FOLLOW_subquery_in_update_nested_column_spec7968)
                subquery1341 = self.subquery()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, subquery1341.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 241, update_nested_column_spec_StartIndex, success)


            pass
        return retval

    # $ANTLR end "update_nested_column_spec"


    class delete_command_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.delete_command_return, self).__init__()

            self.tree = None





    # $ANTLR start "delete_command"
    # ./output/PLSQL3.g:1262:1: delete_command : 'DELETE' ( 'FROM' )? selected_table ( 'WHERE' ( keyCURRENT_OF cursor_name | sql_condition ) )? ( returning_clause )? ;
    def delete_command(self, ):
        retval = self.delete_command_return()
        retval.start = self.input.LT(1)

        delete_command_StartIndex = self.input.index()

        root_0 = None

        string_literal1342 = None
        string_literal1343 = None
        string_literal1345 = None
        selected_table1344 = None

        keyCURRENT_OF1346 = None

        cursor_name1347 = None

        sql_condition1348 = None

        returning_clause1349 = None


        string_literal1342_tree = None
        string_literal1343_tree = None
        string_literal1345_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 242):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1263:2: ( 'DELETE' ( 'FROM' )? selected_table ( 'WHERE' ( keyCURRENT_OF cursor_name | sql_condition ) )? ( returning_clause )? )
                # ./output/PLSQL3.g:1263:4: 'DELETE' ( 'FROM' )? selected_table ( 'WHERE' ( keyCURRENT_OF cursor_name | sql_condition ) )? ( returning_clause )?
                pass
                root_0 = self._adaptor.nil()


                string_literal1342 = self.match(self.input, 79, self.FOLLOW_79_in_delete_command7979)
                if self._state.backtracking == 0:
                    string_literal1342_tree = self._adaptor.createWithPayload(string_literal1342)
                    self._adaptor.addChild(root_0, string_literal1342_tree)



                # ./output/PLSQL3.g:1263:13: ( 'FROM' )?
                alt350 = 2
                LA350_0 = self.input.LA(1)

                if (LA350_0 == 93) :
                    alt350 = 1
                if alt350 == 1:
                    # ./output/PLSQL3.g:1263:15: 'FROM'
                    pass
                    string_literal1343 = self.match(self.input, 93, self.FOLLOW_93_in_delete_command7983)
                    if self._state.backtracking == 0:
                        string_literal1343_tree = self._adaptor.createWithPayload(string_literal1343)
                        self._adaptor.addChild(root_0, string_literal1343_tree)






                self._state.following.append(self.FOLLOW_selected_table_in_delete_command7988)
                selected_table1344 = self.selected_table()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, selected_table1344.tree)


                # ./output/PLSQL3.g:1264:3: ( 'WHERE' ( keyCURRENT_OF cursor_name | sql_condition ) )?
                alt352 = 2
                LA352_0 = self.input.LA(1)

                if (LA352_0 == 165) :
                    alt352 = 1
                if alt352 == 1:
                    # ./output/PLSQL3.g:1264:5: 'WHERE' ( keyCURRENT_OF cursor_name | sql_condition )
                    pass
                    string_literal1345 = self.match(self.input, 165, self.FOLLOW_165_in_delete_command7994)
                    if self._state.backtracking == 0:
                        string_literal1345_tree = self._adaptor.createWithPayload(string_literal1345)
                        self._adaptor.addChild(root_0, string_literal1345_tree)



                    # ./output/PLSQL3.g:1265:4: ( keyCURRENT_OF cursor_name | sql_condition )
                    alt351 = 2
                    LA351_0 = self.input.LA(1)

                    if (LA351_0 == ID) :
                        LA351 = self.input.LA(2)
                        if LA351 == ID:
                            LA351_3 = self.input.LA(3)

                            if (LA351_3 == EOF or LA351_3 == SEMI or (140 <= LA351_3 <= 141)) :
                                alt351 = 1
                            elif (LA351_3 == DOUBLEQUOTED_STRING or LA351_3 == ID or LA351_3 == LPAREN or LA351_3 == MINUS or LA351_3 == NUMBER or LA351_3 == PLUS or LA351_3 == QUOTED_STRING or LA351_3 == 65 or LA351_3 == 81 or LA351_3 == 89 or LA351_3 == 120 or LA351_3 == 125 or LA351_3 == 144 or LA351_3 == 147 or LA351_3 == 151 or LA351_3 == 156) :
                                alt351 = 2
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed


                                nvae = NoViableAltException("", 351, 3, self.input)

                                raise nvae


                        elif LA351 == ASTERISK or LA351 == DIVIDE or LA351 == DOT or LA351 == DOUBLEVERTBAR or LA351 == EQ or LA351 == EXPONENT or LA351 == GEQ or LA351 == GTH or LA351 == LEQ or LA351 == LPAREN or LA351 == LTH or LA351 == MINUS or LA351 == NOT_EQ or LA351 == PLUS or LA351 == 57 or LA351 == 99 or LA351 == 106 or LA351 == 107 or LA351 == 118:
                            alt351 = 2
                        elif LA351 == DOUBLEQUOTED_STRING:
                            alt351 = 1
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed


                            nvae = NoViableAltException("", 351, 1, self.input)

                            raise nvae


                    elif (LA351_0 == DOUBLEQUOTED_STRING or LA351_0 == LPAREN or LA351_0 == MINUS or LA351_0 == NUMBER or LA351_0 == PLUS or LA351_0 == QUOTED_STRING or LA351_0 == 52 or LA351_0 == 65 or LA351_0 == 81 or (88 <= LA351_0 <= 89) or LA351_0 == 118 or LA351_0 == 120 or LA351_0 == 134 or LA351_0 == 144 or LA351_0 == 147 or LA351_0 == 151 or LA351_0 == 156) :
                        alt351 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 351, 0, self.input)

                        raise nvae


                    if alt351 == 1:
                        # ./output/PLSQL3.g:1265:6: keyCURRENT_OF cursor_name
                        pass
                        self._state.following.append(self.FOLLOW_keyCURRENT_OF_in_delete_command8001)
                        keyCURRENT_OF1346 = self.keyCURRENT_OF()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, keyCURRENT_OF1346.tree)


                        self._state.following.append(self.FOLLOW_cursor_name_in_delete_command8003)
                        cursor_name1347 = self.cursor_name()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, cursor_name1347.tree)



                    elif alt351 == 2:
                        # ./output/PLSQL3.g:1266:6: sql_condition
                        pass
                        self._state.following.append(self.FOLLOW_sql_condition_in_delete_command8010)
                        sql_condition1348 = self.sql_condition()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, sql_condition1348.tree)








                # ./output/PLSQL3.g:1269:3: ( returning_clause )?
                alt353 = 2
                LA353_0 = self.input.LA(1)

                if ((140 <= LA353_0 <= 141)) :
                    alt353 = 1
                if alt353 == 1:
                    # ./output/PLSQL3.g:1269:5: returning_clause
                    pass
                    self._state.following.append(self.FOLLOW_returning_clause_in_delete_command8026)
                    returning_clause1349 = self.returning_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, returning_clause1349.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 242, delete_command_StartIndex, success)


            pass
        return retval

    # $ANTLR end "delete_command"


    class returning_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.returning_clause_return, self).__init__()

            self.tree = None





    # $ANTLR start "returning_clause"
    # ./output/PLSQL3.g:1272:1: returning_clause : ( keyRETURN | keyRETURNING ) select_list ( keyBULK keyCOLLECT )? 'INTO' lvalues ;
    def returning_clause(self, ):
        retval = self.returning_clause_return()
        retval.start = self.input.LT(1)

        returning_clause_StartIndex = self.input.index()

        root_0 = None

        string_literal1355 = None
        keyRETURN1350 = None

        keyRETURNING1351 = None

        select_list1352 = None

        keyBULK1353 = None

        keyCOLLECT1354 = None

        lvalues1356 = None


        string_literal1355_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 243):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1273:2: ( ( keyRETURN | keyRETURNING ) select_list ( keyBULK keyCOLLECT )? 'INTO' lvalues )
                # ./output/PLSQL3.g:1273:4: ( keyRETURN | keyRETURNING ) select_list ( keyBULK keyCOLLECT )? 'INTO' lvalues
                pass
                root_0 = self._adaptor.nil()


                # ./output/PLSQL3.g:1273:4: ( keyRETURN | keyRETURNING )
                alt354 = 2
                LA354_0 = self.input.LA(1)

                if (LA354_0 == 140) :
                    alt354 = 1
                elif (LA354_0 == 141) :
                    alt354 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 354, 0, self.input)

                    raise nvae


                if alt354 == 1:
                    # ./output/PLSQL3.g:1273:6: keyRETURN
                    pass
                    self._state.following.append(self.FOLLOW_keyRETURN_in_returning_clause8042)
                    keyRETURN1350 = self.keyRETURN()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyRETURN1350.tree)



                elif alt354 == 2:
                    # ./output/PLSQL3.g:1273:18: keyRETURNING
                    pass
                    self._state.following.append(self.FOLLOW_keyRETURNING_in_returning_clause8046)
                    keyRETURNING1351 = self.keyRETURNING()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyRETURNING1351.tree)





                self._state.following.append(self.FOLLOW_select_list_in_returning_clause8050)
                select_list1352 = self.select_list()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, select_list1352.tree)


                # ./output/PLSQL3.g:1273:45: ( keyBULK keyCOLLECT )?
                alt355 = 2
                LA355_0 = self.input.LA(1)

                if (LA355_0 == ID) :
                    alt355 = 1
                if alt355 == 1:
                    # ./output/PLSQL3.g:1273:47: keyBULK keyCOLLECT
                    pass
                    self._state.following.append(self.FOLLOW_keyBULK_in_returning_clause8054)
                    keyBULK1353 = self.keyBULK()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyBULK1353.tree)


                    self._state.following.append(self.FOLLOW_keyCOLLECT_in_returning_clause8056)
                    keyCOLLECT1354 = self.keyCOLLECT()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyCOLLECT1354.tree)





                string_literal1355 = self.match(self.input, 105, self.FOLLOW_105_in_returning_clause8061)
                if self._state.backtracking == 0:
                    string_literal1355_tree = self._adaptor.createWithPayload(string_literal1355)
                    self._adaptor.addChild(root_0, string_literal1355_tree)



                self._state.following.append(self.FOLLOW_lvalues_in_returning_clause8063)
                lvalues1356 = self.lvalues()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, lvalues1356.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 243, returning_clause_StartIndex, success)


            pass
        return retval

    # $ANTLR end "returning_clause"


    class set_transaction_command_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.set_transaction_command_return, self).__init__()

            self.tree = None





    # $ANTLR start "set_transaction_command"
    # ./output/PLSQL3.g:1276:1: set_transaction_command : 'SET' keyTRANSACTION keyREAD keyONLY ;
    def set_transaction_command(self, ):
        retval = self.set_transaction_command_return()
        retval.start = self.input.LT(1)

        set_transaction_command_StartIndex = self.input.index()

        root_0 = None

        string_literal1357 = None
        keyTRANSACTION1358 = None

        keyREAD1359 = None

        keyONLY1360 = None


        string_literal1357_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 244):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1277:2: ( 'SET' keyTRANSACTION keyREAD keyONLY )
                # ./output/PLSQL3.g:1277:4: 'SET' keyTRANSACTION keyREAD keyONLY
                pass
                root_0 = self._adaptor.nil()


                string_literal1357 = self.match(self.input, 148, self.FOLLOW_148_in_set_transaction_command8074)
                if self._state.backtracking == 0:
                    string_literal1357_tree = self._adaptor.createWithPayload(string_literal1357)
                    self._adaptor.addChild(root_0, string_literal1357_tree)



                self._state.following.append(self.FOLLOW_keyTRANSACTION_in_set_transaction_command8076)
                keyTRANSACTION1358 = self.keyTRANSACTION()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyTRANSACTION1358.tree)


                self._state.following.append(self.FOLLOW_keyREAD_in_set_transaction_command8078)
                keyREAD1359 = self.keyREAD()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyREAD1359.tree)


                self._state.following.append(self.FOLLOW_keyONLY_in_set_transaction_command8080)
                keyONLY1360 = self.keyONLY()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyONLY1360.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 244, set_transaction_command_StartIndex, success)


            pass
        return retval

    # $ANTLR end "set_transaction_command"


    class close_statement_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.close_statement_return, self).__init__()

            self.tree = None





    # $ANTLR start "close_statement"
    # ./output/PLSQL3.g:1280:1: close_statement : keyCLOSE cursor_name ;
    def close_statement(self, ):
        retval = self.close_statement_return()
        retval.start = self.input.LT(1)

        close_statement_StartIndex = self.input.index()

        root_0 = None

        keyCLOSE1361 = None

        cursor_name1362 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 245):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1281:2: ( keyCLOSE cursor_name )
                # ./output/PLSQL3.g:1281:4: keyCLOSE cursor_name
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyCLOSE_in_close_statement8091)
                keyCLOSE1361 = self.keyCLOSE()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyCLOSE1361.tree)


                self._state.following.append(self.FOLLOW_cursor_name_in_close_statement8093)
                cursor_name1362 = self.cursor_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, cursor_name1362.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 245, close_statement_StartIndex, success)


            pass
        return retval

    # $ANTLR end "close_statement"


    class fetch_statement_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.fetch_statement_return, self).__init__()

            self.tree = None





    # $ANTLR start "fetch_statement"
    # ./output/PLSQL3.g:1284:1: fetch_statement : 'FETCH' cursor_name 'INTO' ( variable_names | record_name ) ;
    def fetch_statement(self, ):
        retval = self.fetch_statement_return()
        retval.start = self.input.LT(1)

        fetch_statement_StartIndex = self.input.index()

        root_0 = None

        string_literal1363 = None
        string_literal1365 = None
        cursor_name1364 = None

        variable_names1366 = None

        record_name1367 = None


        string_literal1363_tree = None
        string_literal1365_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 246):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1285:2: ( 'FETCH' cursor_name 'INTO' ( variable_names | record_name ) )
                # ./output/PLSQL3.g:1285:4: 'FETCH' cursor_name 'INTO' ( variable_names | record_name )
                pass
                root_0 = self._adaptor.nil()


                string_literal1363 = self.match(self.input, 90, self.FOLLOW_90_in_fetch_statement8104)
                if self._state.backtracking == 0:
                    string_literal1363_tree = self._adaptor.createWithPayload(string_literal1363)
                    self._adaptor.addChild(root_0, string_literal1363_tree)



                self._state.following.append(self.FOLLOW_cursor_name_in_fetch_statement8106)
                cursor_name1364 = self.cursor_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, cursor_name1364.tree)


                string_literal1365 = self.match(self.input, 105, self.FOLLOW_105_in_fetch_statement8108)
                if self._state.backtracking == 0:
                    string_literal1365_tree = self._adaptor.createWithPayload(string_literal1365)
                    self._adaptor.addChild(root_0, string_literal1365_tree)



                # ./output/PLSQL3.g:1286:3: ( variable_names | record_name )
                alt356 = 2
                LA356_0 = self.input.LA(1)

                if (LA356_0 == DOUBLEQUOTED_STRING or LA356_0 == ID) :
                    LA356_1 = self.input.LA(2)

                    if (self.synpred562_PLSQL3()) :
                        alt356 = 1
                    elif (True) :
                        alt356 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 356, 1, self.input)

                        raise nvae


                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 356, 0, self.input)

                    raise nvae


                if alt356 == 1:
                    # ./output/PLSQL3.g:1286:5: variable_names
                    pass
                    self._state.following.append(self.FOLLOW_variable_names_in_fetch_statement8115)
                    variable_names1366 = self.variable_names()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, variable_names1366.tree)



                elif alt356 == 2:
                    # ./output/PLSQL3.g:1287:5: record_name
                    pass
                    self._state.following.append(self.FOLLOW_record_name_in_fetch_statement8121)
                    record_name1367 = self.record_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, record_name1367.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 246, fetch_statement_StartIndex, success)


            pass
        return retval

    # $ANTLR end "fetch_statement"


    class lock_table_statement_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.lock_table_statement_return, self).__init__()

            self.tree = None





    # $ANTLR start "lock_table_statement"
    # ./output/PLSQL3.g:1291:1: lock_table_statement : 'LOCK' 'TABLE' table_reference_list 'IN' lock_mode 'MODE' ( 'NOWAIT' )? ;
    def lock_table_statement(self, ):
        retval = self.lock_table_statement_return()
        retval.start = self.input.LT(1)

        lock_table_statement_StartIndex = self.input.index()

        root_0 = None

        string_literal1368 = None
        string_literal1369 = None
        string_literal1371 = None
        string_literal1373 = None
        string_literal1374 = None
        table_reference_list1370 = None

        lock_mode1372 = None


        string_literal1368_tree = None
        string_literal1369_tree = None
        string_literal1371_tree = None
        string_literal1373_tree = None
        string_literal1374_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 247):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1292:2: ( 'LOCK' 'TABLE' table_reference_list 'IN' lock_mode 'MODE' ( 'NOWAIT' )? )
                # ./output/PLSQL3.g:1292:4: 'LOCK' 'TABLE' table_reference_list 'IN' lock_mode 'MODE' ( 'NOWAIT' )?
                pass
                root_0 = self._adaptor.nil()


                string_literal1368 = self.match(self.input, 108, self.FOLLOW_108_in_lock_table_statement8136)
                if self._state.backtracking == 0:
                    string_literal1368_tree = self._adaptor.createWithPayload(string_literal1368)
                    self._adaptor.addChild(root_0, string_literal1368_tree)



                string_literal1369 = self.match(self.input, 153, self.FOLLOW_153_in_lock_table_statement8138)
                if self._state.backtracking == 0:
                    string_literal1369_tree = self._adaptor.createWithPayload(string_literal1369)
                    self._adaptor.addChild(root_0, string_literal1369_tree)



                self._state.following.append(self.FOLLOW_table_reference_list_in_lock_table_statement8140)
                table_reference_list1370 = self.table_reference_list()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, table_reference_list1370.tree)


                string_literal1371 = self.match(self.input, 99, self.FOLLOW_99_in_lock_table_statement8144)
                if self._state.backtracking == 0:
                    string_literal1371_tree = self._adaptor.createWithPayload(string_literal1371)
                    self._adaptor.addChild(root_0, string_literal1371_tree)



                self._state.following.append(self.FOLLOW_lock_mode_in_lock_table_statement8146)
                lock_mode1372 = self.lock_mode()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, lock_mode1372.tree)


                string_literal1373 = self.match(self.input, 113, self.FOLLOW_113_in_lock_table_statement8148)
                if self._state.backtracking == 0:
                    string_literal1373_tree = self._adaptor.createWithPayload(string_literal1373)
                    self._adaptor.addChild(root_0, string_literal1373_tree)



                # ./output/PLSQL3.g:1293:25: ( 'NOWAIT' )?
                alt357 = 2
                LA357_0 = self.input.LA(1)

                if (LA357_0 == 119) :
                    alt357 = 1
                if alt357 == 1:
                    # ./output/PLSQL3.g:1293:27: 'NOWAIT'
                    pass
                    string_literal1374 = self.match(self.input, 119, self.FOLLOW_119_in_lock_table_statement8152)
                    if self._state.backtracking == 0:
                        string_literal1374_tree = self._adaptor.createWithPayload(string_literal1374)
                        self._adaptor.addChild(root_0, string_literal1374_tree)








                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 247, lock_table_statement_StartIndex, success)


            pass
        return retval

    # $ANTLR end "lock_table_statement"


    class lock_mode_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.lock_mode_return, self).__init__()

            self.tree = None





    # $ANTLR start "lock_mode"
    # ./output/PLSQL3.g:1296:1: lock_mode : ( 'ROW' 'SHARE' | 'ROW' 'EXCLUSIVE' | 'SHARE' 'UPDATE' | 'SHARE' | 'SHARE' 'ROW' 'EXCLUSIVE' | 'EXCLUSIVE' );
    def lock_mode(self, ):
        retval = self.lock_mode_return()
        retval.start = self.input.LT(1)

        lock_mode_StartIndex = self.input.index()

        root_0 = None

        string_literal1375 = None
        string_literal1376 = None
        string_literal1377 = None
        string_literal1378 = None
        string_literal1379 = None
        string_literal1380 = None
        string_literal1381 = None
        string_literal1382 = None
        string_literal1383 = None
        string_literal1384 = None
        string_literal1385 = None

        string_literal1375_tree = None
        string_literal1376_tree = None
        string_literal1377_tree = None
        string_literal1378_tree = None
        string_literal1379_tree = None
        string_literal1380_tree = None
        string_literal1381_tree = None
        string_literal1382_tree = None
        string_literal1383_tree = None
        string_literal1384_tree = None
        string_literal1385_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 248):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1297:2: ( 'ROW' 'SHARE' | 'ROW' 'EXCLUSIVE' | 'SHARE' 'UPDATE' | 'SHARE' | 'SHARE' 'ROW' 'EXCLUSIVE' | 'EXCLUSIVE' )
                alt358 = 6
                LA358 = self.input.LA(1)
                if LA358 == 143:
                    LA358_1 = self.input.LA(2)

                    if (LA358_1 == 149) :
                        alt358 = 1
                    elif (LA358_1 == 87) :
                        alt358 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 358, 1, self.input)

                        raise nvae


                elif LA358 == 149:
                    LA358 = self.input.LA(2)
                    if LA358 == 159:
                        alt358 = 3
                    elif LA358 == 143:
                        alt358 = 5
                    elif LA358 == 113:
                        alt358 = 4
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed


                        nvae = NoViableAltException("", 358, 2, self.input)

                        raise nvae


                elif LA358 == 87:
                    alt358 = 6
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 358, 0, self.input)

                    raise nvae


                if alt358 == 1:
                    # ./output/PLSQL3.g:1297:4: 'ROW' 'SHARE'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal1375 = self.match(self.input, 143, self.FOLLOW_143_in_lock_mode8166)
                    if self._state.backtracking == 0:
                        string_literal1375_tree = self._adaptor.createWithPayload(string_literal1375)
                        self._adaptor.addChild(root_0, string_literal1375_tree)



                    string_literal1376 = self.match(self.input, 149, self.FOLLOW_149_in_lock_mode8168)
                    if self._state.backtracking == 0:
                        string_literal1376_tree = self._adaptor.createWithPayload(string_literal1376)
                        self._adaptor.addChild(root_0, string_literal1376_tree)




                elif alt358 == 2:
                    # ./output/PLSQL3.g:1298:4: 'ROW' 'EXCLUSIVE'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal1377 = self.match(self.input, 143, self.FOLLOW_143_in_lock_mode8173)
                    if self._state.backtracking == 0:
                        string_literal1377_tree = self._adaptor.createWithPayload(string_literal1377)
                        self._adaptor.addChild(root_0, string_literal1377_tree)



                    string_literal1378 = self.match(self.input, 87, self.FOLLOW_87_in_lock_mode8175)
                    if self._state.backtracking == 0:
                        string_literal1378_tree = self._adaptor.createWithPayload(string_literal1378)
                        self._adaptor.addChild(root_0, string_literal1378_tree)




                elif alt358 == 3:
                    # ./output/PLSQL3.g:1299:4: 'SHARE' 'UPDATE'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal1379 = self.match(self.input, 149, self.FOLLOW_149_in_lock_mode8180)
                    if self._state.backtracking == 0:
                        string_literal1379_tree = self._adaptor.createWithPayload(string_literal1379)
                        self._adaptor.addChild(root_0, string_literal1379_tree)



                    string_literal1380 = self.match(self.input, 159, self.FOLLOW_159_in_lock_mode8182)
                    if self._state.backtracking == 0:
                        string_literal1380_tree = self._adaptor.createWithPayload(string_literal1380)
                        self._adaptor.addChild(root_0, string_literal1380_tree)




                elif alt358 == 4:
                    # ./output/PLSQL3.g:1300:4: 'SHARE'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal1381 = self.match(self.input, 149, self.FOLLOW_149_in_lock_mode8187)
                    if self._state.backtracking == 0:
                        string_literal1381_tree = self._adaptor.createWithPayload(string_literal1381)
                        self._adaptor.addChild(root_0, string_literal1381_tree)




                elif alt358 == 5:
                    # ./output/PLSQL3.g:1301:4: 'SHARE' 'ROW' 'EXCLUSIVE'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal1382 = self.match(self.input, 149, self.FOLLOW_149_in_lock_mode8192)
                    if self._state.backtracking == 0:
                        string_literal1382_tree = self._adaptor.createWithPayload(string_literal1382)
                        self._adaptor.addChild(root_0, string_literal1382_tree)



                    string_literal1383 = self.match(self.input, 143, self.FOLLOW_143_in_lock_mode8194)
                    if self._state.backtracking == 0:
                        string_literal1383_tree = self._adaptor.createWithPayload(string_literal1383)
                        self._adaptor.addChild(root_0, string_literal1383_tree)



                    string_literal1384 = self.match(self.input, 87, self.FOLLOW_87_in_lock_mode8196)
                    if self._state.backtracking == 0:
                        string_literal1384_tree = self._adaptor.createWithPayload(string_literal1384)
                        self._adaptor.addChild(root_0, string_literal1384_tree)




                elif alt358 == 6:
                    # ./output/PLSQL3.g:1302:4: 'EXCLUSIVE'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal1385 = self.match(self.input, 87, self.FOLLOW_87_in_lock_mode8201)
                    if self._state.backtracking == 0:
                        string_literal1385_tree = self._adaptor.createWithPayload(string_literal1385)
                        self._adaptor.addChild(root_0, string_literal1385_tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 248, lock_mode_StartIndex, success)


            pass
        return retval

    # $ANTLR end "lock_mode"


    class open_statement_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.open_statement_return, self).__init__()

            self.tree = None





    # $ANTLR start "open_statement"
    # ./output/PLSQL3.g:1305:1: open_statement : keyOPEN cursor_name ( LPAREN plsql_expressions RPAREN )? ;
    def open_statement(self, ):
        retval = self.open_statement_return()
        retval.start = self.input.LT(1)

        open_statement_StartIndex = self.input.index()

        root_0 = None

        LPAREN1388 = None
        RPAREN1390 = None
        keyOPEN1386 = None

        cursor_name1387 = None

        plsql_expressions1389 = None


        LPAREN1388_tree = None
        RPAREN1390_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 249):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1306:2: ( keyOPEN cursor_name ( LPAREN plsql_expressions RPAREN )? )
                # ./output/PLSQL3.g:1306:4: keyOPEN cursor_name ( LPAREN plsql_expressions RPAREN )?
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyOPEN_in_open_statement8212)
                keyOPEN1386 = self.keyOPEN()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyOPEN1386.tree)


                self._state.following.append(self.FOLLOW_cursor_name_in_open_statement8214)
                cursor_name1387 = self.cursor_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, cursor_name1387.tree)


                # ./output/PLSQL3.g:1306:24: ( LPAREN plsql_expressions RPAREN )?
                alt359 = 2
                LA359_0 = self.input.LA(1)

                if (LA359_0 == LPAREN) :
                    alt359 = 1
                if alt359 == 1:
                    # ./output/PLSQL3.g:1306:26: LPAREN plsql_expressions RPAREN
                    pass
                    LPAREN1388 = self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_open_statement8218)
                    if self._state.backtracking == 0:
                        LPAREN1388_tree = self._adaptor.createWithPayload(LPAREN1388)
                        self._adaptor.addChild(root_0, LPAREN1388_tree)



                    self._state.following.append(self.FOLLOW_plsql_expressions_in_open_statement8220)
                    plsql_expressions1389 = self.plsql_expressions()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, plsql_expressions1389.tree)


                    RPAREN1390 = self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_open_statement8222)
                    if self._state.backtracking == 0:
                        RPAREN1390_tree = self._adaptor.createWithPayload(RPAREN1390)
                        self._adaptor.addChild(root_0, RPAREN1390_tree)








                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 249, open_statement_StartIndex, success)


            pass
        return retval

    # $ANTLR end "open_statement"


    class rollback_statement_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.rollback_statement_return, self).__init__()

            self.tree = None





    # $ANTLR start "rollback_statement"
    # ./output/PLSQL3.g:1309:1: rollback_statement : keyROLLBACK ( keyWORK )? ( 'TO' ( 'SAVEPOINT' )? savepoint_name )? ( 'COMMENT' quoted_string )? ;
    def rollback_statement(self, ):
        retval = self.rollback_statement_return()
        retval.start = self.input.LT(1)

        rollback_statement_StartIndex = self.input.index()

        root_0 = None

        string_literal1393 = None
        string_literal1394 = None
        string_literal1396 = None
        keyROLLBACK1391 = None

        keyWORK1392 = None

        savepoint_name1395 = None

        quoted_string1397 = None


        string_literal1393_tree = None
        string_literal1394_tree = None
        string_literal1396_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 250):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1310:2: ( keyROLLBACK ( keyWORK )? ( 'TO' ( 'SAVEPOINT' )? savepoint_name )? ( 'COMMENT' quoted_string )? )
                # ./output/PLSQL3.g:1310:4: keyROLLBACK ( keyWORK )? ( 'TO' ( 'SAVEPOINT' )? savepoint_name )? ( 'COMMENT' quoted_string )?
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_keyROLLBACK_in_rollback_statement8236)
                keyROLLBACK1391 = self.keyROLLBACK()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, keyROLLBACK1391.tree)


                # ./output/PLSQL3.g:1310:16: ( keyWORK )?
                alt360 = 2
                LA360_0 = self.input.LA(1)

                if (LA360_0 == ID) :
                    alt360 = 1
                if alt360 == 1:
                    # ./output/PLSQL3.g:1310:18: keyWORK
                    pass
                    self._state.following.append(self.FOLLOW_keyWORK_in_rollback_statement8240)
                    keyWORK1392 = self.keyWORK()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyWORK1392.tree)





                # ./output/PLSQL3.g:1311:3: ( 'TO' ( 'SAVEPOINT' )? savepoint_name )?
                alt362 = 2
                LA362_0 = self.input.LA(1)

                if (LA362_0 == 155) :
                    alt362 = 1
                if alt362 == 1:
                    # ./output/PLSQL3.g:1311:5: 'TO' ( 'SAVEPOINT' )? savepoint_name
                    pass
                    string_literal1393 = self.match(self.input, 155, self.FOLLOW_155_in_rollback_statement8249)
                    if self._state.backtracking == 0:
                        string_literal1393_tree = self._adaptor.createWithPayload(string_literal1393)
                        self._adaptor.addChild(root_0, string_literal1393_tree)



                    # ./output/PLSQL3.g:1311:10: ( 'SAVEPOINT' )?
                    alt361 = 2
                    LA361_0 = self.input.LA(1)

                    if (LA361_0 == 146) :
                        alt361 = 1
                    if alt361 == 1:
                        # ./output/PLSQL3.g:1311:12: 'SAVEPOINT'
                        pass
                        string_literal1394 = self.match(self.input, 146, self.FOLLOW_146_in_rollback_statement8253)
                        if self._state.backtracking == 0:
                            string_literal1394_tree = self._adaptor.createWithPayload(string_literal1394)
                            self._adaptor.addChild(root_0, string_literal1394_tree)






                    self._state.following.append(self.FOLLOW_savepoint_name_in_rollback_statement8258)
                    savepoint_name1395 = self.savepoint_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, savepoint_name1395.tree)





                # ./output/PLSQL3.g:1312:3: ( 'COMMENT' quoted_string )?
                alt363 = 2
                LA363_0 = self.input.LA(1)

                if (LA363_0 == 69) :
                    alt363 = 1
                if alt363 == 1:
                    # ./output/PLSQL3.g:1312:5: 'COMMENT' quoted_string
                    pass
                    string_literal1396 = self.match(self.input, 69, self.FOLLOW_69_in_rollback_statement8267)
                    if self._state.backtracking == 0:
                        string_literal1396_tree = self._adaptor.createWithPayload(string_literal1396)
                        self._adaptor.addChild(root_0, string_literal1396_tree)



                    self._state.following.append(self.FOLLOW_quoted_string_in_rollback_statement8269)
                    quoted_string1397 = self.quoted_string()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, quoted_string1397.tree)







                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 250, rollback_statement_StartIndex, success)


            pass
        return retval

    # $ANTLR end "rollback_statement"


    class savepoint_statement_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.savepoint_statement_return, self).__init__()

            self.tree = None





    # $ANTLR start "savepoint_statement"
    # ./output/PLSQL3.g:1315:1: savepoint_statement : 'SAVEPOINT' savepoint_name ;
    def savepoint_statement(self, ):
        retval = self.savepoint_statement_return()
        retval.start = self.input.LT(1)

        savepoint_statement_StartIndex = self.input.index()

        root_0 = None

        string_literal1398 = None
        savepoint_name1399 = None


        string_literal1398_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 251):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1316:2: ( 'SAVEPOINT' savepoint_name )
                # ./output/PLSQL3.g:1316:4: 'SAVEPOINT' savepoint_name
                pass
                root_0 = self._adaptor.nil()


                string_literal1398 = self.match(self.input, 146, self.FOLLOW_146_in_savepoint_statement8283)
                if self._state.backtracking == 0:
                    string_literal1398_tree = self._adaptor.createWithPayload(string_literal1398)
                    self._adaptor.addChild(root_0, string_literal1398_tree)



                self._state.following.append(self.FOLLOW_savepoint_name_in_savepoint_statement8285)
                savepoint_name1399 = self.savepoint_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, savepoint_name1399.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 251, savepoint_statement_StartIndex, success)


            pass
        return retval

    # $ANTLR end "savepoint_statement"


    class savepoint_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.savepoint_name_return, self).__init__()

            self.tree = None





    # $ANTLR start "savepoint_name"
    # ./output/PLSQL3.g:1319:1: savepoint_name : identifier ;
    def savepoint_name(self, ):
        retval = self.savepoint_name_return()
        retval.start = self.input.LT(1)

        savepoint_name_StartIndex = self.input.index()

        root_0 = None

        identifier1400 = None



        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 252):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1320:2: ( identifier )
                # ./output/PLSQL3.g:1320:4: identifier
                pass
                root_0 = self._adaptor.nil()


                self._state.following.append(self.FOLLOW_identifier_in_savepoint_name8296)
                identifier1400 = self.identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, identifier1400.tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 252, savepoint_name_StartIndex, success)


            pass
        return retval

    # $ANTLR end "savepoint_name"


    class identifier_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.identifier_return, self).__init__()

            self.tree = None





    # $ANTLR start "identifier"
    # ./output/PLSQL3.g:1323:1: identifier : ( ID | DOUBLEQUOTED_STRING );
    def identifier(self, ):
        retval = self.identifier_return()
        retval.start = self.input.LT(1)

        identifier_StartIndex = self.input.index()

        root_0 = None

        set1401 = None

        set1401_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 253):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1324:2: ( ID | DOUBLEQUOTED_STRING )
                # ./output/PLSQL3.g:
                pass
                root_0 = self._adaptor.nil()


                set1401 = self.input.LT(1)

                if self.input.LA(1) == DOUBLEQUOTED_STRING or self.input.LA(1) == ID:
                    self.input.consume()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set1401))

                    self._state.errorRecovery = False


                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    mse = MismatchedSetException(None, self.input)
                    raise mse





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 253, identifier_StartIndex, success)


            pass
        return retval

    # $ANTLR end "identifier"


    class quoted_string_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.quoted_string_return, self).__init__()

            self.tree = None





    # $ANTLR start "quoted_string"
    # ./output/PLSQL3.g:1329:1: quoted_string : QUOTED_STRING ;
    def quoted_string(self, ):
        retval = self.quoted_string_return()
        retval.start = self.input.LT(1)

        quoted_string_StartIndex = self.input.index()

        root_0 = None

        QUOTED_STRING1402 = None

        QUOTED_STRING1402_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 254):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1330:2: ( QUOTED_STRING )
                # ./output/PLSQL3.g:1330:4: QUOTED_STRING
                pass
                root_0 = self._adaptor.nil()


                QUOTED_STRING1402 = self.match(self.input, QUOTED_STRING, self.FOLLOW_QUOTED_STRING_in_quoted_string8328)
                if self._state.backtracking == 0:
                    QUOTED_STRING1402_tree = self._adaptor.createWithPayload(QUOTED_STRING1402)
                    self._adaptor.addChild(root_0, QUOTED_STRING1402_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 254, quoted_string_StartIndex, success)


            pass
        return retval

    # $ANTLR end "quoted_string"


    class match_string_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.match_string_return, self).__init__()

            self.tree = None





    # $ANTLR start "match_string"
    # ./output/PLSQL3.g:1333:1: match_string : QUOTED_STRING ;
    def match_string(self, ):
        retval = self.match_string_return()
        retval.start = self.input.LT(1)

        match_string_StartIndex = self.input.index()

        root_0 = None

        QUOTED_STRING1403 = None

        QUOTED_STRING1403_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 255):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1334:2: ( QUOTED_STRING )
                # ./output/PLSQL3.g:1334:4: QUOTED_STRING
                pass
                root_0 = self._adaptor.nil()


                QUOTED_STRING1403 = self.match(self.input, QUOTED_STRING, self.FOLLOW_QUOTED_STRING_in_match_string8339)
                if self._state.backtracking == 0:
                    QUOTED_STRING1403_tree = self._adaptor.createWithPayload(QUOTED_STRING1403)
                    self._adaptor.addChild(root_0, QUOTED_STRING1403_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 255, match_string_StartIndex, success)


            pass
        return retval

    # $ANTLR end "match_string"


    class keyA_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyA_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyA"
    # ./output/PLSQL3.g:1336:1: keyA :{...}? ID ;
    def keyA(self, ):
        retval = self.keyA_return()
        retval.start = self.input.LT(1)

        keyA_StartIndex = self.input.index()

        root_0 = None

        ID1404 = None

        ID1404_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 256):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1336:34: ({...}? ID )
                # ./output/PLSQL3.g:1336:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "A")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyA", "(self.input).LT(1).text.upper() == \"A\"")


                ID1404 = self.match(self.input, ID, self.FOLLOW_ID_in_keyA8378)
                if self._state.backtracking == 0:
                    ID1404_tree = self._adaptor.createWithPayload(ID1404)
                    self._adaptor.addChild(root_0, ID1404_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 256, keyA_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyA"


    class keyAUTOMATIC_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyAUTOMATIC_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyAUTOMATIC"
    # ./output/PLSQL3.g:1337:1: keyAUTOMATIC :{...}? ID ;
    def keyAUTOMATIC(self, ):
        retval = self.keyAUTOMATIC_return()
        retval.start = self.input.LT(1)

        keyAUTOMATIC_StartIndex = self.input.index()

        root_0 = None

        ID1405 = None

        ID1405_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 257):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1337:34: ({...}? ID )
                # ./output/PLSQL3.g:1337:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "AUTOMATIC")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyAUTOMATIC", "(self.input).LT(1).text.upper() == \"AUTOMATIC\"")


                ID1405 = self.match(self.input, ID, self.FOLLOW_ID_in_keyAUTOMATIC8407)
                if self._state.backtracking == 0:
                    ID1405_tree = self._adaptor.createWithPayload(ID1405)
                    self._adaptor.addChild(root_0, ID1405_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 257, keyAUTOMATIC_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyAUTOMATIC"


    class keyCOUNT_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyCOUNT_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyCOUNT"
    # ./output/PLSQL3.g:1338:1: keyCOUNT :{...}? ID ;
    def keyCOUNT(self, ):
        retval = self.keyCOUNT_return()
        retval.start = self.input.LT(1)

        keyCOUNT_StartIndex = self.input.index()

        root_0 = None

        ID1406 = None

        ID1406_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 258):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1338:34: ({...}? ID )
                # ./output/PLSQL3.g:1338:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "COUNT")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyCOUNT", "(self.input).LT(1).text.upper() == \"COUNT\"")


                ID1406 = self.match(self.input, ID, self.FOLLOW_ID_in_keyCOUNT8440)
                if self._state.backtracking == 0:
                    ID1406_tree = self._adaptor.createWithPayload(ID1406)
                    self._adaptor.addChild(root_0, ID1406_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 258, keyCOUNT_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyCOUNT"


    class keyCROSS_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyCROSS_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyCROSS"
    # ./output/PLSQL3.g:1339:1: keyCROSS :{...}? ID ;
    def keyCROSS(self, ):
        retval = self.keyCROSS_return()
        retval.start = self.input.LT(1)

        keyCROSS_StartIndex = self.input.index()

        root_0 = None

        ID1407 = None

        ID1407_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 259):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1339:34: ({...}? ID )
                # ./output/PLSQL3.g:1339:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "CROSS")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyCROSS", "(self.input).LT(1).text.upper() == \"CROSS\"")


                ID1407 = self.match(self.input, ID, self.FOLLOW_ID_in_keyCROSS8473)
                if self._state.backtracking == 0:
                    ID1407_tree = self._adaptor.createWithPayload(ID1407)
                    self._adaptor.addChild(root_0, ID1407_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 259, keyCROSS_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyCROSS"


    class keyCUBE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyCUBE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyCUBE"
    # ./output/PLSQL3.g:1340:1: keyCUBE :{...}? ID ;
    def keyCUBE(self, ):
        retval = self.keyCUBE_return()
        retval.start = self.input.LT(1)

        keyCUBE_StartIndex = self.input.index()

        root_0 = None

        ID1408 = None

        ID1408_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 260):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1340:34: ({...}? ID )
                # ./output/PLSQL3.g:1340:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "CUBE")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyCUBE", "(self.input).LT(1).text.upper() == \"CUBE\"")


                ID1408 = self.match(self.input, ID, self.FOLLOW_ID_in_keyCUBE8507)
                if self._state.backtracking == 0:
                    ID1408_tree = self._adaptor.createWithPayload(ID1408)
                    self._adaptor.addChild(root_0, ID1408_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 260, keyCUBE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyCUBE"


    class keyCURRENT_OF_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyCURRENT_OF_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyCURRENT_OF"
    # ./output/PLSQL3.g:1341:1: keyCURRENT_OF :{...}? ID ;
    def keyCURRENT_OF(self, ):
        retval = self.keyCURRENT_OF_return()
        retval.start = self.input.LT(1)

        keyCURRENT_OF_StartIndex = self.input.index()

        root_0 = None

        ID1409 = None

        ID1409_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 261):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1341:34: ({...}? ID )
                # ./output/PLSQL3.g:1341:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "CURRENT_OF")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyCURRENT_OF", "(self.input).LT(1).text.upper() == \"CURRENT_OF\"")


                ID1409 = self.match(self.input, ID, self.FOLLOW_ID_in_keyCURRENT_OF8535)
                if self._state.backtracking == 0:
                    ID1409_tree = self._adaptor.createWithPayload(ID1409)
                    self._adaptor.addChild(root_0, ID1409_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 261, keyCURRENT_OF_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyCURRENT_OF"


    class keyDAY_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyDAY_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyDAY"
    # ./output/PLSQL3.g:1342:1: keyDAY :{...}? ID ;
    def keyDAY(self, ):
        retval = self.keyDAY_return()
        retval.start = self.input.LT(1)

        keyDAY_StartIndex = self.input.index()

        root_0 = None

        ID1410 = None

        ID1410_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 262):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1342:34: ({...}? ID )
                # ./output/PLSQL3.g:1342:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "DAY")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyDAY", "(self.input).LT(1).text.upper() == \"DAY\"")


                ID1410 = self.match(self.input, ID, self.FOLLOW_ID_in_keyDAY8570)
                if self._state.backtracking == 0:
                    ID1410_tree = self._adaptor.createWithPayload(ID1410)
                    self._adaptor.addChild(root_0, ID1410_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 262, keyDAY_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyDAY"


    class keyDBTIMEZONE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyDBTIMEZONE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyDBTIMEZONE"
    # ./output/PLSQL3.g:1343:1: keyDBTIMEZONE :{...}? ID ;
    def keyDBTIMEZONE(self, ):
        retval = self.keyDBTIMEZONE_return()
        retval.start = self.input.LT(1)

        keyDBTIMEZONE_StartIndex = self.input.index()

        root_0 = None

        ID1411 = None

        ID1411_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 263):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1343:34: ({...}? ID )
                # ./output/PLSQL3.g:1343:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "DBTIMEZONE")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyDBTIMEZONE", "(self.input).LT(1).text.upper() == \"DBTIMEZONE\"")


                ID1411 = self.match(self.input, ID, self.FOLLOW_ID_in_keyDBTIMEZONE8598)
                if self._state.backtracking == 0:
                    ID1411_tree = self._adaptor.createWithPayload(ID1411)
                    self._adaptor.addChild(root_0, ID1411_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 263, keyDBTIMEZONE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyDBTIMEZONE"


    class keyDECREMENT_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyDECREMENT_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyDECREMENT"
    # ./output/PLSQL3.g:1344:1: keyDECREMENT :{...}? ID ;
    def keyDECREMENT(self, ):
        retval = self.keyDECREMENT_return()
        retval.start = self.input.LT(1)

        keyDECREMENT_StartIndex = self.input.index()

        root_0 = None

        ID1412 = None

        ID1412_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 264):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1344:34: ({...}? ID )
                # ./output/PLSQL3.g:1344:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "DECREMENT")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyDECREMENT", "(self.input).LT(1).text.upper() == \"DECREMENT\"")


                ID1412 = self.match(self.input, ID, self.FOLLOW_ID_in_keyDECREMENT8627)
                if self._state.backtracking == 0:
                    ID1412_tree = self._adaptor.createWithPayload(ID1412)
                    self._adaptor.addChild(root_0, ID1412_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 264, keyDECREMENT_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyDECREMENT"


    class keyDIMENSION_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyDIMENSION_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyDIMENSION"
    # ./output/PLSQL3.g:1345:1: keyDIMENSION :{...}? ID ;
    def keyDIMENSION(self, ):
        retval = self.keyDIMENSION_return()
        retval.start = self.input.LT(1)

        keyDIMENSION_StartIndex = self.input.index()

        root_0 = None

        ID1413 = None

        ID1413_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 265):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1345:34: ({...}? ID )
                # ./output/PLSQL3.g:1345:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "DIMENSION")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyDIMENSION", "(self.input).LT(1).text.upper() == \"DIMENSION\"")


                ID1413 = self.match(self.input, ID, self.FOLLOW_ID_in_keyDIMENSION8656)
                if self._state.backtracking == 0:
                    ID1413_tree = self._adaptor.createWithPayload(ID1413)
                    self._adaptor.addChild(root_0, ID1413_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 265, keyDIMENSION_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyDIMENSION"


    class keyEMPTY_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyEMPTY_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyEMPTY"
    # ./output/PLSQL3.g:1346:1: keyEMPTY :{...}? ID ;
    def keyEMPTY(self, ):
        retval = self.keyEMPTY_return()
        retval.start = self.input.LT(1)

        keyEMPTY_StartIndex = self.input.index()

        root_0 = None

        ID1414 = None

        ID1414_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 266):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1346:34: ({...}? ID )
                # ./output/PLSQL3.g:1346:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "EMPTY")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyEMPTY", "(self.input).LT(1).text.upper() == \"EMPTY\"")


                ID1414 = self.match(self.input, ID, self.FOLLOW_ID_in_keyEMPTY8689)
                if self._state.backtracking == 0:
                    ID1414_tree = self._adaptor.createWithPayload(ID1414)
                    self._adaptor.addChild(root_0, ID1414_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 266, keyEMPTY_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyEMPTY"


    class keyEQUALS_PATH_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyEQUALS_PATH_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyEQUALS_PATH"
    # ./output/PLSQL3.g:1347:1: keyEQUALS_PATH :{...}? ID ;
    def keyEQUALS_PATH(self, ):
        retval = self.keyEQUALS_PATH_return()
        retval.start = self.input.LT(1)

        keyEQUALS_PATH_StartIndex = self.input.index()

        root_0 = None

        ID1415 = None

        ID1415_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 267):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1347:34: ({...}? ID )
                # ./output/PLSQL3.g:1347:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "EQUALS_PATH")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyEQUALS_PATH", "(self.input).LT(1).text.upper() == \"EQUALS_PATH\"")


                ID1415 = self.match(self.input, ID, self.FOLLOW_ID_in_keyEQUALS_PATH8716)
                if self._state.backtracking == 0:
                    ID1415_tree = self._adaptor.createWithPayload(ID1415)
                    self._adaptor.addChild(root_0, ID1415_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 267, keyEQUALS_PATH_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyEQUALS_PATH"


    class keyESCAPE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyESCAPE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyESCAPE"
    # ./output/PLSQL3.g:1348:1: keyESCAPE :{...}? ID ;
    def keyESCAPE(self, ):
        retval = self.keyESCAPE_return()
        retval.start = self.input.LT(1)

        keyESCAPE_StartIndex = self.input.index()

        root_0 = None

        ID1416 = None

        ID1416_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 268):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1348:34: ({...}? ID )
                # ./output/PLSQL3.g:1348:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "ESCAPE")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyESCAPE", "(self.input).LT(1).text.upper() == \"ESCAPE\"")


                ID1416 = self.match(self.input, ID, self.FOLLOW_ID_in_keyESCAPE8748)
                if self._state.backtracking == 0:
                    ID1416_tree = self._adaptor.createWithPayload(ID1416)
                    self._adaptor.addChild(root_0, ID1416_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 268, keyESCAPE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyESCAPE"


    class keyFIRST_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyFIRST_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyFIRST"
    # ./output/PLSQL3.g:1349:1: keyFIRST :{...}? ID ;
    def keyFIRST(self, ):
        retval = self.keyFIRST_return()
        retval.start = self.input.LT(1)

        keyFIRST_StartIndex = self.input.index()

        root_0 = None

        ID1417 = None

        ID1417_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 269):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1349:34: ({...}? ID )
                # ./output/PLSQL3.g:1349:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "FIRST")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyFIRST", "(self.input).LT(1).text.upper() == \"FIRST\"")


                ID1417 = self.match(self.input, ID, self.FOLLOW_ID_in_keyFIRST8781)
                if self._state.backtracking == 0:
                    ID1417_tree = self._adaptor.createWithPayload(ID1417)
                    self._adaptor.addChild(root_0, ID1417_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 269, keyFIRST_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyFIRST"


    class keyFULL_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyFULL_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyFULL"
    # ./output/PLSQL3.g:1350:1: keyFULL :{...}? ID ;
    def keyFULL(self, ):
        retval = self.keyFULL_return()
        retval.start = self.input.LT(1)

        keyFULL_StartIndex = self.input.index()

        root_0 = None

        ID1418 = None

        ID1418_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 270):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1350:34: ({...}? ID )
                # ./output/PLSQL3.g:1350:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "FULL")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyFULL", "(self.input).LT(1).text.upper() == \"FULL\"")


                ID1418 = self.match(self.input, ID, self.FOLLOW_ID_in_keyFULL8815)
                if self._state.backtracking == 0:
                    ID1418_tree = self._adaptor.createWithPayload(ID1418)
                    self._adaptor.addChild(root_0, ID1418_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 270, keyFULL_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyFULL"


    class keyGROUPING_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyGROUPING_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyGROUPING"
    # ./output/PLSQL3.g:1351:1: keyGROUPING :{...}? ID ;
    def keyGROUPING(self, ):
        retval = self.keyGROUPING_return()
        retval.start = self.input.LT(1)

        keyGROUPING_StartIndex = self.input.index()

        root_0 = None

        ID1419 = None

        ID1419_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 271):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1351:34: ({...}? ID )
                # ./output/PLSQL3.g:1351:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "GROUPING")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyGROUPING", "(self.input).LT(1).text.upper() == \"GROUPING\"")


                ID1419 = self.match(self.input, ID, self.FOLLOW_ID_in_keyGROUPING8845)
                if self._state.backtracking == 0:
                    ID1419_tree = self._adaptor.createWithPayload(ID1419)
                    self._adaptor.addChild(root_0, ID1419_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 271, keyGROUPING_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyGROUPING"


    class keyIGNORE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyIGNORE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyIGNORE"
    # ./output/PLSQL3.g:1352:1: keyIGNORE :{...}? ID ;
    def keyIGNORE(self, ):
        retval = self.keyIGNORE_return()
        retval.start = self.input.LT(1)

        keyIGNORE_StartIndex = self.input.index()

        root_0 = None

        ID1420 = None

        ID1420_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 272):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1352:34: ({...}? ID )
                # ./output/PLSQL3.g:1352:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "IGNORE")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyIGNORE", "(self.input).LT(1).text.upper() == \"IGNORE\"")


                ID1420 = self.match(self.input, ID, self.FOLLOW_ID_in_keyIGNORE8877)
                if self._state.backtracking == 0:
                    ID1420_tree = self._adaptor.createWithPayload(ID1420)
                    self._adaptor.addChild(root_0, ID1420_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 272, keyIGNORE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyIGNORE"


    class keyINCREMENT_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyINCREMENT_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyINCREMENT"
    # ./output/PLSQL3.g:1353:1: keyINCREMENT :{...}? ID ;
    def keyINCREMENT(self, ):
        retval = self.keyINCREMENT_return()
        retval.start = self.input.LT(1)

        keyINCREMENT_StartIndex = self.input.index()

        root_0 = None

        ID1421 = None

        ID1421_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 273):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1353:34: ({...}? ID )
                # ./output/PLSQL3.g:1353:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "INCREMENT")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyINCREMENT", "(self.input).LT(1).text.upper() == \"INCREMENT\"")


                ID1421 = self.match(self.input, ID, self.FOLLOW_ID_in_keyINCREMENT8906)
                if self._state.backtracking == 0:
                    ID1421_tree = self._adaptor.createWithPayload(ID1421)
                    self._adaptor.addChild(root_0, ID1421_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 273, keyINCREMENT_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyINCREMENT"


    class keyINFINITE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyINFINITE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyINFINITE"
    # ./output/PLSQL3.g:1354:1: keyINFINITE :{...}? ID ;
    def keyINFINITE(self, ):
        retval = self.keyINFINITE_return()
        retval.start = self.input.LT(1)

        keyINFINITE_StartIndex = self.input.index()

        root_0 = None

        ID1422 = None

        ID1422_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 274):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1354:34: ({...}? ID )
                # ./output/PLSQL3.g:1354:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "INFINITE")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyINFINITE", "(self.input).LT(1).text.upper() == \"INFINITE\"")


                ID1422 = self.match(self.input, ID, self.FOLLOW_ID_in_keyINFINITE8936)
                if self._state.backtracking == 0:
                    ID1422_tree = self._adaptor.createWithPayload(ID1422)
                    self._adaptor.addChild(root_0, ID1422_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 274, keyINFINITE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyINFINITE"


    class keyINNER_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyINNER_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyINNER"
    # ./output/PLSQL3.g:1355:1: keyINNER :{...}? ID ;
    def keyINNER(self, ):
        retval = self.keyINNER_return()
        retval.start = self.input.LT(1)

        keyINNER_StartIndex = self.input.index()

        root_0 = None

        ID1423 = None

        ID1423_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 275):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1355:34: ({...}? ID )
                # ./output/PLSQL3.g:1355:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "INNER")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyINNER", "(self.input).LT(1).text.upper() == \"INNER\"")


                ID1423 = self.match(self.input, ID, self.FOLLOW_ID_in_keyINNER8969)
                if self._state.backtracking == 0:
                    ID1423_tree = self._adaptor.createWithPayload(ID1423)
                    self._adaptor.addChild(root_0, ID1423_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 275, keyINNER_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyINNER"


    class keyINTERVAL_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyINTERVAL_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyINTERVAL"
    # ./output/PLSQL3.g:1356:1: keyINTERVAL :{...}? ID ;
    def keyINTERVAL(self, ):
        retval = self.keyINTERVAL_return()
        retval.start = self.input.LT(1)

        keyINTERVAL_StartIndex = self.input.index()

        root_0 = None

        ID1424 = None

        ID1424_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 276):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1356:34: ({...}? ID )
                # ./output/PLSQL3.g:1356:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "INTERVAL")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyINTERVAL", "(self.input).LT(1).text.upper() == \"INTERVAL\"")


                ID1424 = self.match(self.input, ID, self.FOLLOW_ID_in_keyINTERVAL8999)
                if self._state.backtracking == 0:
                    ID1424_tree = self._adaptor.createWithPayload(ID1424)
                    self._adaptor.addChild(root_0, ID1424_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 276, keyINTERVAL_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyINTERVAL"


    class keyITERATE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyITERATE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyITERATE"
    # ./output/PLSQL3.g:1357:1: keyITERATE :{...}? ID ;
    def keyITERATE(self, ):
        retval = self.keyITERATE_return()
        retval.start = self.input.LT(1)

        keyITERATE_StartIndex = self.input.index()

        root_0 = None

        ID1425 = None

        ID1425_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 277):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1357:34: ({...}? ID )
                # ./output/PLSQL3.g:1357:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "ITERATE")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyITERATE", "(self.input).LT(1).text.upper() == \"ITERATE\"")


                ID1425 = self.match(self.input, ID, self.FOLLOW_ID_in_keyITERATE9030)
                if self._state.backtracking == 0:
                    ID1425_tree = self._adaptor.createWithPayload(ID1425)
                    self._adaptor.addChild(root_0, ID1425_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 277, keyITERATE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyITERATE"


    class keyJOIN_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyJOIN_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyJOIN"
    # ./output/PLSQL3.g:1358:1: keyJOIN :{...}? ID ;
    def keyJOIN(self, ):
        retval = self.keyJOIN_return()
        retval.start = self.input.LT(1)

        keyJOIN_StartIndex = self.input.index()

        root_0 = None

        ID1426 = None

        ID1426_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 278):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1358:34: ({...}? ID )
                # ./output/PLSQL3.g:1358:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "JOIN")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyJOIN", "(self.input).LT(1).text.upper() == \"JOIN\"")


                ID1426 = self.match(self.input, ID, self.FOLLOW_ID_in_keyJOIN9064)
                if self._state.backtracking == 0:
                    ID1426_tree = self._adaptor.createWithPayload(ID1426)
                    self._adaptor.addChild(root_0, ID1426_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 278, keyJOIN_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyJOIN"


    class keyKEEP_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyKEEP_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyKEEP"
    # ./output/PLSQL3.g:1359:1: keyKEEP :{...}? ID ;
    def keyKEEP(self, ):
        retval = self.keyKEEP_return()
        retval.start = self.input.LT(1)

        keyKEEP_StartIndex = self.input.index()

        root_0 = None

        ID1427 = None

        ID1427_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 279):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1359:34: ({...}? ID )
                # ./output/PLSQL3.g:1359:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "KEEP")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyKEEP", "(self.input).LT(1).text.upper() == \"KEEP\"")


                ID1427 = self.match(self.input, ID, self.FOLLOW_ID_in_keyKEEP9098)
                if self._state.backtracking == 0:
                    ID1427_tree = self._adaptor.createWithPayload(ID1427)
                    self._adaptor.addChild(root_0, ID1427_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 279, keyKEEP_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyKEEP"


    class keyLAST_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyLAST_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyLAST"
    # ./output/PLSQL3.g:1360:1: keyLAST :{...}? ID ;
    def keyLAST(self, ):
        retval = self.keyLAST_return()
        retval.start = self.input.LT(1)

        keyLAST_StartIndex = self.input.index()

        root_0 = None

        ID1428 = None

        ID1428_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 280):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1360:34: ({...}? ID )
                # ./output/PLSQL3.g:1360:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "LAST")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyLAST", "(self.input).LT(1).text.upper() == \"LAST\"")


                ID1428 = self.match(self.input, ID, self.FOLLOW_ID_in_keyLAST9132)
                if self._state.backtracking == 0:
                    ID1428_tree = self._adaptor.createWithPayload(ID1428)
                    self._adaptor.addChild(root_0, ID1428_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 280, keyLAST_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyLAST"


    class keyLEFT_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyLEFT_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyLEFT"
    # ./output/PLSQL3.g:1361:1: keyLEFT :{...}? ID ;
    def keyLEFT(self, ):
        retval = self.keyLEFT_return()
        retval.start = self.input.LT(1)

        keyLEFT_StartIndex = self.input.index()

        root_0 = None

        ID1429 = None

        ID1429_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 281):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1361:34: ({...}? ID )
                # ./output/PLSQL3.g:1361:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "LEFT")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyLEFT", "(self.input).LT(1).text.upper() == \"LEFT\"")


                ID1429 = self.match(self.input, ID, self.FOLLOW_ID_in_keyLEFT9166)
                if self._state.backtracking == 0:
                    ID1429_tree = self._adaptor.createWithPayload(ID1429)
                    self._adaptor.addChild(root_0, ID1429_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 281, keyLEFT_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyLEFT"


    class keyLIKE2_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyLIKE2_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyLIKE2"
    # ./output/PLSQL3.g:1362:1: keyLIKE2 :{...}? ID ;
    def keyLIKE2(self, ):
        retval = self.keyLIKE2_return()
        retval.start = self.input.LT(1)

        keyLIKE2_StartIndex = self.input.index()

        root_0 = None

        ID1430 = None

        ID1430_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 282):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1362:34: ({...}? ID )
                # ./output/PLSQL3.g:1362:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "LIKE2")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyLIKE2", "(self.input).LT(1).text.upper() == \"LIKE2\"")


                ID1430 = self.match(self.input, ID, self.FOLLOW_ID_in_keyLIKE29199)
                if self._state.backtracking == 0:
                    ID1430_tree = self._adaptor.createWithPayload(ID1430)
                    self._adaptor.addChild(root_0, ID1430_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 282, keyLIKE2_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyLIKE2"


    class keyLIKE4_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyLIKE4_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyLIKE4"
    # ./output/PLSQL3.g:1363:1: keyLIKE4 :{...}? ID ;
    def keyLIKE4(self, ):
        retval = self.keyLIKE4_return()
        retval.start = self.input.LT(1)

        keyLIKE4_StartIndex = self.input.index()

        root_0 = None

        ID1431 = None

        ID1431_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 283):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1363:34: ({...}? ID )
                # ./output/PLSQL3.g:1363:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "LIKE4")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyLIKE4", "(self.input).LT(1).text.upper() == \"LIKE4\"")


                ID1431 = self.match(self.input, ID, self.FOLLOW_ID_in_keyLIKE49232)
                if self._state.backtracking == 0:
                    ID1431_tree = self._adaptor.createWithPayload(ID1431)
                    self._adaptor.addChild(root_0, ID1431_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 283, keyLIKE4_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyLIKE4"


    class keyLIKEC_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyLIKEC_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyLIKEC"
    # ./output/PLSQL3.g:1364:1: keyLIKEC :{...}? ID ;
    def keyLIKEC(self, ):
        retval = self.keyLIKEC_return()
        retval.start = self.input.LT(1)

        keyLIKEC_StartIndex = self.input.index()

        root_0 = None

        ID1432 = None

        ID1432_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 284):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1364:34: ({...}? ID )
                # ./output/PLSQL3.g:1364:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "LIKEC")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyLIKEC", "(self.input).LT(1).text.upper() == \"LIKEC\"")


                ID1432 = self.match(self.input, ID, self.FOLLOW_ID_in_keyLIKEC9265)
                if self._state.backtracking == 0:
                    ID1432_tree = self._adaptor.createWithPayload(ID1432)
                    self._adaptor.addChild(root_0, ID1432_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 284, keyLIKEC_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyLIKEC"


    class keyLOCAL_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyLOCAL_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyLOCAL"
    # ./output/PLSQL3.g:1365:1: keyLOCAL :{...}? ID ;
    def keyLOCAL(self, ):
        retval = self.keyLOCAL_return()
        retval.start = self.input.LT(1)

        keyLOCAL_StartIndex = self.input.index()

        root_0 = None

        ID1433 = None

        ID1433_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 285):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1365:34: ({...}? ID )
                # ./output/PLSQL3.g:1365:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "LOCAL")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyLOCAL", "(self.input).LT(1).text.upper() == \"LOCAL\"")


                ID1433 = self.match(self.input, ID, self.FOLLOW_ID_in_keyLOCAL9298)
                if self._state.backtracking == 0:
                    ID1433_tree = self._adaptor.createWithPayload(ID1433)
                    self._adaptor.addChild(root_0, ID1433_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 285, keyLOCAL_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyLOCAL"


    class keyMAIN_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyMAIN_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyMAIN"
    # ./output/PLSQL3.g:1366:1: keyMAIN :{...}? ID ;
    def keyMAIN(self, ):
        retval = self.keyMAIN_return()
        retval.start = self.input.LT(1)

        keyMAIN_StartIndex = self.input.index()

        root_0 = None

        ID1434 = None

        ID1434_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 286):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1366:34: ({...}? ID )
                # ./output/PLSQL3.g:1366:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "MAIN")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyMAIN", "(self.input).LT(1).text.upper() == \"MAIN\"")


                ID1434 = self.match(self.input, ID, self.FOLLOW_ID_in_keyMAIN9332)
                if self._state.backtracking == 0:
                    ID1434_tree = self._adaptor.createWithPayload(ID1434)
                    self._adaptor.addChild(root_0, ID1434_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 286, keyMAIN_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyMAIN"


    class keyMEASURES_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyMEASURES_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyMEASURES"
    # ./output/PLSQL3.g:1367:1: keyMEASURES :{...}? ID ;
    def keyMEASURES(self, ):
        retval = self.keyMEASURES_return()
        retval.start = self.input.LT(1)

        keyMEASURES_StartIndex = self.input.index()

        root_0 = None

        ID1435 = None

        ID1435_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 287):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1367:34: ({...}? ID )
                # ./output/PLSQL3.g:1367:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "MEASURES")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyMEASURES", "(self.input).LT(1).text.upper() == \"MEASURES\"")


                ID1435 = self.match(self.input, ID, self.FOLLOW_ID_in_keyMEASURES9362)
                if self._state.backtracking == 0:
                    ID1435_tree = self._adaptor.createWithPayload(ID1435)
                    self._adaptor.addChild(root_0, ID1435_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 287, keyMEASURES_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyMEASURES"


    class keyMEMBER_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyMEMBER_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyMEMBER"
    # ./output/PLSQL3.g:1368:1: keyMEMBER :{...}? ID ;
    def keyMEMBER(self, ):
        retval = self.keyMEMBER_return()
        retval.start = self.input.LT(1)

        keyMEMBER_StartIndex = self.input.index()

        root_0 = None

        ID1436 = None

        ID1436_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 288):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1368:34: ({...}? ID )
                # ./output/PLSQL3.g:1368:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "MEMBER")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyMEMBER", "(self.input).LT(1).text.upper() == \"MEMBER\"")


                ID1436 = self.match(self.input, ID, self.FOLLOW_ID_in_keyMEMBER9394)
                if self._state.backtracking == 0:
                    ID1436_tree = self._adaptor.createWithPayload(ID1436)
                    self._adaptor.addChild(root_0, ID1436_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 288, keyMEMBER_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyMEMBER"


    class keyMODEL_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyMODEL_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyMODEL"
    # ./output/PLSQL3.g:1369:1: keyMODEL :{...}? ID ;
    def keyMODEL(self, ):
        retval = self.keyMODEL_return()
        retval.start = self.input.LT(1)

        keyMODEL_StartIndex = self.input.index()

        root_0 = None

        ID1437 = None

        ID1437_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 289):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1369:34: ({...}? ID )
                # ./output/PLSQL3.g:1369:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "MODEL")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyMODEL", "(self.input).LT(1).text.upper() == \"MODEL\"")


                ID1437 = self.match(self.input, ID, self.FOLLOW_ID_in_keyMODEL9427)
                if self._state.backtracking == 0:
                    ID1437_tree = self._adaptor.createWithPayload(ID1437)
                    self._adaptor.addChild(root_0, ID1437_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 289, keyMODEL_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyMODEL"


    class keyMONTH_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyMONTH_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyMONTH"
    # ./output/PLSQL3.g:1370:1: keyMONTH :{...}? ID ;
    def keyMONTH(self, ):
        retval = self.keyMONTH_return()
        retval.start = self.input.LT(1)

        keyMONTH_StartIndex = self.input.index()

        root_0 = None

        ID1438 = None

        ID1438_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 290):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1370:34: ({...}? ID )
                # ./output/PLSQL3.g:1370:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "MONTH")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyMONTH", "(self.input).LT(1).text.upper() == \"MONTH\"")


                ID1438 = self.match(self.input, ID, self.FOLLOW_ID_in_keyMONTH9460)
                if self._state.backtracking == 0:
                    ID1438_tree = self._adaptor.createWithPayload(ID1438)
                    self._adaptor.addChild(root_0, ID1438_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 290, keyMONTH_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyMONTH"


    class keyNAN_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyNAN_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyNAN"
    # ./output/PLSQL3.g:1371:1: keyNAN :{...}? ID ;
    def keyNAN(self, ):
        retval = self.keyNAN_return()
        retval.start = self.input.LT(1)

        keyNAN_StartIndex = self.input.index()

        root_0 = None

        ID1439 = None

        ID1439_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 291):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1371:34: ({...}? ID )
                # ./output/PLSQL3.g:1371:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "NAN")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyNAN", "(self.input).LT(1).text.upper() == \"NAN\"")


                ID1439 = self.match(self.input, ID, self.FOLLOW_ID_in_keyNAN9495)
                if self._state.backtracking == 0:
                    ID1439_tree = self._adaptor.createWithPayload(ID1439)
                    self._adaptor.addChild(root_0, ID1439_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 291, keyNAN_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyNAN"


    class keyNATURAL_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyNATURAL_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyNATURAL"
    # ./output/PLSQL3.g:1372:1: keyNATURAL :{...}? ID ;
    def keyNATURAL(self, ):
        retval = self.keyNATURAL_return()
        retval.start = self.input.LT(1)

        keyNATURAL_StartIndex = self.input.index()

        root_0 = None

        ID1440 = None

        ID1440_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 292):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1372:34: ({...}? ID )
                # ./output/PLSQL3.g:1372:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "NATURAL")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyNATURAL", "(self.input).LT(1).text.upper() == \"NATURAL\"")


                ID1440 = self.match(self.input, ID, self.FOLLOW_ID_in_keyNATURAL9526)
                if self._state.backtracking == 0:
                    ID1440_tree = self._adaptor.createWithPayload(ID1440)
                    self._adaptor.addChild(root_0, ID1440_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 292, keyNATURAL_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyNATURAL"


    class keyNAV_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyNAV_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyNAV"
    # ./output/PLSQL3.g:1373:1: keyNAV :{...}? ID ;
    def keyNAV(self, ):
        retval = self.keyNAV_return()
        retval.start = self.input.LT(1)

        keyNAV_StartIndex = self.input.index()

        root_0 = None

        ID1441 = None

        ID1441_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 293):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1373:34: ({...}? ID )
                # ./output/PLSQL3.g:1373:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "NAV")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyNAV", "(self.input).LT(1).text.upper() == \"NAV\"")


                ID1441 = self.match(self.input, ID, self.FOLLOW_ID_in_keyNAV9561)
                if self._state.backtracking == 0:
                    ID1441_tree = self._adaptor.createWithPayload(ID1441)
                    self._adaptor.addChild(root_0, ID1441_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 293, keyNAV_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyNAV"


    class keyNOCYCLE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyNOCYCLE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyNOCYCLE"
    # ./output/PLSQL3.g:1374:1: keyNOCYCLE :{...}? ID ;
    def keyNOCYCLE(self, ):
        retval = self.keyNOCYCLE_return()
        retval.start = self.input.LT(1)

        keyNOCYCLE_StartIndex = self.input.index()

        root_0 = None

        ID1442 = None

        ID1442_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 294):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1374:34: ({...}? ID )
                # ./output/PLSQL3.g:1374:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "NOCYCLE")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyNOCYCLE", "(self.input).LT(1).text.upper() == \"NOCYCLE\"")


                ID1442 = self.match(self.input, ID, self.FOLLOW_ID_in_keyNOCYCLE9592)
                if self._state.backtracking == 0:
                    ID1442_tree = self._adaptor.createWithPayload(ID1442)
                    self._adaptor.addChild(root_0, ID1442_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 294, keyNOCYCLE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyNOCYCLE"


    class keyNULLS_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyNULLS_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyNULLS"
    # ./output/PLSQL3.g:1375:1: keyNULLS :{...}? ID ;
    def keyNULLS(self, ):
        retval = self.keyNULLS_return()
        retval.start = self.input.LT(1)

        keyNULLS_StartIndex = self.input.index()

        root_0 = None

        ID1443 = None

        ID1443_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 295):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1375:34: ({...}? ID )
                # ./output/PLSQL3.g:1375:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "NULLS")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyNULLS", "(self.input).LT(1).text.upper() == \"NULLS\"")


                ID1443 = self.match(self.input, ID, self.FOLLOW_ID_in_keyNULLS9625)
                if self._state.backtracking == 0:
                    ID1443_tree = self._adaptor.createWithPayload(ID1443)
                    self._adaptor.addChild(root_0, ID1443_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 295, keyNULLS_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyNULLS"


    class keyONLY_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyONLY_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyONLY"
    # ./output/PLSQL3.g:1376:1: keyONLY :{...}? ID ;
    def keyONLY(self, ):
        retval = self.keyONLY_return()
        retval.start = self.input.LT(1)

        keyONLY_StartIndex = self.input.index()

        root_0 = None

        ID1444 = None

        ID1444_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 296):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1376:34: ({...}? ID )
                # ./output/PLSQL3.g:1376:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "ONLY")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyONLY", "(self.input).LT(1).text.upper() == \"ONLY\"")


                ID1444 = self.match(self.input, ID, self.FOLLOW_ID_in_keyONLY9659)
                if self._state.backtracking == 0:
                    ID1444_tree = self._adaptor.createWithPayload(ID1444)
                    self._adaptor.addChild(root_0, ID1444_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 296, keyONLY_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyONLY"


    class keyOUTER_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyOUTER_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyOUTER"
    # ./output/PLSQL3.g:1377:1: keyOUTER :{...}? ID ;
    def keyOUTER(self, ):
        retval = self.keyOUTER_return()
        retval.start = self.input.LT(1)

        keyOUTER_StartIndex = self.input.index()

        root_0 = None

        ID1445 = None

        ID1445_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 297):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1377:34: ({...}? ID )
                # ./output/PLSQL3.g:1377:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "OUTER")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyOUTER", "(self.input).LT(1).text.upper() == \"OUTER\"")


                ID1445 = self.match(self.input, ID, self.FOLLOW_ID_in_keyOUTER9692)
                if self._state.backtracking == 0:
                    ID1445_tree = self._adaptor.createWithPayload(ID1445)
                    self._adaptor.addChild(root_0, ID1445_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 297, keyOUTER_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyOUTER"


    class keyPARTITION_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyPARTITION_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyPARTITION"
    # ./output/PLSQL3.g:1378:1: keyPARTITION :{...}? ID ;
    def keyPARTITION(self, ):
        retval = self.keyPARTITION_return()
        retval.start = self.input.LT(1)

        keyPARTITION_StartIndex = self.input.index()

        root_0 = None

        ID1446 = None

        ID1446_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 298):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1378:34: ({...}? ID )
                # ./output/PLSQL3.g:1378:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "PARTITION")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyPARTITION", "(self.input).LT(1).text.upper() == \"PARTITION\"")


                ID1446 = self.match(self.input, ID, self.FOLLOW_ID_in_keyPARTITION9721)
                if self._state.backtracking == 0:
                    ID1446_tree = self._adaptor.createWithPayload(ID1446)
                    self._adaptor.addChild(root_0, ID1446_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 298, keyPARTITION_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyPARTITION"


    class keyPRECISION_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyPRECISION_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyPRECISION"
    # ./output/PLSQL3.g:1379:1: keyPRECISION :{...}? ID ;
    def keyPRECISION(self, ):
        retval = self.keyPRECISION_return()
        retval.start = self.input.LT(1)

        keyPRECISION_StartIndex = self.input.index()

        root_0 = None

        ID1447 = None

        ID1447_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 299):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1379:34: ({...}? ID )
                # ./output/PLSQL3.g:1379:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "PRECISION")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyPRECISION", "(self.input).LT(1).text.upper() == \"PRECISION\"")


                ID1447 = self.match(self.input, ID, self.FOLLOW_ID_in_keyPRECISION9750)
                if self._state.backtracking == 0:
                    ID1447_tree = self._adaptor.createWithPayload(ID1447)
                    self._adaptor.addChild(root_0, ID1447_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 299, keyPRECISION_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyPRECISION"


    class keyPRESENT_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyPRESENT_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyPRESENT"
    # ./output/PLSQL3.g:1380:1: keyPRESENT :{...}? ID ;
    def keyPRESENT(self, ):
        retval = self.keyPRESENT_return()
        retval.start = self.input.LT(1)

        keyPRESENT_StartIndex = self.input.index()

        root_0 = None

        ID1448 = None

        ID1448_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 300):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1380:34: ({...}? ID )
                # ./output/PLSQL3.g:1380:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "PRESENT")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyPRESENT", "(self.input).LT(1).text.upper() == \"PRESENT\"")


                ID1448 = self.match(self.input, ID, self.FOLLOW_ID_in_keyPRESENT9781)
                if self._state.backtracking == 0:
                    ID1448_tree = self._adaptor.createWithPayload(ID1448)
                    self._adaptor.addChild(root_0, ID1448_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 300, keyPRESENT_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyPRESENT"


    class keyREFERENCE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyREFERENCE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyREFERENCE"
    # ./output/PLSQL3.g:1381:1: keyREFERENCE :{...}? ID ;
    def keyREFERENCE(self, ):
        retval = self.keyREFERENCE_return()
        retval.start = self.input.LT(1)

        keyREFERENCE_StartIndex = self.input.index()

        root_0 = None

        ID1449 = None

        ID1449_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 301):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1381:34: ({...}? ID )
                # ./output/PLSQL3.g:1381:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "REFERENCE")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyREFERENCE", "(self.input).LT(1).text.upper() == \"REFERENCE\"")


                ID1449 = self.match(self.input, ID, self.FOLLOW_ID_in_keyREFERENCE9810)
                if self._state.backtracking == 0:
                    ID1449_tree = self._adaptor.createWithPayload(ID1449)
                    self._adaptor.addChild(root_0, ID1449_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 301, keyREFERENCE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyREFERENCE"


    class keyREGEXP_LIKE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyREGEXP_LIKE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyREGEXP_LIKE"
    # ./output/PLSQL3.g:1382:1: keyREGEXP_LIKE :{...}? ID ;
    def keyREGEXP_LIKE(self, ):
        retval = self.keyREGEXP_LIKE_return()
        retval.start = self.input.LT(1)

        keyREGEXP_LIKE_StartIndex = self.input.index()

        root_0 = None

        ID1450 = None

        ID1450_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 302):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1382:34: ({...}? ID )
                # ./output/PLSQL3.g:1382:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "REGEXP_LIKE")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyREGEXP_LIKE", "(self.input).LT(1).text.upper() == \"REGEXP_LIKE\"")


                ID1450 = self.match(self.input, ID, self.FOLLOW_ID_in_keyREGEXP_LIKE9837)
                if self._state.backtracking == 0:
                    ID1450_tree = self._adaptor.createWithPayload(ID1450)
                    self._adaptor.addChild(root_0, ID1450_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 302, keyREGEXP_LIKE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyREGEXP_LIKE"


    class keyRIGHT_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyRIGHT_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyRIGHT"
    # ./output/PLSQL3.g:1384:1: keyRIGHT :{...}? ID ;
    def keyRIGHT(self, ):
        retval = self.keyRIGHT_return()
        retval.start = self.input.LT(1)

        keyRIGHT_StartIndex = self.input.index()

        root_0 = None

        ID1451 = None

        ID1451_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 303):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1384:34: ({...}? ID )
                # ./output/PLSQL3.g:1384:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "RIGHT")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyRIGHT", "(self.input).LT(1).text.upper() == \"RIGHT\"")


                ID1451 = self.match(self.input, ID, self.FOLLOW_ID_in_keyRIGHT9871)
                if self._state.backtracking == 0:
                    ID1451_tree = self._adaptor.createWithPayload(ID1451)
                    self._adaptor.addChild(root_0, ID1451_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 303, keyRIGHT_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyRIGHT"


    class keyROLLUP_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyROLLUP_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyROLLUP"
    # ./output/PLSQL3.g:1385:1: keyROLLUP :{...}? ID ;
    def keyROLLUP(self, ):
        retval = self.keyROLLUP_return()
        retval.start = self.input.LT(1)

        keyROLLUP_StartIndex = self.input.index()

        root_0 = None

        ID1452 = None

        ID1452_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 304):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1385:34: ({...}? ID )
                # ./output/PLSQL3.g:1385:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "ROLLUP")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyROLLUP", "(self.input).LT(1).text.upper() == \"ROLLUP\"")


                ID1452 = self.match(self.input, ID, self.FOLLOW_ID_in_keyROLLUP9903)
                if self._state.backtracking == 0:
                    ID1452_tree = self._adaptor.createWithPayload(ID1452)
                    self._adaptor.addChild(root_0, ID1452_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 304, keyROLLUP_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyROLLUP"


    class keyRULES_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyRULES_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyRULES"
    # ./output/PLSQL3.g:1386:1: keyRULES :{...}? ID ;
    def keyRULES(self, ):
        retval = self.keyRULES_return()
        retval.start = self.input.LT(1)

        keyRULES_StartIndex = self.input.index()

        root_0 = None

        ID1453 = None

        ID1453_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 305):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1386:34: ({...}? ID )
                # ./output/PLSQL3.g:1386:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "RULES")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyRULES", "(self.input).LT(1).text.upper() == \"RULES\"")


                ID1453 = self.match(self.input, ID, self.FOLLOW_ID_in_keyRULES9936)
                if self._state.backtracking == 0:
                    ID1453_tree = self._adaptor.createWithPayload(ID1453)
                    self._adaptor.addChild(root_0, ID1453_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 305, keyRULES_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyRULES"


    class keySECOND_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keySECOND_return, self).__init__()

            self.tree = None





    # $ANTLR start "keySECOND"
    # ./output/PLSQL3.g:1387:1: keySECOND :{...}? ID ;
    def keySECOND(self, ):
        retval = self.keySECOND_return()
        retval.start = self.input.LT(1)

        keySECOND_StartIndex = self.input.index()

        root_0 = None

        ID1454 = None

        ID1454_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 306):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1387:34: ({...}? ID )
                # ./output/PLSQL3.g:1387:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "SECOND")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keySECOND", "(self.input).LT(1).text.upper() == \"SECOND\"")


                ID1454 = self.match(self.input, ID, self.FOLLOW_ID_in_keySECOND9968)
                if self._state.backtracking == 0:
                    ID1454_tree = self._adaptor.createWithPayload(ID1454)
                    self._adaptor.addChild(root_0, ID1454_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 306, keySECOND_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keySECOND"


    class keySECONDS_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keySECONDS_return, self).__init__()

            self.tree = None





    # $ANTLR start "keySECONDS"
    # ./output/PLSQL3.g:1388:1: keySECONDS :{...}? ID ;
    def keySECONDS(self, ):
        retval = self.keySECONDS_return()
        retval.start = self.input.LT(1)

        keySECONDS_StartIndex = self.input.index()

        root_0 = None

        ID1455 = None

        ID1455_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 307):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1388:34: ({...}? ID )
                # ./output/PLSQL3.g:1388:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "SECONDS")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keySECONDS", "(self.input).LT(1).text.upper() == \"SECONDS\"")


                ID1455 = self.match(self.input, ID, self.FOLLOW_ID_in_keySECONDS9999)
                if self._state.backtracking == 0:
                    ID1455_tree = self._adaptor.createWithPayload(ID1455)
                    self._adaptor.addChild(root_0, ID1455_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 307, keySECONDS_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keySECONDS"


    class keySEQUENTIAL_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keySEQUENTIAL_return, self).__init__()

            self.tree = None





    # $ANTLR start "keySEQUENTIAL"
    # ./output/PLSQL3.g:1389:1: keySEQUENTIAL :{...}? ID ;
    def keySEQUENTIAL(self, ):
        retval = self.keySEQUENTIAL_return()
        retval.start = self.input.LT(1)

        keySEQUENTIAL_StartIndex = self.input.index()

        root_0 = None

        ID1456 = None

        ID1456_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 308):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1389:34: ({...}? ID )
                # ./output/PLSQL3.g:1389:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "SEQUENTIAL")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keySEQUENTIAL", "(self.input).LT(1).text.upper() == \"SEQUENTIAL\"")


                ID1456 = self.match(self.input, ID, self.FOLLOW_ID_in_keySEQUENTIAL10027)
                if self._state.backtracking == 0:
                    ID1456_tree = self._adaptor.createWithPayload(ID1456)
                    self._adaptor.addChild(root_0, ID1456_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 308, keySEQUENTIAL_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keySEQUENTIAL"


    class keySESSIONTIMEZONE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keySESSIONTIMEZONE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keySESSIONTIMEZONE"
    # ./output/PLSQL3.g:1390:1: keySESSIONTIMEZONE :{...}? ID ;
    def keySESSIONTIMEZONE(self, ):
        retval = self.keySESSIONTIMEZONE_return()
        retval.start = self.input.LT(1)

        keySESSIONTIMEZONE_StartIndex = self.input.index()

        root_0 = None

        ID1457 = None

        ID1457_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 309):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1390:34: ({...}? ID )
                # ./output/PLSQL3.g:1390:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "SESSIONTIMEZONE")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keySESSIONTIMEZONE", "(self.input).LT(1).text.upper() == \"SESSIONTIMEZONE\"")


                ID1457 = self.match(self.input, ID, self.FOLLOW_ID_in_keySESSIONTIMEZONE10050)
                if self._state.backtracking == 0:
                    ID1457_tree = self._adaptor.createWithPayload(ID1457)
                    self._adaptor.addChild(root_0, ID1457_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 309, keySESSIONTIMEZONE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keySESSIONTIMEZONE"


    class keySETS_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keySETS_return, self).__init__()

            self.tree = None





    # $ANTLR start "keySETS"
    # ./output/PLSQL3.g:1391:1: keySETS :{...}? ID ;
    def keySETS(self, ):
        retval = self.keySETS_return()
        retval.start = self.input.LT(1)

        keySETS_StartIndex = self.input.index()

        root_0 = None

        ID1458 = None

        ID1458_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 310):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1391:34: ({...}? ID )
                # ./output/PLSQL3.g:1391:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "SETS")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keySETS", "(self.input).LT(1).text.upper() == \"SETS\"")


                ID1458 = self.match(self.input, ID, self.FOLLOW_ID_in_keySETS10084)
                if self._state.backtracking == 0:
                    ID1458_tree = self._adaptor.createWithPayload(ID1458)
                    self._adaptor.addChild(root_0, ID1458_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 310, keySETS_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keySETS"


    class keySIBLINGS_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keySIBLINGS_return, self).__init__()

            self.tree = None





    # $ANTLR start "keySIBLINGS"
    # ./output/PLSQL3.g:1392:1: keySIBLINGS :{...}? ID ;
    def keySIBLINGS(self, ):
        retval = self.keySIBLINGS_return()
        retval.start = self.input.LT(1)

        keySIBLINGS_StartIndex = self.input.index()

        root_0 = None

        ID1459 = None

        ID1459_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 311):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1392:34: ({...}? ID )
                # ./output/PLSQL3.g:1392:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "SIBLINGS")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keySIBLINGS", "(self.input).LT(1).text.upper() == \"SIBLINGS\"")


                ID1459 = self.match(self.input, ID, self.FOLLOW_ID_in_keySIBLINGS10114)
                if self._state.backtracking == 0:
                    ID1459_tree = self._adaptor.createWithPayload(ID1459)
                    self._adaptor.addChild(root_0, ID1459_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 311, keySIBLINGS_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keySIBLINGS"


    class keySINGLE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keySINGLE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keySINGLE"
    # ./output/PLSQL3.g:1393:1: keySINGLE :{...}? ID ;
    def keySINGLE(self, ):
        retval = self.keySINGLE_return()
        retval.start = self.input.LT(1)

        keySINGLE_StartIndex = self.input.index()

        root_0 = None

        ID1460 = None

        ID1460_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 312):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1393:34: ({...}? ID )
                # ./output/PLSQL3.g:1393:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "SINGLE")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keySINGLE", "(self.input).LT(1).text.upper() == \"SINGLE\"")


                ID1460 = self.match(self.input, ID, self.FOLLOW_ID_in_keySINGLE10146)
                if self._state.backtracking == 0:
                    ID1460_tree = self._adaptor.createWithPayload(ID1460)
                    self._adaptor.addChild(root_0, ID1460_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 312, keySINGLE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keySINGLE"


    class keySOME_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keySOME_return, self).__init__()

            self.tree = None





    # $ANTLR start "keySOME"
    # ./output/PLSQL3.g:1394:1: keySOME :{...}? ID ;
    def keySOME(self, ):
        retval = self.keySOME_return()
        retval.start = self.input.LT(1)

        keySOME_StartIndex = self.input.index()

        root_0 = None

        ID1461 = None

        ID1461_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 313):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1394:34: ({...}? ID )
                # ./output/PLSQL3.g:1394:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "SOME")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keySOME", "(self.input).LT(1).text.upper() == \"SOME\"")


                ID1461 = self.match(self.input, ID, self.FOLLOW_ID_in_keySOME10180)
                if self._state.backtracking == 0:
                    ID1461_tree = self._adaptor.createWithPayload(ID1461)
                    self._adaptor.addChild(root_0, ID1461_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 313, keySOME_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keySOME"


    class keySUBMULTISET_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keySUBMULTISET_return, self).__init__()

            self.tree = None





    # $ANTLR start "keySUBMULTISET"
    # ./output/PLSQL3.g:1395:1: keySUBMULTISET :{...}? ID ;
    def keySUBMULTISET(self, ):
        retval = self.keySUBMULTISET_return()
        retval.start = self.input.LT(1)

        keySUBMULTISET_StartIndex = self.input.index()

        root_0 = None

        ID1462 = None

        ID1462_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 314):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1395:34: ({...}? ID )
                # ./output/PLSQL3.g:1395:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "SUBMULTISET")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keySUBMULTISET", "(self.input).LT(1).text.upper() == \"SUBMULTISET\"")


                ID1462 = self.match(self.input, ID, self.FOLLOW_ID_in_keySUBMULTISET10207)
                if self._state.backtracking == 0:
                    ID1462_tree = self._adaptor.createWithPayload(ID1462)
                    self._adaptor.addChild(root_0, ID1462_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 314, keySUBMULTISET_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keySUBMULTISET"


    class keyTIME_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyTIME_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyTIME"
    # ./output/PLSQL3.g:1396:1: keyTIME :{...}? ID ;
    def keyTIME(self, ):
        retval = self.keyTIME_return()
        retval.start = self.input.LT(1)

        keyTIME_StartIndex = self.input.index()

        root_0 = None

        ID1463 = None

        ID1463_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 315):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1396:34: ({...}? ID )
                # ./output/PLSQL3.g:1396:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "TIME")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyTIME", "(self.input).LT(1).text.upper() == \"TIME\"")


                ID1463 = self.match(self.input, ID, self.FOLLOW_ID_in_keyTIME10241)
                if self._state.backtracking == 0:
                    ID1463_tree = self._adaptor.createWithPayload(ID1463)
                    self._adaptor.addChild(root_0, ID1463_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 315, keyTIME_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyTIME"


    class keyTIMESTAMP_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyTIMESTAMP_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyTIMESTAMP"
    # ./output/PLSQL3.g:1397:1: keyTIMESTAMP :{...}? ID ;
    def keyTIMESTAMP(self, ):
        retval = self.keyTIMESTAMP_return()
        retval.start = self.input.LT(1)

        keyTIMESTAMP_StartIndex = self.input.index()

        root_0 = None

        ID1464 = None

        ID1464_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 316):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1397:34: ({...}? ID )
                # ./output/PLSQL3.g:1397:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "TIMESTAMP")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyTIMESTAMP", "(self.input).LT(1).text.upper() == \"TIMESTAMP\"")


                ID1464 = self.match(self.input, ID, self.FOLLOW_ID_in_keyTIMESTAMP10270)
                if self._state.backtracking == 0:
                    ID1464_tree = self._adaptor.createWithPayload(ID1464)
                    self._adaptor.addChild(root_0, ID1464_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 316, keyTIMESTAMP_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyTIMESTAMP"


    class keyTHE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyTHE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyTHE"
    # ./output/PLSQL3.g:1398:1: keyTHE :{...}? ID ;
    def keyTHE(self, ):
        retval = self.keyTHE_return()
        retval.start = self.input.LT(1)

        keyTHE_StartIndex = self.input.index()

        root_0 = None

        ID1465 = None

        ID1465_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 317):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1398:34: ({...}? ID )
                # ./output/PLSQL3.g:1398:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "THE")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyTHE", "(self.input).LT(1).text.upper() == \"THE\"")


                ID1465 = self.match(self.input, ID, self.FOLLOW_ID_in_keyTHE10305)
                if self._state.backtracking == 0:
                    ID1465_tree = self._adaptor.createWithPayload(ID1465)
                    self._adaptor.addChild(root_0, ID1465_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 317, keyTHE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyTHE"


    class keyUNDER_PATH_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyUNDER_PATH_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyUNDER_PATH"
    # ./output/PLSQL3.g:1399:1: keyUNDER_PATH :{...}? ID ;
    def keyUNDER_PATH(self, ):
        retval = self.keyUNDER_PATH_return()
        retval.start = self.input.LT(1)

        keyUNDER_PATH_StartIndex = self.input.index()

        root_0 = None

        ID1466 = None

        ID1466_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 318):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1399:34: ({...}? ID )
                # ./output/PLSQL3.g:1399:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "UNDER_PATH")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyUNDER_PATH", "(self.input).LT(1).text.upper() == \"UNDER_PATH\"")


                ID1466 = self.match(self.input, ID, self.FOLLOW_ID_in_keyUNDER_PATH10333)
                if self._state.backtracking == 0:
                    ID1466_tree = self._adaptor.createWithPayload(ID1466)
                    self._adaptor.addChild(root_0, ID1466_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 318, keyUNDER_PATH_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyUNDER_PATH"


    class keyUNTIL_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyUNTIL_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyUNTIL"
    # ./output/PLSQL3.g:1400:1: keyUNTIL :{...}? ID ;
    def keyUNTIL(self, ):
        retval = self.keyUNTIL_return()
        retval.start = self.input.LT(1)

        keyUNTIL_StartIndex = self.input.index()

        root_0 = None

        ID1467 = None

        ID1467_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 319):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1400:34: ({...}? ID )
                # ./output/PLSQL3.g:1400:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "UNTIL")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyUNTIL", "(self.input).LT(1).text.upper() == \"UNTIL\"")


                ID1467 = self.match(self.input, ID, self.FOLLOW_ID_in_keyUNTIL10366)
                if self._state.backtracking == 0:
                    ID1467_tree = self._adaptor.createWithPayload(ID1467)
                    self._adaptor.addChild(root_0, ID1467_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 319, keyUNTIL_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyUNTIL"


    class keyUPDATED_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyUPDATED_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyUPDATED"
    # ./output/PLSQL3.g:1401:1: keyUPDATED :{...}? ID ;
    def keyUPDATED(self, ):
        retval = self.keyUPDATED_return()
        retval.start = self.input.LT(1)

        keyUPDATED_StartIndex = self.input.index()

        root_0 = None

        ID1468 = None

        ID1468_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 320):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1401:34: ({...}? ID )
                # ./output/PLSQL3.g:1401:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "UPDATED")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyUPDATED", "(self.input).LT(1).text.upper() == \"UPDATED\"")


                ID1468 = self.match(self.input, ID, self.FOLLOW_ID_in_keyUPDATED10397)
                if self._state.backtracking == 0:
                    ID1468_tree = self._adaptor.createWithPayload(ID1468)
                    self._adaptor.addChild(root_0, ID1468_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 320, keyUPDATED_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyUPDATED"


    class keyUPSERT_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyUPSERT_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyUPSERT"
    # ./output/PLSQL3.g:1402:1: keyUPSERT :{...}? ID ;
    def keyUPSERT(self, ):
        retval = self.keyUPSERT_return()
        retval.start = self.input.LT(1)

        keyUPSERT_StartIndex = self.input.index()

        root_0 = None

        ID1469 = None

        ID1469_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 321):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1402:34: ({...}? ID )
                # ./output/PLSQL3.g:1402:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "UPSERT")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyUPSERT", "(self.input).LT(1).text.upper() == \"UPSERT\"")


                ID1469 = self.match(self.input, ID, self.FOLLOW_ID_in_keyUPSERT10429)
                if self._state.backtracking == 0:
                    ID1469_tree = self._adaptor.createWithPayload(ID1469)
                    self._adaptor.addChild(root_0, ID1469_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 321, keyUPSERT_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyUPSERT"


    class keyWAIT_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyWAIT_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyWAIT"
    # ./output/PLSQL3.g:1403:1: keyWAIT :{...}? ID ;
    def keyWAIT(self, ):
        retval = self.keyWAIT_return()
        retval.start = self.input.LT(1)

        keyWAIT_StartIndex = self.input.index()

        root_0 = None

        ID1470 = None

        ID1470_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 322):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1403:34: ({...}? ID )
                # ./output/PLSQL3.g:1403:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "WAIT")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyWAIT", "(self.input).LT(1).text.upper() == \"WAIT\"")


                ID1470 = self.match(self.input, ID, self.FOLLOW_ID_in_keyWAIT10463)
                if self._state.backtracking == 0:
                    ID1470_tree = self._adaptor.createWithPayload(ID1470)
                    self._adaptor.addChild(root_0, ID1470_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 322, keyWAIT_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyWAIT"


    class keyYEAR_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyYEAR_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyYEAR"
    # ./output/PLSQL3.g:1404:1: keyYEAR :{...}? ID ;
    def keyYEAR(self, ):
        retval = self.keyYEAR_return()
        retval.start = self.input.LT(1)

        keyYEAR_StartIndex = self.input.index()

        root_0 = None

        ID1471 = None

        ID1471_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 323):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1404:34: ({...}? ID )
                # ./output/PLSQL3.g:1404:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "YEAR")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyYEAR", "(self.input).LT(1).text.upper() == \"YEAR\"")


                ID1471 = self.match(self.input, ID, self.FOLLOW_ID_in_keyYEAR10497)
                if self._state.backtracking == 0:
                    ID1471_tree = self._adaptor.createWithPayload(ID1471)
                    self._adaptor.addChild(root_0, ID1471_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 323, keyYEAR_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyYEAR"


    class keyZONE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyZONE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyZONE"
    # ./output/PLSQL3.g:1405:1: keyZONE :{...}? ID ;
    def keyZONE(self, ):
        retval = self.keyZONE_return()
        retval.start = self.input.LT(1)

        keyZONE_StartIndex = self.input.index()

        root_0 = None

        ID1472 = None

        ID1472_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 324):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1405:34: ({...}? ID )
                # ./output/PLSQL3.g:1405:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "ZONE")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyZONE", "(self.input).LT(1).text.upper() == \"ZONE\"")


                ID1472 = self.match(self.input, ID, self.FOLLOW_ID_in_keyZONE10531)
                if self._state.backtracking == 0:
                    ID1472_tree = self._adaptor.createWithPayload(ID1472)
                    self._adaptor.addChild(root_0, ID1472_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 324, keyZONE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyZONE"


    class keyARRAY_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyARRAY_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyARRAY"
    # ./output/PLSQL3.g:1407:1: keyARRAY :{...}? ID ;
    def keyARRAY(self, ):
        retval = self.keyARRAY_return()
        retval.start = self.input.LT(1)

        keyARRAY_StartIndex = self.input.index()

        root_0 = None

        ID1473 = None

        ID1473_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 325):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1407:34: ({...}? ID )
                # ./output/PLSQL3.g:1407:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "ARRAY")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyARRAY", "(self.input).LT(1).text.upper() == \"ARRAY\"")


                ID1473 = self.match(self.input, ID, self.FOLLOW_ID_in_keyARRAY10565)
                if self._state.backtracking == 0:
                    ID1473_tree = self._adaptor.createWithPayload(ID1473)
                    self._adaptor.addChild(root_0, ID1473_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 325, keyARRAY_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyARRAY"


    class keyAUTONOMOUS_TRANSACTION_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyAUTONOMOUS_TRANSACTION_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyAUTONOMOUS_TRANSACTION"
    # ./output/PLSQL3.g:1408:1: keyAUTONOMOUS_TRANSACTION :{...}? ID ;
    def keyAUTONOMOUS_TRANSACTION(self, ):
        retval = self.keyAUTONOMOUS_TRANSACTION_return()
        retval.start = self.input.LT(1)

        keyAUTONOMOUS_TRANSACTION_StartIndex = self.input.index()

        root_0 = None

        ID1474 = None

        ID1474_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 326):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1408:34: ({...}? ID )
                # ./output/PLSQL3.g:1408:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "AUTONOMOUS_TRANSACTION")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyAUTONOMOUS_TRANSACTION", "(self.input).LT(1).text.upper() == \"AUTONOMOUS_TRANSACTION\"")


                ID1474 = self.match(self.input, ID, self.FOLLOW_ID_in_keyAUTONOMOUS_TRANSACTION10581)
                if self._state.backtracking == 0:
                    ID1474_tree = self._adaptor.createWithPayload(ID1474)
                    self._adaptor.addChild(root_0, ID1474_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 326, keyAUTONOMOUS_TRANSACTION_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyAUTONOMOUS_TRANSACTION"


    class keyBODY_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyBODY_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyBODY"
    # ./output/PLSQL3.g:1409:1: keyBODY :{...}? ID ;
    def keyBODY(self, ):
        retval = self.keyBODY_return()
        retval.start = self.input.LT(1)

        keyBODY_StartIndex = self.input.index()

        root_0 = None

        ID1475 = None

        ID1475_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 327):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1409:34: ({...}? ID )
                # ./output/PLSQL3.g:1409:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "BODY")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyBODY", "(self.input).LT(1).text.upper() == \"BODY\"")


                ID1475 = self.match(self.input, ID, self.FOLLOW_ID_in_keyBODY10615)
                if self._state.backtracking == 0:
                    ID1475_tree = self._adaptor.createWithPayload(ID1475)
                    self._adaptor.addChild(root_0, ID1475_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 327, keyBODY_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyBODY"


    class keyBUILTIN_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyBUILTIN_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyBUILTIN"
    # ./output/PLSQL3.g:1410:1: keyBUILTIN :{...}? ID ;
    def keyBUILTIN(self, ):
        retval = self.keyBUILTIN_return()
        retval.start = self.input.LT(1)

        keyBUILTIN_StartIndex = self.input.index()

        root_0 = None

        ID1476 = None

        ID1476_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 328):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1410:34: ({...}? ID )
                # ./output/PLSQL3.g:1410:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "BUILTIN")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyBUILTIN", "(self.input).LT(1).text.upper() == \"BUILTIN\"")


                ID1476 = self.match(self.input, ID, self.FOLLOW_ID_in_keyBUILTIN10646)
                if self._state.backtracking == 0:
                    ID1476_tree = self._adaptor.createWithPayload(ID1476)
                    self._adaptor.addChild(root_0, ID1476_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 328, keyBUILTIN_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyBUILTIN"


    class keyBULK_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyBULK_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyBULK"
    # ./output/PLSQL3.g:1411:1: keyBULK :{...}? ID ;
    def keyBULK(self, ):
        retval = self.keyBULK_return()
        retval.start = self.input.LT(1)

        keyBULK_StartIndex = self.input.index()

        root_0 = None

        ID1477 = None

        ID1477_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 329):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1411:34: ({...}? ID )
                # ./output/PLSQL3.g:1411:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "BULK")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyBULK", "(self.input).LT(1).text.upper() == \"BULK\"")


                ID1477 = self.match(self.input, ID, self.FOLLOW_ID_in_keyBULK10680)
                if self._state.backtracking == 0:
                    ID1477_tree = self._adaptor.createWithPayload(ID1477)
                    self._adaptor.addChild(root_0, ID1477_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 329, keyBULK_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyBULK"


    class keyBYTE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyBYTE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyBYTE"
    # ./output/PLSQL3.g:1412:1: keyBYTE :{...}? ID ;
    def keyBYTE(self, ):
        retval = self.keyBYTE_return()
        retval.start = self.input.LT(1)

        keyBYTE_StartIndex = self.input.index()

        root_0 = None

        ID1478 = None

        ID1478_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 330):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1412:34: ({...}? ID )
                # ./output/PLSQL3.g:1412:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "BYTE")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyBYTE", "(self.input).LT(1).text.upper() == \"BYTE\"")


                ID1478 = self.match(self.input, ID, self.FOLLOW_ID_in_keyBYTE10714)
                if self._state.backtracking == 0:
                    ID1478_tree = self._adaptor.createWithPayload(ID1478)
                    self._adaptor.addChild(root_0, ID1478_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 330, keyBYTE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyBYTE"


    class keyCLOSE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyCLOSE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyCLOSE"
    # ./output/PLSQL3.g:1413:1: keyCLOSE :{...}? ID ;
    def keyCLOSE(self, ):
        retval = self.keyCLOSE_return()
        retval.start = self.input.LT(1)

        keyCLOSE_StartIndex = self.input.index()

        root_0 = None

        ID1479 = None

        ID1479_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 331):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1413:34: ({...}? ID )
                # ./output/PLSQL3.g:1413:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "CLOSE")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyCLOSE", "(self.input).LT(1).text.upper() == \"CLOSE\"")


                ID1479 = self.match(self.input, ID, self.FOLLOW_ID_in_keyCLOSE10747)
                if self._state.backtracking == 0:
                    ID1479_tree = self._adaptor.createWithPayload(ID1479)
                    self._adaptor.addChild(root_0, ID1479_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 331, keyCLOSE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyCLOSE"


    class keyCOLLECT_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyCOLLECT_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyCOLLECT"
    # ./output/PLSQL3.g:1414:1: keyCOLLECT :{...}? ID ;
    def keyCOLLECT(self, ):
        retval = self.keyCOLLECT_return()
        retval.start = self.input.LT(1)

        keyCOLLECT_StartIndex = self.input.index()

        root_0 = None

        ID1480 = None

        ID1480_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 332):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1414:34: ({...}? ID )
                # ./output/PLSQL3.g:1414:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "COLLECT")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyCOLLECT", "(self.input).LT(1).text.upper() == \"COLLECT\"")


                ID1480 = self.match(self.input, ID, self.FOLLOW_ID_in_keyCOLLECT10778)
                if self._state.backtracking == 0:
                    ID1480_tree = self._adaptor.createWithPayload(ID1480)
                    self._adaptor.addChild(root_0, ID1480_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 332, keyCOLLECT_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyCOLLECT"


    class keyCURSOR_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyCURSOR_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyCURSOR"
    # ./output/PLSQL3.g:1415:1: keyCURSOR :{...}? ID ;
    def keyCURSOR(self, ):
        retval = self.keyCURSOR_return()
        retval.start = self.input.LT(1)

        keyCURSOR_StartIndex = self.input.index()

        root_0 = None

        ID1481 = None

        ID1481_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 333):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1415:34: ({...}? ID )
                # ./output/PLSQL3.g:1415:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "CURSOR")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyCURSOR", "(self.input).LT(1).text.upper() == \"CURSOR\"")


                ID1481 = self.match(self.input, ID, self.FOLLOW_ID_in_keyCURSOR10810)
                if self._state.backtracking == 0:
                    ID1481_tree = self._adaptor.createWithPayload(ID1481)
                    self._adaptor.addChild(root_0, ID1481_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 333, keyCURSOR_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyCURSOR"


    class keyELSIF_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyELSIF_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyELSIF"
    # ./output/PLSQL3.g:1416:1: keyELSIF : 'ELSIF' ;
    def keyELSIF(self, ):
        retval = self.keyELSIF_return()
        retval.start = self.input.LT(1)

        keyELSIF_StartIndex = self.input.index()

        root_0 = None

        string_literal1482 = None

        string_literal1482_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 334):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1416:34: ( 'ELSIF' )
                # ./output/PLSQL3.g:1416:36: 'ELSIF'
                pass
                root_0 = self._adaptor.nil()


                string_literal1482 = self.match(self.input, 84, self.FOLLOW_84_in_keyELSIF10841)
                if self._state.backtracking == 0:
                    string_literal1482_tree = self._adaptor.createWithPayload(string_literal1482)
                    self._adaptor.addChild(root_0, string_literal1482_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 334, keyELSIF_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyELSIF"


    class keyEXCEPTION_INIT_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyEXCEPTION_INIT_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyEXCEPTION_INIT"
    # ./output/PLSQL3.g:1417:1: keyEXCEPTION_INIT :{...}? ID ;
    def keyEXCEPTION_INIT(self, ):
        retval = self.keyEXCEPTION_INIT_return()
        retval.start = self.input.LT(1)

        keyEXCEPTION_INIT_StartIndex = self.input.index()

        root_0 = None

        ID1483 = None

        ID1483_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 335):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1417:34: ({...}? ID )
                # ./output/PLSQL3.g:1417:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "EXCEPTION_INIT")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyEXCEPTION_INIT", "(self.input).LT(1).text.upper() == \"EXCEPTION_INIT\"")


                ID1483 = self.match(self.input, ID, self.FOLLOW_ID_in_keyEXCEPTION_INIT10866)
                if self._state.backtracking == 0:
                    ID1483_tree = self._adaptor.createWithPayload(ID1483)
                    self._adaptor.addChild(root_0, ID1483_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 335, keyEXCEPTION_INIT_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyEXCEPTION_INIT"


    class keyEXIT_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyEXIT_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyEXIT"
    # ./output/PLSQL3.g:1418:1: keyEXIT :{...}? ID ;
    def keyEXIT(self, ):
        retval = self.keyEXIT_return()
        retval.start = self.input.LT(1)

        keyEXIT_StartIndex = self.input.index()

        root_0 = None

        ID1484 = None

        ID1484_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 336):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1418:34: ({...}? ID )
                # ./output/PLSQL3.g:1418:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "EXIT")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyEXIT", "(self.input).LT(1).text.upper() == \"EXIT\"")


                ID1484 = self.match(self.input, ID, self.FOLLOW_ID_in_keyEXIT10900)
                if self._state.backtracking == 0:
                    ID1484_tree = self._adaptor.createWithPayload(ID1484)
                    self._adaptor.addChild(root_0, ID1484_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 336, keyEXIT_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyEXIT"


    class keyFIPSFLAG_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyFIPSFLAG_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyFIPSFLAG"
    # ./output/PLSQL3.g:1419:1: keyFIPSFLAG :{...}? ID ;
    def keyFIPSFLAG(self, ):
        retval = self.keyFIPSFLAG_return()
        retval.start = self.input.LT(1)

        keyFIPSFLAG_StartIndex = self.input.index()

        root_0 = None

        ID1485 = None

        ID1485_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 337):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1419:34: ({...}? ID )
                # ./output/PLSQL3.g:1419:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "FIPSFLAG")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyFIPSFLAG", "(self.input).LT(1).text.upper() == \"FIPSFLAG\"")


                ID1485 = self.match(self.input, ID, self.FOLLOW_ID_in_keyFIPSFLAG10930)
                if self._state.backtracking == 0:
                    ID1485_tree = self._adaptor.createWithPayload(ID1485)
                    self._adaptor.addChild(root_0, ID1485_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 337, keyFIPSFLAG_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyFIPSFLAG"


    class keyFUNCTION_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyFUNCTION_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyFUNCTION"
    # ./output/PLSQL3.g:1420:1: keyFUNCTION : 'FUNCTION' ;
    def keyFUNCTION(self, ):
        retval = self.keyFUNCTION_return()
        retval.start = self.input.LT(1)

        keyFUNCTION_StartIndex = self.input.index()

        root_0 = None

        string_literal1486 = None

        string_literal1486_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 338):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1420:34: ( 'FUNCTION' )
                # ./output/PLSQL3.g:1420:36: 'FUNCTION'
                pass
                root_0 = self._adaptor.nil()


                string_literal1486 = self.match(self.input, 94, self.FOLLOW_94_in_keyFUNCTION10958)
                if self._state.backtracking == 0:
                    string_literal1486_tree = self._adaptor.createWithPayload(string_literal1486)
                    self._adaptor.addChild(root_0, string_literal1486_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 338, keyFUNCTION_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyFUNCTION"


    class keyINTERFACE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyINTERFACE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyINTERFACE"
    # ./output/PLSQL3.g:1421:1: keyINTERFACE :{...}? ID ;
    def keyINTERFACE(self, ):
        retval = self.keyINTERFACE_return()
        retval.start = self.input.LT(1)

        keyINTERFACE_StartIndex = self.input.index()

        root_0 = None

        ID1487 = None

        ID1487_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 339):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1421:34: ({...}? ID )
                # ./output/PLSQL3.g:1421:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "INTERFACE")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyINTERFACE", "(self.input).LT(1).text.upper() == \"INTERFACE\"")


                ID1487 = self.match(self.input, ID, self.FOLLOW_ID_in_keyINTERFACE10988)
                if self._state.backtracking == 0:
                    ID1487_tree = self._adaptor.createWithPayload(ID1487)
                    self._adaptor.addChild(root_0, ID1487_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 339, keyINTERFACE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyINTERFACE"


    class keyLOOP_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyLOOP_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyLOOP"
    # ./output/PLSQL3.g:1422:1: keyLOOP : 'LOOP' ;
    def keyLOOP(self, ):
        retval = self.keyLOOP_return()
        retval.start = self.input.LT(1)

        keyLOOP_StartIndex = self.input.index()

        root_0 = None

        string_literal1488 = None

        string_literal1488_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 340):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1422:34: ( 'LOOP' )
                # ./output/PLSQL3.g:1422:36: 'LOOP'
                pass
                root_0 = self._adaptor.nil()


                string_literal1488 = self.match(self.input, 110, self.FOLLOW_110_in_keyLOOP11020)
                if self._state.backtracking == 0:
                    string_literal1488_tree = self._adaptor.createWithPayload(string_literal1488)
                    self._adaptor.addChild(root_0, string_literal1488_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 340, keyLOOP_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyLOOP"


    class keyNEW_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyNEW_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyNEW"
    # ./output/PLSQL3.g:1423:1: keyNEW :{...}? ID ;
    def keyNEW(self, ):
        retval = self.keyNEW_return()
        retval.start = self.input.LT(1)

        keyNEW_StartIndex = self.input.index()

        root_0 = None

        ID1489 = None

        ID1489_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 341):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1423:34: ({...}? ID )
                # ./output/PLSQL3.g:1423:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "NEW")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyNEW", "(self.input).LT(1).text.upper() == \"NEW\"")


                ID1489 = self.match(self.input, ID, self.FOLLOW_ID_in_keyNEW11056)
                if self._state.backtracking == 0:
                    ID1489_tree = self._adaptor.createWithPayload(ID1489)
                    self._adaptor.addChild(root_0, ID1489_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 341, keyNEW_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyNEW"


    class keyNEW_NAMES_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyNEW_NAMES_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyNEW_NAMES"
    # ./output/PLSQL3.g:1424:1: keyNEW_NAMES :{...}? ID ;
    def keyNEW_NAMES(self, ):
        retval = self.keyNEW_NAMES_return()
        retval.start = self.input.LT(1)

        keyNEW_NAMES_StartIndex = self.input.index()

        root_0 = None

        ID1490 = None

        ID1490_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 342):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1424:34: ({...}? ID )
                # ./output/PLSQL3.g:1424:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "NEW_NAMES")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyNEW_NAMES", "(self.input).LT(1).text.upper() == \"NEW_NAMES\"")


                ID1490 = self.match(self.input, ID, self.FOLLOW_ID_in_keyNEW_NAMES11085)
                if self._state.backtracking == 0:
                    ID1490_tree = self._adaptor.createWithPayload(ID1490)
                    self._adaptor.addChild(root_0, ID1490_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 342, keyNEW_NAMES_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyNEW_NAMES"


    class keyOPEN_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyOPEN_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyOPEN"
    # ./output/PLSQL3.g:1425:1: keyOPEN :{...}? ID ;
    def keyOPEN(self, ):
        retval = self.keyOPEN_return()
        retval.start = self.input.LT(1)

        keyOPEN_StartIndex = self.input.index()

        root_0 = None

        ID1491 = None

        ID1491_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 343):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1425:34: ({...}? ID )
                # ./output/PLSQL3.g:1425:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "OPEN")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyOPEN", "(self.input).LT(1).text.upper() == \"OPEN\"")


                ID1491 = self.match(self.input, ID, self.FOLLOW_ID_in_keyOPEN11119)
                if self._state.backtracking == 0:
                    ID1491_tree = self._adaptor.createWithPayload(ID1491)
                    self._adaptor.addChild(root_0, ID1491_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 343, keyOPEN_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyOPEN"


    class keyOUT_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyOUT_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyOUT"
    # ./output/PLSQL3.g:1426:1: keyOUT : 'OUT' ;
    def keyOUT(self, ):
        retval = self.keyOUT_return()
        retval.start = self.input.LT(1)

        keyOUT_StartIndex = self.input.index()

        root_0 = None

        string_literal1492 = None

        string_literal1492_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 344):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1426:34: ( 'OUT' )
                # ./output/PLSQL3.g:1426:36: 'OUT'
                pass
                root_0 = self._adaptor.nil()


                string_literal1492 = self.match(self.input, 129, self.FOLLOW_129_in_keyOUT11152)
                if self._state.backtracking == 0:
                    string_literal1492_tree = self._adaptor.createWithPayload(string_literal1492)
                    self._adaptor.addChild(root_0, string_literal1492_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 344, keyOUT_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyOUT"


    class keyPACKAGE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyPACKAGE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyPACKAGE"
    # ./output/PLSQL3.g:1427:1: keyPACKAGE : 'PACKAGE' ;
    def keyPACKAGE(self, ):
        retval = self.keyPACKAGE_return()
        retval.start = self.input.LT(1)

        keyPACKAGE_StartIndex = self.input.index()

        root_0 = None

        string_literal1493 = None

        string_literal1493_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 345):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1427:34: ( 'PACKAGE' )
                # ./output/PLSQL3.g:1427:36: 'PACKAGE'
                pass
                root_0 = self._adaptor.nil()


                string_literal1493 = self.match(self.input, 130, self.FOLLOW_130_in_keyPACKAGE11182)
                if self._state.backtracking == 0:
                    string_literal1493_tree = self._adaptor.createWithPayload(string_literal1493)
                    self._adaptor.addChild(root_0, string_literal1493_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 345, keyPACKAGE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyPACKAGE"


    class keyPRAGMA_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyPRAGMA_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyPRAGMA"
    # ./output/PLSQL3.g:1428:1: keyPRAGMA : 'PRAGMA' ;
    def keyPRAGMA(self, ):
        retval = self.keyPRAGMA_return()
        retval.start = self.input.LT(1)

        keyPRAGMA_StartIndex = self.input.index()

        root_0 = None

        string_literal1494 = None

        string_literal1494_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 346):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1428:34: ( 'PRAGMA' )
                # ./output/PLSQL3.g:1428:36: 'PRAGMA'
                pass
                root_0 = self._adaptor.nil()


                string_literal1494 = self.match(self.input, 133, self.FOLLOW_133_in_keyPRAGMA11213)
                if self._state.backtracking == 0:
                    string_literal1494_tree = self._adaptor.createWithPayload(string_literal1494)
                    self._adaptor.addChild(root_0, string_literal1494_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 346, keyPRAGMA_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyPRAGMA"


    class keyRAISE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyRAISE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyRAISE"
    # ./output/PLSQL3.g:1429:1: keyRAISE : 'RAISE' ;
    def keyRAISE(self, ):
        retval = self.keyRAISE_return()
        retval.start = self.input.LT(1)

        keyRAISE_StartIndex = self.input.index()

        root_0 = None

        string_literal1495 = None

        string_literal1495_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 347):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1429:34: ( 'RAISE' )
                # ./output/PLSQL3.g:1429:36: 'RAISE'
                pass
                root_0 = self._adaptor.nil()


                string_literal1495 = self.match(self.input, 136, self.FOLLOW_136_in_keyRAISE11245)
                if self._state.backtracking == 0:
                    string_literal1495_tree = self._adaptor.createWithPayload(string_literal1495)
                    self._adaptor.addChild(root_0, string_literal1495_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 347, keyRAISE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyRAISE"


    class keyRANGE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyRANGE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyRANGE"
    # ./output/PLSQL3.g:1430:1: keyRANGE :{...}? ID ;
    def keyRANGE(self, ):
        retval = self.keyRANGE_return()
        retval.start = self.input.LT(1)

        keyRANGE_StartIndex = self.input.index()

        root_0 = None

        ID1496 = None

        ID1496_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 348):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1430:34: ({...}? ID )
                # ./output/PLSQL3.g:1430:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "RANGE")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyRANGE", "(self.input).LT(1).text.upper() == \"RANGE\"")


                ID1496 = self.match(self.input, ID, self.FOLLOW_ID_in_keyRANGE11279)
                if self._state.backtracking == 0:
                    ID1496_tree = self._adaptor.createWithPayload(ID1496)
                    self._adaptor.addChild(root_0, ID1496_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 348, keyRANGE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyRANGE"


    class keyREAD_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyREAD_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyREAD"
    # ./output/PLSQL3.g:1431:1: keyREAD :{...}? ID ;
    def keyREAD(self, ):
        retval = self.keyREAD_return()
        retval.start = self.input.LT(1)

        keyREAD_StartIndex = self.input.index()

        root_0 = None

        ID1497 = None

        ID1497_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 349):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1431:34: ({...}? ID )
                # ./output/PLSQL3.g:1431:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "READ")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyREAD", "(self.input).LT(1).text.upper() == \"READ\"")


                ID1497 = self.match(self.input, ID, self.FOLLOW_ID_in_keyREAD11313)
                if self._state.backtracking == 0:
                    ID1497_tree = self._adaptor.createWithPayload(ID1497)
                    self._adaptor.addChild(root_0, ID1497_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 349, keyREAD_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyREAD"


    class keyRECORD_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyRECORD_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyRECORD"
    # ./output/PLSQL3.g:1432:1: keyRECORD : 'RECORD' ;
    def keyRECORD(self, ):
        retval = self.keyRECORD_return()
        retval.start = self.input.LT(1)

        keyRECORD_StartIndex = self.input.index()

        root_0 = None

        string_literal1498 = None

        string_literal1498_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 350):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1432:34: ( 'RECORD' )
                # ./output/PLSQL3.g:1432:36: 'RECORD'
                pass
                root_0 = self._adaptor.nil()


                string_literal1498 = self.match(self.input, 139, self.FOLLOW_139_in_keyRECORD11343)
                if self._state.backtracking == 0:
                    string_literal1498_tree = self._adaptor.createWithPayload(string_literal1498)
                    self._adaptor.addChild(root_0, string_literal1498_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 350, keyRECORD_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyRECORD"


    class keyREF_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyREF_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyREF"
    # ./output/PLSQL3.g:1433:1: keyREF :{...}? ID ;
    def keyREF(self, ):
        retval = self.keyREF_return()
        retval.start = self.input.LT(1)

        keyREF_StartIndex = self.input.index()

        root_0 = None

        ID1499 = None

        ID1499_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 351):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1433:34: ({...}? ID )
                # ./output/PLSQL3.g:1433:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "REF")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyREF", "(self.input).LT(1).text.upper() == \"REF\"")


                ID1499 = self.match(self.input, ID, self.FOLLOW_ID_in_keyREF11379)
                if self._state.backtracking == 0:
                    ID1499_tree = self._adaptor.createWithPayload(ID1499)
                    self._adaptor.addChild(root_0, ID1499_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 351, keyREF_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyREF"


    class keyREPLACE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyREPLACE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyREPLACE"
    # ./output/PLSQL3.g:1434:1: keyREPLACE :{...}? ID ;
    def keyREPLACE(self, ):
        retval = self.keyREPLACE_return()
        retval.start = self.input.LT(1)

        keyREPLACE_StartIndex = self.input.index()

        root_0 = None

        ID1500 = None

        ID1500_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 352):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1434:34: ({...}? ID )
                # ./output/PLSQL3.g:1434:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()

                if not (((self.input).LT(1).text.upper() == "REPLACE")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyREPLACE", "(self.input).LT(1).text.upper() == \"REPLACE\"")


                ID1500 = self.match(self.input, ID, self.FOLLOW_ID_in_keyREPLACE11410)
                if self._state.backtracking == 0:
                    ID1500_tree = self._adaptor.createWithPayload(ID1500)
                    self._adaptor.addChild(root_0, ID1500_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 352, keyREPLACE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyREPLACE"


    class keyRESTRICT_REFERENCES_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyRESTRICT_REFERENCES_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyRESTRICT_REFERENCES"
    # ./output/PLSQL3.g:1435:1: keyRESTRICT_REFERENCES :{...}? ID ;
    def keyRESTRICT_REFERENCES(self, ):
        retval = self.keyRESTRICT_REFERENCES_return()
        retval.start = self.input.LT(1)

        keyRESTRICT_REFERENCES_StartIndex = self.input.index()

        root_0 = None

        ID1501 = None

        ID1501_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 353):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1435:34: ({...}? ID )
                # ./output/PLSQL3.g:1435:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "RESTRICT_REFERENCES")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyRESTRICT_REFERENCES", "(self.input).LT(1).text.upper() == \"RESTRICT_REFERENCES\"")


                ID1501 = self.match(self.input, ID, self.FOLLOW_ID_in_keyRESTRICT_REFERENCES11429)
                if self._state.backtracking == 0:
                    ID1501_tree = self._adaptor.createWithPayload(ID1501)
                    self._adaptor.addChild(root_0, ID1501_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 353, keyRESTRICT_REFERENCES_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyRESTRICT_REFERENCES"


    class keyRETURN_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyRETURN_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyRETURN"
    # ./output/PLSQL3.g:1436:1: keyRETURN : 'RETURN' ;
    def keyRETURN(self, ):
        retval = self.keyRETURN_return()
        retval.start = self.input.LT(1)

        keyRETURN_StartIndex = self.input.index()

        root_0 = None

        string_literal1502 = None

        string_literal1502_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 354):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1436:34: ( 'RETURN' )
                # ./output/PLSQL3.g:1436:36: 'RETURN'
                pass
                root_0 = self._adaptor.nil()


                string_literal1502 = self.match(self.input, 140, self.FOLLOW_140_in_keyRETURN11459)
                if self._state.backtracking == 0:
                    string_literal1502_tree = self._adaptor.createWithPayload(string_literal1502)
                    self._adaptor.addChild(root_0, string_literal1502_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 354, keyRETURN_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyRETURN"


    class keyRETURNING_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyRETURNING_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyRETURNING"
    # ./output/PLSQL3.g:1437:1: keyRETURNING : 'RETURNING' ;
    def keyRETURNING(self, ):
        retval = self.keyRETURNING_return()
        retval.start = self.input.LT(1)

        keyRETURNING_StartIndex = self.input.index()

        root_0 = None

        string_literal1503 = None

        string_literal1503_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 355):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1437:34: ( 'RETURNING' )
                # ./output/PLSQL3.g:1437:36: 'RETURNING'
                pass
                root_0 = self._adaptor.nil()


                string_literal1503 = self.match(self.input, 141, self.FOLLOW_141_in_keyRETURNING11487)
                if self._state.backtracking == 0:
                    string_literal1503_tree = self._adaptor.createWithPayload(string_literal1503)
                    self._adaptor.addChild(root_0, string_literal1503_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 355, keyRETURNING_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyRETURNING"


    class keyREVERSE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyREVERSE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyREVERSE"
    # ./output/PLSQL3.g:1438:1: keyREVERSE :{...}? ID ;
    def keyREVERSE(self, ):
        retval = self.keyREVERSE_return()
        retval.start = self.input.LT(1)

        keyREVERSE_StartIndex = self.input.index()

        root_0 = None

        ID1504 = None

        ID1504_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 356):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1438:34: ({...}? ID )
                # ./output/PLSQL3.g:1438:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "REVERSE")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyREVERSE", "(self.input).LT(1).text.upper() == \"REVERSE\"")


                ID1504 = self.match(self.input, ID, self.FOLLOW_ID_in_keyREVERSE11519)
                if self._state.backtracking == 0:
                    ID1504_tree = self._adaptor.createWithPayload(ID1504)
                    self._adaptor.addChild(root_0, ID1504_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 356, keyREVERSE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyREVERSE"


    class keyROLLBACK_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyROLLBACK_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyROLLBACK"
    # ./output/PLSQL3.g:1439:1: keyROLLBACK : 'ROLLBACK' ;
    def keyROLLBACK(self, ):
        retval = self.keyROLLBACK_return()
        retval.start = self.input.LT(1)

        keyROLLBACK_StartIndex = self.input.index()

        root_0 = None

        string_literal1505 = None

        string_literal1505_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 357):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1439:34: ( 'ROLLBACK' )
                # ./output/PLSQL3.g:1439:36: 'ROLLBACK'
                pass
                root_0 = self._adaptor.nil()


                string_literal1505 = self.match(self.input, 142, self.FOLLOW_142_in_keyROLLBACK11547)
                if self._state.backtracking == 0:
                    string_literal1505_tree = self._adaptor.createWithPayload(string_literal1505)
                    self._adaptor.addChild(root_0, string_literal1505_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 357, keyROLLBACK_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyROLLBACK"


    class keySERIALLY_REUSABLE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keySERIALLY_REUSABLE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keySERIALLY_REUSABLE"
    # ./output/PLSQL3.g:1440:1: keySERIALLY_REUSABLE :{...}? ID ;
    def keySERIALLY_REUSABLE(self, ):
        retval = self.keySERIALLY_REUSABLE_return()
        retval.start = self.input.LT(1)

        keySERIALLY_REUSABLE_StartIndex = self.input.index()

        root_0 = None

        ID1506 = None

        ID1506_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 358):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1440:34: ({...}? ID )
                # ./output/PLSQL3.g:1440:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "SERIALLY_REUSABLE")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keySERIALLY_REUSABLE", "(self.input).LT(1).text.upper() == \"SERIALLY_REUSABLE\"")


                ID1506 = self.match(self.input, ID, self.FOLLOW_ID_in_keySERIALLY_REUSABLE11569)
                if self._state.backtracking == 0:
                    ID1506_tree = self._adaptor.createWithPayload(ID1506)
                    self._adaptor.addChild(root_0, ID1506_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 358, keySERIALLY_REUSABLE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keySERIALLY_REUSABLE"


    class keySUBTYPE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keySUBTYPE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keySUBTYPE"
    # ./output/PLSQL3.g:1441:1: keySUBTYPE :{...}? ID ;
    def keySUBTYPE(self, ):
        retval = self.keySUBTYPE_return()
        retval.start = self.input.LT(1)

        keySUBTYPE_StartIndex = self.input.index()

        root_0 = None

        ID1507 = None

        ID1507_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 359):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1441:34: ({...}? ID )
                # ./output/PLSQL3.g:1441:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "SUBTYPE")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keySUBTYPE", "(self.input).LT(1).text.upper() == \"SUBTYPE\"")


                ID1507 = self.match(self.input, ID, self.FOLLOW_ID_in_keySUBTYPE11600)
                if self._state.backtracking == 0:
                    ID1507_tree = self._adaptor.createWithPayload(ID1507)
                    self._adaptor.addChild(root_0, ID1507_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 359, keySUBTYPE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keySUBTYPE"


    class keyTRANSACTION_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyTRANSACTION_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyTRANSACTION"
    # ./output/PLSQL3.g:1442:1: keyTRANSACTION :{...}? ID ;
    def keyTRANSACTION(self, ):
        retval = self.keyTRANSACTION_return()
        retval.start = self.input.LT(1)

        keyTRANSACTION_StartIndex = self.input.index()

        root_0 = None

        ID1508 = None

        ID1508_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 360):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1442:34: ({...}? ID )
                # ./output/PLSQL3.g:1442:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "TRANSACTION")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyTRANSACTION", "(self.input).LT(1).text.upper() == \"TRANSACTION\"")


                ID1508 = self.match(self.input, ID, self.FOLLOW_ID_in_keyTRANSACTION11627)
                if self._state.backtracking == 0:
                    ID1508_tree = self._adaptor.createWithPayload(ID1508)
                    self._adaptor.addChild(root_0, ID1508_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 360, keyTRANSACTION_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyTRANSACTION"


    class keyTYPE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyTYPE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyTYPE"
    # ./output/PLSQL3.g:1443:1: keyTYPE :{...}? ID ;
    def keyTYPE(self, ):
        retval = self.keyTYPE_return()
        retval.start = self.input.LT(1)

        keyTYPE_StartIndex = self.input.index()

        root_0 = None

        ID1509 = None

        ID1509_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 361):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1443:34: ({...}? ID )
                # ./output/PLSQL3.g:1443:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "TYPE")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyTYPE", "(self.input).LT(1).text.upper() == \"TYPE\"")


                ID1509 = self.match(self.input, ID, self.FOLLOW_ID_in_keyTYPE11661)
                if self._state.backtracking == 0:
                    ID1509_tree = self._adaptor.createWithPayload(ID1509)
                    self._adaptor.addChild(root_0, ID1509_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 361, keyTYPE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyTYPE"


    class keyUSING_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyUSING_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyUSING"
    # ./output/PLSQL3.g:1444:1: keyUSING :{...}? ID ;
    def keyUSING(self, ):
        retval = self.keyUSING_return()
        retval.start = self.input.LT(1)

        keyUSING_StartIndex = self.input.index()

        root_0 = None

        ID1510 = None

        ID1510_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 362):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1444:34: ({...}? ID )
                # ./output/PLSQL3.g:1444:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "USING")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyUSING", "(self.input).LT(1).text.upper() == \"USING\"")


                ID1510 = self.match(self.input, ID, self.FOLLOW_ID_in_keyUSING11694)
                if self._state.backtracking == 0:
                    ID1510_tree = self._adaptor.createWithPayload(ID1510)
                    self._adaptor.addChild(root_0, ID1510_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 362, keyUSING_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyUSING"


    class keyVARRAY_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyVARRAY_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyVARRAY"
    # ./output/PLSQL3.g:1445:1: keyVARRAY :{...}? ID ;
    def keyVARRAY(self, ):
        retval = self.keyVARRAY_return()
        retval.start = self.input.LT(1)

        keyVARRAY_StartIndex = self.input.index()

        root_0 = None

        ID1511 = None

        ID1511_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 363):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1445:34: ({...}? ID )
                # ./output/PLSQL3.g:1445:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "VARRAY")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyVARRAY", "(self.input).LT(1).text.upper() == \"VARRAY\"")


                ID1511 = self.match(self.input, ID, self.FOLLOW_ID_in_keyVARRAY11726)
                if self._state.backtracking == 0:
                    ID1511_tree = self._adaptor.createWithPayload(ID1511)
                    self._adaptor.addChild(root_0, ID1511_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 363, keyVARRAY_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyVARRAY"


    class keyVARYING_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyVARYING_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyVARYING"
    # ./output/PLSQL3.g:1446:1: keyVARYING :{...}? ID ;
    def keyVARYING(self, ):
        retval = self.keyVARYING_return()
        retval.start = self.input.LT(1)

        keyVARYING_StartIndex = self.input.index()

        root_0 = None

        ID1512 = None

        ID1512_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 364):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1446:33: ({...}? ID )
                # ./output/PLSQL3.g:1446:35: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "VARYING")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyVARYING", "(self.input).LT(1).text.upper() == \"VARYING\"")


                ID1512 = self.match(self.input, ID, self.FOLLOW_ID_in_keyVARYING11756)
                if self._state.backtracking == 0:
                    ID1512_tree = self._adaptor.createWithPayload(ID1512)
                    self._adaptor.addChild(root_0, ID1512_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 364, keyVARYING_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyVARYING"


    class keyWHILE_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyWHILE_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyWHILE"
    # ./output/PLSQL3.g:1447:1: keyWHILE : 'WHILE' ;
    def keyWHILE(self, ):
        retval = self.keyWHILE_return()
        retval.start = self.input.LT(1)

        keyWHILE_StartIndex = self.input.index()

        root_0 = None

        string_literal1513 = None

        string_literal1513_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 365):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1447:34: ( 'WHILE' )
                # ./output/PLSQL3.g:1447:36: 'WHILE'
                pass
                root_0 = self._adaptor.nil()


                string_literal1513 = self.match(self.input, 166, self.FOLLOW_166_in_keyWHILE11787)
                if self._state.backtracking == 0:
                    string_literal1513_tree = self._adaptor.createWithPayload(string_literal1513)
                    self._adaptor.addChild(root_0, string_literal1513_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 365, keyWHILE_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyWHILE"


    class keyWORK_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.keyWORK_return, self).__init__()

            self.tree = None





    # $ANTLR start "keyWORK"
    # ./output/PLSQL3.g:1448:1: keyWORK :{...}? ID ;
    def keyWORK(self, ):
        retval = self.keyWORK_return()
        retval.start = self.input.LT(1)

        keyWORK_StartIndex = self.input.index()

        root_0 = None

        ID1514 = None

        ID1514_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 366):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1448:34: ({...}? ID )
                # ./output/PLSQL3.g:1448:36: {...}? ID
                pass
                root_0 = self._adaptor.nil()


                if not (((self.input).LT(1).text.upper() == "WORK")):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    raise FailedPredicateException(self.input, "keyWORK", "(self.input).LT(1).text.upper() == \"WORK\"")


                ID1514 = self.match(self.input, ID, self.FOLLOW_ID_in_keyWORK11822)
                if self._state.backtracking == 0:
                    ID1514_tree = self._adaptor.createWithPayload(ID1514)
                    self._adaptor.addChild(root_0, ID1514_tree)





                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 366, keyWORK_StartIndex, success)


            pass
        return retval

    # $ANTLR end "keyWORK"


    class sql_identifier_return(ParserRuleReturnScope):
        def __init__(self):
            super(PLSQL3Parser.sql_identifier_return, self).__init__()

            self.tree = None





    # $ANTLR start "sql_identifier"
    # ./output/PLSQL3.g:1450:1: sql_identifier : ( identifier | 'ROWID' );
    def sql_identifier(self, ):
        retval = self.sql_identifier_return()
        retval.start = self.input.LT(1)

        sql_identifier_StartIndex = self.input.index()

        root_0 = None

        string_literal1516 = None
        identifier1515 = None


        string_literal1516_tree = None

        success = False

        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 367):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval


                # ./output/PLSQL3.g:1451:2: ( identifier | 'ROWID' )
                alt364 = 2
                LA364_0 = self.input.LA(1)

                if (LA364_0 == DOUBLEQUOTED_STRING or LA364_0 == ID) :
                    alt364 = 1
                elif (LA364_0 == 144) :
                    alt364 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed


                    nvae = NoViableAltException("", 364, 0, self.input)

                    raise nvae


                if alt364 == 1:
                    # ./output/PLSQL3.g:1451:4: identifier
                    pass
                    root_0 = self._adaptor.nil()


                    self._state.following.append(self.FOLLOW_identifier_in_sql_identifier11831)
                    identifier1515 = self.identifier()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, identifier1515.tree)



                elif alt364 == 2:
                    # ./output/PLSQL3.g:1452:4: 'ROWID'
                    pass
                    root_0 = self._adaptor.nil()


                    string_literal1516 = self.match(self.input, 144, self.FOLLOW_144_in_sql_identifier11836)
                    if self._state.backtracking == 0:
                        string_literal1516_tree = self._adaptor.createWithPayload(string_literal1516)
                        self._adaptor.addChild(root_0, string_literal1516_tree)




                retval.stop = self.input.LT(-1)


                if self._state.backtracking == 0:
                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)



                success = True

            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)

        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 367, sql_identifier_StartIndex, success)


            pass
        return retval

    # $ANTLR end "sql_identifier"

    # $ANTLR start "synpred13_PLSQL3"
    def synpred13_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:75:4: ( type_declaration )
        # ./output/PLSQL3.g:75:4: type_declaration
        pass
        self._state.following.append(self.FOLLOW_type_declaration_in_synpred13_PLSQL3234)
        self.type_declaration()

        self._state.following.pop()



    # $ANTLR end "synpred13_PLSQL3"



    # $ANTLR start "synpred14_PLSQL3"
    def synpred14_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:76:4: ( subtype_declaration )
        # ./output/PLSQL3.g:76:4: subtype_declaration
        pass
        self._state.following.append(self.FOLLOW_subtype_declaration_in_synpred14_PLSQL3239)
        self.subtype_declaration()

        self._state.following.pop()



    # $ANTLR end "synpred14_PLSQL3"



    # $ANTLR start "synpred27_PLSQL3"
    def synpred27_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:95:29: ( keyNEW )
        # ./output/PLSQL3.g:95:29: keyNEW
        pass
        self._state.following.append(self.FOLLOW_keyNEW_in_synpred27_PLSQL3361)
        self.keyNEW()

        self._state.following.pop()



    # $ANTLR end "synpred27_PLSQL3"



    # $ANTLR start "synpred43_PLSQL3"
    def synpred43_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:125:4: ( assignment_statement )
        # ./output/PLSQL3.g:125:4: assignment_statement
        pass
        self._state.following.append(self.FOLLOW_assignment_statement_in_synpred43_PLSQL3562)
        self.assignment_statement()

        self._state.following.pop()



    # $ANTLR end "synpred43_PLSQL3"



    # $ANTLR start "synpred44_PLSQL3"
    def synpred44_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:126:4: ( exit_statement )
        # ./output/PLSQL3.g:126:4: exit_statement
        pass
        self._state.following.append(self.FOLLOW_exit_statement_in_synpred44_PLSQL3567)
        self.exit_statement()

        self._state.following.pop()



    # $ANTLR end "synpred44_PLSQL3"



    # $ANTLR start "synpred46_PLSQL3"
    def synpred46_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:128:4: ( case_statement )
        # ./output/PLSQL3.g:128:4: case_statement
        pass
        self._state.following.append(self.FOLLOW_case_statement_in_synpred46_PLSQL3577)
        self.case_statement()

        self._state.following.pop()



    # $ANTLR end "synpred46_PLSQL3"



    # $ANTLR start "synpred48_PLSQL3"
    def synpred48_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:130:4: ( loop_statement )
        # ./output/PLSQL3.g:130:4: loop_statement
        pass
        self._state.following.append(self.FOLLOW_loop_statement_in_synpred48_PLSQL3588)
        self.loop_statement()

        self._state.following.pop()



    # $ANTLR end "synpred48_PLSQL3"



    # $ANTLR start "synpred52_PLSQL3"
    def synpred52_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:134:4: ( sql_statement )
        # ./output/PLSQL3.g:134:4: sql_statement
        pass
        self._state.following.append(self.FOLLOW_sql_statement_in_synpred52_PLSQL3609)
        self.sql_statement()

        self._state.following.pop()



    # $ANTLR end "synpred52_PLSQL3"



    # $ANTLR start "synpred53_PLSQL3"
    def synpred53_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:135:4: ( plsql_block )
        # ./output/PLSQL3.g:135:4: plsql_block
        pass
        self._state.following.append(self.FOLLOW_plsql_block_in_synpred53_PLSQL3614)
        self.plsql_block()

        self._state.following.pop()



    # $ANTLR end "synpred53_PLSQL3"



    # $ANTLR start "synpred62_PLSQL3"
    def synpred62_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:151:4: ( subtype_declaration )
        # ./output/PLSQL3.g:151:4: subtype_declaration
        pass
        self._state.following.append(self.FOLLOW_subtype_declaration_in_synpred62_PLSQL3723)
        self.subtype_declaration()

        self._state.following.pop()



    # $ANTLR end "synpred62_PLSQL3"



    # $ANTLR start "synpred70_PLSQL3"
    def synpred70_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:159:4: ( type_declaration )
        # ./output/PLSQL3.g:159:4: type_declaration
        pass
        self._state.following.append(self.FOLLOW_type_declaration_in_synpred70_PLSQL3769)
        self.type_declaration()

        self._state.following.pop()



    # $ANTLR end "synpred70_PLSQL3"



    # $ANTLR start "synpred73_PLSQL3"
    def synpred73_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:165:5: ( keyRESTRICT_REFERENCES LPAREN ( 'DEFAULT' | function_name ) ( COMMA pragma_param )+ RPAREN )
        # ./output/PLSQL3.g:165:5: keyRESTRICT_REFERENCES LPAREN ( 'DEFAULT' | function_name ) ( COMMA pragma_param )+ RPAREN
        pass
        self._state.following.append(self.FOLLOW_keyRESTRICT_REFERENCES_in_synpred73_PLSQL3793)
        self.keyRESTRICT_REFERENCES()

        self._state.following.pop()

        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred73_PLSQL3795)

        # ./output/PLSQL3.g:165:35: ( 'DEFAULT' | function_name )
        alt369 = 2
        LA369_0 = self.input.LA(1)

        if (LA369_0 == 78) :
            alt369 = 1
        elif (LA369_0 == DOUBLEQUOTED_STRING or LA369_0 == ID or LA369_0 == QUOTED_STRING) :
            alt369 = 2
        else:
            if self._state.backtracking > 0:
                raise BacktrackingFailed


            nvae = NoViableAltException("", 369, 0, self.input)

            raise nvae


        if alt369 == 1:
            # ./output/PLSQL3.g:165:37: 'DEFAULT'
            pass
            self.match(self.input, 78, self.FOLLOW_78_in_synpred73_PLSQL3799)


        elif alt369 == 2:
            # ./output/PLSQL3.g:165:49: function_name
            pass
            self._state.following.append(self.FOLLOW_function_name_in_synpred73_PLSQL3803)
            self.function_name()

            self._state.following.pop()




        # ./output/PLSQL3.g:165:65: ( COMMA pragma_param )+
        cnt370 = 0
        while True: #loop370
            alt370 = 2
            LA370_0 = self.input.LA(1)

            if (LA370_0 == COMMA) :
                alt370 = 1


            if alt370 == 1:
                # ./output/PLSQL3.g:165:67: COMMA pragma_param
                pass
                self.match(self.input, COMMA, self.FOLLOW_COMMA_in_synpred73_PLSQL3809)

                self._state.following.append(self.FOLLOW_pragma_param_in_synpred73_PLSQL3811)
                self.pragma_param()

                self._state.following.pop()


            else:
                if cnt370 >= 1:
                    break #loop370

                if self._state.backtracking > 0:
                    raise BacktrackingFailed


                eee = EarlyExitException(370, self.input)
                raise eee

            cnt370 += 1


        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred73_PLSQL3816)



    # $ANTLR end "synpred73_PLSQL3"



    # $ANTLR start "synpred74_PLSQL3"
    def synpred74_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:166:5: ( keyEXCEPTION_INIT LPAREN exception_name COMMA literal RPAREN )
        # ./output/PLSQL3.g:166:5: keyEXCEPTION_INIT LPAREN exception_name COMMA literal RPAREN
        pass
        self._state.following.append(self.FOLLOW_keyEXCEPTION_INIT_in_synpred74_PLSQL3823)
        self.keyEXCEPTION_INIT()

        self._state.following.pop()

        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred74_PLSQL3825)

        self._state.following.append(self.FOLLOW_exception_name_in_synpred74_PLSQL3827)
        self.exception_name()

        self._state.following.pop()

        self.match(self.input, COMMA, self.FOLLOW_COMMA_in_synpred74_PLSQL3829)

        self._state.following.append(self.FOLLOW_literal_in_synpred74_PLSQL3831)
        self.literal()

        self._state.following.pop()

        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred74_PLSQL3833)



    # $ANTLR end "synpred74_PLSQL3"



    # $ANTLR start "synpred75_PLSQL3"
    def synpred75_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:167:5: ( keyAUTONOMOUS_TRANSACTION )
        # ./output/PLSQL3.g:167:5: keyAUTONOMOUS_TRANSACTION
        pass
        self._state.following.append(self.FOLLOW_keyAUTONOMOUS_TRANSACTION_in_synpred75_PLSQL3839)
        self.keyAUTONOMOUS_TRANSACTION()

        self._state.following.pop()



    # $ANTLR end "synpred75_PLSQL3"



    # $ANTLR start "synpred76_PLSQL3"
    def synpred76_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:168:5: ( keySERIALLY_REUSABLE )
        # ./output/PLSQL3.g:168:5: keySERIALLY_REUSABLE
        pass
        self._state.following.append(self.FOLLOW_keySERIALLY_REUSABLE_in_synpred76_PLSQL3845)
        self.keySERIALLY_REUSABLE()

        self._state.following.pop()



    # $ANTLR end "synpred76_PLSQL3"



    # $ANTLR start "synpred77_PLSQL3"
    def synpred77_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:169:5: ( keyBUILTIN LPAREN pragma_params RPAREN )
        # ./output/PLSQL3.g:169:5: keyBUILTIN LPAREN pragma_params RPAREN
        pass
        self._state.following.append(self.FOLLOW_keyBUILTIN_in_synpred77_PLSQL3851)
        self.keyBUILTIN()

        self._state.following.pop()

        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred77_PLSQL3853)

        self._state.following.append(self.FOLLOW_pragma_params_in_synpred77_PLSQL3855)
        self.pragma_params()

        self._state.following.pop()

        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred77_PLSQL3857)



    # $ANTLR end "synpred77_PLSQL3"



    # $ANTLR start "synpred78_PLSQL3"
    def synpred78_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:170:5: ( keyFIPSFLAG LPAREN pragma_params RPAREN )
        # ./output/PLSQL3.g:170:5: keyFIPSFLAG LPAREN pragma_params RPAREN
        pass
        self._state.following.append(self.FOLLOW_keyFIPSFLAG_in_synpred78_PLSQL3863)
        self.keyFIPSFLAG()

        self._state.following.pop()

        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred78_PLSQL3865)

        self._state.following.append(self.FOLLOW_pragma_params_in_synpred78_PLSQL3867)
        self.pragma_params()

        self._state.following.pop()

        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred78_PLSQL3869)



    # $ANTLR end "synpred78_PLSQL3"



    # $ANTLR start "synpred79_PLSQL3"
    def synpred79_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:171:5: ( keyINTERFACE LPAREN pragma_params RPAREN )
        # ./output/PLSQL3.g:171:5: keyINTERFACE LPAREN pragma_params RPAREN
        pass
        self._state.following.append(self.FOLLOW_keyINTERFACE_in_synpred79_PLSQL3875)
        self.keyINTERFACE()

        self._state.following.pop()

        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred79_PLSQL3877)

        self._state.following.append(self.FOLLOW_pragma_params_in_synpred79_PLSQL3879)
        self.pragma_params()

        self._state.following.pop()

        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred79_PLSQL3881)



    # $ANTLR end "synpred79_PLSQL3"



    # $ANTLR start "synpred80_PLSQL3"
    def synpred80_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:172:5: ( keyNEW_NAMES LPAREN pragma_params RPAREN )
        # ./output/PLSQL3.g:172:5: keyNEW_NAMES LPAREN pragma_params RPAREN
        pass
        self._state.following.append(self.FOLLOW_keyNEW_NAMES_in_synpred80_PLSQL3887)
        self.keyNEW_NAMES()

        self._state.following.pop()

        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred80_PLSQL3889)

        self._state.following.append(self.FOLLOW_pragma_params_in_synpred80_PLSQL3891)
        self.pragma_params()

        self._state.following.pop()

        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred80_PLSQL3893)



    # $ANTLR end "synpred80_PLSQL3"



    # $ANTLR start "synpred114_PLSQL3"
    def synpred114_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:239:4: ( keyINTERVAL keyDAY ( LPAREN NUMBER RPAREN )? 'TO' keySECOND ( LPAREN NUMBER RPAREN )? )
        # ./output/PLSQL3.g:239:4: keyINTERVAL keyDAY ( LPAREN NUMBER RPAREN )? 'TO' keySECOND ( LPAREN NUMBER RPAREN )?
        pass
        self._state.following.append(self.FOLLOW_keyINTERVAL_in_synpred114_PLSQL31280)
        self.keyINTERVAL()

        self._state.following.pop()

        self._state.following.append(self.FOLLOW_keyDAY_in_synpred114_PLSQL31282)
        self.keyDAY()

        self._state.following.pop()

        # ./output/PLSQL3.g:239:23: ( LPAREN NUMBER RPAREN )?
        alt379 = 2
        LA379_0 = self.input.LA(1)

        if (LA379_0 == LPAREN) :
            alt379 = 1
        if alt379 == 1:
            # ./output/PLSQL3.g:239:25: LPAREN NUMBER RPAREN
            pass
            self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred114_PLSQL31286)

            self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_synpred114_PLSQL31288)

            self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred114_PLSQL31290)




        self.match(self.input, 155, self.FOLLOW_155_in_synpred114_PLSQL31295)

        self._state.following.append(self.FOLLOW_keySECOND_in_synpred114_PLSQL31297)
        self.keySECOND()

        self._state.following.pop()

        # ./output/PLSQL3.g:239:64: ( LPAREN NUMBER RPAREN )?
        alt380 = 2
        LA380_0 = self.input.LA(1)

        if (LA380_0 == LPAREN) :
            alt380 = 1
        if alt380 == 1:
            # ./output/PLSQL3.g:239:66: LPAREN NUMBER RPAREN
            pass
            self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred114_PLSQL31301)

            self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_synpred114_PLSQL31303)

            self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred114_PLSQL31305)






    # $ANTLR end "synpred114_PLSQL3"



    # $ANTLR start "synpred116_PLSQL3"
    def synpred116_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:240:4: ( keyINTERVAL keyYEAR ( LPAREN NUMBER RPAREN )? 'TO' keyMONTH )
        # ./output/PLSQL3.g:240:4: keyINTERVAL keyYEAR ( LPAREN NUMBER RPAREN )? 'TO' keyMONTH
        pass
        self._state.following.append(self.FOLLOW_keyINTERVAL_in_synpred116_PLSQL31313)
        self.keyINTERVAL()

        self._state.following.pop()

        self._state.following.append(self.FOLLOW_keyYEAR_in_synpred116_PLSQL31315)
        self.keyYEAR()

        self._state.following.pop()

        # ./output/PLSQL3.g:240:24: ( LPAREN NUMBER RPAREN )?
        alt381 = 2
        LA381_0 = self.input.LA(1)

        if (LA381_0 == LPAREN) :
            alt381 = 1
        if alt381 == 1:
            # ./output/PLSQL3.g:240:26: LPAREN NUMBER RPAREN
            pass
            self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred116_PLSQL31319)

            self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_synpred116_PLSQL31321)

            self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred116_PLSQL31323)




        self.match(self.input, 155, self.FOLLOW_155_in_synpred116_PLSQL31328)

        self._state.following.append(self.FOLLOW_keyMONTH_in_synpred116_PLSQL31330)
        self.keyMONTH()

        self._state.following.pop()



    # $ANTLR end "synpred116_PLSQL3"



    # $ANTLR start "synpred117_PLSQL3"
    def synpred117_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:241:6: ( keyTIME )
        # ./output/PLSQL3.g:241:6: keyTIME
        pass
        self._state.following.append(self.FOLLOW_keyTIME_in_synpred117_PLSQL31337)
        self.keyTIME()

        self._state.following.pop()



    # $ANTLR end "synpred117_PLSQL3"



    # $ANTLR start "synpred172_PLSQL3"
    def synpred172_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:267:4: ( datatype )
        # ./output/PLSQL3.g:267:4: datatype
        pass
        self._state.following.append(self.FOLLOW_datatype_in_synpred172_PLSQL31806)
        self.datatype()

        self._state.following.pop()



    # $ANTLR end "synpred172_PLSQL3"



    # $ANTLR start "synpred232_PLSQL3"
    def synpred232_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:471:28: ({...}? LPAREN ( call_parameters )? RPAREN )
        # ./output/PLSQL3.g:471:28: {...}? LPAREN ( call_parameters )? RPAREN
        pass
        if not ((input.LA(1) != LPAREN or input.LA(2) != PLUS or input.LA(3) != RPAREN )):
            if self._state.backtracking > 0:
                raise BacktrackingFailed


            raise FailedPredicateException(self.input, "synpred232_PLSQL3", " input.LA(1) != LPAREN or input.LA(2) != PLUS or input.LA(3) != RPAREN ")


        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred232_PLSQL32921)

        # ./output/PLSQL3.g:471:110: ( call_parameters )?
        alt424 = 2
        LA424_0 = self.input.LA(1)

        if (LA424_0 == DOUBLEQUOTED_STRING or LA424_0 == ID or LA424_0 == LPAREN or LA424_0 == MINUS or LA424_0 == NUMBER or LA424_0 == PLUS or LA424_0 == QUOTED_STRING or LA424_0 == 65 or LA424_0 == 81 or LA424_0 == 89 or LA424_0 == 118 or LA424_0 == 120 or LA424_0 == 144 or LA424_0 == 147 or LA424_0 == 151 or LA424_0 == 156) :
            alt424 = 1
        if alt424 == 1:
            # ./output/PLSQL3.g:471:112: call_parameters
            pass
            self._state.following.append(self.FOLLOW_call_parameters_in_synpred232_PLSQL32925)
            self.call_parameters()

            self._state.following.pop()




        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred232_PLSQL32930)



    # $ANTLR end "synpred232_PLSQL3"



    # $ANTLR start "synpred238_PLSQL3"
    def synpred238_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:506:7: ( numeric_loop_param )
        # ./output/PLSQL3.g:506:9: numeric_loop_param
        pass
        self._state.following.append(self.FOLLOW_numeric_loop_param_in_synpred238_PLSQL33077)
        self.numeric_loop_param()

        self._state.following.pop()



    # $ANTLR end "synpred238_PLSQL3"



    # $ANTLR start "synpred239_PLSQL3"
    def synpred239_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:507:7: ( cursor_loop_param )
        # ./output/PLSQL3.g:507:9: cursor_loop_param
        pass
        self._state.following.append(self.FOLLOW_cursor_loop_param_in_synpred239_PLSQL33093)
        self.cursor_loop_param()

        self._state.following.pop()



    # $ANTLR end "synpred239_PLSQL3"



    # $ANTLR start "synpred242_PLSQL3"
    def synpred242_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:518:22: ( keyREVERSE )
        # ./output/PLSQL3.g:518:22: keyREVERSE
        pass
        self._state.following.append(self.FOLLOW_keyREVERSE_in_synpred242_PLSQL33157)
        self.keyREVERSE()

        self._state.following.pop()



    # $ANTLR end "synpred242_PLSQL3"



    # $ANTLR start "synpred252_PLSQL3"
    def synpred252_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:576:4: ( close_statement )
        # ./output/PLSQL3.g:576:4: close_statement
        pass
        self._state.following.append(self.FOLLOW_close_statement_in_synpred252_PLSQL33391)
        self.close_statement()

        self._state.following.pop()



    # $ANTLR end "synpred252_PLSQL3"



    # $ANTLR start "synpred256_PLSQL3"
    def synpred256_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:580:4: ( open_statement )
        # ./output/PLSQL3.g:580:4: open_statement
        pass
        self._state.following.append(self.FOLLOW_open_statement_in_synpred256_PLSQL33411)
        self.open_statement()

        self._state.following.pop()



    # $ANTLR end "synpred256_PLSQL3"



    # $ANTLR start "synpred263_PLSQL3"
    def synpred263_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:599:12: ( join_clause )
        # ./output/PLSQL3.g:599:12: join_clause
        pass
        self._state.following.append(self.FOLLOW_join_clause_in_synpred263_PLSQL33510)
        self.join_clause()

        self._state.following.pop()



    # $ANTLR end "synpred263_PLSQL3"



    # $ANTLR start "synpred264_PLSQL3"
    def synpred264_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:599:26: ( LPAREN join_clause RPAREN )
        # ./output/PLSQL3.g:599:26: LPAREN join_clause RPAREN
        pass
        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred264_PLSQL33514)

        self._state.following.append(self.FOLLOW_join_clause_in_synpred264_PLSQL33516)
        self.join_clause()

        self._state.following.pop()

        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred264_PLSQL33518)



    # $ANTLR end "synpred264_PLSQL3"



    # $ANTLR start "synpred265_PLSQL3"
    def synpred265_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:600:5: ( where_clause )
        # ./output/PLSQL3.g:600:5: where_clause
        pass
        self._state.following.append(self.FOLLOW_where_clause_in_synpred265_PLSQL33530)
        self.where_clause()

        self._state.following.pop()



    # $ANTLR end "synpred265_PLSQL3"



    # $ANTLR start "synpred266_PLSQL3"
    def synpred266_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:600:23: ( hierarchical_query_clause )
        # ./output/PLSQL3.g:600:23: hierarchical_query_clause
        pass
        self._state.following.append(self.FOLLOW_hierarchical_query_clause_in_synpred266_PLSQL33537)
        self.hierarchical_query_clause()

        self._state.following.pop()



    # $ANTLR end "synpred266_PLSQL3"



    # $ANTLR start "synpred267_PLSQL3"
    def synpred267_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:600:54: ( group_by_clause )
        # ./output/PLSQL3.g:600:54: group_by_clause
        pass
        self._state.following.append(self.FOLLOW_group_by_clause_in_synpred267_PLSQL33544)
        self.group_by_clause()

        self._state.following.pop()



    # $ANTLR end "synpred267_PLSQL3"



    # $ANTLR start "synpred268_PLSQL3"
    def synpred268_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:601:5: ( 'HAVING' sql_condition )
        # ./output/PLSQL3.g:601:5: 'HAVING' sql_condition
        pass
        self.match(self.input, 97, self.FOLLOW_97_in_synpred268_PLSQL33553)

        self._state.following.append(self.FOLLOW_sql_condition_in_synpred268_PLSQL33555)
        self.sql_condition()

        self._state.following.pop()



    # $ANTLR end "synpred268_PLSQL3"



    # $ANTLR start "synpred269_PLSQL3"
    def synpred269_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:601:33: ( model_clause )
        # ./output/PLSQL3.g:601:33: model_clause
        pass
        self._state.following.append(self.FOLLOW_model_clause_in_synpred269_PLSQL33562)
        self.model_clause()

        self._state.following.pop()



    # $ANTLR end "synpred269_PLSQL3"



    # $ANTLR start "synpred274_PLSQL3"
    def synpred274_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:602:5: ( ( 'UNION' ( 'ALL' )? | 'INTERSECT' | 'MINUS' ) ( select_expression | subquery ) )
        # ./output/PLSQL3.g:602:5: ( 'UNION' ( 'ALL' )? | 'INTERSECT' | 'MINUS' ) ( select_expression | subquery )
        pass
        # ./output/PLSQL3.g:602:5: ( 'UNION' ( 'ALL' )? | 'INTERSECT' | 'MINUS' )
        alt429 = 3
        LA429 = self.input.LA(1)
        if LA429 == 157:
            alt429 = 1
        elif LA429 == 104:
            alt429 = 2
        elif LA429 == 111:
            alt429 = 3
        else:
            if self._state.backtracking > 0:
                raise BacktrackingFailed


            nvae = NoViableAltException("", 429, 0, self.input)

            raise nvae


        if alt429 == 1:
            # ./output/PLSQL3.g:602:7: 'UNION' ( 'ALL' )?
            pass
            self.match(self.input, 157, self.FOLLOW_157_in_synpred274_PLSQL33573)

            # ./output/PLSQL3.g:602:15: ( 'ALL' )?
            alt428 = 2
            LA428_0 = self.input.LA(1)

            if (LA428_0 == 50) :
                alt428 = 1
            if alt428 == 1:
                # ./output/PLSQL3.g:602:17: 'ALL'
                pass
                self.match(self.input, 50, self.FOLLOW_50_in_synpred274_PLSQL33577)





        elif alt429 == 2:
            # ./output/PLSQL3.g:603:6: 'INTERSECT'
            pass
            self.match(self.input, 104, self.FOLLOW_104_in_synpred274_PLSQL33587)


        elif alt429 == 3:
            # ./output/PLSQL3.g:604:6: 'MINUS'
            pass
            self.match(self.input, 111, self.FOLLOW_111_in_synpred274_PLSQL33594)




        # ./output/PLSQL3.g:606:4: ( select_expression | subquery )
        alt430 = 2
        LA430_0 = self.input.LA(1)

        if (LA430_0 == 147) :
            alt430 = 1
        elif (LA430_0 == LPAREN) :
            alt430 = 2
        else:
            if self._state.backtracking > 0:
                raise BacktrackingFailed


            nvae = NoViableAltException("", 430, 0, self.input)

            raise nvae


        if alt430 == 1:
            # ./output/PLSQL3.g:606:6: select_expression
            pass
            self._state.following.append(self.FOLLOW_select_expression_in_synpred274_PLSQL33606)
            self.select_expression()

            self._state.following.pop()


        elif alt430 == 2:
            # ./output/PLSQL3.g:607:6: subquery
            pass
            self._state.following.append(self.FOLLOW_subquery_in_synpred274_PLSQL33614)
            self.subquery()

            self._state.following.pop()






    # $ANTLR end "synpred274_PLSQL3"



    # $ANTLR start "synpred275_PLSQL3"
    def synpred275_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:610:5: ( order_by_clause )
        # ./output/PLSQL3.g:610:5: order_by_clause
        pass
        self._state.following.append(self.FOLLOW_order_by_clause_in_synpred275_PLSQL33630)
        self.order_by_clause()

        self._state.following.pop()



    # $ANTLR end "synpred275_PLSQL3"



    # $ANTLR start "synpred278_PLSQL3"
    def synpred278_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:623:21: ( COMMA selected_table )
        # ./output/PLSQL3.g:623:21: COMMA selected_table
        pass
        self.match(self.input, COMMA, self.FOLLOW_COMMA_in_synpred278_PLSQL33686)

        self._state.following.append(self.FOLLOW_selected_table_in_synpred278_PLSQL33688)
        self.selected_table()

        self._state.following.pop()



    # $ANTLR end "synpred278_PLSQL3"



    # $ANTLR start "synpred279_PLSQL3"
    def synpred279_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:627:21: ( inner_cross_join_clause )
        # ./output/PLSQL3.g:627:21: inner_cross_join_clause
        pass
        self._state.following.append(self.FOLLOW_inner_cross_join_clause_in_synpred279_PLSQL33706)
        self.inner_cross_join_clause()

        self._state.following.pop()



    # $ANTLR end "synpred279_PLSQL3"



    # $ANTLR start "synpred280_PLSQL3"
    def synpred280_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:627:47: ( outer_join_clause )
        # ./output/PLSQL3.g:627:47: outer_join_clause
        pass
        self._state.following.append(self.FOLLOW_outer_join_clause_in_synpred280_PLSQL33710)
        self.outer_join_clause()

        self._state.following.pop()



    # $ANTLR end "synpred280_PLSQL3"



    # $ANTLR start "synpred283_PLSQL3"
    def synpred283_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:630:4: ( ( keyINNER )? keyJOIN table_name ( 'ON' sql_condition | keyUSING LPAREN column_specs RPAREN ) )
        # ./output/PLSQL3.g:630:4: ( keyINNER )? keyJOIN table_name ( 'ON' sql_condition | keyUSING LPAREN column_specs RPAREN )
        pass
        # ./output/PLSQL3.g:630:4: ( keyINNER )?
        alt431 = 2
        LA431_0 = self.input.LA(1)

        if (LA431_0 == ID) :
            LA431_1 = self.input.LA(2)

            if (LA431_1 == ID) :
                LA431_2 = self.input.LA(3)

                if (LA431_2 == ID) :
                    LA431_4 = self.input.LA(4)

                    if (LA431_4 == ID or LA431_4 == 126) :
                        alt431 = 1
                elif (LA431_2 == DOUBLEQUOTED_STRING or LA431_2 == 144) :
                    alt431 = 1
        if alt431 == 1:
            # ./output/PLSQL3.g:630:6: keyINNER
            pass
            self._state.following.append(self.FOLLOW_keyINNER_in_synpred283_PLSQL33725)
            self.keyINNER()

            self._state.following.pop()




        self._state.following.append(self.FOLLOW_keyJOIN_in_synpred283_PLSQL33730)
        self.keyJOIN()

        self._state.following.pop()

        self._state.following.append(self.FOLLOW_table_name_in_synpred283_PLSQL33732)
        self.table_name()

        self._state.following.pop()

        # ./output/PLSQL3.g:630:37: ( 'ON' sql_condition | keyUSING LPAREN column_specs RPAREN )
        alt432 = 2
        LA432_0 = self.input.LA(1)

        if (LA432_0 == 126) :
            alt432 = 1
        elif (LA432_0 == ID) :
            alt432 = 2
        else:
            if self._state.backtracking > 0:
                raise BacktrackingFailed


            nvae = NoViableAltException("", 432, 0, self.input)

            raise nvae


        if alt432 == 1:
            # ./output/PLSQL3.g:630:39: 'ON' sql_condition
            pass
            self.match(self.input, 126, self.FOLLOW_126_in_synpred283_PLSQL33736)

            self._state.following.append(self.FOLLOW_sql_condition_in_synpred283_PLSQL33738)
            self.sql_condition()

            self._state.following.pop()


        elif alt432 == 2:
            # ./output/PLSQL3.g:630:60: keyUSING LPAREN column_specs RPAREN
            pass
            self._state.following.append(self.FOLLOW_keyUSING_in_synpred283_PLSQL33742)
            self.keyUSING()

            self._state.following.pop()

            self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred283_PLSQL33744)

            self._state.following.append(self.FOLLOW_column_specs_in_synpred283_PLSQL33746)
            self.column_specs()

            self._state.following.pop()

            self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred283_PLSQL33748)






    # $ANTLR end "synpred283_PLSQL3"



    # $ANTLR start "synpred284_PLSQL3"
    def synpred284_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:631:6: ( keyCROSS )
        # ./output/PLSQL3.g:631:6: keyCROSS
        pass
        self._state.following.append(self.FOLLOW_keyCROSS_in_synpred284_PLSQL33757)
        self.keyCROSS()

        self._state.following.pop()



    # $ANTLR end "synpred284_PLSQL3"



    # $ANTLR start "synpred286_PLSQL3"
    def synpred286_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:635:5: ( outer_join_type keyJOIN )
        # ./output/PLSQL3.g:635:5: outer_join_type keyJOIN
        pass
        self._state.following.append(self.FOLLOW_outer_join_type_in_synpred286_PLSQL33794)
        self.outer_join_type()

        self._state.following.pop()

        self._state.following.append(self.FOLLOW_keyJOIN_in_synpred286_PLSQL33796)
        self.keyJOIN()

        self._state.following.pop()



    # $ANTLR end "synpred286_PLSQL3"



    # $ANTLR start "synpred287_PLSQL3"
    def synpred287_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:636:18: ( outer_join_type )
        # ./output/PLSQL3.g:636:18: outer_join_type
        pass
        self._state.following.append(self.FOLLOW_outer_join_type_in_synpred287_PLSQL33806)
        self.outer_join_type()

        self._state.following.pop()



    # $ANTLR end "synpred287_PLSQL3"



    # $ANTLR start "synpred288_PLSQL3"
    def synpred288_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:638:20: ( query_partition_clause )
        # ./output/PLSQL3.g:638:20: query_partition_clause
        pass
        self._state.following.append(self.FOLLOW_query_partition_clause_in_synpred288_PLSQL33823)
        self.query_partition_clause()

        self._state.following.pop()



    # $ANTLR end "synpred288_PLSQL3"



    # $ANTLR start "synpred289_PLSQL3"
    def synpred289_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:639:5: ( 'ON' sql_condition )
        # ./output/PLSQL3.g:639:5: 'ON' sql_condition
        pass
        self.match(self.input, 126, self.FOLLOW_126_in_synpred289_PLSQL33832)

        self._state.following.append(self.FOLLOW_sql_condition_in_synpred289_PLSQL33834)
        self.sql_condition()

        self._state.following.pop()



    # $ANTLR end "synpred289_PLSQL3"



    # $ANTLR start "synpred290_PLSQL3"
    def synpred290_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:639:26: ( keyUSING LPAREN column_specs RPAREN )
        # ./output/PLSQL3.g:639:26: keyUSING LPAREN column_specs RPAREN
        pass
        self._state.following.append(self.FOLLOW_keyUSING_in_synpred290_PLSQL33838)
        self.keyUSING()

        self._state.following.pop()

        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred290_PLSQL33840)

        self._state.following.append(self.FOLLOW_column_specs_in_synpred290_PLSQL33842)
        self.column_specs()

        self._state.following.pop()

        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred290_PLSQL33844)



    # $ANTLR end "synpred290_PLSQL3"



    # $ANTLR start "synpred291_PLSQL3"
    def synpred291_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:645:6: ( keyFULL )
        # ./output/PLSQL3.g:645:6: keyFULL
        pass
        self._state.following.append(self.FOLLOW_keyFULL_in_synpred291_PLSQL33873)
        self.keyFULL()

        self._state.following.pop()



    # $ANTLR end "synpred291_PLSQL3"



    # $ANTLR start "synpred292_PLSQL3"
    def synpred292_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:645:16: ( keyLEFT )
        # ./output/PLSQL3.g:645:16: keyLEFT
        pass
        self._state.following.append(self.FOLLOW_keyLEFT_in_synpred292_PLSQL33877)
        self.keyLEFT()

        self._state.following.pop()



    # $ANTLR end "synpred292_PLSQL3"



    # $ANTLR start "synpred293_PLSQL3"
    def synpred293_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:645:39: ( keyOUTER )
        # ./output/PLSQL3.g:645:39: keyOUTER
        pass
        self._state.following.append(self.FOLLOW_keyOUTER_in_synpred293_PLSQL33887)
        self.keyOUTER()

        self._state.following.pop()



    # $ANTLR end "synpred293_PLSQL3"



    # $ANTLR start "synpred295_PLSQL3"
    def synpred295_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:654:55: ( keyNOCYCLE )
        # ./output/PLSQL3.g:654:55: keyNOCYCLE
        pass
        self._state.following.append(self.FOLLOW_keyNOCYCLE_in_synpred295_PLSQL33943)
        self.keyNOCYCLE()

        self._state.following.pop()



    # $ANTLR end "synpred295_PLSQL3"



    # $ANTLR start "synpred296_PLSQL3"
    def synpred296_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:660:20: ( COMMA group_by_expr )
        # ./output/PLSQL3.g:660:20: COMMA group_by_expr
        pass
        self.match(self.input, COMMA, self.FOLLOW_COMMA_in_synpred296_PLSQL33976)

        self._state.following.append(self.FOLLOW_group_by_expr_in_synpred296_PLSQL33978)
        self.group_by_expr()

        self._state.following.pop()



    # $ANTLR end "synpred296_PLSQL3"



    # $ANTLR start "synpred297_PLSQL3"
    def synpred297_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:663:4: ( rollup_cube_clause )
        # ./output/PLSQL3.g:663:4: rollup_cube_clause
        pass
        self._state.following.append(self.FOLLOW_rollup_cube_clause_in_synpred297_PLSQL33991)
        self.rollup_cube_clause()

        self._state.following.pop()



    # $ANTLR end "synpred297_PLSQL3"



    # $ANTLR start "synpred298_PLSQL3"
    def synpred298_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:664:4: ( grouping_sets_clause )
        # ./output/PLSQL3.g:664:4: grouping_sets_clause
        pass
        self._state.following.append(self.FOLLOW_grouping_sets_clause_in_synpred298_PLSQL33996)
        self.grouping_sets_clause()

        self._state.following.pop()



    # $ANTLR end "synpred298_PLSQL3"



    # $ANTLR start "synpred299_PLSQL3"
    def synpred299_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:668:6: ( keyROLLUP )
        # ./output/PLSQL3.g:668:6: keyROLLUP
        pass
        self._state.following.append(self.FOLLOW_keyROLLUP_in_synpred299_PLSQL34013)
        self.keyROLLUP()

        self._state.following.pop()



    # $ANTLR end "synpred299_PLSQL3"



    # $ANTLR start "synpred301_PLSQL3"
    def synpred301_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:677:4: ( rollup_cube_clause )
        # ./output/PLSQL3.g:677:4: rollup_cube_clause
        pass
        self._state.following.append(self.FOLLOW_rollup_cube_clause_in_synpred301_PLSQL34072)
        self.rollup_cube_clause()

        self._state.following.pop()



    # $ANTLR end "synpred301_PLSQL3"



    # $ANTLR start "synpred304_PLSQL3"
    def synpred304_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:685:8: ( keyIGNORE )
        # ./output/PLSQL3.g:685:8: keyIGNORE
        pass
        self._state.following.append(self.FOLLOW_keyIGNORE_in_synpred304_PLSQL34126)
        self.keyIGNORE()

        self._state.following.pop()



    # $ANTLR end "synpred304_PLSQL3"



    # $ANTLR start "synpred305_PLSQL3"
    def synpred305_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:685:6: ( ( keyIGNORE | keyKEEP ) keyNAV )
        # ./output/PLSQL3.g:685:6: ( keyIGNORE | keyKEEP ) keyNAV
        pass
        # ./output/PLSQL3.g:685:6: ( keyIGNORE | keyKEEP )
        alt433 = 2
        LA433_0 = self.input.LA(1)

        if (LA433_0 == ID) :
            LA433_1 = self.input.LA(2)

            if (((((self.synpred304_PLSQL3()) and (self.synpred304_PLSQL3()))) and (((self.input).LT(1).text.upper() == "IGNORE")))) :
                alt433 = 1
            elif (((self.input).LT(1).text.upper() == "KEEP")) :
                alt433 = 2
            else:
                if self._state.backtracking > 0:
                    raise BacktrackingFailed


                nvae = NoViableAltException("", 433, 1, self.input)

                raise nvae


        else:
            if self._state.backtracking > 0:
                raise BacktrackingFailed


            nvae = NoViableAltException("", 433, 0, self.input)

            raise nvae


        if alt433 == 1:
            # ./output/PLSQL3.g:685:8: keyIGNORE
            pass
            self._state.following.append(self.FOLLOW_keyIGNORE_in_synpred305_PLSQL34126)
            self.keyIGNORE()

            self._state.following.pop()


        elif alt433 == 2:
            # ./output/PLSQL3.g:685:20: keyKEEP
            pass
            self._state.following.append(self.FOLLOW_keyKEEP_in_synpred305_PLSQL34130)
            self.keyKEEP()

            self._state.following.pop()




        self._state.following.append(self.FOLLOW_keyNAV_in_synpred305_PLSQL34134)
        self.keyNAV()

        self._state.following.pop()



    # $ANTLR end "synpred305_PLSQL3"



    # $ANTLR start "synpred306_PLSQL3"
    def synpred306_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:686:16: ( keyDIMENSION )
        # ./output/PLSQL3.g:686:16: keyDIMENSION
        pass
        self._state.following.append(self.FOLLOW_keyDIMENSION_in_synpred306_PLSQL34147)
        self.keyDIMENSION()

        self._state.following.pop()



    # $ANTLR end "synpred306_PLSQL3"



    # $ANTLR start "synpred311_PLSQL3"
    def synpred311_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:706:6: ( query_partition_clause ( column_spec )? )
        # ./output/PLSQL3.g:706:6: query_partition_clause ( column_spec )?
        pass
        self._state.following.append(self.FOLLOW_query_partition_clause_in_synpred311_PLSQL34271)
        self.query_partition_clause()

        self._state.following.pop()

        # ./output/PLSQL3.g:706:29: ( column_spec )?
        alt435 = 2
        LA435_0 = self.input.LA(1)

        if (LA435_0 == DOUBLEQUOTED_STRING or LA435_0 == ID or LA435_0 == 144) :
            alt435 = 1
        if alt435 == 1:
            # ./output/PLSQL3.g:706:31: column_spec
            pass
            self._state.following.append(self.FOLLOW_column_spec_in_synpred311_PLSQL34275)
            self.column_spec()

            self._state.following.pop()






    # $ANTLR end "synpred311_PLSQL3"



    # $ANTLR start "synpred318_PLSQL3"
    def synpred318_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:717:56: ( keyAUTOMATIC )
        # ./output/PLSQL3.g:717:56: keyAUTOMATIC
        pass
        self._state.following.append(self.FOLLOW_keyAUTOMATIC_in_synpred318_PLSQL34382)
        self.keyAUTOMATIC()

        self._state.following.pop()



    # $ANTLR end "synpred318_PLSQL3"



    # $ANTLR start "synpred330_PLSQL3"
    def synpred330_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:734:4: ( sql_condition )
        # ./output/PLSQL3.g:734:4: sql_condition
        pass
        self._state.following.append(self.FOLLOW_sql_condition_in_synpred330_PLSQL34543)
        self.sql_condition()

        self._state.following.pop()



    # $ANTLR end "synpred330_PLSQL3"



    # $ANTLR start "synpred331_PLSQL3"
    def synpred331_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:734:20: ( sql_expression )
        # ./output/PLSQL3.g:734:20: sql_expression
        pass
        self._state.following.append(self.FOLLOW_sql_expression_in_synpred331_PLSQL34547)
        self.sql_expression()

        self._state.following.pop()



    # $ANTLR end "synpred331_PLSQL3"



    # $ANTLR start "synpred335_PLSQL3"
    def synpred335_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:742:55: ( keyINCREMENT )
        # ./output/PLSQL3.g:742:55: keyINCREMENT
        pass
        self._state.following.append(self.FOLLOW_keyINCREMENT_in_synpred335_PLSQL34618)
        self.keyINCREMENT()

        self._state.following.pop()



    # $ANTLR end "synpred335_PLSQL3"



    # $ANTLR start "synpred343_PLSQL3"
    def synpred343_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:768:20: ( COMMA order_by_expr )
        # ./output/PLSQL3.g:768:20: COMMA order_by_expr
        pass
        self.match(self.input, COMMA, self.FOLLOW_COMMA_in_synpred343_PLSQL34785)

        self._state.following.append(self.FOLLOW_order_by_expr_in_synpred343_PLSQL34787)
        self.order_by_expr()

        self._state.following.pop()



    # $ANTLR end "synpred343_PLSQL3"



    # $ANTLR start "synpred345_PLSQL3"
    def synpred345_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:775:5: ( 'ASC' | 'DESC' )
        # ./output/PLSQL3.g:
        pass
        if self.input.LA(1) == 54 or self.input.LA(1) == 80:
            self.input.consume()
            self._state.errorRecovery = False


        else:
            if self._state.backtracking > 0:
                raise BacktrackingFailed


            mse = MismatchedSetException(None, self.input)
            raise mse





    # $ANTLR end "synpred345_PLSQL3"



    # $ANTLR start "synpred346_PLSQL3"
    def synpred346_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:775:34: ( 'DESC' )
        # ./output/PLSQL3.g:775:34: 'DESC'
        pass
        self.match(self.input, 80, self.FOLLOW_80_in_synpred346_PLSQL34829)



    # $ANTLR end "synpred346_PLSQL3"



    # $ANTLR start "synpred347_PLSQL3"
    def synpred347_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:775:46: ( keyNULLS keyFIRST )
        # ./output/PLSQL3.g:775:46: keyNULLS keyFIRST
        pass
        self._state.following.append(self.FOLLOW_keyNULLS_in_synpred347_PLSQL34836)
        self.keyNULLS()

        self._state.following.pop()

        self._state.following.append(self.FOLLOW_keyFIRST_in_synpred347_PLSQL34838)
        self.keyFIRST()

        self._state.following.pop()



    # $ANTLR end "synpred347_PLSQL3"



    # $ANTLR start "synpred348_PLSQL3"
    def synpred348_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:775:66: ( keyNULLS keyLAST )
        # ./output/PLSQL3.g:775:66: keyNULLS keyLAST
        pass
        self._state.following.append(self.FOLLOW_keyNULLS_in_synpred348_PLSQL34842)
        self.keyNULLS()

        self._state.following.pop()

        self._state.following.append(self.FOLLOW_keyLAST_in_synpred348_PLSQL34844)
        self.keyLAST()

        self._state.following.pop()



    # $ANTLR end "synpred348_PLSQL3"



    # $ANTLR start "synpred355_PLSQL3"
    def synpred355_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:811:4: ({...}? sql_expression )
        # ./output/PLSQL3.g:811:4: {...}? sql_expression
        pass
        if not ((is_sql )):
            if self._state.backtracking > 0:
                raise BacktrackingFailed


            raise FailedPredicateException(self.input, "synpred355_PLSQL3", "  is_sql ")


        self._state.following.append(self.FOLLOW_sql_expression_in_synpred355_PLSQL34998)
        self.sql_expression()

        self._state.following.pop()



    # $ANTLR end "synpred355_PLSQL3"



    # $ANTLR start "synpred357_PLSQL3"
    def synpred357_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:830:14: ( 'OR' expr_or )
        # ./output/PLSQL3.g:830:14: 'OR' expr_or
        pass
        self.match(self.input, 127, self.FOLLOW_127_in_synpred357_PLSQL35076)

        self._state.following.append(self.FOLLOW_expr_or_in_synpred357_PLSQL35078)
        self.expr_or()

        self._state.following.pop()



    # $ANTLR end "synpred357_PLSQL3"



    # $ANTLR start "synpred358_PLSQL3"
    def synpred358_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:833:15: ( 'AND' expr_and )
        # ./output/PLSQL3.g:833:15: 'AND' expr_and
        pass
        self.match(self.input, 51, self.FOLLOW_51_in_synpred358_PLSQL35095)

        self._state.following.append(self.FOLLOW_expr_and_in_synpred358_PLSQL35097)
        self.expr_and()

        self._state.following.pop()



    # $ANTLR end "synpred358_PLSQL3"



    # $ANTLR start "synpred360_PLSQL3"
    def synpred360_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:840:5: ( relational_op expr_add )
        # ./output/PLSQL3.g:840:5: relational_op expr_add
        pass
        self._state.following.append(self.FOLLOW_relational_op_in_synpred360_PLSQL35134)
        self.relational_op()

        self._state.following.pop()

        self._state.following.append(self.FOLLOW_expr_add_in_synpred360_PLSQL35136)
        self.expr_add()

        self._state.following.pop()



    # $ANTLR end "synpred360_PLSQL3"



    # $ANTLR start "synpred361_PLSQL3"
    def synpred361_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:841:5: ( FOUND_ATTR )
        # ./output/PLSQL3.g:841:5: FOUND_ATTR
        pass
        self.match(self.input, FOUND_ATTR, self.FOLLOW_FOUND_ATTR_in_synpred361_PLSQL35142)



    # $ANTLR end "synpred361_PLSQL3"



    # $ANTLR start "synpred362_PLSQL3"
    def synpred362_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:841:18: ( NOTFOUND_ATTR )
        # ./output/PLSQL3.g:841:18: NOTFOUND_ATTR
        pass
        self.match(self.input, NOTFOUND_ATTR, self.FOLLOW_NOTFOUND_ATTR_in_synpred362_PLSQL35146)



    # $ANTLR end "synpred362_PLSQL3"



    # $ANTLR start "synpred363_PLSQL3"
    def synpred363_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:841:34: ( ISOPEN_ATTR )
        # ./output/PLSQL3.g:841:34: ISOPEN_ATTR
        pass
        self.match(self.input, ISOPEN_ATTR, self.FOLLOW_ISOPEN_ATTR_in_synpred363_PLSQL35150)



    # $ANTLR end "synpred363_PLSQL3"



    # $ANTLR start "synpred364_PLSQL3"
    def synpred364_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:841:48: ( ROWCOUNT_ATTR )
        # ./output/PLSQL3.g:841:48: ROWCOUNT_ATTR
        pass
        self.match(self.input, ROWCOUNT_ATTR, self.FOLLOW_ROWCOUNT_ATTR_in_synpred364_PLSQL35154)



    # $ANTLR end "synpred364_PLSQL3"



    # $ANTLR start "synpred365_PLSQL3"
    def synpred365_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:841:64: ( BULK_ROWCOUNT_ATTR )
        # ./output/PLSQL3.g:841:64: BULK_ROWCOUNT_ATTR
        pass
        self.match(self.input, BULK_ROWCOUNT_ATTR, self.FOLLOW_BULK_ROWCOUNT_ATTR_in_synpred365_PLSQL35158)



    # $ANTLR end "synpred365_PLSQL3"



    # $ANTLR start "synpred367_PLSQL3"
    def synpred367_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:842:5: ( 'IS' ( 'NOT' )? 'NULL' )
        # ./output/PLSQL3.g:842:5: 'IS' ( 'NOT' )? 'NULL'
        pass
        self.match(self.input, 106, self.FOLLOW_106_in_synpred367_PLSQL35164)

        # ./output/PLSQL3.g:842:10: ( 'NOT' )?
        alt447 = 2
        LA447_0 = self.input.LA(1)

        if (LA447_0 == 118) :
            alt447 = 1
        if alt447 == 1:
            # ./output/PLSQL3.g:842:12: 'NOT'
            pass
            self.match(self.input, 118, self.FOLLOW_118_in_synpred367_PLSQL35168)




        self.match(self.input, 120, self.FOLLOW_120_in_synpred367_PLSQL35173)



    # $ANTLR end "synpred367_PLSQL3"



    # $ANTLR start "synpred369_PLSQL3"
    def synpred369_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:843:5: ( ( 'NOT' )? 'LIKE' expr_add )
        # ./output/PLSQL3.g:843:5: ( 'NOT' )? 'LIKE' expr_add
        pass
        # ./output/PLSQL3.g:843:5: ( 'NOT' )?
        alt448 = 2
        LA448_0 = self.input.LA(1)

        if (LA448_0 == 118) :
            alt448 = 1
        if alt448 == 1:
            # ./output/PLSQL3.g:843:7: 'NOT'
            pass
            self.match(self.input, 118, self.FOLLOW_118_in_synpred369_PLSQL35181)




        self.match(self.input, 107, self.FOLLOW_107_in_synpred369_PLSQL35186)

        self._state.following.append(self.FOLLOW_expr_add_in_synpred369_PLSQL35188)
        self.expr_add()

        self._state.following.pop()



    # $ANTLR end "synpred369_PLSQL3"



    # $ANTLR start "synpred371_PLSQL3"
    def synpred371_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:844:5: ( ( 'NOT' )? 'BETWEEN' expr_add 'AND' expr_add )
        # ./output/PLSQL3.g:844:5: ( 'NOT' )? 'BETWEEN' expr_add 'AND' expr_add
        pass
        # ./output/PLSQL3.g:844:5: ( 'NOT' )?
        alt449 = 2
        LA449_0 = self.input.LA(1)

        if (LA449_0 == 118) :
            alt449 = 1
        if alt449 == 1:
            # ./output/PLSQL3.g:844:7: 'NOT'
            pass
            self.match(self.input, 118, self.FOLLOW_118_in_synpred371_PLSQL35196)




        self.match(self.input, 57, self.FOLLOW_57_in_synpred371_PLSQL35201)

        self._state.following.append(self.FOLLOW_expr_add_in_synpred371_PLSQL35203)
        self.expr_add()

        self._state.following.pop()

        self.match(self.input, 51, self.FOLLOW_51_in_synpred371_PLSQL35205)

        self._state.following.append(self.FOLLOW_expr_add_in_synpred371_PLSQL35207)
        self.expr_add()

        self._state.following.pop()



    # $ANTLR end "synpred371_PLSQL3"



    # $ANTLR start "synpred373_PLSQL3"
    def synpred373_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:845:5: ( ( 'NOT' )? 'IN' LPAREN nested_expressions RPAREN )
        # ./output/PLSQL3.g:845:5: ( 'NOT' )? 'IN' LPAREN nested_expressions RPAREN
        pass
        # ./output/PLSQL3.g:845:5: ( 'NOT' )?
        alt450 = 2
        LA450_0 = self.input.LA(1)

        if (LA450_0 == 118) :
            alt450 = 1
        if alt450 == 1:
            # ./output/PLSQL3.g:845:7: 'NOT'
            pass
            self.match(self.input, 118, self.FOLLOW_118_in_synpred373_PLSQL35215)




        self.match(self.input, 99, self.FOLLOW_99_in_synpred373_PLSQL35220)

        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred373_PLSQL35222)

        self._state.following.append(self.FOLLOW_nested_expressions_in_synpred373_PLSQL35224)
        self.nested_expressions()

        self._state.following.pop()

        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred373_PLSQL35226)



    # $ANTLR end "synpred373_PLSQL3"



    # $ANTLR start "synpred375_PLSQL3"
    def synpred375_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:854:21: ( COMMA sql_expression )
        # ./output/PLSQL3.g:854:21: COMMA sql_expression
        pass
        self.match(self.input, COMMA, self.FOLLOW_COMMA_in_synpred375_PLSQL35261)

        self._state.following.append(self.FOLLOW_sql_expression_in_synpred375_PLSQL35263)
        self.sql_expression()

        self._state.following.pop()



    # $ANTLR end "synpred375_PLSQL3"



    # $ANTLR start "synpred378_PLSQL3"
    def synpred378_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:861:15: ( ( PLUS | MINUS | DOUBLEVERTBAR ) expr_mul )
        # ./output/PLSQL3.g:861:15: ( PLUS | MINUS | DOUBLEVERTBAR ) expr_mul
        pass
        if self.input.LA(1) == DOUBLEVERTBAR or self.input.LA(1) == MINUS or self.input.LA(1) == PLUS:
            self.input.consume()
            self._state.errorRecovery = False


        else:
            if self._state.backtracking > 0:
                raise BacktrackingFailed


            mse = MismatchedSetException(None, self.input)
            raise mse



        self._state.following.append(self.FOLLOW_expr_mul_in_synpred378_PLSQL35311)
        self.expr_mul()

        self._state.following.pop()



    # $ANTLR end "synpred378_PLSQL3"



    # $ANTLR start "synpred380_PLSQL3"
    def synpred380_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:864:16: ( ( ASTERISK | DIVIDE ) expr_sign )
        # ./output/PLSQL3.g:864:16: ( ASTERISK | DIVIDE ) expr_sign
        pass
        if self.input.LA(1) == ASTERISK or self.input.LA(1) == DIVIDE:
            self.input.consume()
            self._state.errorRecovery = False


        else:
            if self._state.backtracking > 0:
                raise BacktrackingFailed


            mse = MismatchedSetException(None, self.input)
            raise mse



        self._state.following.append(self.FOLLOW_expr_sign_in_synpred380_PLSQL35338)
        self.expr_sign()

        self._state.following.pop()



    # $ANTLR end "synpred380_PLSQL3"



    # $ANTLR start "synpred383_PLSQL3"
    def synpred383_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:870:16: ( EXPONENT expr_expr )
        # ./output/PLSQL3.g:870:16: EXPONENT expr_expr
        pass
        self.match(self.input, EXPONENT, self.FOLLOW_EXPONENT_in_synpred383_PLSQL35376)

        self._state.following.append(self.FOLLOW_expr_expr_in_synpred383_PLSQL35378)
        self.expr_expr()

        self._state.following.pop()



    # $ANTLR end "synpred383_PLSQL3"



    # $ANTLR start "synpred384_PLSQL3"
    def synpred384_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:873:4: ( expr_paren )
        # ./output/PLSQL3.g:873:6: expr_paren
        pass
        self._state.following.append(self.FOLLOW_expr_paren_in_synpred384_PLSQL35393)
        self.expr_paren()

        self._state.following.pop()



    # $ANTLR end "synpred384_PLSQL3"



    # $ANTLR start "synpred385_PLSQL3"
    def synpred385_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:874:4: ( function_expression )
        # ./output/PLSQL3.g:874:6: function_expression
        pass
        self._state.following.append(self.FOLLOW_function_expression_in_synpred385_PLSQL35406)
        self.function_expression()

        self._state.following.pop()



    # $ANTLR end "synpred385_PLSQL3"



    # $ANTLR start "synpred386_PLSQL3"
    def synpred386_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:876:4: ( case_expression )
        # ./output/PLSQL3.g:876:6: case_expression
        pass
        self._state.following.append(self.FOLLOW_case_expression_in_synpred386_PLSQL35420)
        self.case_expression()

        self._state.following.pop()



    # $ANTLR end "synpred386_PLSQL3"



    # $ANTLR start "synpred387_PLSQL3"
    def synpred387_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:877:4: ( cursor_expression )
        # ./output/PLSQL3.g:877:6: cursor_expression
        pass
        self._state.following.append(self.FOLLOW_cursor_expression_in_synpred387_PLSQL35433)
        self.cursor_expression()

        self._state.following.pop()



    # $ANTLR end "synpred387_PLSQL3"



    # $ANTLR start "synpred388_PLSQL3"
    def synpred388_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:878:4: ( simple_expression )
        # ./output/PLSQL3.g:878:6: simple_expression
        pass
        self._state.following.append(self.FOLLOW_simple_expression_in_synpred388_PLSQL35446)
        self.simple_expression()

        self._state.following.pop()



    # $ANTLR end "synpred388_PLSQL3"



    # $ANTLR start "synpred389_PLSQL3"
    def synpred389_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:879:4: ( select_expression )
        # ./output/PLSQL3.g:879:6: select_expression
        pass
        self._state.following.append(self.FOLLOW_select_expression_in_synpred389_PLSQL35459)
        self.select_expression()

        self._state.following.pop()



    # $ANTLR end "synpred389_PLSQL3"



    # $ANTLR start "synpred396_PLSQL3"
    def synpred396_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:893:4: ( column_spec )
        # ./output/PLSQL3.g:893:6: column_spec
        pass
        self._state.following.append(self.FOLLOW_column_spec_in_synpred396_PLSQL35518)
        self.column_spec()

        self._state.following.pop()



    # $ANTLR end "synpred396_PLSQL3"



    # $ANTLR start "synpred410_PLSQL3"
    def synpred410_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:944:23: ( keyDBTIMEZONE )
        # ./output/PLSQL3.g:944:23: keyDBTIMEZONE
        pass
        self._state.following.append(self.FOLLOW_keyDBTIMEZONE_in_synpred410_PLSQL35815)
        self.keyDBTIMEZONE()

        self._state.following.pop()



    # $ANTLR end "synpred410_PLSQL3"



    # $ANTLR start "synpred411_PLSQL3"
    def synpred411_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:944:39: ( keySESSIONTIMEZONE )
        # ./output/PLSQL3.g:944:39: keySESSIONTIMEZONE
        pass
        self._state.following.append(self.FOLLOW_keySESSIONTIMEZONE_in_synpred411_PLSQL35819)
        self.keySESSIONTIMEZONE()

        self._state.following.pop()



    # $ANTLR end "synpred411_PLSQL3"



    # $ANTLR start "synpred413_PLSQL3"
    def synpred413_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:948:4: ( function_call ( DOT nested_expression )? )
        # ./output/PLSQL3.g:948:4: function_call ( DOT nested_expression )?
        pass
        self._state.following.append(self.FOLLOW_function_call_in_synpred413_PLSQL35839)
        self.function_call()

        self._state.following.pop()

        # ./output/PLSQL3.g:948:18: ( DOT nested_expression )?
        alt451 = 2
        LA451_0 = self.input.LA(1)

        if (LA451_0 == DOT) :
            alt451 = 1
        if alt451 == 1:
            # ./output/PLSQL3.g:948:20: DOT nested_expression
            pass
            self.match(self.input, DOT, self.FOLLOW_DOT_in_synpred413_PLSQL35843)

            self._state.following.append(self.FOLLOW_nested_expression_in_synpred413_PLSQL35845)
            self.nested_expression()

            self._state.following.pop()






    # $ANTLR end "synpred413_PLSQL3"



    # $ANTLR start "synpred416_PLSQL3"
    def synpred416_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:951:18: ( LPAREN nested_expression RPAREN )
        # ./output/PLSQL3.g:951:18: LPAREN nested_expression RPAREN
        pass
        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred416_PLSQL35883)

        self._state.following.append(self.FOLLOW_nested_expression_in_synpred416_PLSQL35885)
        self.nested_expression()

        self._state.following.pop()

        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred416_PLSQL35887)



    # $ANTLR end "synpred416_PLSQL3"



    # $ANTLR start "synpred421_PLSQL3"
    def synpred421_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:962:5: ( keyDAY ( LPAREN leading_field_precision RPAREN )? 'TO' keySECOND ( LPAREN fractional_second_precision RPAREN )? )
        # ./output/PLSQL3.g:962:5: keyDAY ( LPAREN leading_field_precision RPAREN )? 'TO' keySECOND ( LPAREN fractional_second_precision RPAREN )?
        pass
        self._state.following.append(self.FOLLOW_keyDAY_in_synpred421_PLSQL35959)
        self.keyDAY()

        self._state.following.pop()

        # ./output/PLSQL3.g:962:12: ( LPAREN leading_field_precision RPAREN )?
        alt454 = 2
        LA454_0 = self.input.LA(1)

        if (LA454_0 == LPAREN) :
            alt454 = 1
        if alt454 == 1:
            # ./output/PLSQL3.g:962:14: LPAREN leading_field_precision RPAREN
            pass
            self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred421_PLSQL35963)

            self._state.following.append(self.FOLLOW_leading_field_precision_in_synpred421_PLSQL35965)
            self.leading_field_precision()

            self._state.following.pop()

            self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred421_PLSQL35967)




        self.match(self.input, 155, self.FOLLOW_155_in_synpred421_PLSQL35972)

        self._state.following.append(self.FOLLOW_keySECOND_in_synpred421_PLSQL35974)
        self.keySECOND()

        self._state.following.pop()

        # ./output/PLSQL3.g:962:70: ( LPAREN fractional_second_precision RPAREN )?
        alt455 = 2
        LA455_0 = self.input.LA(1)

        if (LA455_0 == LPAREN) :
            alt455 = 1
        if alt455 == 1:
            # ./output/PLSQL3.g:962:72: LPAREN fractional_second_precision RPAREN
            pass
            self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred421_PLSQL35978)

            self._state.following.append(self.FOLLOW_fractional_second_precision_in_synpred421_PLSQL35980)
            self.fractional_second_precision()

            self._state.following.pop()

            self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred421_PLSQL35982)






    # $ANTLR end "synpred421_PLSQL3"



    # $ANTLR start "synpred428_PLSQL3"
    def synpred428_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1023:21: ( DOT sql_identifier )
        # ./output/PLSQL3.g:1023:21: DOT sql_identifier
        pass
        self.match(self.input, DOT, self.FOLLOW_DOT_in_synpred428_PLSQL36228)

        self._state.following.append(self.FOLLOW_sql_identifier_in_synpred428_PLSQL36230)
        self.sql_identifier()

        self._state.following.pop()



    # $ANTLR end "synpred428_PLSQL3"



    # $ANTLR start "synpred432_PLSQL3"
    def synpred432_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1036:6: ( table_spec )
        # ./output/PLSQL3.g:1036:6: table_spec
        pass
        self._state.following.append(self.FOLLOW_table_spec_in_synpred432_PLSQL36277)
        self.table_spec()

        self._state.following.pop()



    # $ANTLR end "synpred432_PLSQL3"



    # $ANTLR start "synpred435_PLSQL3"
    def synpred435_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1036:54: ( alias )
        # ./output/PLSQL3.g:1036:54: alias
        pass
        self._state.following.append(self.FOLLOW_alias_in_synpred435_PLSQL36298)
        self.alias()

        self._state.following.pop()



    # $ANTLR end "synpred435_PLSQL3"



    # $ANTLR start "synpred441_PLSQL3"
    def synpred441_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1051:4: ({...}? condition_or )
        # ./output/PLSQL3.g:1051:4: {...}? condition_or
        pass
        if not ((is_sql )):
            if self._state.backtracking > 0:
                raise BacktrackingFailed


            raise FailedPredicateException(self.input, "synpred441_PLSQL3", "  is_sql ")


        self._state.following.append(self.FOLLOW_condition_or_in_synpred441_PLSQL36389)
        self.condition_or()

        self._state.following.pop()



    # $ANTLR end "synpred441_PLSQL3"



    # $ANTLR start "synpred442_PLSQL3"
    def synpred442_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1063:20: ( 'OR' condition_and )
        # ./output/PLSQL3.g:1063:20: 'OR' condition_and
        pass
        self.match(self.input, 127, self.FOLLOW_127_in_synpred442_PLSQL36442)

        self._state.following.append(self.FOLLOW_condition_and_in_synpred442_PLSQL36444)
        self.condition_and()

        self._state.following.pop()



    # $ANTLR end "synpred442_PLSQL3"



    # $ANTLR start "synpred443_PLSQL3"
    def synpred443_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1066:20: ( 'AND' condition_not )
        # ./output/PLSQL3.g:1066:20: 'AND' condition_not
        pass
        self.match(self.input, 51, self.FOLLOW_51_in_synpred443_PLSQL36461)

        self._state.following.append(self.FOLLOW_condition_not_in_synpred443_PLSQL36463)
        self.condition_not()

        self._state.following.pop()



    # $ANTLR end "synpred443_PLSQL3"



    # $ANTLR start "synpred446_PLSQL3"
    def synpred446_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1074:4: ( condition_is )
        # ./output/PLSQL3.g:1074:4: condition_is
        pass
        self._state.following.append(self.FOLLOW_condition_is_in_synpred446_PLSQL36498)
        self.condition_is()

        self._state.following.pop()



    # $ANTLR end "synpred446_PLSQL3"



    # $ANTLR start "synpred447_PLSQL3"
    def synpred447_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1075:4: ( condition_comparison )
        # ./output/PLSQL3.g:1075:4: condition_comparison
        pass
        self._state.following.append(self.FOLLOW_condition_comparison_in_synpred447_PLSQL36503)
        self.condition_comparison()

        self._state.following.pop()



    # $ANTLR end "synpred447_PLSQL3"



    # $ANTLR start "synpred448_PLSQL3"
    def synpred448_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1076:4: ( condition_group_comparison )
        # ./output/PLSQL3.g:1076:4: condition_group_comparison
        pass
        self._state.following.append(self.FOLLOW_condition_group_comparison_in_synpred448_PLSQL36508)
        self.condition_group_comparison()

        self._state.following.pop()



    # $ANTLR end "synpred448_PLSQL3"



    # $ANTLR start "synpred449_PLSQL3"
    def synpred449_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1077:4: ( condition_in )
        # ./output/PLSQL3.g:1077:4: condition_in
        pass
        self._state.following.append(self.FOLLOW_condition_in_in_synpred449_PLSQL36513)
        self.condition_in()

        self._state.following.pop()



    # $ANTLR end "synpred449_PLSQL3"



    # $ANTLR start "synpred450_PLSQL3"
    def synpred450_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1078:4: ( condition_is_a_set )
        # ./output/PLSQL3.g:1078:4: condition_is_a_set
        pass
        self._state.following.append(self.FOLLOW_condition_is_a_set_in_synpred450_PLSQL36518)
        self.condition_is_a_set()

        self._state.following.pop()



    # $ANTLR end "synpred450_PLSQL3"



    # $ANTLR start "synpred451_PLSQL3"
    def synpred451_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1079:4: ( condition_is_any )
        # ./output/PLSQL3.g:1079:4: condition_is_any
        pass
        self._state.following.append(self.FOLLOW_condition_is_any_in_synpred451_PLSQL36523)
        self.condition_is_any()

        self._state.following.pop()



    # $ANTLR end "synpred451_PLSQL3"



    # $ANTLR start "synpred452_PLSQL3"
    def synpred452_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1080:4: ( condition_is_empty )
        # ./output/PLSQL3.g:1080:4: condition_is_empty
        pass
        self._state.following.append(self.FOLLOW_condition_is_empty_in_synpred452_PLSQL36528)
        self.condition_is_empty()

        self._state.following.pop()



    # $ANTLR end "synpred452_PLSQL3"



    # $ANTLR start "synpred453_PLSQL3"
    def synpred453_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1081:4: ( condition_is_of_type )
        # ./output/PLSQL3.g:1081:4: condition_is_of_type
        pass
        self._state.following.append(self.FOLLOW_condition_is_of_type_in_synpred453_PLSQL36533)
        self.condition_is_of_type()

        self._state.following.pop()



    # $ANTLR end "synpred453_PLSQL3"



    # $ANTLR start "synpred454_PLSQL3"
    def synpred454_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1082:4: ( condition_is_present )
        # ./output/PLSQL3.g:1082:4: condition_is_present
        pass
        self._state.following.append(self.FOLLOW_condition_is_present_in_synpred454_PLSQL36538)
        self.condition_is_present()

        self._state.following.pop()



    # $ANTLR end "synpred454_PLSQL3"



    # $ANTLR start "synpred455_PLSQL3"
    def synpred455_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1083:4: ( condition_like )
        # ./output/PLSQL3.g:1083:4: condition_like
        pass
        self._state.following.append(self.FOLLOW_condition_like_in_synpred455_PLSQL36543)
        self.condition_like()

        self._state.following.pop()



    # $ANTLR end "synpred455_PLSQL3"



    # $ANTLR start "synpred456_PLSQL3"
    def synpred456_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1084:4: ( condition_memeber )
        # ./output/PLSQL3.g:1084:4: condition_memeber
        pass
        self._state.following.append(self.FOLLOW_condition_memeber_in_synpred456_PLSQL36548)
        self.condition_memeber()

        self._state.following.pop()



    # $ANTLR end "synpred456_PLSQL3"



    # $ANTLR start "synpred457_PLSQL3"
    def synpred457_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1085:4: ( condition_between )
        # ./output/PLSQL3.g:1085:4: condition_between
        pass
        self._state.following.append(self.FOLLOW_condition_between_in_synpred457_PLSQL36553)
        self.condition_between()

        self._state.following.pop()



    # $ANTLR end "synpred457_PLSQL3"



    # $ANTLR start "synpred458_PLSQL3"
    def synpred458_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1086:4: ( condition_regexp_like )
        # ./output/PLSQL3.g:1086:4: condition_regexp_like
        pass
        self._state.following.append(self.FOLLOW_condition_regexp_like_in_synpred458_PLSQL36558)
        self.condition_regexp_like()

        self._state.following.pop()



    # $ANTLR end "synpred458_PLSQL3"



    # $ANTLR start "synpred459_PLSQL3"
    def synpred459_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1087:4: ( condition_submultiset )
        # ./output/PLSQL3.g:1087:4: condition_submultiset
        pass
        self._state.following.append(self.FOLLOW_condition_submultiset_in_synpred459_PLSQL36563)
        self.condition_submultiset()

        self._state.following.pop()



    # $ANTLR end "synpred459_PLSQL3"



    # $ANTLR start "synpred460_PLSQL3"
    def synpred460_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1088:4: ( condition_equals_path )
        # ./output/PLSQL3.g:1088:4: condition_equals_path
        pass
        self._state.following.append(self.FOLLOW_condition_equals_path_in_synpred460_PLSQL36568)
        self.condition_equals_path()

        self._state.following.pop()



    # $ANTLR end "synpred460_PLSQL3"



    # $ANTLR start "synpred461_PLSQL3"
    def synpred461_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1089:4: ( condition_under_path )
        # ./output/PLSQL3.g:1089:4: condition_under_path
        pass
        self._state.following.append(self.FOLLOW_condition_under_path_in_synpred461_PLSQL36573)
        self.condition_under_path()

        self._state.following.pop()



    # $ANTLR end "synpred461_PLSQL3"



    # $ANTLR start "synpred463_PLSQL3"
    def synpred463_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1096:37: ( keyNAN )
        # ./output/PLSQL3.g:1096:37: keyNAN
        pass
        self._state.following.append(self.FOLLOW_keyNAN_in_synpred463_PLSQL36617)
        self.keyNAN()

        self._state.following.pop()



    # $ANTLR end "synpred463_PLSQL3"



    # $ANTLR start "synpred464_PLSQL3"
    def synpred464_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1096:46: ( keyINFINITE )
        # ./output/PLSQL3.g:1096:46: keyINFINITE
        pass
        self._state.following.append(self.FOLLOW_keyINFINITE_in_synpred464_PLSQL36621)
        self.keyINFINITE()

        self._state.following.pop()



    # $ANTLR end "synpred464_PLSQL3"



    # $ANTLR start "synpred467_PLSQL3"
    def synpred467_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1099:102: ( outer_join_sign )
        # ./output/PLSQL3.g:1099:102: outer_join_sign
        pass
        self._state.following.append(self.FOLLOW_outer_join_sign_in_synpred467_PLSQL36668)
        self.outer_join_sign()

        self._state.following.pop()



    # $ANTLR end "synpred467_PLSQL3"



    # $ANTLR start "synpred468_PLSQL3"
    def synpred468_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1099:4: ( LPAREN sql_expressions RPAREN ( outer_join_sign )? ( EQ | NOT_EQ ) LPAREN select_command RPAREN ( outer_join_sign )? )
        # ./output/PLSQL3.g:1099:4: LPAREN sql_expressions RPAREN ( outer_join_sign )? ( EQ | NOT_EQ ) LPAREN select_command RPAREN ( outer_join_sign )?
        pass
        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred468_PLSQL36637)

        self._state.following.append(self.FOLLOW_sql_expressions_in_synpred468_PLSQL36639)
        self.sql_expressions()

        self._state.following.pop()

        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred468_PLSQL36641)

        # ./output/PLSQL3.g:1099:34: ( outer_join_sign )?
        alt457 = 2
        LA457_0 = self.input.LA(1)

        if (LA457_0 == LPAREN) :
            alt457 = 1
        if alt457 == 1:
            # ./output/PLSQL3.g:1099:36: outer_join_sign
            pass
            self._state.following.append(self.FOLLOW_outer_join_sign_in_synpred468_PLSQL36645)
            self.outer_join_sign()

            self._state.following.pop()




        if self.input.LA(1) == EQ or self.input.LA(1) == NOT_EQ:
            self.input.consume()
            self._state.errorRecovery = False


        else:
            if self._state.backtracking > 0:
                raise BacktrackingFailed


            mse = MismatchedSetException(None, self.input)
            raise mse



        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred468_PLSQL36660)

        self._state.following.append(self.FOLLOW_select_command_in_synpred468_PLSQL36662)
        self.select_command()

        self._state.following.pop()

        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred468_PLSQL36664)

        # ./output/PLSQL3.g:1099:100: ( outer_join_sign )?
        alt458 = 2
        LA458_0 = self.input.LA(1)

        if (LA458_0 == LPAREN) :
            alt458 = 1
        if alt458 == 1:
            # ./output/PLSQL3.g:1099:102: outer_join_sign
            pass
            self._state.following.append(self.FOLLOW_outer_join_sign_in_synpred468_PLSQL36668)
            self.outer_join_sign()

            self._state.following.pop()






    # $ANTLR end "synpred468_PLSQL3"



    # $ANTLR start "synpred477_PLSQL3"
    def synpred477_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1100:108: ( sql_expression )
        # ./output/PLSQL3.g:1100:108: sql_expression
        pass
        self._state.following.append(self.FOLLOW_sql_expression_in_synpred477_PLSQL36727)
        self.sql_expression()

        self._state.following.pop()



    # $ANTLR end "synpred477_PLSQL3"



    # $ANTLR start "synpred478_PLSQL3"
    def synpred478_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1100:158: ( outer_join_sign )
        # ./output/PLSQL3.g:1100:158: outer_join_sign
        pass
        self._state.following.append(self.FOLLOW_outer_join_sign_in_synpred478_PLSQL36741)
        self.outer_join_sign()

        self._state.following.pop()



    # $ANTLR end "synpred478_PLSQL3"



    # $ANTLR start "synpred482_PLSQL3"
    def synpred482_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1103:87: ( grouping_expression_list )
        # ./output/PLSQL3.g:1103:87: grouping_expression_list
        pass
        self._state.following.append(self.FOLLOW_grouping_expression_list_in_synpred482_PLSQL36788)
        self.grouping_expression_list()

        self._state.following.pop()



    # $ANTLR end "synpred482_PLSQL3"



    # $ANTLR start "synpred483_PLSQL3"
    def synpred483_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1103:4: ( LPAREN sql_expressions RPAREN ( EQ | NOT_EQ ) ( 'ANY' | keySOME | 'ALL' ) LPAREN ( grouping_expression_list | select_command ) RPAREN )
        # ./output/PLSQL3.g:1103:4: LPAREN sql_expressions RPAREN ( EQ | NOT_EQ ) ( 'ANY' | keySOME | 'ALL' ) LPAREN ( grouping_expression_list | select_command ) RPAREN
        pass
        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred483_PLSQL36754)

        self._state.following.append(self.FOLLOW_sql_expressions_in_synpred483_PLSQL36756)
        self.sql_expressions()

        self._state.following.pop()

        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred483_PLSQL36758)

        if self.input.LA(1) == EQ or self.input.LA(1) == NOT_EQ:
            self.input.consume()
            self._state.errorRecovery = False


        else:
            if self._state.backtracking > 0:
                raise BacktrackingFailed


            mse = MismatchedSetException(None, self.input)
            raise mse



        # ./output/PLSQL3.g:1103:50: ( 'ANY' | keySOME | 'ALL' )
        alt459 = 3
        LA459 = self.input.LA(1)
        if LA459 == 52:
            alt459 = 1
        elif LA459 == ID:
            alt459 = 2
        elif LA459 == 50:
            alt459 = 3
        else:
            if self._state.backtracking > 0:
                raise BacktrackingFailed


            nvae = NoViableAltException("", 459, 0, self.input)

            raise nvae


        if alt459 == 1:
            # ./output/PLSQL3.g:1103:52: 'ANY'
            pass
            self.match(self.input, 52, self.FOLLOW_52_in_synpred483_PLSQL36772)


        elif alt459 == 2:
            # ./output/PLSQL3.g:1103:60: keySOME
            pass
            self._state.following.append(self.FOLLOW_keySOME_in_synpred483_PLSQL36776)
            self.keySOME()

            self._state.following.pop()


        elif alt459 == 3:
            # ./output/PLSQL3.g:1103:70: 'ALL'
            pass
            self.match(self.input, 50, self.FOLLOW_50_in_synpred483_PLSQL36780)




        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred483_PLSQL36784)

        # ./output/PLSQL3.g:1103:85: ( grouping_expression_list | select_command )
        alt460 = 2
        LA460_0 = self.input.LA(1)

        if (LA460_0 == DOUBLEQUOTED_STRING or LA460_0 == ID or LA460_0 == LPAREN or LA460_0 == MINUS or LA460_0 == NUMBER or LA460_0 == PLUS or LA460_0 == QUOTED_STRING or LA460_0 == 65 or LA460_0 == 81 or LA460_0 == 89 or LA460_0 == 120 or LA460_0 == 144 or LA460_0 == 151 or LA460_0 == 156) :
            alt460 = 1
        elif (LA460_0 == 147) :
            LA460_13 = self.input.LA(2)

            if (self.synpred482_PLSQL3()) :
                alt460 = 1
            elif (True) :
                alt460 = 2
            else:
                if self._state.backtracking > 0:
                    raise BacktrackingFailed


                nvae = NoViableAltException("", 460, 13, self.input)

                raise nvae


        else:
            if self._state.backtracking > 0:
                raise BacktrackingFailed


            nvae = NoViableAltException("", 460, 0, self.input)

            raise nvae


        if alt460 == 1:
            # ./output/PLSQL3.g:1103:87: grouping_expression_list
            pass
            self._state.following.append(self.FOLLOW_grouping_expression_list_in_synpred483_PLSQL36788)
            self.grouping_expression_list()

            self._state.following.pop()


        elif alt460 == 2:
            # ./output/PLSQL3.g:1103:114: select_command
            pass
            self._state.following.append(self.FOLLOW_select_command_in_synpred483_PLSQL36792)
            self.select_command()

            self._state.following.pop()




        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred483_PLSQL36796)



    # $ANTLR end "synpred483_PLSQL3"



    # $ANTLR start "synpred491_PLSQL3"
    def synpred491_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1104:96: ( sql_expressions )
        # ./output/PLSQL3.g:1104:96: sql_expressions
        pass
        self._state.following.append(self.FOLLOW_sql_expressions_in_synpred491_PLSQL36847)
        self.sql_expressions()

        self._state.following.pop()



    # $ANTLR end "synpred491_PLSQL3"



    # $ANTLR start "synpred493_PLSQL3"
    def synpred493_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1107:59: ( grouping_expression_list )
        # ./output/PLSQL3.g:1107:59: grouping_expression_list
        pass
        self._state.following.append(self.FOLLOW_grouping_expression_list_in_synpred493_PLSQL36884)
        self.grouping_expression_list()

        self._state.following.pop()



    # $ANTLR end "synpred493_PLSQL3"



    # $ANTLR start "synpred494_PLSQL3"
    def synpred494_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1107:4: ( LPAREN sql_expressions RPAREN ( 'NOT' )? 'IN' LPAREN ( grouping_expression_list | select_command ) RPAREN )
        # ./output/PLSQL3.g:1107:4: LPAREN sql_expressions RPAREN ( 'NOT' )? 'IN' LPAREN ( grouping_expression_list | select_command ) RPAREN
        pass
        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred494_PLSQL36865)

        self._state.following.append(self.FOLLOW_sql_expressions_in_synpred494_PLSQL36867)
        self.sql_expressions()

        self._state.following.pop()

        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred494_PLSQL36869)

        # ./output/PLSQL3.g:1107:34: ( 'NOT' )?
        alt461 = 2
        LA461_0 = self.input.LA(1)

        if (LA461_0 == 118) :
            alt461 = 1
        if alt461 == 1:
            # ./output/PLSQL3.g:1107:36: 'NOT'
            pass
            self.match(self.input, 118, self.FOLLOW_118_in_synpred494_PLSQL36873)




        self.match(self.input, 99, self.FOLLOW_99_in_synpred494_PLSQL36878)

        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred494_PLSQL36880)

        # ./output/PLSQL3.g:1107:57: ( grouping_expression_list | select_command )
        alt462 = 2
        LA462_0 = self.input.LA(1)

        if (LA462_0 == DOUBLEQUOTED_STRING or LA462_0 == ID or LA462_0 == LPAREN or LA462_0 == MINUS or LA462_0 == NUMBER or LA462_0 == PLUS or LA462_0 == QUOTED_STRING or LA462_0 == 65 or LA462_0 == 81 or LA462_0 == 89 or LA462_0 == 120 or LA462_0 == 144 or LA462_0 == 151 or LA462_0 == 156) :
            alt462 = 1
        elif (LA462_0 == 147) :
            LA462_13 = self.input.LA(2)

            if (self.synpred493_PLSQL3()) :
                alt462 = 1
            elif (True) :
                alt462 = 2
            else:
                if self._state.backtracking > 0:
                    raise BacktrackingFailed


                nvae = NoViableAltException("", 462, 13, self.input)

                raise nvae


        else:
            if self._state.backtracking > 0:
                raise BacktrackingFailed


            nvae = NoViableAltException("", 462, 0, self.input)

            raise nvae


        if alt462 == 1:
            # ./output/PLSQL3.g:1107:59: grouping_expression_list
            pass
            self._state.following.append(self.FOLLOW_grouping_expression_list_in_synpred494_PLSQL36884)
            self.grouping_expression_list()

            self._state.following.pop()


        elif alt462 == 2:
            # ./output/PLSQL3.g:1107:86: select_command
            pass
            self._state.following.append(self.FOLLOW_select_command_in_synpred494_PLSQL36888)
            self.select_command()

            self._state.following.pop()




        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred494_PLSQL36892)



    # $ANTLR end "synpred494_PLSQL3"



    # $ANTLR start "synpred496_PLSQL3"
    def synpred496_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1108:44: ( expression_list )
        # ./output/PLSQL3.g:1108:44: expression_list
        pass
        self._state.following.append(self.FOLLOW_expression_list_in_synpred496_PLSQL36912)
        self.expression_list()

        self._state.following.pop()



    # $ANTLR end "synpred496_PLSQL3"



    # $ANTLR start "synpred506_PLSQL3"
    def synpred506_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1132:41: ( keyLIKEC )
        # ./output/PLSQL3.g:1132:41: keyLIKEC
        pass
        self._state.following.append(self.FOLLOW_keyLIKEC_in_synpred506_PLSQL37092)
        self.keyLIKEC()

        self._state.following.pop()



    # $ANTLR end "synpred506_PLSQL3"



    # $ANTLR start "synpred507_PLSQL3"
    def synpred507_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1132:52: ( keyLIKE2 )
        # ./output/PLSQL3.g:1132:52: keyLIKE2
        pass
        self._state.following.append(self.FOLLOW_keyLIKE2_in_synpred507_PLSQL37096)
        self.keyLIKE2()

        self._state.following.pop()



    # $ANTLR end "synpred507_PLSQL3"



    # $ANTLR start "synpred508_PLSQL3"
    def synpred508_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1132:91: ( keyESCAPE sql_expression )
        # ./output/PLSQL3.g:1132:91: keyESCAPE sql_expression
        pass
        self._state.following.append(self.FOLLOW_keyESCAPE_in_synpred508_PLSQL37108)
        self.keyESCAPE()

        self._state.following.pop()

        self._state.following.append(self.FOLLOW_sql_expression_in_synpred508_PLSQL37110)
        self.sql_expression()

        self._state.following.pop()



    # $ANTLR end "synpred508_PLSQL3"



    # $ANTLR start "synpred517_PLSQL3"
    def synpred517_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1162:22: ( COMMA expression_list )
        # ./output/PLSQL3.g:1162:22: COMMA expression_list
        pass
        self.match(self.input, COMMA, self.FOLLOW_COMMA_in_synpred517_PLSQL37321)

        self._state.following.append(self.FOLLOW_expression_list_in_synpred517_PLSQL37323)
        self.expression_list()

        self._state.following.pop()



    # $ANTLR end "synpred517_PLSQL3"



    # $ANTLR start "synpred518_PLSQL3"
    def synpred518_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1165:4: ( LPAREN sql_expressions RPAREN )
        # ./output/PLSQL3.g:1165:4: LPAREN sql_expressions RPAREN
        pass
        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred518_PLSQL37336)

        self._state.following.append(self.FOLLOW_sql_expressions_in_synpred518_PLSQL37338)
        self.sql_expressions()

        self._state.following.pop()

        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred518_PLSQL37340)



    # $ANTLR end "synpred518_PLSQL3"



    # $ANTLR start "synpred526_PLSQL3"
    def synpred526_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1183:4: ( sql_expression )
        # ./output/PLSQL3.g:1183:6: sql_expression
        pass
        self._state.following.append(self.FOLLOW_sql_expression_in_synpred526_PLSQL37437)
        self.sql_expression()

        self._state.following.pop()



    # $ANTLR end "synpred526_PLSQL3"



    # $ANTLR start "synpred529_PLSQL3"
    def synpred529_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1197:9: ( 'PRIOR' )
        # ./output/PLSQL3.g:1197:9: 'PRIOR'
        pass
        self.match(self.input, 134, self.FOLLOW_134_in_synpred529_PLSQL37528)



    # $ANTLR end "synpred529_PLSQL3"



    # $ANTLR start "synpred530_PLSQL3"
    def synpred530_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1197:5: ( ( 'PRIOR' )? sql_condition )
        # ./output/PLSQL3.g:1197:7: ( 'PRIOR' )? sql_condition
        pass
        # ./output/PLSQL3.g:1197:7: ( 'PRIOR' )?
        alt463 = 2
        LA463_0 = self.input.LA(1)

        if (LA463_0 == 134) :
            LA463_1 = self.input.LA(2)

            if (self.synpred529_PLSQL3()) :
                alt463 = 1
        if alt463 == 1:
            # ./output/PLSQL3.g:1197:9: 'PRIOR'
            pass
            self.match(self.input, 134, self.FOLLOW_134_in_synpred530_PLSQL37528)




        self._state.following.append(self.FOLLOW_sql_condition_in_synpred530_PLSQL37533)
        self.sql_condition()

        self._state.following.pop()



    # $ANTLR end "synpred530_PLSQL3"



    # $ANTLR start "synpred531_PLSQL3"
    def synpred531_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1197:40: ( 'PRIOR' )
        # ./output/PLSQL3.g:1197:40: 'PRIOR'
        pass
        self.match(self.input, 134, self.FOLLOW_134_in_synpred531_PLSQL37540)



    # $ANTLR end "synpred531_PLSQL3"



    # $ANTLR start "synpred540_PLSQL3"
    def synpred540_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1216:6: ( sql_expression )
        # ./output/PLSQL3.g:1216:8: sql_expression
        pass
        self._state.following.append(self.FOLLOW_sql_expression_in_synpred540_PLSQL37691)
        self.sql_expression()

        self._state.following.pop()



    # $ANTLR end "synpred540_PLSQL3"



    # $ANTLR start "synpred541_PLSQL3"
    def synpred541_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1216:45: ( NUMBER )
        # ./output/PLSQL3.g:1216:47: NUMBER
        pass
        self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_synpred541_PLSQL37703)



    # $ANTLR end "synpred541_PLSQL3"



    # $ANTLR start "synpred562_PLSQL3"
    def synpred562_PLSQL3_fragment(self, ):
        # ./output/PLSQL3.g:1286:5: ( variable_names )
        # ./output/PLSQL3.g:1286:5: variable_names
        pass
        self._state.following.append(self.FOLLOW_variable_names_in_synpred562_PLSQL38115)
        self.variable_names()

        self._state.following.pop()



    # $ANTLR end "synpred562_PLSQL3"




    def synpred238_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred238_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred416_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred416_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred386_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred386_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred13_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred13_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred331_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred331_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred335_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred335_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred299_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred299_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred450_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred450_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred70_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred70_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred291_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred291_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred508_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred508_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred284_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred284_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred78_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred78_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred540_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred540_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred458_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred458_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred347_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred347_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred518_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred518_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred482_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred482_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred279_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred279_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred239_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred239_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred263_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred263_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred52_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred52_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred287_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred287_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred375_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred375_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred447_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred447_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred301_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred301_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred343_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred343_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred529_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred529_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred369_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred369_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred442_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred442_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred304_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred304_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred477_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred477_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred117_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred117_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred367_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred367_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred290_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred290_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred295_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred295_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred80_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred80_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred494_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred494_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred44_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred44_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred268_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred268_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred483_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred483_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred27_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred27_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred541_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred541_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred389_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred389_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred348_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred348_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred365_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred365_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred384_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred384_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred410_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred410_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred460_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred460_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred289_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred289_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred453_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred453_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred491_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred491_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred478_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred478_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred48_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred48_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred288_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred288_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred371_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred371_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred46_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred46_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred443_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred443_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred452_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred452_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred73_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred73_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred468_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred468_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred264_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred264_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred363_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred363_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred292_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred292_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred461_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred461_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred252_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred252_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred496_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred496_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred116_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred116_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred77_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred77_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred172_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred172_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred396_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred396_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred455_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred455_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred531_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred531_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred451_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred451_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred464_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred464_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred467_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred467_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred346_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred346_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred411_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred411_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred449_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred449_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred283_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred283_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred383_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred383_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred267_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred267_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred79_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred79_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred457_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred457_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred266_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred266_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred378_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred378_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred373_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred373_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred454_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred454_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred114_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred114_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred306_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred306_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred275_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred275_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred432_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred432_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred380_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred380_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred463_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred463_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred448_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred448_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred297_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred297_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred493_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred493_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred562_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred562_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred298_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred298_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred361_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred361_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred286_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred286_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred256_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred256_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred387_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred387_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred311_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred311_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred421_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred421_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred62_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred62_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred530_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred530_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred446_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred446_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred358_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred358_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred74_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred74_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred357_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred357_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred435_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred435_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred526_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred526_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred278_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred278_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred345_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred345_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred364_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred364_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred232_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred232_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred385_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred385_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred459_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred459_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred76_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred76_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred75_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred75_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred265_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred265_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred517_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred517_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred14_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred14_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred293_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred293_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred413_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred413_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred362_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred362_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred296_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred296_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred441_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred441_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred428_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred428_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred456_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred456_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred360_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred360_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred269_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred269_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred280_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred280_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred305_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred305_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred43_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred43_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred388_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred388_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred355_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred355_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred507_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred507_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred506_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred506_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred53_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred53_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred330_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred330_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred318_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred318_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred274_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred274_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred242_PLSQL3(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred242_PLSQL3_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success



    # lookup tables for DFA #10

    DFA10_eot = DFA.unpack(
        u"\u02c4\uffff"
        )

    DFA10_eof = DFA.unpack(
        u"\u02c4\uffff"
        )

    DFA10_min = DFA.unpack(
        u"\1\17\2\15\4\uffff\20\5\1\26\7\5\1\102\11\5\1\uffff\1\17\1\42\1"
        u"\5\2\42\1\33\1\17\1\26\1\17\1\5\1\17\1\5\1\17\1\uffff\1\42\2\5"
        u"\1\42\1\u0094\1\42\1\u0094\1\42\1\u0094\1\5\1\42\1\5\3\42\1\5\1"
        u"\u0094\1\17\1\42\1\17\1\7\27\26\1\102\6\26\1\7\1\26\1\7\1\uffff"
        u"\1\13\2\54\1\42\1\26\1\54\1\13\1\26\1\5\1\7\2\53\1\uffff\1\7\2"
        u"\uffff\1\54\1\26\1\17\1\26\1\17\1\26\1\17\4\54\1\5\1\42\1\17\1"
        u"\7\2\54\1\7\1\17\1\26\1\170\1\0\1\17\1\26\1\17\1\26\1\uffff\1\42"
        u"\1\26\3\42\2\26\1\42\1\u0094\1\42\1\u0094\1\42\1\u0094\1\26\1\42"
        u"\1\26\3\42\1\26\1\u0094\1\17\3\42\3\5\1\54\2\5\13\13\1\7\5\13\1"
        u"\26\7\13\1\102\6\13\1\7\1\13\1\7\1\17\1\152\1\5\1\17\1\42\2\17"
        u"\1\7\1\17\1\5\2\54\2\5\1\11\2\54\2\5\1\11\2\54\2\5\1\11\4\5\1\54"
        u"\1\5\1\11\2\5\1\42\1\26\1\6\1\26\1\55\2\7\2\53\1\13\3\54\1\26\1"
        u"\17\1\26\1\17\1\26\1\17\4\54\1\26\1\42\1\17\1\7\3\54\1\u009b\2"
        u"\42\1\13\2\42\1\33\1\42\1\26\1\17\1\13\1\17\1\13\1\42\2\13\1\42"
        u"\1\u0094\1\42\1\u0094\1\42\1\u0094\1\13\1\42\1\13\3\42\1\13\1\u0094"
        u"\1\17\2\42\1\13\2\5\2\57\1\42\1\6\1\17\1\5\1\17\1\5\1\17\2\5\1"
        u"\17\1\5\1\54\3\26\2\17\1\42\4\26\2\54\1\26\2\11\2\54\1\26\2\11"
        u"\2\54\1\26\2\11\4\26\1\54\2\11\2\26\1\54\1\13\2\54\1\42\1\26\1"
        u"\54\1\26\2\7\2\53\1\54\1\26\1\17\1\26\1\17\1\26\1\17\4\54\1\13"
        u"\1\42\1\17\1\7\2\54\13\13\1\7\5\13\1\26\7\13\1\102\6\13\1\7\1\13"
        u"\1\7\1\17\1\54\1\26\10\11\1\55\1\42\1\26\1\15\2\57\1\54\1\17\1"
        u"\26\1\17\1\26\1\17\2\26\1\17\1\26\1\5\1\42\3\13\1\54\3\13\2\17"
        u"\1\13\2\54\1\13\2\11\2\54\1\13\2\11\2\54\1\13\2\11\4\13\1\54\2"
        u"\11\2\13\1\42\1\13\2\42\1\33\1\42\1\26\1\17\1\13\1\17\1\13\1\42"
        u"\2\13\1\42\1\u0094\1\42\1\u0094\1\42\1\u0094\1\13\1\42\1\13\3\42"
        u"\1\13\1\u0094\1\17\2\42\1\5\1\55\1\uffff\4\17\1\54\1\17\10\11\1"
        u"\54\1\u009b\1\42\2\13\2\57\1\17\1\13\1\17\1\13\1\17\2\13\1\17\2"
        u"\13\2\54\1\42\1\26\1\54\1\26\2\7\2\53\1\54\1\26\1\17\1\26\1\17"
        u"\1\26\1\17\4\54\1\13\1\42\1\17\1\7\2\54\10\11\1\26\1\15\4\17\1"
        u"\54\1\17\10\11\1\42\3\13\1\54\3\13\2\17\1\13\2\54\1\13\2\11\2\54"
        u"\1\13\2\11\2\54\1\13\2\11\4\13\1\54\2\11\2\13\10\11\2\13\4\17\1"
        u"\54\1\u009b\1\42\2\13\2\57\1\17\1\13\1\17\1\13\1\17\2\13\1\17\1"
        u"\13\10\11\1\54\1\17\10\11\2\13\4\17\10\11"
        )

    DFA10_max = DFA.unpack(
        u"\1\u0087\2\u00a3\4\uffff\6\166\1\u0089\3\166\1\u00a7\5\166\1\26"
        u"\7\166\1\103\10\166\1\u008c\1\uffff\1\u00a3\1\42\1\166\2\42\1\u009b"
        u"\1\42\1\26\1\u0090\1\166\1\u0090\1\166\1\u00a3\1\uffff\1\42\2\166"
        u"\1\42\1\u0094\1\42\1\u0094\1\42\1\u0094\1\166\1\42\1\166\3\42\1"
        u"\166\1\u0094\1\u0090\2\42\1\u00a7\6\166\1\u0089\10\166\1\26\7\166"
        u"\1\103\11\166\1\uffff\3\54\1\42\1\26\1\54\1\u00a3\1\26\1\166\1"
        u"\57\2\53\1\uffff\1\u00a7\2\uffff\1\54\1\102\1\u0090\1\102\1\u0090"
        u"\1\102\1\u0090\4\54\1\166\1\42\1\u0090\1\57\2\54\1\u00a7\1\u009c"
        u"\1\26\1\170\1\0\1\u0090\1\166\1\u0090\1\166\1\uffff\1\42\1\166"
        u"\3\42\2\166\1\42\1\u0094\1\42\1\u0094\1\42\1\u0094\1\166\1\42\1"
        u"\166\3\42\1\166\1\u0094\1\u0090\3\42\3\166\1\54\1\166\1\u00a7\1"
        u"\u00a3\6\54\1\u0089\3\54\1\u00a7\5\54\1\26\3\103\4\54\1\103\3\54"
        u"\1\103\2\54\1\57\1\54\1\57\1\26\1\u008c\1\166\1\u0090\1\42\1\u00a3"
        u"\1\u0090\1\u00a7\1\u009c\1\166\2\54\2\166\1\15\2\54\2\166\1\15"
        u"\2\54\2\166\1\15\4\166\1\54\1\166\1\15\2\166\1\42\1\26\1\177\1"
        u"\26\1\55\1\166\1\57\2\53\4\54\1\102\1\u0090\1\102\1\u0090\1\102"
        u"\1\u0090\4\54\1\166\1\42\1\u0090\1\57\3\54\1\u009b\2\42\1\54\2"
        u"\42\1\u009b\1\42\1\26\1\u0090\1\54\1\u0090\1\54\1\42\1\54\1\103"
        u"\1\42\1\u0094\1\42\1\u0094\1\42\1\u0094\1\54\1\42\1\54\3\42\1\54"
        u"\1\u0094\1\u0090\2\42\1\u00a3\2\166\2\57\1\42\1\177\1\u0090\1\166"
        u"\1\u0090\1\166\1\u0090\2\166\1\u0090\1\166\1\54\1\166\1\u00a7\1"
        u"\166\2\u0090\1\42\4\166\2\54\2\166\1\15\2\54\2\166\1\15\2\54\2"
        u"\166\1\15\4\166\1\54\1\166\1\15\2\166\4\54\1\42\1\26\1\54\1\26"
        u"\2\57\2\53\1\54\1\102\1\u0090\1\102\1\u0090\1\102\1\u0090\5\54"
        u"\1\42\1\u0090\1\57\2\54\1\u00a3\6\54\1\u0089\3\54\1\u00a7\5\54"
        u"\1\26\3\103\4\54\1\103\3\54\1\103\2\54\1\57\1\54\1\57\1\26\1\54"
        u"\1\u00a7\10\15\1\u00a7\1\42\2\166\2\57\1\54\1\u0090\1\166\1\u0090"
        u"\1\166\1\u0090\2\166\1\u0090\2\166\1\42\5\54\1\u00a7\1\54\2\u0090"
        u"\3\54\1\103\1\54\1\15\2\54\1\103\1\54\1\15\2\54\1\103\1\54\1\15"
        u"\6\54\1\15\2\54\1\42\1\54\2\42\1\u009b\1\42\1\26\1\u0090\1\54\1"
        u"\u0090\1\54\1\42\1\54\1\103\1\42\1\u0094\1\42\1\u0094\1\42\1\u0094"
        u"\1\54\1\42\1\54\3\42\1\54\1\u0094\1\u0090\2\42\1\166\1\u00a7\1"
        u"\uffff\4\u0090\1\54\1\26\10\15\1\54\1\u009b\1\42\1\54\3\57\1\u0090"
        u"\1\54\1\u0090\1\54\1\u0090\2\54\1\u0090\4\54\1\42\1\26\1\54\1\26"
        u"\2\57\2\53\1\54\1\102\1\u0090\1\102\1\u0090\1\102\1\u0090\5\54"
        u"\1\42\1\u0090\1\57\2\54\10\11\2\166\4\u0090\1\54\1\26\10\15\1\42"
        u"\5\54\1\u00a7\1\54\2\u0090\3\54\1\103\1\54\1\15\2\54\1\103\1\54"
        u"\1\15\2\54\1\103\1\54\1\15\6\54\1\15\2\54\10\11\2\54\4\u0090\1"
        u"\54\1\u009b\1\42\1\54\3\57\1\u0090\1\54\1\u0090\1\54\1\u0090\2"
        u"\54\1\u0090\1\54\10\11\1\54\1\26\10\15\2\54\4\u0090\10\11"
        )

    DFA10_accept = DFA.unpack(
        u"\3\uffff\1\11\1\12\1\14\1\1\42\uffff\1\13\15\uffff\1\10\66\uffff"
        u"\1\2\14\uffff\1\5\1\uffff\1\4\1\7\32\uffff\1\3\u0176\uffff\1\6"
        u"\u00b3\uffff"
        )

    DFA10_special = DFA.unpack(
        u"\u0094\uffff\1\0\u022f\uffff"
        )


    DFA10_transition = [
        DFA.unpack(u"\1\2\6\uffff\1\1\107\uffff\1\4\46\uffff\1\5\1\uffff"
        u"\1\3"),
        DFA.unpack(u"\1\51\1\uffff\1\50\6\uffff\1\21\43\uffff\1\45\1\11"
        u"\1\10\1\7\1\42\1\17\2\uffff\1\30\1\33\1\43\3\uffff\1\6\1\uffff"
        u"\1\20\2\14\5\uffff\1\27\3\uffff\1\51\4\uffff\1\25\12\uffff\1\23"
        u"\1\22\5\uffff\1\15\2\uffff\1\40\1\uffff\1\37\1\12\1\34\1\44\3\uffff"
        u"\2\14\1\35\1\36\6\uffff\1\41\1\13\4\uffff\1\16\1\26\5\uffff\1\46"
        u"\5\uffff\1\24\11\uffff\1\47\1\uffff\1\31\1\32"),
        DFA.unpack(u"\1\51\1\uffff\1\6\6\uffff\1\6\43\uffff\6\6\2\uffff"
        u"\3\6\3\uffff\1\6\1\uffff\3\6\5\uffff\1\6\3\uffff\1\51\4\uffff\1"
        u"\6\12\uffff\2\6\5\uffff\1\6\2\uffff\1\6\1\uffff\4\6\3\uffff\4\6"
        u"\6\uffff\2\6\4\uffff\2\6\5\uffff\1\6\5\uffff\1\6\11\uffff\1\6\1"
        u"\uffff\2\6"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\25\uffff\1\53\21\uffff\1\6\40\uffff\1\6\33\uffff"
        u"\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\6\25\uffff\1\55\21\uffff\1\6\40\uffff\1\6\33\uffff"
        u"\1\52\13\uffff\1\6\22\uffff\1\54"),
        DFA.unpack(u"\1\6\25\uffff\1\56\21\uffff\1\6\40\uffff\1\6\33\uffff"
        u"\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\1\uffff\1\64\5\uffff\1\62\10\uffff\1\57\4\uffff"
        u"\1\60\17\uffff\1\65\1\uffff\1\6\1\uffff\1\63\36\uffff\1\6\33\uffff"
        u"\1\66\13\uffff\1\6\25\uffff\1\67\32\uffff\1\61"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\25\uffff\1\70\21\uffff\1\6\40\uffff\1\6\33\uffff"
        u"\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\71"),
        DFA.unpack(u"\1\6\20\uffff\1\72\4\uffff\1\73\21\uffff\1\6\25\uffff"
        u"\1\74\12\uffff\1\6\33\uffff\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\6\25\uffff\1\75\21\uffff\1\6\25\uffff\1\76\12\uffff"
        u"\1\6\33\uffff\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\6\25\uffff\1\77\21\uffff\1\6\25\uffff\1\100\12\uffff"
        u"\1\6\33\uffff\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\6\20\uffff\1\101\4\uffff\1\102\21\uffff\1\6\40\uffff"
        u"\1\6\33\uffff\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\6\20\uffff\1\103\4\uffff\1\104\21\uffff\1\6\40\uffff"
        u"\1\6\33\uffff\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\6\25\uffff\1\105\21\uffff\1\6\40\uffff\1\6\33\uffff"
        u"\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\6\25\uffff\1\106\21\uffff\1\6\40\uffff\1\6\33\uffff"
        u"\1\52\13\uffff\1\6"),
        DFA.unpack(u"\2\107"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\47\uffff\1\6\25\uffff\1\110\12\uffff\1\6\33\uffff"
        u"\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\1\uffff\1\64\5\uffff\1\111\35\uffff\1\65\1\uffff"
        u"\1\6\1\uffff\1\63\36\uffff\1\6\33\uffff\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\6\25\uffff\1\112\21\uffff\1\6\40\uffff\1\6\33\uffff"
        u"\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\6\1\uffff\1\64\5\uffff\1\62\15\uffff\1\113\17\uffff"
        u"\1\65\1\uffff\1\6\1\uffff\1\63\36\uffff\1\6\33\uffff\1\66\13\uffff"
        u"\1\6\25\uffff\1\67"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\155\6\uffff\1\114\4\uffff\1\156\36\uffff\1\152\1"
        u"\117\1\116\1\115\1\147\1\125\2\uffff\1\135\1\140\1\150\5\uffff"
        u"\1\126\2\122\5\uffff\1\134\10\uffff\1\132\12\uffff\1\130\1\127"
        u"\5\uffff\1\123\2\uffff\1\145\1\uffff\1\144\1\120\1\141\1\151\3"
        u"\uffff\2\122\1\142\1\143\6\uffff\1\146\1\121\4\uffff\1\124\1\133"
        u"\5\uffff\1\153\5\uffff\1\131\11\uffff\1\154\1\uffff\1\136\1\137"),
        DFA.unpack(u"\1\157"),
        DFA.unpack(u"\1\6\25\uffff\1\55\21\uffff\1\6\40\uffff\1\6\33\uffff"
        u"\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\160"),
        DFA.unpack(u"\1\161"),
        DFA.unpack(u"\1\162\177\uffff\1\163"),
        DFA.unpack(u"\1\165\6\uffff\1\165\13\uffff\1\164"),
        DFA.unpack(u"\1\166"),
        DFA.unpack(u"\1\167\6\uffff\1\167\171\uffff\1\170"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\171\6\uffff\1\171\171\uffff\1\172"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\155\6\uffff\1\174\4\uffff\1\156\36\uffff\1\152\1"
        u"\117\1\116\1\115\1\147\1\125\2\uffff\1\135\1\140\1\150\5\uffff"
        u"\1\126\2\122\5\uffff\1\134\10\uffff\1\132\12\uffff\1\130\1\127"
        u"\5\uffff\1\123\2\uffff\1\145\1\uffff\1\144\1\120\1\141\1\151\3"
        u"\uffff\2\122\1\142\1\143\6\uffff\1\146\1\121\4\uffff\1\124\1\133"
        u"\1\175\4\uffff\1\153\2\uffff\1\176\2\uffff\1\131\2\uffff\1\173"
        u"\6\uffff\1\154\1\uffff\1\136\1\137"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\177"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\25\uffff\1\73\21\uffff\1\6\25\uffff\1\74\12\uffff"
        u"\1\6\33\uffff\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\u0080"),
        DFA.unpack(u"\1\u0081"),
        DFA.unpack(u"\1\u0082"),
        DFA.unpack(u"\1\u0083"),
        DFA.unpack(u"\1\u0084"),
        DFA.unpack(u"\1\u0085"),
        DFA.unpack(u"\1\6\25\uffff\1\102\21\uffff\1\6\40\uffff\1\6\33\uffff"
        u"\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\u0086"),
        DFA.unpack(u"\1\6\25\uffff\1\104\21\uffff\1\6\40\uffff\1\6\33\uffff"
        u"\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\u0087"),
        DFA.unpack(u"\1\u0088"),
        DFA.unpack(u"\1\u0089"),
        DFA.unpack(u"\1\6\20\uffff\1\u008a\4\uffff\1\u008b\21\uffff\1\6"
        u"\40\uffff\1\6\33\uffff\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\u008c"),
        DFA.unpack(u"\1\u008d\6\uffff\1\u008d\171\uffff\1\170"),
        DFA.unpack(u"\1\u008e"),
        DFA.unpack(u"\1\165\6\uffff\1\165\13\uffff\1\u008f"),
        DFA.unpack(u"\1\u0097\5\uffff\1\u0095\1\uffff\1\156\6\uffff\1\u0090"
        u"\4\uffff\1\u0091\17\uffff\1\u0098\1\uffff\1\u0094\1\uffff\1\u0096"
        u"\12\uffff\6\156\2\uffff\3\156\5\uffff\3\156\5\uffff\1\156\10\uffff"
        u"\1\156\12\uffff\2\156\5\uffff\1\156\2\uffff\1\156\1\uffff\4\156"
        u"\1\u0093\2\uffff\4\156\6\uffff\2\156\4\uffff\2\156\5\uffff\1\156"
        u"\5\uffff\1\156\11\uffff\1\156\1\uffff\2\156\3\uffff\1\u0092"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\4\uffff\1\u009a\21\uffff\1\u0094\110\uffff"
        u"\1\u0093"),
        DFA.unpack(u"\1\u0099\4\uffff\1\u009c\21\uffff\1\u0094\110\uffff"
        u"\1\u0093\22\uffff\1\u009b"),
        DFA.unpack(u"\1\u0099\4\uffff\1\u009d\21\uffff\1\u0094\110\uffff"
        u"\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\4\uffff\1\u009e\21\uffff\1\u0094\110\uffff"
        u"\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u009f"),
        DFA.unpack(u"\1\u00a0\4\uffff\1\u00a1\21\uffff\1\u0094\25\uffff"
        u"\1\u00a2\62\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\4\uffff\1\u00a3\21\uffff\1\u0094\25\uffff"
        u"\1\u00a4\62\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\4\uffff\1\u00a5\21\uffff\1\u0094\25\uffff"
        u"\1\u00a6\62\uffff\1\u0093"),
        DFA.unpack(u"\1\u00a7\4\uffff\1\u00a8\21\uffff\1\u0094\110\uffff"
        u"\1\u0093"),
        DFA.unpack(u"\1\u00a9\4\uffff\1\u00aa\21\uffff\1\u0094\110\uffff"
        u"\1\u0093"),
        DFA.unpack(u"\1\u0099\4\uffff\1\u00ab\21\uffff\1\u0094\110\uffff"
        u"\1\u0093"),
        DFA.unpack(u"\1\u0099\4\uffff\1\u00ac\21\uffff\1\u0094\110\uffff"
        u"\1\u0093"),
        DFA.unpack(u"\2\u00ad"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\25\uffff\1\u00ae\62\uffff"
        u"\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0097\5\uffff\1\u00af\10\uffff\1\u0099\24\uffff"
        u"\1\u0098\1\uffff\1\u0094\1\uffff\1\u0096\106\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\4\uffff\1\u00b0\21\uffff\1\u0094\110\uffff"
        u"\1\u0093"),
        DFA.unpack(u"\1\u0097\5\uffff\1\u0095\10\uffff\1\u0099\4\uffff\1"
        u"\u00b1\17\uffff\1\u0098\1\uffff\1\u0094\1\uffff\1\u0096\106\uffff"
        u"\1\u0093"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\u00b2\40\uffff\1\u00b3"),
        DFA.unpack(u"\1\u00b4"),
        DFA.unpack(u"\1\u00b5"),
        DFA.unpack(u"\1\u00b6"),
        DFA.unpack(u"\1\u00b7"),
        DFA.unpack(u"\1\u00b8"),
        DFA.unpack(u"\1\u00dc\3\uffff\1\u00db\6\uffff\1\u00c4\25\uffff\1"
        u"\u00dd\15\uffff\1\u00d8\1\u00bc\1\u00bb\1\u00ba\1\u00d5\1\u00c2"
        u"\2\uffff\1\u00cb\1\u00ce\1\u00d6\5\uffff\1\u00c3\2\u00bf\5\uffff"
        u"\1\u00ca\10\uffff\1\u00c8\7\uffff\1\u00b9\2\uffff\1\u00c6\1\u00c5"
        u"\5\uffff\1\u00c0\2\uffff\1\u00d3\1\uffff\1\u00d2\1\u00bd\1\u00cf"
        u"\1\u00d7\3\uffff\2\u00bf\1\u00d0\1\u00d1\6\uffff\1\u00d4\1\u00be"
        u"\4\uffff\1\u00c1\1\u00c9\5\uffff\1\u00d9\5\uffff\1\u00c7\11\uffff"
        u"\1\u00da\1\uffff\1\u00cc\1\u00cd"),
        DFA.unpack(u"\1\u00de"),
        DFA.unpack(u"\1\6\1\uffff\1\64\5\uffff\1\u00df\15\uffff\1\u00e0"
        u"\17\uffff\1\65\1\uffff\1\6\1\uffff\1\63\36\uffff\1\6\33\uffff\1"
        u"\u00e1\13\uffff\1\6"),
        DFA.unpack(u"\1\64\5\uffff\1\u00e2\35\uffff\1\65\3\uffff\1\63"),
        DFA.unpack(u"\1\65"),
        DFA.unpack(u"\1\65"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\u0097\5\uffff\1\u0095\1\uffff\1\156\6\uffff\1\u00e3"
        u"\4\uffff\1\u00e4\17\uffff\1\u0098\1\uffff\1\u0094\1\uffff\1\u0096"
        u"\12\uffff\6\156\2\uffff\3\156\5\uffff\3\156\5\uffff\1\156\10\uffff"
        u"\1\156\12\uffff\2\156\5\uffff\1\156\2\uffff\1\156\1\uffff\4\156"
        u"\1\u0093\2\uffff\4\156\6\uffff\2\156\4\uffff\2\156\5\uffff\1\156"
        u"\5\uffff\1\156\11\uffff\1\156\1\uffff\2\156\3\uffff\1\u0092"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\1\u00e5"),
        DFA.unpack(u"\1\u00e6\25\uffff\1\u00e8\25\uffff\1\u00e7"),
        DFA.unpack(u"\1\u00e9\6\uffff\1\u00e9\171\uffff\1\u00ea"),
        DFA.unpack(u"\1\u00eb\25\uffff\1\u00ed\25\uffff\1\u00ec"),
        DFA.unpack(u"\1\u00ee\6\uffff\1\u00ee\171\uffff\1\u00ef"),
        DFA.unpack(u"\1\u00f0\25\uffff\1\u00f2\25\uffff\1\u00f1"),
        DFA.unpack(u"\1\u00f3\6\uffff\1\u00f3\171\uffff\1\u00f4"),
        DFA.unpack(u"\1\u00f5"),
        DFA.unpack(u"\1\u00f6"),
        DFA.unpack(u"\1\u00f7"),
        DFA.unpack(u"\1\u00f8"),
        DFA.unpack(u"\1\6\25\uffff\1\u008b\21\uffff\1\6\40\uffff\1\6\33"
        u"\uffff\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\u00f9"),
        DFA.unpack(u"\1\u00fa\6\uffff\1\u00fa\171\uffff\1\u00fb"),
        DFA.unpack(u"\1\64\5\uffff\1\u00e2\35\uffff\1\65\3\uffff\1\63"),
        DFA.unpack(u"\1\u00fc"),
        DFA.unpack(u"\1\u00fd"),
        DFA.unpack(u"\1\156\5\uffff\1\156\10\uffff\1\156\4\uffff\1\u00fe"
        u"\1\uffff\1\u0099\4\uffff\1\u0099\1\uffff\1\u0099\2\uffff\1\u0099"
        u"\3\uffff\1\156\1\uffff\1\156\1\uffff\1\156\106\uffff\1\156\44\uffff"
        u"\1\u00ff\13\uffff\1\156"),
        DFA.unpack(u"\1\156\6\uffff\1\156\4\uffff\1\156\1\uffff\1\156\4"
        u"\uffff\1\u0100\1\uffff\1\156\2\uffff\1\156\31\uffff\1\156\17\uffff"
        u"\1\156\7\uffff\1\156\34\uffff\1\156\1\uffff\1\156\27\uffff\1\156"
        u"\2\uffff\1\156\3\uffff\1\156\4\uffff\1\156"),
        DFA.unpack(u"\1\u0101"),
        DFA.unpack(u"\1\u0102"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\u0103\6\uffff\1\u0103\171\uffff\1\u0104"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0105\6\uffff\1\u0105\171\uffff\1\u0106"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\u0107"),
        DFA.unpack(u"\1\u0099\4\uffff\1\u009c\21\uffff\1\u0094\110\uffff"
        u"\1\u0093"),
        DFA.unpack(u"\1\u0108"),
        DFA.unpack(u"\1\u0109"),
        DFA.unpack(u"\1\u010a"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\4\uffff\1\u00a1\1\uffff\1\u0099\4\uffff\1"
        u"\u0099\1\uffff\1\u0099\2\uffff\1\u0099\5\uffff\1\u0094\25\uffff"
        u"\1\u00a2\62\uffff\1\u0093"),
        DFA.unpack(u"\1\u010b"),
        DFA.unpack(u"\1\u010c"),
        DFA.unpack(u"\1\u010d"),
        DFA.unpack(u"\1\u010e"),
        DFA.unpack(u"\1\u010f"),
        DFA.unpack(u"\1\u0110"),
        DFA.unpack(u"\1\u0099\4\uffff\1\u00a8\1\uffff\1\u0099\4\uffff\1"
        u"\u0099\1\uffff\1\u0099\2\uffff\1\u0099\5\uffff\1\u0094\110\uffff"
        u"\1\u0093"),
        DFA.unpack(u"\1\u0111"),
        DFA.unpack(u"\1\u0099\4\uffff\1\u00aa\1\uffff\1\u0099\4\uffff\1"
        u"\u0099\1\uffff\1\u0099\2\uffff\1\u0099\5\uffff\1\u0094\110\uffff"
        u"\1\u0093"),
        DFA.unpack(u"\1\u0112"),
        DFA.unpack(u"\1\u0113"),
        DFA.unpack(u"\1\u0114"),
        DFA.unpack(u"\1\u0115\4\uffff\1\u0116\21\uffff\1\u0094\110\uffff"
        u"\1\u0093"),
        DFA.unpack(u"\1\u0117"),
        DFA.unpack(u"\1\u0118\6\uffff\1\u0118\171\uffff\1\u0104"),
        DFA.unpack(u"\1\u0119"),
        DFA.unpack(u"\1\u011a"),
        DFA.unpack(u"\1\u011b"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\u011c"),
        DFA.unpack(u"\1\6\25\uffff\1\u011d\21\uffff\1\6\40\uffff\1\6\33"
        u"\uffff\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6\60\uffff\1\61"),
        DFA.unpack(u"\1\u00dc\3\uffff\1\u00db\6\uffff\1\u00c4\25\uffff\1"
        u"\u00dd\15\uffff\1\u00d8\1\u00bc\1\u00bb\1\u00ba\1\u00d5\1\u00c2"
        u"\2\uffff\1\u00cb\1\u00ce\1\u00d6\5\uffff\1\u00c3\2\u00bf\5\uffff"
        u"\1\u00ca\10\uffff\1\u00c8\12\uffff\1\u00c6\1\u00c5\5\uffff\1\u00c0"
        u"\2\uffff\1\u00d3\1\uffff\1\u00d2\1\u00bd\1\u00cf\1\u00d7\3\uffff"
        u"\2\u00bf\1\u00d0\1\u00d1\6\uffff\1\u00d4\1\u00be\4\uffff\1\u00c1"
        u"\1\u00c9\5\uffff\1\u00d9\5\uffff\1\u00c7\11\uffff\1\u00da\1\uffff"
        u"\1\u00cc\1\u00cd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u011e\20\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u0120\20\uffff\1\u00dd\134\uffff"
        u"\1\u011f"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u0121\20\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u0127\3\uffff\1\u00dc\1\uffff\1\u0125\10\uffff\1"
        u"\u0122\4\uffff\1\u0123\17\uffff\1\u0128\1\u00dd\2\uffff\1\u0126"
        u"\167\uffff\1\u0124"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u0129\20\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u012a"),
        DFA.unpack(u"\1\u00dc\12\uffff\1\u012b\4\uffff\1\u012c\20\uffff"
        u"\1\u00dd\26\uffff\1\u012d"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u012e\20\uffff\1\u00dd\26\uffff"
        u"\1\u012f"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u0130\20\uffff\1\u00dd\26\uffff"
        u"\1\u0131"),
        DFA.unpack(u"\1\u00dc\12\uffff\1\u0132\4\uffff\1\u0133\20\uffff"
        u"\1\u00dd"),
        DFA.unpack(u"\1\u00dc\12\uffff\1\u0134\4\uffff\1\u0135\20\uffff"
        u"\1\u00dd"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u0136\20\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u0137\20\uffff\1\u00dd"),
        DFA.unpack(u"\2\u0138"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd\26\uffff\1\u0139"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u0127\3\uffff\1\u00dc\1\uffff\1\u013a\35\uffff\1"
        u"\u0128\1\u00dd\2\uffff\1\u0126"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u013b\20\uffff\1\u00dd"),
        DFA.unpack(u"\1\u0127\3\uffff\1\u00dc\1\uffff\1\u0125\15\uffff\1"
        u"\u013c\17\uffff\1\u0128\1\u00dd\2\uffff\1\u0126"),
        DFA.unpack(u"\1\u013d\6\uffff\1\u013d"),
        DFA.unpack(u"\1\176\41\uffff\1\67"),
        DFA.unpack(u"\1\6\20\uffff\1\u013e\26\uffff\1\6\40\uffff\1\6\33"
        u"\uffff\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\u013f\6\uffff\1\u013f\171\uffff\1\u0140"),
        DFA.unpack(u"\1\u008f"),
        DFA.unpack(u"\1\155\6\uffff\1\174\4\uffff\1\156\36\uffff\1\152\1"
        u"\117\1\116\1\115\1\147\1\125\2\uffff\1\135\1\140\1\150\5\uffff"
        u"\1\126\2\122\5\uffff\1\134\10\uffff\1\132\12\uffff\1\130\1\127"
        u"\5\uffff\1\123\2\uffff\1\145\1\uffff\1\144\1\120\1\141\1\151\3"
        u"\uffff\2\122\1\142\1\143\6\uffff\1\146\1\121\4\uffff\1\124\1\133"
        u"\1\175\4\uffff\1\153\5\uffff\1\131\2\uffff\1\173\6\uffff\1\154"
        u"\1\uffff\1\136\1\137"),
        DFA.unpack(u"\1\u0141\6\uffff\1\u0141\171\uffff\1\u0140"),
        DFA.unpack(u"\1\156\5\uffff\1\156\10\uffff\1\156\4\uffff\1\u0142"
        u"\1\uffff\1\u0099\4\uffff\1\u0099\1\uffff\1\u0099\2\uffff\1\u0099"
        u"\3\uffff\1\156\1\uffff\1\156\1\uffff\1\156\106\uffff\1\156\44\uffff"
        u"\1\u00ff\13\uffff\1\156"),
        DFA.unpack(u"\1\156\6\uffff\1\156\4\uffff\1\156\1\uffff\1\156\4"
        u"\uffff\1\u0143\1\uffff\1\156\2\uffff\1\156\31\uffff\1\156\17\uffff"
        u"\1\156\7\uffff\1\156\34\uffff\1\156\1\uffff\1\156\27\uffff\1\156"
        u"\2\uffff\1\156\3\uffff\1\156\4\uffff\1\156"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\u00e8"),
        DFA.unpack(u"\1\u00e8"),
        DFA.unpack(u"\1\6\47\uffff\1\6\25\uffff\1\74\12\uffff\1\6\33\uffff"
        u"\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\6\3\uffff\1\u0145\3\uffff\1\u0144\37\uffff\1\6\40"
        u"\uffff\1\6\33\uffff\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\u0145\3\uffff\1\u0144"),
        DFA.unpack(u"\1\u00ed"),
        DFA.unpack(u"\1\u00ed"),
        DFA.unpack(u"\1\6\47\uffff\1\6\25\uffff\1\76\12\uffff\1\6\33\uffff"
        u"\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\6\3\uffff\1\u0147\3\uffff\1\u0146\37\uffff\1\6\40"
        u"\uffff\1\6\33\uffff\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\u0147\3\uffff\1\u0146"),
        DFA.unpack(u"\1\u00f2"),
        DFA.unpack(u"\1\u00f2"),
        DFA.unpack(u"\1\6\47\uffff\1\6\25\uffff\1\100\12\uffff\1\6\33\uffff"
        u"\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\6\3\uffff\1\u0149\3\uffff\1\u0148\37\uffff\1\6\40"
        u"\uffff\1\6\33\uffff\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\u0149\3\uffff\1\u0148"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\u014a"),
        DFA.unpack(u"\1\6\3\uffff\1\u014c\3\uffff\1\u014b\37\uffff\1\6\40"
        u"\uffff\1\6\33\uffff\1\52\13\uffff\1\6"),
        DFA.unpack(u"\1\u014c\3\uffff\1\u014b"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\u014d"),
        DFA.unpack(u"\1\u014e"),
        DFA.unpack(u"\1\156\1\uffff\1\156\2\uffff\2\156\3\uffff\6\156\1"
        u"\uffff\1\156\1\uffff\1\156\2\uffff\2\156\2\uffff\2\156\2\uffff"
        u"\1\156\5\uffff\1\156\1\uffff\1\u014f\6\uffff\1\156\5\uffff\1\156"
        u"\51\uffff\1\156\6\uffff\2\156\12\uffff\1\156\10\uffff\1\156"),
        DFA.unpack(u"\1\u0150"),
        DFA.unpack(u"\1\u0094"),
        DFA.unpack(u"\1\u0097\5\uffff\1\u0151\10\uffff\1\u0099\4\uffff\1"
        u"\u00b1\17\uffff\1\u0098\1\uffff\1\u0094\1\uffff\1\u0096\106\uffff"
        u"\1\u0093"),
        DFA.unpack(u"\1\u0097\5\uffff\1\u0152\35\uffff\1\u0098\3\uffff\1"
        u"\u0096"),
        DFA.unpack(u"\1\u0098"),
        DFA.unpack(u"\1\u0098"),
        DFA.unpack(u"\1\u0153\40\uffff\1\u0154"),
        DFA.unpack(u"\1\u0155"),
        DFA.unpack(u"\1\u0156"),
        DFA.unpack(u"\1\u0157"),
        DFA.unpack(u"\1\u0158\25\uffff\1\u015a\25\uffff\1\u0159"),
        DFA.unpack(u"\1\u015b\6\uffff\1\u015b\171\uffff\1\u015c"),
        DFA.unpack(u"\1\u015d\25\uffff\1\u015f\25\uffff\1\u015e"),
        DFA.unpack(u"\1\u0160\6\uffff\1\u0160\171\uffff\1\u0161"),
        DFA.unpack(u"\1\u0162\25\uffff\1\u0164\25\uffff\1\u0163"),
        DFA.unpack(u"\1\u0165\6\uffff\1\u0165\171\uffff\1\u0166"),
        DFA.unpack(u"\1\u0167"),
        DFA.unpack(u"\1\u0168"),
        DFA.unpack(u"\1\u0169"),
        DFA.unpack(u"\1\u016a"),
        DFA.unpack(u"\1\u0099\4\uffff\1\u0116\1\uffff\1\u0099\4\uffff\1"
        u"\u0099\1\uffff\1\u0099\2\uffff\1\u0099\5\uffff\1\u0094\110\uffff"
        u"\1\u0093"),
        DFA.unpack(u"\1\u016b"),
        DFA.unpack(u"\1\u016c\6\uffff\1\u016c\171\uffff\1\u016d"),
        DFA.unpack(u"\1\u0097\5\uffff\1\u0152\35\uffff\1\u0098\3\uffff\1"
        u"\u0096"),
        DFA.unpack(u"\1\u016e"),
        DFA.unpack(u"\1\u016f"),
        DFA.unpack(u"\1\u00b3"),
        DFA.unpack(u"\1\163"),
        DFA.unpack(u"\1\u0170"),
        DFA.unpack(u"\1\u0171"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u0120\20\uffff\1\u00dd"),
        DFA.unpack(u"\1\u0172"),
        DFA.unpack(u"\1\u0173"),
        DFA.unpack(u"\1\u0174\177\uffff\1\u0175"),
        DFA.unpack(u"\1\u0176"),
        DFA.unpack(u"\1\u0177"),
        DFA.unpack(u"\1\u0178\6\uffff\1\u0178\171\uffff\1\u0179"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u017a\6\uffff\1\u017a\171\uffff\1\u017b"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u017c"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u012c\20\uffff\1\u00dd\26\uffff"
        u"\1\u012d"),
        DFA.unpack(u"\1\u017d"),
        DFA.unpack(u"\1\u017e"),
        DFA.unpack(u"\1\u017f"),
        DFA.unpack(u"\1\u0180"),
        DFA.unpack(u"\1\u0181"),
        DFA.unpack(u"\1\u0182"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u0133\20\uffff\1\u00dd"),
        DFA.unpack(u"\1\u0183"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u0135\20\uffff\1\u00dd"),
        DFA.unpack(u"\1\u0184"),
        DFA.unpack(u"\1\u0185"),
        DFA.unpack(u"\1\u0186"),
        DFA.unpack(u"\1\u00dc\12\uffff\1\u0187\4\uffff\1\u0188\20\uffff"
        u"\1\u00dd"),
        DFA.unpack(u"\1\u0189"),
        DFA.unpack(u"\1\u018a\6\uffff\1\u018a\171\uffff\1\u0179"),
        DFA.unpack(u"\1\u018b"),
        DFA.unpack(u"\1\u018c"),
        DFA.unpack(u"\1\u00dc\3\uffff\1\u01af\6\uffff\1\u0198\25\uffff\1"
        u"\u00dd\15\uffff\1\u01ac\1\u0190\1\u018f\1\u018e\1\u01a9\1\u0196"
        u"\2\uffff\1\u019f\1\u01a2\1\u01aa\5\uffff\1\u0197\2\u0193\5\uffff"
        u"\1\u019e\10\uffff\1\u019c\7\uffff\1\u018d\2\uffff\1\u019a\1\u0199"
        u"\5\uffff\1\u0194\2\uffff\1\u01a7\1\uffff\1\u01a6\1\u0191\1\u01a3"
        u"\1\u01ab\3\uffff\2\u0193\1\u01a4\1\u01a5\6\uffff\1\u01a8\1\u0192"
        u"\4\uffff\1\u0195\1\u019d\5\uffff\1\u01ad\5\uffff\1\u019b\11\uffff"
        u"\1\u01ae\1\uffff\1\u01a0\1\u01a1"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\7\uffff\1\u01b0\15\uffff\1\u00e0\21\uffff\1\6"
        u"\1\uffff\1\63\36\uffff\1\6\33\uffff\1\u00e1\13\uffff\1\6"),
        DFA.unpack(u"\1\63"),
        DFA.unpack(u"\1\63"),
        DFA.unpack(u"\1\u01b1"),
        DFA.unpack(u"\1\156\1\uffff\1\156\2\uffff\2\156\3\uffff\6\156\1"
        u"\uffff\1\156\1\uffff\1\156\2\uffff\2\156\2\uffff\2\156\2\uffff"
        u"\1\156\5\uffff\1\156\1\uffff\1\u01b2\6\uffff\1\156\5\uffff\1\156"
        u"\51\uffff\1\156\6\uffff\2\156\12\uffff\1\156\10\uffff\1\156"),
        DFA.unpack(u"\1\u01b3\6\uffff\1\u01b3\171\uffff\1\u01b4"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\u01b5\6\uffff\1\u01b5\171\uffff\1\u01b6"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\u01b7\6\uffff\1\u01b7\171\uffff\1\u01b8"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\u01b9\6\uffff\1\u01b9\171\uffff\1\u01ba"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\u01bb"),
        DFA.unpack(u"\1\u0099\4\uffff\1\u01bc\21\uffff\1\u0094\110\uffff"
        u"\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093\60\uffff"
        u"\1\u0092"),
        DFA.unpack(u"\1\u01bd\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u01be\6\uffff\1\u01be\171\uffff\1\u01bf"),
        DFA.unpack(u"\1\u01c0\6\uffff\1\u01c0\171\uffff\1\u01bf"),
        DFA.unpack(u"\1\u01c1"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u015a"),
        DFA.unpack(u"\1\u015a"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\25\uffff\1\u00a2\62\uffff"
        u"\1\u0093"),
        DFA.unpack(u"\1\u01c3\3\uffff\1\u01c2\10\uffff\1\u0099\26\uffff"
        u"\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u01c3\3\uffff\1\u01c2"),
        DFA.unpack(u"\1\u015f"),
        DFA.unpack(u"\1\u015f"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\25\uffff\1\u00a4\62\uffff"
        u"\1\u0093"),
        DFA.unpack(u"\1\u01c5\3\uffff\1\u01c4\10\uffff\1\u0099\26\uffff"
        u"\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u01c5\3\uffff\1\u01c4"),
        DFA.unpack(u"\1\u0164"),
        DFA.unpack(u"\1\u0164"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\25\uffff\1\u00a6\62\uffff"
        u"\1\u0093"),
        DFA.unpack(u"\1\u01c7\3\uffff\1\u01c6\10\uffff\1\u0099\26\uffff"
        u"\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u01c7\3\uffff\1\u01c6"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u01c8"),
        DFA.unpack(u"\1\u01ca\3\uffff\1\u01c9\10\uffff\1\u0099\26\uffff"
        u"\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u01ca\3\uffff\1\u01c9"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u01cb"),
        DFA.unpack(u"\1\u01cc\40\uffff\1\u01cd"),
        DFA.unpack(u"\1\u01ce"),
        DFA.unpack(u"\1\u01cf"),
        DFA.unpack(u"\1\u01d0"),
        DFA.unpack(u"\1\u01d1"),
        DFA.unpack(u"\1\u01d2"),
        DFA.unpack(u"\1\u01d3"),
        DFA.unpack(u"\1\u0127\3\uffff\1\u00dc\1\uffff\1\u01d4\15\uffff\1"
        u"\u013c\17\uffff\1\u0128\1\u00dd\2\uffff\1\u0126"),
        DFA.unpack(u"\1\u0127\5\uffff\1\u01d5\35\uffff\1\u0128\3\uffff\1"
        u"\u0126"),
        DFA.unpack(u"\1\u0128"),
        DFA.unpack(u"\1\u0128"),
        DFA.unpack(u"\1\u01d6"),
        DFA.unpack(u"\1\u01d7\25\uffff\1\u01d9\25\uffff\1\u01d8"),
        DFA.unpack(u"\1\u01da\6\uffff\1\u01da\171\uffff\1\u01db"),
        DFA.unpack(u"\1\u01dc\25\uffff\1\u01de\25\uffff\1\u01dd"),
        DFA.unpack(u"\1\u01df\6\uffff\1\u01df\171\uffff\1\u01e0"),
        DFA.unpack(u"\1\u01e1\25\uffff\1\u01e3\25\uffff\1\u01e2"),
        DFA.unpack(u"\1\u01e4\6\uffff\1\u01e4\171\uffff\1\u01e5"),
        DFA.unpack(u"\1\u01e6"),
        DFA.unpack(u"\1\u01e7"),
        DFA.unpack(u"\1\u01e8"),
        DFA.unpack(u"\1\u01e9"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u0188\20\uffff\1\u00dd"),
        DFA.unpack(u"\1\u01ea"),
        DFA.unpack(u"\1\u01eb\6\uffff\1\u01eb\171\uffff\1\u01ec"),
        DFA.unpack(u"\1\u0127\5\uffff\1\u01d5\35\uffff\1\u0128\3\uffff\1"
        u"\u0126"),
        DFA.unpack(u"\1\u01ed"),
        DFA.unpack(u"\1\u01ee"),
        DFA.unpack(u"\1\u00dc\3\uffff\1\u01af\6\uffff\1\u0198\25\uffff\1"
        u"\u00dd\15\uffff\1\u01ac\1\u0190\1\u018f\1\u018e\1\u01a9\1\u0196"
        u"\2\uffff\1\u019f\1\u01a2\1\u01aa\5\uffff\1\u0197\2\u0193\5\uffff"
        u"\1\u019e\10\uffff\1\u019c\12\uffff\1\u019a\1\u0199\5\uffff\1\u0194"
        u"\2\uffff\1\u01a7\1\uffff\1\u01a6\1\u0191\1\u01a3\1\u01ab\3\uffff"
        u"\2\u0193\1\u01a4\1\u01a5\6\uffff\1\u01a8\1\u0192\4\uffff\1\u0195"
        u"\1\u019d\5\uffff\1\u01ad\5\uffff\1\u019b\11\uffff\1\u01ae\1\uffff"
        u"\1\u01a0\1\u01a1"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u01ef\20\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u01f1\20\uffff\1\u00dd\134\uffff"
        u"\1\u01f0"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u01f2\20\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u01f8\3\uffff\1\u00dc\1\uffff\1\u01f6\10\uffff\1"
        u"\u01f3\4\uffff\1\u01f4\17\uffff\1\u01f9\1\u00dd\2\uffff\1\u01f7"
        u"\167\uffff\1\u01f5"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u01fa\20\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u01fb"),
        DFA.unpack(u"\1\u00dc\12\uffff\1\u01fc\4\uffff\1\u01fd\20\uffff"
        u"\1\u00dd\26\uffff\1\u01fe"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u01ff\20\uffff\1\u00dd\26\uffff"
        u"\1\u0200"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u0201\20\uffff\1\u00dd\26\uffff"
        u"\1\u0202"),
        DFA.unpack(u"\1\u00dc\12\uffff\1\u0203\4\uffff\1\u0204\20\uffff"
        u"\1\u00dd"),
        DFA.unpack(u"\1\u00dc\12\uffff\1\u0205\4\uffff\1\u0206\20\uffff"
        u"\1\u00dd"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u0207\20\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u0208\20\uffff\1\u00dd"),
        DFA.unpack(u"\2\u0209"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd\26\uffff\1\u020a"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u01f8\3\uffff\1\u00dc\1\uffff\1\u020b\35\uffff\1"
        u"\u01f9\1\u00dd\2\uffff\1\u01f7"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u020c\20\uffff\1\u00dd"),
        DFA.unpack(u"\1\u01f8\3\uffff\1\u00dc\1\uffff\1\u01f6\15\uffff\1"
        u"\u020d\17\uffff\1\u01f9\1\u00dd\2\uffff\1\u01f7"),
        DFA.unpack(u"\1\u020e\6\uffff\1\u020e"),
        DFA.unpack(u"\1\u020f"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093\6\uffff"
        u"\1\u0210\51\uffff\1\u0092"),
        DFA.unpack(u"\1\u0145\3\uffff\1\u0211"),
        DFA.unpack(u"\1\u0145\3\uffff\1\u0211"),
        DFA.unpack(u"\1\u0147\3\uffff\1\u0212"),
        DFA.unpack(u"\1\u0147\3\uffff\1\u0212"),
        DFA.unpack(u"\1\u0149\3\uffff\1\u0213"),
        DFA.unpack(u"\1\u0149\3\uffff\1\u0213"),
        DFA.unpack(u"\1\u014c\3\uffff\1\u0214"),
        DFA.unpack(u"\1\u014c\3\uffff\1\u0214"),
        DFA.unpack(u"\1\156\110\uffff\1\156\44\uffff\1\u00ff\13\uffff\1"
        u"\156"),
        DFA.unpack(u"\1\u0215"),
        DFA.unpack(u"\1\u0099\6\uffff\1\u0099\4\uffff\1\u0099\1\uffff\1"
        u"\u0099\2\uffff\1\u0099\5\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0216\10\uffff\1\u0099\4\uffff\1\u00b1\21\uffff"
        u"\1\u0094\1\uffff\1\u0096\106\uffff\1\u0093"),
        DFA.unpack(u"\1\u0096"),
        DFA.unpack(u"\1\u0096"),
        DFA.unpack(u"\1\u0154"),
        DFA.unpack(u"\1\u0217\6\uffff\1\u0217\171\uffff\1\u0218"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0219\6\uffff\1\u0219\171\uffff\1\u021a"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u021b\6\uffff\1\u021b\171\uffff\1\u021c"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u021d\6\uffff\1\u021d\171\uffff\1\u021e"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\6\47\uffff\1\6\40\uffff\1\6\33\uffff\1\52\13\uffff"
        u"\1\6"),
        DFA.unpack(u"\1\u021f"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u0220"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u0221\20\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd\172\uffff\1\u0124"),
        DFA.unpack(u"\1\u00dc\12\uffff\1\u0222\25\uffff\1\u00dd"),
        DFA.unpack(u"\1\u0223\6\uffff\1\u0223\171\uffff\1\u0224"),
        DFA.unpack(u"\1\u0225\6\uffff\1\u0225\171\uffff\1\u0224"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u01d9"),
        DFA.unpack(u"\1\u01d9"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd\26\uffff\1\u012d"),
        DFA.unpack(u"\1\u0227\1\uffff\1\u00dc\1\uffff\1\u0226\36\uffff\1"
        u"\u00dd"),
        DFA.unpack(u"\1\u0227\3\uffff\1\u0226"),
        DFA.unpack(u"\1\u01de"),
        DFA.unpack(u"\1\u01de"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd\26\uffff\1\u012f"),
        DFA.unpack(u"\1\u0229\1\uffff\1\u00dc\1\uffff\1\u0228\36\uffff\1"
        u"\u00dd"),
        DFA.unpack(u"\1\u0229\3\uffff\1\u0228"),
        DFA.unpack(u"\1\u01e3"),
        DFA.unpack(u"\1\u01e3"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd\26\uffff\1\u0131"),
        DFA.unpack(u"\1\u022b\1\uffff\1\u00dc\1\uffff\1\u022a\36\uffff\1"
        u"\u00dd"),
        DFA.unpack(u"\1\u022b\3\uffff\1\u022a"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u022c"),
        DFA.unpack(u"\1\u022e\1\uffff\1\u00dc\1\uffff\1\u022d\36\uffff\1"
        u"\u00dd"),
        DFA.unpack(u"\1\u022e\3\uffff\1\u022d"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u022f"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u01f1\20\uffff\1\u00dd"),
        DFA.unpack(u"\1\u0230"),
        DFA.unpack(u"\1\u0231"),
        DFA.unpack(u"\1\u0232\177\uffff\1\u0233"),
        DFA.unpack(u"\1\u0234"),
        DFA.unpack(u"\1\u0235"),
        DFA.unpack(u"\1\u0236\6\uffff\1\u0236\171\uffff\1\u0237"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u0238\6\uffff\1\u0238\171\uffff\1\u0239"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u023a"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u01fd\20\uffff\1\u00dd\26\uffff"
        u"\1\u01fe"),
        DFA.unpack(u"\1\u023b"),
        DFA.unpack(u"\1\u023c"),
        DFA.unpack(u"\1\u023d"),
        DFA.unpack(u"\1\u023e"),
        DFA.unpack(u"\1\u023f"),
        DFA.unpack(u"\1\u0240"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u0204\20\uffff\1\u00dd"),
        DFA.unpack(u"\1\u0241"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u0206\20\uffff\1\u00dd"),
        DFA.unpack(u"\1\u0242"),
        DFA.unpack(u"\1\u0243"),
        DFA.unpack(u"\1\u0244"),
        DFA.unpack(u"\1\u00dc\12\uffff\1\u0245\4\uffff\1\u0246\20\uffff"
        u"\1\u00dd"),
        DFA.unpack(u"\1\u0247"),
        DFA.unpack(u"\1\u0248\6\uffff\1\u0248\171\uffff\1\u0237"),
        DFA.unpack(u"\1\u0249"),
        DFA.unpack(u"\1\u024a"),
        DFA.unpack(u"\1\6\7\uffff\1\u01b0\15\uffff\1\u00e0\21\uffff\1\6"
        u"\40\uffff\1\6\33\uffff\1\u00e1\13\uffff\1\6"),
        DFA.unpack(u"\1\156\110\uffff\1\156\6\uffff\1\u0210\35\uffff\1\u00ff"
        u"\13\uffff\1\156"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\u024b\6\uffff\1\u024b\171\uffff\1\u024c"),
        DFA.unpack(u"\1\u024d\6\uffff\1\u024d\171\uffff\1\u024e"),
        DFA.unpack(u"\1\u024f\6\uffff\1\u024f\171\uffff\1\u0250"),
        DFA.unpack(u"\1\u0251\6\uffff\1\u0251\171\uffff\1\u0252"),
        DFA.unpack(u"\1\u0253"),
        DFA.unpack(u"\1\u0254\6\uffff\1\u0254"),
        DFA.unpack(u"\1\u01c3\3\uffff\1\u0255"),
        DFA.unpack(u"\1\u01c3\3\uffff\1\u0255"),
        DFA.unpack(u"\1\u01c5\3\uffff\1\u0256"),
        DFA.unpack(u"\1\u01c5\3\uffff\1\u0256"),
        DFA.unpack(u"\1\u01c7\3\uffff\1\u0257"),
        DFA.unpack(u"\1\u01c7\3\uffff\1\u0257"),
        DFA.unpack(u"\1\u01ca\3\uffff\1\u0258"),
        DFA.unpack(u"\1\u01ca\3\uffff\1\u0258"),
        DFA.unpack(u"\1\u01cd"),
        DFA.unpack(u"\1\u0175"),
        DFA.unpack(u"\1\u0259"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\1\uffff\1\u025a\15\uffff\1\u013c\20\uffff"
        u"\1\u00dd\2\uffff\1\u0126"),
        DFA.unpack(u"\1\u0126"),
        DFA.unpack(u"\1\u0126"),
        DFA.unpack(u"\1\u025b\6\uffff\1\u025b\171\uffff\1\u025c"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u025d\6\uffff\1\u025d\171\uffff\1\u025e"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u025f\6\uffff\1\u025f\171\uffff\1\u0260"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u0261\6\uffff\1\u0261\171\uffff\1\u0262"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u0263\40\uffff\1\u0264"),
        DFA.unpack(u"\1\u0265"),
        DFA.unpack(u"\1\u0266"),
        DFA.unpack(u"\1\u0267"),
        DFA.unpack(u"\1\u0268"),
        DFA.unpack(u"\1\u0269"),
        DFA.unpack(u"\1\u026a"),
        DFA.unpack(u"\1\u01f8\3\uffff\1\u00dc\1\uffff\1\u026b\15\uffff\1"
        u"\u020d\17\uffff\1\u01f9\1\u00dd\2\uffff\1\u01f7"),
        DFA.unpack(u"\1\u01f8\5\uffff\1\u026c\35\uffff\1\u01f9\3\uffff\1"
        u"\u01f7"),
        DFA.unpack(u"\1\u01f9"),
        DFA.unpack(u"\1\u01f9"),
        DFA.unpack(u"\1\u026d"),
        DFA.unpack(u"\1\u026e\25\uffff\1\u0270\25\uffff\1\u026f"),
        DFA.unpack(u"\1\u0271\6\uffff\1\u0271\171\uffff\1\u0272"),
        DFA.unpack(u"\1\u0273\25\uffff\1\u0275\25\uffff\1\u0274"),
        DFA.unpack(u"\1\u0276\6\uffff\1\u0276\171\uffff\1\u0277"),
        DFA.unpack(u"\1\u0278\25\uffff\1\u027a\25\uffff\1\u0279"),
        DFA.unpack(u"\1\u027b\6\uffff\1\u027b\171\uffff\1\u027c"),
        DFA.unpack(u"\1\u027d"),
        DFA.unpack(u"\1\u027e"),
        DFA.unpack(u"\1\u027f"),
        DFA.unpack(u"\1\u0280"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u0246\20\uffff\1\u00dd"),
        DFA.unpack(u"\1\u0281"),
        DFA.unpack(u"\1\u0282\6\uffff\1\u0282\171\uffff\1\u0283"),
        DFA.unpack(u"\1\u01f8\5\uffff\1\u026c\35\uffff\1\u01f9\3\uffff\1"
        u"\u01f7"),
        DFA.unpack(u"\1\u0284"),
        DFA.unpack(u"\1\u0285"),
        DFA.unpack(u"\1\u0145"),
        DFA.unpack(u"\1\u0145"),
        DFA.unpack(u"\1\u0147"),
        DFA.unpack(u"\1\u0147"),
        DFA.unpack(u"\1\u0149"),
        DFA.unpack(u"\1\u0149"),
        DFA.unpack(u"\1\u014c"),
        DFA.unpack(u"\1\u014c"),
        DFA.unpack(u"\1\u0099\26\uffff\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0216\10\uffff\1\u0099\4\uffff\1\u00b1\21\uffff"
        u"\1\u0094\110\uffff\1\u0093"),
        DFA.unpack(u"\1\u0286\6\uffff\1\u0286\171\uffff\1\u0287"),
        DFA.unpack(u"\1\u0288\6\uffff\1\u0288\171\uffff\1\u0289"),
        DFA.unpack(u"\1\u028a\6\uffff\1\u028a\171\uffff\1\u028b"),
        DFA.unpack(u"\1\u028c\6\uffff\1\u028c\171\uffff\1\u028d"),
        DFA.unpack(u"\1\u028e"),
        DFA.unpack(u"\1\u028f\6\uffff\1\u028f"),
        DFA.unpack(u"\1\u0227\3\uffff\1\u0290"),
        DFA.unpack(u"\1\u0227\3\uffff\1\u0290"),
        DFA.unpack(u"\1\u0229\3\uffff\1\u0291"),
        DFA.unpack(u"\1\u0229\3\uffff\1\u0291"),
        DFA.unpack(u"\1\u022b\3\uffff\1\u0292"),
        DFA.unpack(u"\1\u022b\3\uffff\1\u0292"),
        DFA.unpack(u"\1\u022e\3\uffff\1\u0293"),
        DFA.unpack(u"\1\u022e\3\uffff\1\u0293"),
        DFA.unpack(u"\1\u0294"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u0295"),
        DFA.unpack(u"\1\u00dc\17\uffff\1\u0296\20\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd\172\uffff\1\u01f5"),
        DFA.unpack(u"\1\u00dc\12\uffff\1\u0297\25\uffff\1\u00dd"),
        DFA.unpack(u"\1\u0298\6\uffff\1\u0298\171\uffff\1\u0299"),
        DFA.unpack(u"\1\u029a\6\uffff\1\u029a\171\uffff\1\u0299"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u0270"),
        DFA.unpack(u"\1\u0270"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd\26\uffff\1\u01fe"),
        DFA.unpack(u"\1\u029c\1\uffff\1\u00dc\1\uffff\1\u029b\36\uffff\1"
        u"\u00dd"),
        DFA.unpack(u"\1\u029c\3\uffff\1\u029b"),
        DFA.unpack(u"\1\u0275"),
        DFA.unpack(u"\1\u0275"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd\26\uffff\1\u0200"),
        DFA.unpack(u"\1\u029e\1\uffff\1\u00dc\1\uffff\1\u029d\36\uffff\1"
        u"\u00dd"),
        DFA.unpack(u"\1\u029e\3\uffff\1\u029d"),
        DFA.unpack(u"\1\u027a"),
        DFA.unpack(u"\1\u027a"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd\26\uffff\1\u0202"),
        DFA.unpack(u"\1\u02a0\1\uffff\1\u00dc\1\uffff\1\u029f\36\uffff\1"
        u"\u00dd"),
        DFA.unpack(u"\1\u02a0\3\uffff\1\u029f"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u02a1"),
        DFA.unpack(u"\1\u02a3\1\uffff\1\u00dc\1\uffff\1\u02a2\36\uffff\1"
        u"\u00dd"),
        DFA.unpack(u"\1\u02a3\3\uffff\1\u02a2"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u01c3"),
        DFA.unpack(u"\1\u01c3"),
        DFA.unpack(u"\1\u01c5"),
        DFA.unpack(u"\1\u01c5"),
        DFA.unpack(u"\1\u01c7"),
        DFA.unpack(u"\1\u01c7"),
        DFA.unpack(u"\1\u01ca"),
        DFA.unpack(u"\1\u01ca"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\1\uffff\1\u025a\15\uffff\1\u013c\20\uffff"
        u"\1\u00dd"),
        DFA.unpack(u"\1\u02a4\6\uffff\1\u02a4\171\uffff\1\u02a5"),
        DFA.unpack(u"\1\u02a6\6\uffff\1\u02a6\171\uffff\1\u02a7"),
        DFA.unpack(u"\1\u02a8\6\uffff\1\u02a8\171\uffff\1\u02a9"),
        DFA.unpack(u"\1\u02aa\6\uffff\1\u02aa\171\uffff\1\u02ab"),
        DFA.unpack(u"\1\u0264"),
        DFA.unpack(u"\1\u0233"),
        DFA.unpack(u"\1\u02ac"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\1\uffff\1\u02ad\15\uffff\1\u020d\20\uffff"
        u"\1\u00dd\2\uffff\1\u01f7"),
        DFA.unpack(u"\1\u01f7"),
        DFA.unpack(u"\1\u01f7"),
        DFA.unpack(u"\1\u02ae\6\uffff\1\u02ae\171\uffff\1\u02af"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u02b0\6\uffff\1\u02b0\171\uffff\1\u02b1"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u02b2\6\uffff\1\u02b2\171\uffff\1\u02b3"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u02b4\6\uffff\1\u02b4\171\uffff\1\u02b5"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u0227"),
        DFA.unpack(u"\1\u0227"),
        DFA.unpack(u"\1\u0229"),
        DFA.unpack(u"\1\u0229"),
        DFA.unpack(u"\1\u022b"),
        DFA.unpack(u"\1\u022b"),
        DFA.unpack(u"\1\u022e"),
        DFA.unpack(u"\1\u022e"),
        DFA.unpack(u"\1\u02b6"),
        DFA.unpack(u"\1\u02b7\6\uffff\1\u02b7"),
        DFA.unpack(u"\1\u029c\3\uffff\1\u02b8"),
        DFA.unpack(u"\1\u029c\3\uffff\1\u02b8"),
        DFA.unpack(u"\1\u029e\3\uffff\1\u02b9"),
        DFA.unpack(u"\1\u029e\3\uffff\1\u02b9"),
        DFA.unpack(u"\1\u02a0\3\uffff\1\u02ba"),
        DFA.unpack(u"\1\u02a0\3\uffff\1\u02ba"),
        DFA.unpack(u"\1\u02a3\3\uffff\1\u02bb"),
        DFA.unpack(u"\1\u02a3\3\uffff\1\u02bb"),
        DFA.unpack(u"\1\u00dc\40\uffff\1\u00dd"),
        DFA.unpack(u"\1\u00dc\1\uffff\1\u02ad\15\uffff\1\u020d\20\uffff"
        u"\1\u00dd"),
        DFA.unpack(u"\1\u02bc\6\uffff\1\u02bc\171\uffff\1\u02bd"),
        DFA.unpack(u"\1\u02be\6\uffff\1\u02be\171\uffff\1\u02bf"),
        DFA.unpack(u"\1\u02c0\6\uffff\1\u02c0\171\uffff\1\u02c1"),
        DFA.unpack(u"\1\u02c2\6\uffff\1\u02c2\171\uffff\1\u02c3"),
        DFA.unpack(u"\1\u029c"),
        DFA.unpack(u"\1\u029c"),
        DFA.unpack(u"\1\u029e"),
        DFA.unpack(u"\1\u029e"),
        DFA.unpack(u"\1\u02a0"),
        DFA.unpack(u"\1\u02a0"),
        DFA.unpack(u"\1\u02a3"),
        DFA.unpack(u"\1\u02a3")
    ]

    # class definition for DFA #10

    class DFA10(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0:
                LA10_148 = input.LA(1)


                index10_148 = input.index()
                input.rewind()

                s = -1
                if (((((((self.input).LT(1).text.upper() == "TYPE")) and (((this.input).LT(1).text.upper() == "TYPE")))) and (self.synpred13_PLSQL3()))):
                    s = 110

                elif (((((self.synpred14_PLSQL3()) and (self.synpred14_PLSQL3()))) and (((self.input).LT(1).text.upper() == "SUBTYPE")))):
                    s = 153


                input.seek(index10_148)

                if s >= 0:
                    return s

            if self._state.backtracking > 0:
                raise BacktrackingFailed

            nvae = NoViableAltException(self_.getDescription(), 10, _s, input)
            self_.error(nvae)
            raise nvae

    # lookup tables for DFA #19

    DFA19_eot = DFA.unpack(
        u"\u00c3\uffff"
        )

    DFA19_eof = DFA.unpack(
        u"\u00c3\uffff"
        )

    DFA19_min = DFA.unpack(
        u"\1\17\2\15\1\136\4\uffff\20\5\1\26\7\5\1\102\11\5\1\uffff\1\26"
        u"\1\uffff\1\42\1\5\2\42\1\33\1\17\1\26\1\17\1\5\1\17\1\5\1\17\1"
        u"\42\2\5\1\42\1\u0094\1\42\1\u0094\1\42\1\u0094\1\5\1\42\1\5\3\42"
        u"\1\5\1\u0094\1\17\1\42\1\17\1\136\1\13\2\54\1\42\1\26\1\54\1\uffff"
        u"\1\26\1\5\1\7\2\53\1\uffff\1\7\1\uffff\1\54\1\26\1\17\1\26\1\17"
        u"\1\26\1\17\4\54\1\5\1\42\1\17\1\7\2\54\1\42\3\5\1\54\3\5\1\17\1"
        u"\42\2\17\1\33\1\42\1\5\2\54\2\5\1\11\2\54\2\5\1\11\2\54\2\5\1\11"
        u"\4\5\1\54\1\5\1\11\2\5\1\54\1\u009b\1\42\2\5\2\57\1\42\1\54\1\17"
        u"\1\5\1\17\1\5\1\17\2\5\1\17\1\5\1\54\1\17\1\54\1\26\10\11\2\5\1"
        u"\175\1\uffff\4\17\10\11"
        )

    DFA19_max = DFA.unpack(
        u"\1\u0087\2\u00a3\1\u0087\4\uffff\6\166\1\u0089\3\166\1\u00a7\5"
        u"\166\1\26\7\166\1\103\11\166\1\uffff\1\26\1\uffff\1\42\1\166\2"
        u"\42\1\u009b\1\42\1\26\1\u0090\1\166\1\u0090\1\166\1\u00a3\1\42"
        u"\2\166\1\42\1\u0094\1\42\1\u0094\1\42\1\u0094\1\166\1\42\1\166"
        u"\3\42\1\166\1\u0094\1\u0090\2\42\1\u0087\3\54\1\42\1\26\1\54\1"
        u"\uffff\1\26\1\166\1\57\2\53\1\uffff\1\u00a7\1\uffff\1\54\1\102"
        u"\1\u0090\1\102\1\u0090\1\102\1\u0090\4\54\1\166\1\42\1\u0090\1"
        u"\57\2\54\1\42\3\166\1\54\1\166\1\u00a7\1\166\1\u0090\1\42\1\u00a3"
        u"\1\u0090\1\u009b\1\42\1\166\2\54\2\166\1\15\2\54\2\166\1\15\2\54"
        u"\2\166\1\15\4\166\1\54\1\166\1\15\2\166\1\54\1\u009b\1\42\2\166"
        u"\2\57\1\42\1\54\1\u0090\1\166\1\u0090\1\166\1\u0090\2\166\1\u0090"
        u"\1\166\1\54\1\26\1\54\1\u00a7\10\15\2\166\1\u009b\1\uffff\4\u0090"
        u"\10\11"
        )

    DFA19_accept = DFA.unpack(
        u"\4\uffff\1\10\1\11\1\12\1\1\42\uffff\1\4\1\uffff\1\2\47\uffff\1"
        u"\3\5\uffff\1\6\1\uffff\1\5\131\uffff\1\7\14\uffff"
        )

    DFA19_special = DFA.unpack(
        u"\u00c3\uffff"
        )


    DFA19_transition = [
        DFA.unpack(u"\1\2\6\uffff\1\1\62\uffff\1\3\24\uffff\1\5\46\uffff"
        u"\1\6\1\uffff\1\4"),
        DFA.unpack(u"\1\52\1\uffff\1\51\6\uffff\1\22\43\uffff\1\46\1\12"
        u"\1\11\1\10\1\43\1\20\2\uffff\1\31\1\34\1\44\3\uffff\1\7\1\uffff"
        u"\1\21\2\15\5\uffff\1\30\3\uffff\1\52\4\uffff\1\26\12\uffff\1\24"
        u"\1\23\5\uffff\1\16\2\uffff\1\41\1\uffff\1\40\1\13\1\35\1\45\3\uffff"
        u"\2\15\1\36\1\37\6\uffff\1\42\1\14\4\uffff\1\17\1\27\5\uffff\1\47"
        u"\5\uffff\1\25\11\uffff\1\50\1\uffff\1\32\1\33"),
        DFA.unpack(u"\1\52\1\uffff\1\7\6\uffff\1\7\43\uffff\6\7\2\uffff"
        u"\3\7\3\uffff\1\7\1\uffff\3\7\5\uffff\1\7\3\uffff\1\52\4\uffff\1"
        u"\7\12\uffff\2\7\5\uffff\1\7\2\uffff\1\7\1\uffff\4\7\3\uffff\4\7"
        u"\6\uffff\2\7\4\uffff\2\7\5\uffff\1\7\5\uffff\1\7\11\uffff\1\7\1"
        u"\uffff\2\7"),
        DFA.unpack(u"\1\5\40\uffff\1\53\7\uffff\1\4"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\25\uffff\1\55\21\uffff\1\7\40\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\25\uffff\1\57\21\uffff\1\7\40\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7\22\uffff\1\56"),
        DFA.unpack(u"\1\7\25\uffff\1\60\21\uffff\1\7\40\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\1\uffff\1\66\5\uffff\1\64\10\uffff\1\61\4\uffff"
        u"\1\62\17\uffff\1\67\1\uffff\1\7\1\uffff\1\65\36\uffff\1\7\33\uffff"
        u"\1\70\13\uffff\1\7\60\uffff\1\63"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\25\uffff\1\71\21\uffff\1\7\40\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\72"),
        DFA.unpack(u"\1\7\20\uffff\1\73\4\uffff\1\74\21\uffff\1\7\25\uffff"
        u"\1\75\12\uffff\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\25\uffff\1\76\21\uffff\1\7\25\uffff\1\77\12\uffff"
        u"\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\25\uffff\1\100\21\uffff\1\7\25\uffff\1\101\12"
        u"\uffff\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\20\uffff\1\102\4\uffff\1\103\21\uffff\1\7\40\uffff"
        u"\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\20\uffff\1\104\4\uffff\1\105\21\uffff\1\7\40\uffff"
        u"\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\25\uffff\1\106\21\uffff\1\7\40\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\25\uffff\1\107\21\uffff\1\7\40\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\2\110"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\25\uffff\1\111\12\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\1\uffff\1\66\5\uffff\1\112\35\uffff\1\67\1\uffff"
        u"\1\7\1\uffff\1\65\36\uffff\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\25\uffff\1\113\21\uffff\1\7\40\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\1\uffff\1\66\5\uffff\1\64\15\uffff\1\114\17\uffff"
        u"\1\67\1\uffff\1\7\1\uffff\1\65\36\uffff\1\7\33\uffff\1\70\13\uffff"
        u"\1\7"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\115"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\116"),
        DFA.unpack(u"\1\7\25\uffff\1\57\21\uffff\1\7\40\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\117"),
        DFA.unpack(u"\1\120"),
        DFA.unpack(u"\1\121\177\uffff\1\122"),
        DFA.unpack(u"\1\124\6\uffff\1\124\13\uffff\1\123"),
        DFA.unpack(u"\1\125"),
        DFA.unpack(u"\1\126\6\uffff\1\126\171\uffff\1\127"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\130\6\uffff\1\130\171\uffff\1\131"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\54\6\uffff\1\133\43\uffff\6\54\2\uffff\3\54\5\uffff"
        u"\3\54\5\uffff\1\54\10\uffff\1\54\12\uffff\2\54\5\uffff\1\54\2\uffff"
        u"\1\54\1\uffff\4\54\3\uffff\4\54\6\uffff\2\54\4\uffff\2\54\1\134"
        u"\4\uffff\1\54\2\uffff\1\124\2\uffff\1\54\2\uffff\1\132\6\uffff"
        u"\1\54\1\uffff\2\54"),
        DFA.unpack(u"\1\135"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\25\uffff\1\74\21\uffff\1\7\25\uffff\1\75\12\uffff"
        u"\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\136"),
        DFA.unpack(u"\1\137"),
        DFA.unpack(u"\1\140"),
        DFA.unpack(u"\1\141"),
        DFA.unpack(u"\1\142"),
        DFA.unpack(u"\1\143"),
        DFA.unpack(u"\1\7\25\uffff\1\103\21\uffff\1\7\40\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\144"),
        DFA.unpack(u"\1\7\25\uffff\1\105\21\uffff\1\7\40\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\145"),
        DFA.unpack(u"\1\146"),
        DFA.unpack(u"\1\147"),
        DFA.unpack(u"\1\7\20\uffff\1\150\4\uffff\1\151\21\uffff\1\7\40\uffff"
        u"\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\152"),
        DFA.unpack(u"\1\153\6\uffff\1\153\171\uffff\1\127"),
        DFA.unpack(u"\1\154"),
        DFA.unpack(u"\1\124\6\uffff\1\124\13\uffff\1\155"),
        DFA.unpack(u"\1\5\50\uffff\1\4"),
        DFA.unpack(u"\1\156\40\uffff\1\157"),
        DFA.unpack(u"\1\160"),
        DFA.unpack(u"\1\161"),
        DFA.unpack(u"\1\162"),
        DFA.unpack(u"\1\163"),
        DFA.unpack(u"\1\164"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\165"),
        DFA.unpack(u"\1\7\1\uffff\1\66\5\uffff\1\166\15\uffff\1\167\17\uffff"
        u"\1\67\1\uffff\1\7\1\uffff\1\65\36\uffff\1\7\33\uffff\1\170\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\66\5\uffff\1\171\35\uffff\1\67\3\uffff\1\65"),
        DFA.unpack(u"\1\67"),
        DFA.unpack(u"\1\67"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\54\5\uffff\1\54\10\uffff\1\172\4\uffff\1\173\17"
        u"\uffff\1\54\1\uffff\1\54\1\uffff\1\54\106\uffff\1\54\60\uffff\1"
        u"\54"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\174"),
        DFA.unpack(u"\1\175\25\uffff\1\177\25\uffff\1\176"),
        DFA.unpack(u"\1\u0080\6\uffff\1\u0080\171\uffff\1\u0081"),
        DFA.unpack(u"\1\u0082\25\uffff\1\u0084\25\uffff\1\u0083"),
        DFA.unpack(u"\1\u0085\6\uffff\1\u0085\171\uffff\1\u0086"),
        DFA.unpack(u"\1\u0087\25\uffff\1\u0089\25\uffff\1\u0088"),
        DFA.unpack(u"\1\u008a\6\uffff\1\u008a\171\uffff\1\u008b"),
        DFA.unpack(u"\1\u008c"),
        DFA.unpack(u"\1\u008d"),
        DFA.unpack(u"\1\u008e"),
        DFA.unpack(u"\1\u008f"),
        DFA.unpack(u"\1\7\25\uffff\1\151\21\uffff\1\7\40\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\u0090"),
        DFA.unpack(u"\1\u0091\6\uffff\1\u0091\171\uffff\1\u0092"),
        DFA.unpack(u"\1\66\5\uffff\1\171\35\uffff\1\67\3\uffff\1\65"),
        DFA.unpack(u"\1\u0093"),
        DFA.unpack(u"\1\u0094"),
        DFA.unpack(u"\1\u0095"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\u0096"),
        DFA.unpack(u"\1\7\25\uffff\1\u0097\21\uffff\1\7\40\uffff\1\7\33"
        u"\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7\60\uffff\1\63"),
        DFA.unpack(u"\1\7\20\uffff\1\u0098\26\uffff\1\7\40\uffff\1\7\33"
        u"\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\u0099\6\uffff\1\u0099\171\uffff\1\u009a"),
        DFA.unpack(u"\1\155"),
        DFA.unpack(u"\1\54\6\uffff\1\133\43\uffff\6\54\2\uffff\3\54\5\uffff"
        u"\3\54\5\uffff\1\54\10\uffff\1\54\12\uffff\2\54\5\uffff\1\54\2\uffff"
        u"\1\54\1\uffff\4\54\3\uffff\4\54\6\uffff\2\54\4\uffff\2\54\1\134"
        u"\4\uffff\1\54\5\uffff\1\54\2\uffff\1\132\6\uffff\1\54\1\uffff\2"
        u"\54"),
        DFA.unpack(u"\1\u009b\6\uffff\1\u009b\171\uffff\1\u009a"),
        DFA.unpack(u"\1\u009c\1\uffff\1\54\4\uffff\1\54\1\uffff\1\54\2\uffff"
        u"\1\54\163\uffff\1\54"),
        DFA.unpack(u"\1\u009d"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\177"),
        DFA.unpack(u"\1\177"),
        DFA.unpack(u"\1\7\47\uffff\1\7\25\uffff\1\75\12\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\3\uffff\1\u009f\3\uffff\1\u009e\37\uffff\1\7\40"
        u"\uffff\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\u009f\3\uffff\1\u009e"),
        DFA.unpack(u"\1\u0084"),
        DFA.unpack(u"\1\u0084"),
        DFA.unpack(u"\1\7\47\uffff\1\7\25\uffff\1\77\12\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\3\uffff\1\u00a1\3\uffff\1\u00a0\37\uffff\1\7\40"
        u"\uffff\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\u00a1\3\uffff\1\u00a0"),
        DFA.unpack(u"\1\u0089"),
        DFA.unpack(u"\1\u0089"),
        DFA.unpack(u"\1\7\47\uffff\1\7\25\uffff\1\101\12\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\3\uffff\1\u00a3\3\uffff\1\u00a2\37\uffff\1\7\40"
        u"\uffff\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\u00a3\3\uffff\1\u00a2"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\u00a4"),
        DFA.unpack(u"\1\7\3\uffff\1\u00a6\3\uffff\1\u00a5\37\uffff\1\7\40"
        u"\uffff\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\u00a6\3\uffff\1\u00a5"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\157"),
        DFA.unpack(u"\1\122"),
        DFA.unpack(u"\1\u00a7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\7\uffff\1\u00a8\15\uffff\1\167\21\uffff\1\7\1"
        u"\uffff\1\65\36\uffff\1\7\33\uffff\1\170\13\uffff\1\7"),
        DFA.unpack(u"\1\65"),
        DFA.unpack(u"\1\65"),
        DFA.unpack(u"\1\u00a9"),
        DFA.unpack(u"\1\u00aa"),
        DFA.unpack(u"\1\u00ab\6\uffff\1\u00ab\171\uffff\1\u00ac"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\u00ad\6\uffff\1\u00ad\171\uffff\1\u00ae"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\u00af\6\uffff\1\u00af\171\uffff\1\u00b0"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\u00b1\6\uffff\1\u00b1\171\uffff\1\u00b2"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\u00b3"),
        DFA.unpack(u"\1\u00b4\6\uffff\1\u00b4"),
        DFA.unpack(u"\1\u00b5"),
        DFA.unpack(u"\1\54\26\uffff\1\54\110\uffff\1\54\6\uffff\1\u00b6"
        u"\51\uffff\1\54"),
        DFA.unpack(u"\1\u009f\3\uffff\1\u00b7"),
        DFA.unpack(u"\1\u009f\3\uffff\1\u00b7"),
        DFA.unpack(u"\1\u00a1\3\uffff\1\u00b8"),
        DFA.unpack(u"\1\u00a1\3\uffff\1\u00b8"),
        DFA.unpack(u"\1\u00a3\3\uffff\1\u00b9"),
        DFA.unpack(u"\1\u00a3\3\uffff\1\u00b9"),
        DFA.unpack(u"\1\u00a6\3\uffff\1\u00ba"),
        DFA.unpack(u"\1\u00a6\3\uffff\1\u00ba"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\7\uffff\1\u00a8\15\uffff\1\167\21\uffff\1\7\40"
        u"\uffff\1\7\33\uffff\1\170\13\uffff\1\7"),
        DFA.unpack(u"\1\u00b6\35\uffff\1\54"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\u00bb\6\uffff\1\u00bb\171\uffff\1\u00bc"),
        DFA.unpack(u"\1\u00bd\6\uffff\1\u00bd\171\uffff\1\u00be"),
        DFA.unpack(u"\1\u00bf\6\uffff\1\u00bf\171\uffff\1\u00c0"),
        DFA.unpack(u"\1\u00c1\6\uffff\1\u00c1\171\uffff\1\u00c2"),
        DFA.unpack(u"\1\u009f"),
        DFA.unpack(u"\1\u009f"),
        DFA.unpack(u"\1\u00a1"),
        DFA.unpack(u"\1\u00a1"),
        DFA.unpack(u"\1\u00a3"),
        DFA.unpack(u"\1\u00a3"),
        DFA.unpack(u"\1\u00a6"),
        DFA.unpack(u"\1\u00a6")
    ]

    # class definition for DFA #19

    class DFA19(DFA):
        pass


    # lookup tables for DFA #29

    DFA29_eot = DFA.unpack(
        u"\u0170\uffff"
        )

    DFA29_eof = DFA.unpack(
        u"\u0170\uffff"
        )

    DFA29_min = DFA.unpack(
        u"\1\17\2\15\1\136\4\uffff\20\5\1\26\7\5\1\102\11\5\1\uffff\1\26"
        u"\1\17\1\42\1\5\2\42\1\33\1\17\1\26\1\17\1\5\1\17\1\5\1\17\1\42"
        u"\2\5\1\42\1\u0094\1\42\1\u0094\1\42\1\u0094\1\5\1\42\1\5\3\42\1"
        u"\5\1\u0094\1\17\1\42\1\17\1\136\12\26\1\7\15\26\1\102\6\26\1\7"
        u"\1\26\1\7\1\uffff\1\13\2\54\1\42\1\26\1\54\1\uffff\1\26\1\5\1\7"
        u"\2\53\1\uffff\1\7\1\uffff\1\54\1\26\1\17\1\26\1\17\1\26\1\17\4"
        u"\54\1\5\1\42\1\17\1\7\2\54\1\170\1\uffff\1\0\1\42\1\26\2\42\1\7"
        u"\1\17\1\26\1\17\1\26\1\17\1\26\1\42\2\26\1\42\1\u0094\1\42\1\u0094"
        u"\1\42\1\u0094\1\26\1\42\1\26\3\42\1\26\1\u0094\1\17\3\42\3\5\1"
        u"\54\3\5\1\17\1\42\2\17\1\7\1\17\1\5\2\54\2\5\1\11\2\54\2\5\1\11"
        u"\2\54\2\5\1\11\4\5\1\54\1\5\1\11\2\5\1\55\1\13\2\54\1\42\1\26\1"
        u"\6\1\26\2\7\2\53\1\54\1\26\1\17\1\26\1\17\1\26\1\17\4\54\1\26\1"
        u"\42\1\17\1\7\3\54\1\u009b\1\42\2\5\2\57\1\42\1\6\1\17\1\5\1\17"
        u"\1\5\1\17\2\5\1\17\1\5\1\42\3\26\1\54\3\26\2\17\1\26\2\54\1\26"
        u"\2\11\2\54\1\26\2\11\2\54\1\26\2\11\4\26\1\54\2\11\2\26\1\54\1"
        u"\17\1\54\1\26\10\11\1\54\1\55\1\42\1\26\1\15\2\57\1\17\1\26\1\17"
        u"\1\26\1\17\2\26\1\17\1\26\2\5\1\55\1\uffff\4\17\1\54\1\17\20\11"
        u"\1\26\1\15\4\17\10\11"
        )

    DFA29_max = DFA.unpack(
        u"\1\u0087\2\u00a3\1\u0087\4\uffff\6\166\1\u0089\3\166\1\u00a7\5"
        u"\166\1\26\7\166\1\103\11\166\1\uffff\1\26\1\u00a3\1\42\1\166\2"
        u"\42\1\u009b\1\42\1\26\1\u0090\1\166\1\u0090\1\166\1\u00a3\1\42"
        u"\2\166\1\42\1\u0094\1\42\1\u0094\1\42\1\u0094\1\166\1\42\1\166"
        u"\3\42\1\166\1\u0094\1\u0090\2\42\1\u0087\6\166\1\u0089\3\166\1"
        u"\u00a7\5\166\1\26\7\166\1\103\11\166\1\uffff\3\54\1\42\1\26\1\54"
        u"\1\uffff\1\26\1\166\1\57\2\53\1\uffff\1\u00a7\1\uffff\1\54\1\102"
        u"\1\u0090\1\102\1\u0090\1\102\1\u0090\4\54\1\166\1\42\1\u0090\1"
        u"\57\2\54\1\170\1\uffff\1\0\1\42\1\166\2\42\1\u00a7\1\u009c\1\26"
        u"\1\u0090\1\166\1\u0090\1\166\1\42\2\166\1\42\1\u0094\1\42\1\u0094"
        u"\1\42\1\u0094\1\166\1\42\1\166\3\42\1\166\1\u0094\1\u0090\3\42"
        u"\3\166\1\54\1\166\1\u00a7\1\166\1\u0090\1\42\1\u00a3\1\u0090\1"
        u"\u00a7\1\u009c\1\166\2\54\2\166\1\15\2\54\2\166\1\15\2\54\2\166"
        u"\1\15\4\166\1\54\1\166\1\15\2\166\1\55\3\54\1\42\1\26\1\177\1\26"
        u"\1\166\1\57\2\53\1\54\1\102\1\u0090\1\102\1\u0090\1\102\1\u0090"
        u"\4\54\1\166\1\42\1\u0090\1\57\3\54\1\u009b\1\42\2\166\2\57\1\42"
        u"\1\177\1\u0090\1\166\1\u0090\1\166\1\u0090\2\166\1\u0090\1\166"
        u"\1\42\3\166\1\54\1\166\1\u00a7\1\166\2\u0090\1\166\2\54\2\166\1"
        u"\15\2\54\2\166\1\15\2\54\2\166\1\15\4\166\1\54\1\166\1\15\2\166"
        u"\1\54\1\26\1\54\1\u00a7\10\15\1\54\1\u00a7\1\42\2\166\2\57\1\u0090"
        u"\1\166\1\u0090\1\166\1\u0090\2\166\1\u0090\3\166\1\u00a7\1\uffff"
        u"\4\u0090\1\54\1\26\10\15\10\11\2\166\4\u0090\10\11"
        )

    DFA29_accept = DFA.unpack(
        u"\4\uffff\1\10\1\11\1\13\1\1\42\uffff\1\4\105\uffff\1\12\6\uffff"
        u"\1\3\5\uffff\1\6\1\uffff\1\5\22\uffff\1\2\u00b8\uffff\1\7\44\uffff"
        )

    DFA29_special = DFA.unpack(
        u"\u0093\uffff\1\0\u00dc\uffff"
        )


    DFA29_transition = [
        DFA.unpack(u"\1\2\6\uffff\1\1\62\uffff\1\3\24\uffff\1\5\46\uffff"
        u"\1\6\1\uffff\1\4"),
        DFA.unpack(u"\1\52\1\uffff\1\51\6\uffff\1\22\43\uffff\1\46\1\12"
        u"\1\11\1\10\1\43\1\20\2\uffff\1\31\1\34\1\44\3\uffff\1\7\1\uffff"
        u"\1\21\2\15\5\uffff\1\30\3\uffff\1\52\4\uffff\1\26\12\uffff\1\24"
        u"\1\23\5\uffff\1\16\2\uffff\1\41\1\uffff\1\40\1\13\1\35\1\45\3\uffff"
        u"\2\15\1\36\1\37\6\uffff\1\42\1\14\4\uffff\1\17\1\27\5\uffff\1\47"
        u"\5\uffff\1\25\11\uffff\1\50\1\uffff\1\32\1\33"),
        DFA.unpack(u"\1\52\1\uffff\1\7\6\uffff\1\7\43\uffff\6\7\2\uffff"
        u"\3\7\3\uffff\1\7\1\uffff\3\7\5\uffff\1\7\3\uffff\1\52\4\uffff\1"
        u"\7\12\uffff\2\7\5\uffff\1\7\2\uffff\1\7\1\uffff\4\7\3\uffff\4\7"
        u"\6\uffff\2\7\4\uffff\2\7\5\uffff\1\7\5\uffff\1\7\11\uffff\1\7\1"
        u"\uffff\2\7"),
        DFA.unpack(u"\1\5\40\uffff\1\53\7\uffff\1\4"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\25\uffff\1\55\21\uffff\1\7\40\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\25\uffff\1\57\21\uffff\1\7\40\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7\22\uffff\1\56"),
        DFA.unpack(u"\1\7\25\uffff\1\60\21\uffff\1\7\40\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\1\uffff\1\66\5\uffff\1\64\10\uffff\1\61\4\uffff"
        u"\1\62\17\uffff\1\67\1\uffff\1\7\1\uffff\1\65\36\uffff\1\7\33\uffff"
        u"\1\70\13\uffff\1\7\60\uffff\1\63"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\25\uffff\1\71\21\uffff\1\7\40\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\72"),
        DFA.unpack(u"\1\7\20\uffff\1\73\4\uffff\1\74\21\uffff\1\7\25\uffff"
        u"\1\75\12\uffff\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\25\uffff\1\76\21\uffff\1\7\25\uffff\1\77\12\uffff"
        u"\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\25\uffff\1\100\21\uffff\1\7\25\uffff\1\101\12"
        u"\uffff\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\20\uffff\1\102\4\uffff\1\103\21\uffff\1\7\40\uffff"
        u"\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\20\uffff\1\104\4\uffff\1\105\21\uffff\1\7\40\uffff"
        u"\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\25\uffff\1\106\21\uffff\1\7\40\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\25\uffff\1\107\21\uffff\1\7\40\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\2\110"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\25\uffff\1\111\12\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\1\uffff\1\66\5\uffff\1\112\35\uffff\1\67\1\uffff"
        u"\1\7\1\uffff\1\65\36\uffff\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\25\uffff\1\113\21\uffff\1\7\40\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\1\uffff\1\66\5\uffff\1\64\15\uffff\1\114\17\uffff"
        u"\1\67\1\uffff\1\7\1\uffff\1\65\36\uffff\1\7\33\uffff\1\70\13\uffff"
        u"\1\7"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\115"),
        DFA.unpack(u"\1\157\6\uffff\1\130\4\uffff\1\160\36\uffff\1\154\1"
        u"\120\1\117\1\116\1\151\1\126\2\uffff\1\137\1\142\1\152\5\uffff"
        u"\1\127\2\123\5\uffff\1\136\10\uffff\1\134\12\uffff\1\132\1\131"
        u"\5\uffff\1\124\2\uffff\1\147\1\uffff\1\146\1\121\1\143\1\153\3"
        u"\uffff\2\123\1\144\1\145\6\uffff\1\150\1\122\4\uffff\1\125\1\135"
        u"\5\uffff\1\155\5\uffff\1\133\11\uffff\1\156\1\uffff\1\140\1\141"),
        DFA.unpack(u"\1\161"),
        DFA.unpack(u"\1\7\25\uffff\1\57\21\uffff\1\7\40\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\162"),
        DFA.unpack(u"\1\163"),
        DFA.unpack(u"\1\164\177\uffff\1\165"),
        DFA.unpack(u"\1\167\6\uffff\1\167\13\uffff\1\166"),
        DFA.unpack(u"\1\170"),
        DFA.unpack(u"\1\171\6\uffff\1\171\171\uffff\1\172"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\173\6\uffff\1\173\171\uffff\1\174"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\157\6\uffff\1\176\4\uffff\1\160\36\uffff\1\154\1"
        u"\120\1\117\1\116\1\151\1\126\2\uffff\1\137\1\142\1\152\5\uffff"
        u"\1\127\2\123\5\uffff\1\136\10\uffff\1\134\12\uffff\1\132\1\131"
        u"\5\uffff\1\124\2\uffff\1\147\1\uffff\1\146\1\121\1\143\1\153\3"
        u"\uffff\2\123\1\144\1\145\6\uffff\1\150\1\122\4\uffff\1\125\1\135"
        u"\1\177\4\uffff\1\155\2\uffff\1\167\2\uffff\1\133\2\uffff\1\175"
        u"\6\uffff\1\156\1\uffff\1\140\1\141"),
        DFA.unpack(u"\1\u0080"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\25\uffff\1\74\21\uffff\1\7\25\uffff\1\75\12\uffff"
        u"\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\u0081"),
        DFA.unpack(u"\1\u0082"),
        DFA.unpack(u"\1\u0083"),
        DFA.unpack(u"\1\u0084"),
        DFA.unpack(u"\1\u0085"),
        DFA.unpack(u"\1\u0086"),
        DFA.unpack(u"\1\7\25\uffff\1\103\21\uffff\1\7\40\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\u0087"),
        DFA.unpack(u"\1\7\25\uffff\1\105\21\uffff\1\7\40\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\u0088"),
        DFA.unpack(u"\1\u0089"),
        DFA.unpack(u"\1\u008a"),
        DFA.unpack(u"\1\7\20\uffff\1\u008b\4\uffff\1\u008c\21\uffff\1\7"
        u"\40\uffff\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\u008d"),
        DFA.unpack(u"\1\u008e\6\uffff\1\u008e\171\uffff\1\172"),
        DFA.unpack(u"\1\u008f"),
        DFA.unpack(u"\1\167\6\uffff\1\167\13\uffff\1\u0090"),
        DFA.unpack(u"\1\5\50\uffff\1\4"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\4\uffff\1\u0094\21\uffff\1\u0093\110\uffff"
        u"\1\u0091"),
        DFA.unpack(u"\1\u0092\4\uffff\1\u0096\21\uffff\1\u0093\110\uffff"
        u"\1\u0091\22\uffff\1\u0095"),
        DFA.unpack(u"\1\u0092\4\uffff\1\u0097\21\uffff\1\u0093\110\uffff"
        u"\1\u0091"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u009d\5\uffff\1\u009b\1\uffff\1\160\6\uffff\1\u0098"
        u"\4\uffff\1\u0099\17\uffff\1\u009e\1\uffff\1\u0093\1\uffff\1\u009c"
        u"\12\uffff\6\160\2\uffff\3\160\5\uffff\3\160\5\uffff\1\160\10\uffff"
        u"\1\160\12\uffff\2\160\5\uffff\1\160\2\uffff\1\160\1\uffff\4\160"
        u"\1\u0091\2\uffff\4\160\6\uffff\2\160\4\uffff\2\160\5\uffff\1\160"
        u"\5\uffff\1\160\11\uffff\1\160\1\uffff\2\160\3\uffff\1\u009a"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\4\uffff\1\u009f\21\uffff\1\u0093\110\uffff"
        u"\1\u0091"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u00a0"),
        DFA.unpack(u"\1\u00a1\4\uffff\1\u00a2\21\uffff\1\u0093\25\uffff"
        u"\1\u00a3\62\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\4\uffff\1\u00a4\21\uffff\1\u0093\25\uffff"
        u"\1\u00a5\62\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\4\uffff\1\u00a6\21\uffff\1\u0093\25\uffff"
        u"\1\u00a7\62\uffff\1\u0091"),
        DFA.unpack(u"\1\u00a8\4\uffff\1\u00a9\21\uffff\1\u0093\110\uffff"
        u"\1\u0091"),
        DFA.unpack(u"\1\u00aa\4\uffff\1\u00ab\21\uffff\1\u0093\110\uffff"
        u"\1\u0091"),
        DFA.unpack(u"\1\u0092\4\uffff\1\u00ac\21\uffff\1\u0093\110\uffff"
        u"\1\u0091"),
        DFA.unpack(u"\1\u0092\4\uffff\1\u00ad\21\uffff\1\u0093\110\uffff"
        u"\1\u0091"),
        DFA.unpack(u"\2\u00ae"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\25\uffff\1\u00af\62\uffff"
        u"\1\u0091"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u009d\5\uffff\1\u00b0\10\uffff\1\u0092\24\uffff"
        u"\1\u009e\1\uffff\1\u0093\1\uffff\1\u009c\106\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\4\uffff\1\u00b1\21\uffff\1\u0093\110\uffff"
        u"\1\u0091"),
        DFA.unpack(u"\1\u009d\5\uffff\1\u009b\10\uffff\1\u0092\4\uffff\1"
        u"\u00b2\17\uffff\1\u009e\1\uffff\1\u0093\1\uffff\1\u009c\106\uffff"
        u"\1\u0091"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\u00b3\40\uffff\1\u00b4"),
        DFA.unpack(u"\1\u00b5"),
        DFA.unpack(u"\1\u00b6"),
        DFA.unpack(u"\1\u00b7"),
        DFA.unpack(u"\1\u00b8"),
        DFA.unpack(u"\1\u00b9"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\u00ba"),
        DFA.unpack(u"\1\7\1\uffff\1\66\5\uffff\1\u00bb\15\uffff\1\u00bc"
        u"\17\uffff\1\67\1\uffff\1\7\1\uffff\1\65\36\uffff\1\7\33\uffff\1"
        u"\u00bd\13\uffff\1\7"),
        DFA.unpack(u"\1\66\5\uffff\1\u00be\35\uffff\1\67\3\uffff\1\65"),
        DFA.unpack(u"\1\67"),
        DFA.unpack(u"\1\67"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\u009d\5\uffff\1\u009b\1\uffff\1\160\6\uffff\1\u00bf"
        u"\4\uffff\1\u00c0\17\uffff\1\u009e\1\uffff\1\u0093\1\uffff\1\u009c"
        u"\12\uffff\6\160\2\uffff\3\160\5\uffff\3\160\5\uffff\1\160\10\uffff"
        u"\1\160\12\uffff\2\160\5\uffff\1\160\2\uffff\1\160\1\uffff\4\160"
        u"\1\u0091\2\uffff\4\160\6\uffff\2\160\4\uffff\2\160\5\uffff\1\160"
        u"\5\uffff\1\160\11\uffff\1\160\1\uffff\2\160\3\uffff\1\u009a"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\u00c1"),
        DFA.unpack(u"\1\u00c2\25\uffff\1\u00c4\25\uffff\1\u00c3"),
        DFA.unpack(u"\1\u00c5\6\uffff\1\u00c5\171\uffff\1\u00c6"),
        DFA.unpack(u"\1\u00c7\25\uffff\1\u00c9\25\uffff\1\u00c8"),
        DFA.unpack(u"\1\u00ca\6\uffff\1\u00ca\171\uffff\1\u00cb"),
        DFA.unpack(u"\1\u00cc\25\uffff\1\u00ce\25\uffff\1\u00cd"),
        DFA.unpack(u"\1\u00cf\6\uffff\1\u00cf\171\uffff\1\u00d0"),
        DFA.unpack(u"\1\u00d1"),
        DFA.unpack(u"\1\u00d2"),
        DFA.unpack(u"\1\u00d3"),
        DFA.unpack(u"\1\u00d4"),
        DFA.unpack(u"\1\7\25\uffff\1\u008c\21\uffff\1\7\40\uffff\1\7\33"
        u"\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\u00d5"),
        DFA.unpack(u"\1\u00d6\6\uffff\1\u00d6\171\uffff\1\u00d7"),
        DFA.unpack(u"\1\66\5\uffff\1\u00be\35\uffff\1\67\3\uffff\1\65"),
        DFA.unpack(u"\1\u00d8"),
        DFA.unpack(u"\1\u00d9"),
        DFA.unpack(u"\1\u00da"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\u00db"),
        DFA.unpack(u"\1\u0092\4\uffff\1\u0096\21\uffff\1\u0093\110\uffff"
        u"\1\u0091"),
        DFA.unpack(u"\1\u00dc"),
        DFA.unpack(u"\1\u00dd"),
        DFA.unpack(u"\1\160\5\uffff\1\160\10\uffff\1\160\4\uffff\1\u00de"
        u"\1\uffff\1\u0092\4\uffff\1\u0092\1\uffff\1\u0092\2\uffff\1\u0092"
        u"\3\uffff\1\160\1\uffff\1\160\1\uffff\1\160\106\uffff\1\160\44\uffff"
        u"\1\u00df\13\uffff\1\160"),
        DFA.unpack(u"\1\160\6\uffff\1\160\4\uffff\1\160\1\uffff\1\160\4"
        u"\uffff\1\u00e0\1\uffff\1\160\2\uffff\1\160\31\uffff\1\160\17\uffff"
        u"\1\160\7\uffff\1\160\34\uffff\1\160\1\uffff\1\160\27\uffff\1\160"
        u"\2\uffff\1\160\3\uffff\1\160\4\uffff\1\160"),
        DFA.unpack(u"\1\u00e1"),
        DFA.unpack(u"\1\u00e2\6\uffff\1\u00e2\171\uffff\1\u00e3"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u00e4\6\uffff\1\u00e4\171\uffff\1\u00e5"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u00e6"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\4\uffff\1\u00a2\1\uffff\1\u0092\4\uffff\1"
        u"\u0092\1\uffff\1\u0092\2\uffff\1\u0092\5\uffff\1\u0093\25\uffff"
        u"\1\u00a3\62\uffff\1\u0091"),
        DFA.unpack(u"\1\u00e7"),
        DFA.unpack(u"\1\u00e8"),
        DFA.unpack(u"\1\u00e9"),
        DFA.unpack(u"\1\u00ea"),
        DFA.unpack(u"\1\u00eb"),
        DFA.unpack(u"\1\u00ec"),
        DFA.unpack(u"\1\u0092\4\uffff\1\u00a9\1\uffff\1\u0092\4\uffff\1"
        u"\u0092\1\uffff\1\u0092\2\uffff\1\u0092\5\uffff\1\u0093\110\uffff"
        u"\1\u0091"),
        DFA.unpack(u"\1\u00ed"),
        DFA.unpack(u"\1\u0092\4\uffff\1\u00ab\1\uffff\1\u0092\4\uffff\1"
        u"\u0092\1\uffff\1\u0092\2\uffff\1\u0092\5\uffff\1\u0093\110\uffff"
        u"\1\u0091"),
        DFA.unpack(u"\1\u00ee"),
        DFA.unpack(u"\1\u00ef"),
        DFA.unpack(u"\1\u00f0"),
        DFA.unpack(u"\1\u00f1\4\uffff\1\u00f2\21\uffff\1\u0093\110\uffff"
        u"\1\u0091"),
        DFA.unpack(u"\1\u00f3"),
        DFA.unpack(u"\1\u00f4\6\uffff\1\u00f4\171\uffff\1\u00e3"),
        DFA.unpack(u"\1\u00f5"),
        DFA.unpack(u"\1\u00f6"),
        DFA.unpack(u"\1\u00f7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\u00f8"),
        DFA.unpack(u"\1\7\25\uffff\1\u00f9\21\uffff\1\7\40\uffff\1\7\33"
        u"\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7\60\uffff\1\63"),
        DFA.unpack(u"\1\7\20\uffff\1\u00fa\26\uffff\1\7\40\uffff\1\7\33"
        u"\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\u00fb\6\uffff\1\u00fb\171\uffff\1\u00fc"),
        DFA.unpack(u"\1\u0090"),
        DFA.unpack(u"\1\157\6\uffff\1\176\4\uffff\1\160\36\uffff\1\154\1"
        u"\120\1\117\1\116\1\151\1\126\2\uffff\1\137\1\142\1\152\5\uffff"
        u"\1\127\2\123\5\uffff\1\136\10\uffff\1\134\12\uffff\1\132\1\131"
        u"\5\uffff\1\124\2\uffff\1\147\1\uffff\1\146\1\121\1\143\1\153\3"
        u"\uffff\2\123\1\144\1\145\6\uffff\1\150\1\122\4\uffff\1\125\1\135"
        u"\1\177\4\uffff\1\155\5\uffff\1\133\2\uffff\1\175\6\uffff\1\156"
        u"\1\uffff\1\140\1\141"),
        DFA.unpack(u"\1\u00fd\6\uffff\1\u00fd\171\uffff\1\u00fc"),
        DFA.unpack(u"\1\160\5\uffff\1\160\10\uffff\1\160\4\uffff\1\u00fe"
        u"\1\uffff\1\u0092\4\uffff\1\u0092\1\uffff\1\u0092\2\uffff\1\u0092"
        u"\3\uffff\1\160\1\uffff\1\160\1\uffff\1\160\106\uffff\1\160\44\uffff"
        u"\1\u00df\13\uffff\1\160"),
        DFA.unpack(u"\1\160\6\uffff\1\160\4\uffff\1\160\1\uffff\1\160\4"
        u"\uffff\1\u00ff\1\uffff\1\160\2\uffff\1\160\31\uffff\1\160\17\uffff"
        u"\1\160\7\uffff\1\160\34\uffff\1\160\1\uffff\1\160\27\uffff\1\160"
        u"\2\uffff\1\160\3\uffff\1\160\4\uffff\1\160"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\u00c4"),
        DFA.unpack(u"\1\u00c4"),
        DFA.unpack(u"\1\7\47\uffff\1\7\25\uffff\1\75\12\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\3\uffff\1\u0101\3\uffff\1\u0100\37\uffff\1\7\40"
        u"\uffff\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\u0101\3\uffff\1\u0100"),
        DFA.unpack(u"\1\u00c9"),
        DFA.unpack(u"\1\u00c9"),
        DFA.unpack(u"\1\7\47\uffff\1\7\25\uffff\1\77\12\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\3\uffff\1\u0103\3\uffff\1\u0102\37\uffff\1\7\40"
        u"\uffff\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\u0103\3\uffff\1\u0102"),
        DFA.unpack(u"\1\u00ce"),
        DFA.unpack(u"\1\u00ce"),
        DFA.unpack(u"\1\7\47\uffff\1\7\25\uffff\1\101\12\uffff\1\7\33\uffff"
        u"\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\7\3\uffff\1\u0105\3\uffff\1\u0104\37\uffff\1\7\40"
        u"\uffff\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\u0105\3\uffff\1\u0104"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\u0106"),
        DFA.unpack(u"\1\7\3\uffff\1\u0108\3\uffff\1\u0107\37\uffff\1\7\40"
        u"\uffff\1\7\33\uffff\1\54\13\uffff\1\7"),
        DFA.unpack(u"\1\u0108\3\uffff\1\u0107"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\u0093"),
        DFA.unpack(u"\1\u0109\40\uffff\1\u010a"),
        DFA.unpack(u"\1\u010b"),
        DFA.unpack(u"\1\u010c"),
        DFA.unpack(u"\1\u010d"),
        DFA.unpack(u"\1\u010e"),
        DFA.unpack(u"\1\160\1\uffff\1\160\2\uffff\2\160\3\uffff\6\160\1"
        u"\uffff\1\160\1\uffff\1\160\2\uffff\2\160\2\uffff\2\160\2\uffff"
        u"\1\160\5\uffff\1\160\1\uffff\1\u010f\6\uffff\1\160\5\uffff\1\160"
        u"\51\uffff\1\160\6\uffff\2\160\12\uffff\1\160\10\uffff\1\160"),
        DFA.unpack(u"\1\u0110"),
        DFA.unpack(u"\1\u009d\5\uffff\1\u0111\10\uffff\1\u0092\4\uffff\1"
        u"\u00b2\17\uffff\1\u009e\1\uffff\1\u0093\1\uffff\1\u009c\106\uffff"
        u"\1\u0091"),
        DFA.unpack(u"\1\u009d\5\uffff\1\u0112\35\uffff\1\u009e\3\uffff\1"
        u"\u009c"),
        DFA.unpack(u"\1\u009e"),
        DFA.unpack(u"\1\u009e"),
        DFA.unpack(u"\1\u0113"),
        DFA.unpack(u"\1\u0114\25\uffff\1\u0116\25\uffff\1\u0115"),
        DFA.unpack(u"\1\u0117\6\uffff\1\u0117\171\uffff\1\u0118"),
        DFA.unpack(u"\1\u0119\25\uffff\1\u011b\25\uffff\1\u011a"),
        DFA.unpack(u"\1\u011c\6\uffff\1\u011c\171\uffff\1\u011d"),
        DFA.unpack(u"\1\u011e\25\uffff\1\u0120\25\uffff\1\u011f"),
        DFA.unpack(u"\1\u0121\6\uffff\1\u0121\171\uffff\1\u0122"),
        DFA.unpack(u"\1\u0123"),
        DFA.unpack(u"\1\u0124"),
        DFA.unpack(u"\1\u0125"),
        DFA.unpack(u"\1\u0126"),
        DFA.unpack(u"\1\u0092\4\uffff\1\u00f2\1\uffff\1\u0092\4\uffff\1"
        u"\u0092\1\uffff\1\u0092\2\uffff\1\u0092\5\uffff\1\u0093\110\uffff"
        u"\1\u0091"),
        DFA.unpack(u"\1\u0127"),
        DFA.unpack(u"\1\u0128\6\uffff\1\u0128\171\uffff\1\u0129"),
        DFA.unpack(u"\1\u009d\5\uffff\1\u0112\35\uffff\1\u009e\3\uffff\1"
        u"\u009c"),
        DFA.unpack(u"\1\u012a"),
        DFA.unpack(u"\1\u012b"),
        DFA.unpack(u"\1\u00b4"),
        DFA.unpack(u"\1\165"),
        DFA.unpack(u"\1\u012c"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\7\uffff\1\u012d\15\uffff\1\u00bc\21\uffff\1\7"
        u"\1\uffff\1\65\36\uffff\1\7\33\uffff\1\u00bd\13\uffff\1\7"),
        DFA.unpack(u"\1\65"),
        DFA.unpack(u"\1\65"),
        DFA.unpack(u"\1\u012e"),
        DFA.unpack(u"\1\160\1\uffff\1\160\2\uffff\2\160\3\uffff\6\160\1"
        u"\uffff\1\160\1\uffff\1\160\2\uffff\2\160\2\uffff\2\160\2\uffff"
        u"\1\160\5\uffff\1\160\1\uffff\1\u012f\6\uffff\1\160\5\uffff\1\160"
        u"\51\uffff\1\160\6\uffff\2\160\12\uffff\1\160\10\uffff\1\160"),
        DFA.unpack(u"\1\u0130\6\uffff\1\u0130\171\uffff\1\u0131"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\u0132\6\uffff\1\u0132\171\uffff\1\u0133"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\u0134\6\uffff\1\u0134\171\uffff\1\u0135"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\u0136\6\uffff\1\u0136\171\uffff\1\u0137"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\u0138"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0139"),
        DFA.unpack(u"\1\u0092\4\uffff\1\u013a\21\uffff\1\u0093\110\uffff"
        u"\1\u0091"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091\60\uffff"
        u"\1\u009a"),
        DFA.unpack(u"\1\u013b\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u013c\6\uffff\1\u013c\171\uffff\1\u013d"),
        DFA.unpack(u"\1\u013e\6\uffff\1\u013e\171\uffff\1\u013d"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0116"),
        DFA.unpack(u"\1\u0116"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\25\uffff\1\u00a3\62\uffff"
        u"\1\u0091"),
        DFA.unpack(u"\1\u0140\3\uffff\1\u013f\10\uffff\1\u0092\26\uffff"
        u"\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0140\3\uffff\1\u013f"),
        DFA.unpack(u"\1\u011b"),
        DFA.unpack(u"\1\u011b"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\25\uffff\1\u00a5\62\uffff"
        u"\1\u0091"),
        DFA.unpack(u"\1\u0142\3\uffff\1\u0141\10\uffff\1\u0092\26\uffff"
        u"\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0142\3\uffff\1\u0141"),
        DFA.unpack(u"\1\u0120"),
        DFA.unpack(u"\1\u0120"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\25\uffff\1\u00a7\62\uffff"
        u"\1\u0091"),
        DFA.unpack(u"\1\u0144\3\uffff\1\u0143\10\uffff\1\u0092\26\uffff"
        u"\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0144\3\uffff\1\u0143"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0145"),
        DFA.unpack(u"\1\u0147\3\uffff\1\u0146\10\uffff\1\u0092\26\uffff"
        u"\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0147\3\uffff\1\u0146"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0148"),
        DFA.unpack(u"\1\u0149\6\uffff\1\u0149"),
        DFA.unpack(u"\1\u014a"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091\6\uffff"
        u"\1\u014b\51\uffff\1\u009a"),
        DFA.unpack(u"\1\u0101\3\uffff\1\u014c"),
        DFA.unpack(u"\1\u0101\3\uffff\1\u014c"),
        DFA.unpack(u"\1\u0103\3\uffff\1\u014d"),
        DFA.unpack(u"\1\u0103\3\uffff\1\u014d"),
        DFA.unpack(u"\1\u0105\3\uffff\1\u014e"),
        DFA.unpack(u"\1\u0105\3\uffff\1\u014e"),
        DFA.unpack(u"\1\u0108\3\uffff\1\u014f"),
        DFA.unpack(u"\1\u0108\3\uffff\1\u014f"),
        DFA.unpack(u"\1\u010a"),
        DFA.unpack(u"\1\160\110\uffff\1\160\44\uffff\1\u00df\13\uffff\1"
        u"\160"),
        DFA.unpack(u"\1\u0150"),
        DFA.unpack(u"\1\u0092\6\uffff\1\u0092\4\uffff\1\u0092\1\uffff\1"
        u"\u0092\2\uffff\1\u0092\5\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0151\10\uffff\1\u0092\4\uffff\1\u00b2\21\uffff"
        u"\1\u0093\1\uffff\1\u009c\106\uffff\1\u0091"),
        DFA.unpack(u"\1\u009c"),
        DFA.unpack(u"\1\u009c"),
        DFA.unpack(u"\1\u0152\6\uffff\1\u0152\171\uffff\1\u0153"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0154\6\uffff\1\u0154\171\uffff\1\u0155"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0156\6\uffff\1\u0156\171\uffff\1\u0157"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0158\6\uffff\1\u0158\171\uffff\1\u0159"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\7\47\uffff\1\7\40\uffff\1\7\33\uffff\1\54\13\uffff"
        u"\1\7"),
        DFA.unpack(u"\1\7\7\uffff\1\u012d\15\uffff\1\u00bc\21\uffff\1\7"
        u"\40\uffff\1\7\33\uffff\1\u00bd\13\uffff\1\7"),
        DFA.unpack(u"\1\160\110\uffff\1\160\6\uffff\1\u014b\35\uffff\1\u00df"
        u"\13\uffff\1\160"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\u015a\6\uffff\1\u015a\171\uffff\1\u015b"),
        DFA.unpack(u"\1\u015c\6\uffff\1\u015c\171\uffff\1\u015d"),
        DFA.unpack(u"\1\u015e\6\uffff\1\u015e\171\uffff\1\u015f"),
        DFA.unpack(u"\1\u0160\6\uffff\1\u0160\171\uffff\1\u0161"),
        DFA.unpack(u"\1\u0162"),
        DFA.unpack(u"\1\u0163\6\uffff\1\u0163"),
        DFA.unpack(u"\1\u0140\3\uffff\1\u0164"),
        DFA.unpack(u"\1\u0140\3\uffff\1\u0164"),
        DFA.unpack(u"\1\u0142\3\uffff\1\u0165"),
        DFA.unpack(u"\1\u0142\3\uffff\1\u0165"),
        DFA.unpack(u"\1\u0144\3\uffff\1\u0166"),
        DFA.unpack(u"\1\u0144\3\uffff\1\u0166"),
        DFA.unpack(u"\1\u0147\3\uffff\1\u0167"),
        DFA.unpack(u"\1\u0147\3\uffff\1\u0167"),
        DFA.unpack(u"\1\u0101"),
        DFA.unpack(u"\1\u0101"),
        DFA.unpack(u"\1\u0103"),
        DFA.unpack(u"\1\u0103"),
        DFA.unpack(u"\1\u0105"),
        DFA.unpack(u"\1\u0105"),
        DFA.unpack(u"\1\u0108"),
        DFA.unpack(u"\1\u0108"),
        DFA.unpack(u"\1\u0092\26\uffff\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0151\10\uffff\1\u0092\4\uffff\1\u00b2\21\uffff"
        u"\1\u0093\110\uffff\1\u0091"),
        DFA.unpack(u"\1\u0168\6\uffff\1\u0168\171\uffff\1\u0169"),
        DFA.unpack(u"\1\u016a\6\uffff\1\u016a\171\uffff\1\u016b"),
        DFA.unpack(u"\1\u016c\6\uffff\1\u016c\171\uffff\1\u016d"),
        DFA.unpack(u"\1\u016e\6\uffff\1\u016e\171\uffff\1\u016f"),
        DFA.unpack(u"\1\u0140"),
        DFA.unpack(u"\1\u0140"),
        DFA.unpack(u"\1\u0142"),
        DFA.unpack(u"\1\u0142"),
        DFA.unpack(u"\1\u0144"),
        DFA.unpack(u"\1\u0144"),
        DFA.unpack(u"\1\u0147"),
        DFA.unpack(u"\1\u0147")
    ]

    # class definition for DFA #29

    class DFA29(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0:
                LA29_147 = input.LA(1)


                index29_147 = input.index()
                input.rewind()

                s = -1
                if (((((((self.input).LT(1).text.upper() == "SUBTYPE")) and (((this.input).LT(1).text.upper() == "SUBTYPE")))) and (self.synpred62_PLSQL3()))):
                    s = 146

                elif (((((((self.input).LT(1).text.upper() == "TYPE")) and (((this.input).LT(1).text.upper() == "TYPE")))) and (self.synpred70_PLSQL3()))):
                    s = 112


                input.seek(index29_147)

                if s >= 0:
                    return s

            if self._state.backtracking > 0:
                raise BacktrackingFailed

            nvae = NoViableAltException(self_.getDescription(), 29, _s, input)
            self_.error(nvae)
            raise nvae

    # lookup tables for DFA #32

    DFA32_eot = DFA.unpack(
        u"\41\uffff"
        )

    DFA32_eof = DFA.unpack(
        u"\41\uffff"
        )

    DFA32_min = DFA.unpack(
        u"\1\26\1\33\1\17\3\uffff\2\13\1\42\1\13\1\17\1\uffff\1\0\2\17\1"
        u"\42\3\13\5\uffff\1\42\2\13\1\42\3\13\2\0"
        )

    DFA32_max = DFA.unpack(
        u"\1\26\1\33\1\116\3\uffff\2\54\1\42\1\54\1\47\1\uffff\1\0\2\47\1"
        u"\42\3\54\5\uffff\1\42\2\54\1\42\3\54\2\0"
        )

    DFA32_accept = DFA.unpack(
        u"\3\uffff\1\3\1\4\1\1\5\uffff\1\2\7\uffff\1\5\1\6\1\7\1\10\1\11"
        u"\11\uffff"
        )

    DFA32_special = DFA.unpack(
        u"\1\uffff\1\3\12\uffff\1\0\22\uffff\1\2\1\1"
        )


    DFA32_transition = [
        DFA.unpack(u"\1\1"),
        DFA.unpack(u"\1\2"),
        DFA.unpack(u"\1\6\6\uffff\1\6\6\uffff\1\10\4\uffff\1\11\1\uffff"
        u"\1\10\2\uffff\1\7\46\uffff\1\5"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\1\12\1\uffff\1\13\36\uffff\1\14"),
        DFA.unpack(u"\1\15\40\uffff\1\14"),
        DFA.unpack(u"\1\11"),
        DFA.unpack(u"\1\16\40\uffff\1\14"),
        DFA.unpack(u"\1\22\6\uffff\1\22\6\uffff\1\17\4\uffff\1\20\1\uffff"
        u"\1\17\2\uffff\1\21"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\22\6\uffff\1\22\6\uffff\1\30\4\uffff\1\31\1\uffff"
        u"\1\30\2\uffff\1\32"),
        DFA.unpack(u"\1\36\6\uffff\1\36\6\uffff\1\33\4\uffff\1\34\1\uffff"
        u"\1\33\2\uffff\1\35"),
        DFA.unpack(u"\1\20"),
        DFA.unpack(u"\1\15\40\uffff\1\37"),
        DFA.unpack(u"\1\15\40\uffff\1\37"),
        DFA.unpack(u"\1\15\40\uffff\1\40"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\1\31"),
        DFA.unpack(u"\1\15\40\uffff\1\40"),
        DFA.unpack(u"\1\15\40\uffff\1\40"),
        DFA.unpack(u"\1\34"),
        DFA.unpack(u"\1\16\40\uffff\1\14"),
        DFA.unpack(u"\1\16\40\uffff\1\14"),
        DFA.unpack(u"\1\16\40\uffff\1\14"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff")
    ]

    # class definition for DFA #32

    class DFA32(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0:
                LA32_12 = input.LA(1)


                index32_12 = input.index()
                input.rewind()

                s = -1
                if (((((((self.input).LT(1).text.upper() == "BUILTIN")) and (((this.input).LT(1).text.upper() == "BUILTIN")))) and (self.synpred77_PLSQL3()))):
                    s = 19

                elif (((((self.synpred78_PLSQL3()) and (self.synpred78_PLSQL3()))) and (((self.input).LT(1).text.upper() == "FIPSFLAG")))):
                    s = 20

                elif (((((self.synpred79_PLSQL3()) and (self.synpred79_PLSQL3()))) and (((self.input).LT(1).text.upper() == "INTERFACE")))):
                    s = 21

                elif (((((((self.input).LT(1).text.upper() == "NEW_NAMES")) and (((this.input).LT(1).text.upper() == "NEW_NAMES")))) and (self.synpred80_PLSQL3()))):
                    s = 22

                elif (((self.input).LT(1).text.upper() == "TIMESTAMP")):
                    s = 23


                input.seek(index32_12)

                if s >= 0:
                    return s
            el
            if s == 1:
                LA32_32 = input.LA(1)


                index32_32 = input.index()
                input.rewind()

                s = -1
                if (((((((self.input).LT(1).text.upper() == "RESTRICT_REFERENCES")) and (((this.input).LT(1).text.upper() == "RESTRICT_REFERENCES")))) and (self.synpred73_PLSQL3()))):
                    s = 5

                elif (((((((self.input).LT(1).text.upper() == "BUILTIN")) and (((this.input).LT(1).text.upper() == "BUILTIN")))) and (self.synpred77_PLSQL3()))):
                    s = 19

                elif (((((self.synpred78_PLSQL3()) and (self.synpred78_PLSQL3()))) and (((self.input).LT(1).text.upper() == "FIPSFLAG")))):
                    s = 20

                elif (((((self.synpred79_PLSQL3()) and (self.synpred79_PLSQL3()))) and (((self.input).LT(1).text.upper() == "INTERFACE")))):
                    s = 21

                elif (((((((self.input).LT(1).text.upper() == "NEW_NAMES")) and (((this.input).LT(1).text.upper() == "NEW_NAMES")))) and (self.synpred80_PLSQL3()))):
                    s = 22

                elif (((self.input).LT(1).text.upper() == "TIMESTAMP")):
                    s = 23


                input.seek(index32_32)

                if s >= 0:
                    return s
            el
            if s == 2:
                LA32_31 = input.LA(1)


                index32_31 = input.index()
                input.rewind()

                s = -1
                if (((((((self.input).LT(1).text.upper() == "RESTRICT_REFERENCES")) and (((this.input).LT(1).text.upper() == "RESTRICT_REFERENCES")))) and (self.synpred73_PLSQL3()))):
                    s = 5

                elif (((((self.synpred74_PLSQL3()) and (self.synpred74_PLSQL3()))) and (((self.input).LT(1).text.upper() == "EXCEPTION_INIT")))):
                    s = 11

                elif (((((((self.input).LT(1).text.upper() == "BUILTIN")) and (((this.input).LT(1).text.upper() == "BUILTIN")))) and (self.synpred77_PLSQL3()))):
                    s = 19

                elif (((((self.synpred78_PLSQL3()) and (self.synpred78_PLSQL3()))) and (((self.input).LT(1).text.upper() == "FIPSFLAG")))):
                    s = 20

                elif (((((self.synpred79_PLSQL3()) and (self.synpred79_PLSQL3()))) and (((self.input).LT(1).text.upper() == "INTERFACE")))):
                    s = 21

                elif (((((((self.input).LT(1).text.upper() == "NEW_NAMES")) and (((this.input).LT(1).text.upper() == "NEW_NAMES")))) and (self.synpred80_PLSQL3()))):
                    s = 22

                elif (((self.input).LT(1).text.upper() == "TIMESTAMP")):
                    s = 23


                input.seek(index32_31)

                if s >= 0:
                    return s
            el
            if s == 3:
                LA32_1 = input.LA(1)


                index32_1 = input.index()
                input.rewind()

                s = -1
                if (LA32_1 == LPAREN):
                    s = 2

                elif (((((((self.input).LT(1).text.upper() == "AUTONOMOUS_TRANSACTION")) and (((this.input).LT(1).text.upper() == "AUTONOMOUS_TRANSACTION")))) and (self.synpred75_PLSQL3()))):
                    s = 3

                elif (((((self.synpred76_PLSQL3()) and (self.synpred76_PLSQL3()))) and (((self.input).LT(1).text.upper() == "SERIALLY_REUSABLE")))):
                    s = 4


                input.seek(index32_1)

                if s >= 0:
                    return s

            if self._state.backtracking > 0:
                raise BacktrackingFailed

            nvae = NoViableAltException(self_.getDescription(), 32, _s, input)
            self_.error(nvae)
            raise nvae

    # lookup tables for DFA #125

    DFA125_eot = DFA.unpack(
        u"\101\uffff"
        )

    DFA125_eof = DFA.unpack(
        u"\1\2\100\uffff"
        )

    DFA125_min = DFA.unpack(
        u"\1\6\1\0\77\uffff"
        )

    DFA125_max = DFA.unpack(
        u"\1\u00a5\1\0\77\uffff"
        )

    DFA125_accept = DFA.unpack(
        u"\2\uffff\1\2\75\uffff\1\1"
        )

    DFA125_special = DFA.unpack(
        u"\1\uffff\1\0\77\uffff"
        )


    DFA125_transition = [
        DFA.unpack(u"\1\2\1\uffff\1\2\2\uffff\15\2\1\uffff\1\2\1\uffff\1"
        u"\1\2\2\2\uffff\3\2\1\uffff\1\2\2\uffff\2\2\1\uffff\1\2\1\uffff"
        u"\2\2\5\uffff\5\2\1\uffff\1\2\7\uffff\1\2\5\uffff\1\2\10\uffff\2"
        u"\2\1\uffff\1\2\1\uffff\1\2\2\uffff\2\2\3\uffff\1\2\2\uffff\2\2"
        u"\1\uffff\1\2\4\uffff\4\2\2\uffff\2\2\6\uffff\1\2\1\uffff\1\2\5"
        u"\uffff\3\2\5\uffff\1\2\5\uffff\2\2\2\uffff\1\2\2\uffff\1\2\3\uffff"
        u"\2\2\1\uffff\1\2\1\uffff\2\2\6\uffff\2\2"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #125

    class DFA125(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0:
                LA125_1 = input.LA(1)


                index125_1 = input.index()
                input.rewind()

                s = -1
                if ((((((input.LA(1) != LPAREN or input.LA(2) != PLUS or input.LA(3) != RPAREN )) and ((input.LA(1) != LPAREN or input.LA(2) != PLUS or input.LA(3) != RPAREN )))) and (self.synpred232_PLSQL3()))):
                    s = 64

                elif (True):
                    s = 2


                input.seek(index125_1)

                if s >= 0:
                    return s

            if self._state.backtracking > 0:
                raise BacktrackingFailed

            nvae = NoViableAltException(self_.getDescription(), 125, _s, input)
            self_.error(nvae)
            raise nvae

    # lookup tables for DFA #157

    DFA157_eot = DFA.unpack(
        u"\101\uffff"
        )

    DFA157_eof = DFA.unpack(
        u"\1\1\100\uffff"
        )

    DFA157_min = DFA.unpack(
        u"\1\6\41\uffff\1\0\36\uffff"
        )

    DFA157_max = DFA.unpack(
        u"\1\u00a5\41\uffff\1\0\36\uffff"
        )

    DFA157_accept = DFA.unpack(
        u"\1\uffff\1\2\76\uffff\1\1"
        )

    DFA157_special = DFA.unpack(
        u"\42\uffff\1\0\36\uffff"
        )


    DFA157_transition = [
        DFA.unpack(u"\1\1\1\uffff\1\1\2\uffff\1\42\1\1\1\uffff\12\1\1\uffff"
        u"\1\1\1\uffff\3\1\2\uffff\3\1\1\uffff\1\1\2\uffff\2\1\1\uffff\1"
        u"\1\1\uffff\2\1\5\uffff\5\1\1\uffff\1\1\7\uffff\1\1\5\uffff\1\1"
        u"\10\uffff\2\1\1\uffff\1\1\1\uffff\1\1\2\uffff\2\1\3\uffff\1\1\2"
        u"\uffff\2\1\1\uffff\1\1\4\uffff\4\1\2\uffff\2\1\6\uffff\1\1\1\uffff"
        u"\1\1\5\uffff\3\1\5\uffff\1\1\5\uffff\2\1\2\uffff\1\1\2\uffff\1"
        u"\1\3\uffff\2\1\1\uffff\1\1\1\uffff\2\1\3\uffff\1\1\2\uffff\2\1"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #157

    class DFA157(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0:
                LA157_34 = input.LA(1)


                index157_34 = input.index()
                input.rewind()

                s = -1
                if (self.synpred278_PLSQL3()):
                    s = 64

                elif (True):
                    s = 1


                input.seek(index157_34)

                if s >= 0:
                    return s

            if self._state.backtracking > 0:
                raise BacktrackingFailed

            nvae = NoViableAltException(self_.getDescription(), 157, _s, input)
            self_.error(nvae)
            raise nvae

    # lookup tables for DFA #166

    DFA166_eot = DFA.unpack(
        u"\100\uffff"
        )

    DFA166_eof = DFA.unpack(
        u"\1\2\77\uffff"
        )

    DFA166_min = DFA.unpack(
        u"\1\6\1\0\76\uffff"
        )

    DFA166_max = DFA.unpack(
        u"\1\u00a5\1\0\76\uffff"
        )

    DFA166_accept = DFA.unpack(
        u"\2\uffff\1\2\74\uffff\1\1"
        )

    DFA166_special = DFA.unpack(
        u"\1\uffff\1\0\76\uffff"
        )


    DFA166_transition = [
        DFA.unpack(u"\1\2\1\uffff\1\2\2\uffff\2\2\1\uffff\10\2\1\1\1\2\1"
        u"\uffff\1\2\1\uffff\3\2\2\uffff\3\2\1\uffff\1\2\2\uffff\2\2\1\uffff"
        u"\1\2\1\uffff\2\2\5\uffff\5\2\1\uffff\1\2\7\uffff\1\2\5\uffff\1"
        u"\2\10\uffff\2\2\1\uffff\1\2\1\uffff\1\2\2\uffff\2\2\3\uffff\1\2"
        u"\2\uffff\2\2\1\uffff\1\2\4\uffff\4\2\2\uffff\2\2\6\uffff\1\2\1"
        u"\uffff\1\2\5\uffff\3\2\5\uffff\1\2\5\uffff\2\2\2\uffff\1\2\2\uffff"
        u"\1\2\3\uffff\2\2\1\uffff\1\2\1\uffff\2\2\6\uffff\2\2"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #166

    class DFA166(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0:
                LA166_1 = input.LA(1)


                index166_1 = input.index()
                input.rewind()

                s = -1
                if (((((self.synpred288_PLSQL3()) and (self.synpred288_PLSQL3()))) and (((self.input).LT(1).text.upper() == "PARTITION")))):
                    s = 63

                elif (True):
                    s = 2


                input.seek(index166_1)

                if s >= 0:
                    return s

            if self._state.backtracking > 0:
                raise BacktrackingFailed

            nvae = NoViableAltException(self_.getDescription(), 166, _s, input)
            self_.error(nvae)
            raise nvae



    FOLLOW_create_package_in_start_rule50 = frozenset([73])
    FOLLOW_EOF_in_start_rule54 = frozenset([1])
    FOLLOW_73_in_create_package65 = frozenset([127, 130])
    FOLLOW_127_in_create_package69 = frozenset([22])
    FOLLOW_keyREPLACE_in_create_package71 = frozenset([130])
    FOLLOW_package_spec_in_create_package80 = frozenset([1])
    FOLLOW_package_body_in_create_package84 = frozenset([1])
    FOLLOW_keyPACKAGE_in_package_spec98 = frozenset([15, 22, 144])
    FOLLOW_package_name_in_package_spec100 = frozenset([53, 106])
    FOLLOW_set_in_package_spec102 = frozenset([15, 22, 85, 94, 133, 135])
    FOLLOW_package_obj_spec_in_package_spec117 = frozenset([15, 22, 85, 94, 133, 135])
    FOLLOW_85_in_package_spec124 = frozenset([15, 22, 45, 144])
    FOLLOW_package_name_in_package_spec127 = frozenset([45])
    FOLLOW_SEMI_in_package_spec131 = frozenset([1])
    FOLLOW_keyPACKAGE_in_package_body143 = frozenset([22])
    FOLLOW_keyBODY_in_package_body147 = frozenset([15, 22, 144])
    FOLLOW_package_name_in_package_body151 = frozenset([53, 106])
    FOLLOW_set_in_package_body153 = frozenset([15, 22, 56, 73, 85, 94, 133, 135])
    FOLLOW_package_obj_body_in_package_body167 = frozenset([15, 22, 56, 73, 85, 94, 133, 135])
    FOLLOW_56_in_package_body176 = frozenset([10, 15, 22, 26, 56, 65, 70, 73, 77, 79, 90, 92, 94, 95, 98, 101, 108, 110, 120, 133, 135, 136, 140, 142, 144, 146, 147, 148, 159, 166])
    FOLLOW_seq_of_statements_in_package_body178 = frozenset([85])
    FOLLOW_85_in_package_body187 = frozenset([15, 22, 45, 144])
    FOLLOW_package_name_in_package_body191 = frozenset([45])
    FOLLOW_SEMI_in_package_body196 = frozenset([1])
    FOLLOW_schema_name_in_package_name209 = frozenset([13])
    FOLLOW_DOT_in_package_name211 = frozenset([15, 22])
    FOLLOW_identifier_in_package_name216 = frozenset([1])
    FOLLOW_variable_declaration_in_package_obj_spec228 = frozenset([1])
    FOLLOW_type_declaration_in_package_obj_spec234 = frozenset([1])
    FOLLOW_subtype_declaration_in_package_obj_spec239 = frozenset([1])
    FOLLOW_record_declaration_in_package_obj_spec245 = frozenset([1])
    FOLLOW_plsql_table_declaration_in_package_obj_spec251 = frozenset([1])
    FOLLOW_varray_declaration_in_package_obj_spec257 = frozenset([1])
    FOLLOW_cursor_declaration_in_package_obj_spec262 = frozenset([1])
    FOLLOW_cursor_spec_in_package_obj_spec268 = frozenset([1])
    FOLLOW_procedure_spec_in_package_obj_spec274 = frozenset([1])
    FOLLOW_function_spec_in_package_obj_spec280 = frozenset([1])
    FOLLOW_exception_declaration_in_package_obj_spec286 = frozenset([1])
    FOLLOW_pragma_declaration_in_package_obj_spec292 = frozenset([1])
    FOLLOW_variable_name_in_variable_declaration303 = frozenset([15, 22, 58, 59, 60, 61, 62, 63, 66, 67, 68, 72, 74, 75, 76, 82, 91, 102, 103, 109, 112, 114, 115, 116, 117, 121, 122, 123, 124, 131, 132, 137, 138, 144, 150, 160, 162, 163])
    FOLLOW_72_in_variable_declaration306 = frozenset([15, 22, 58, 59, 60, 61, 62, 63, 66, 67, 68, 74, 75, 76, 82, 91, 102, 103, 109, 112, 114, 115, 116, 117, 121, 122, 123, 124, 131, 132, 137, 138, 144, 150, 160, 162, 163])
    FOLLOW_type_spec_in_variable_declaration312 = frozenset([5, 45, 78, 118])
    FOLLOW_118_in_variable_declaration315 = frozenset([120])
    FOLLOW_120_in_variable_declaration317 = frozenset([5, 45, 78])
    FOLLOW_set_in_variable_declaration326 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_plsql_expression_in_variable_declaration336 = frozenset([45])
    FOLLOW_SEMI_in_variable_declaration340 = frozenset([1])
    FOLLOW_keyTYPE_in_type_declaration353 = frozenset([15, 22, 58, 59, 60, 61, 62, 63, 66, 67, 68, 74, 75, 76, 82, 91, 102, 103, 109, 112, 114, 115, 116, 117, 121, 122, 123, 124, 131, 132, 137, 138, 144, 150, 160, 162, 163])
    FOLLOW_type_spec_in_type_declaration355 = frozenset([106])
    FOLLOW_106_in_type_declaration357 = frozenset([15, 22, 27, 58, 59, 60, 61, 62, 63, 66, 67, 68, 74, 75, 76, 82, 91, 102, 103, 109, 112, 114, 115, 116, 117, 121, 122, 123, 124, 131, 132, 137, 138, 144, 150, 160, 162, 163])
    FOLLOW_keyNEW_in_type_declaration361 = frozenset([15, 22, 27, 58, 59, 60, 61, 62, 63, 66, 67, 68, 74, 75, 76, 82, 91, 102, 103, 109, 112, 114, 115, 116, 117, 121, 122, 123, 124, 131, 132, 137, 138, 144, 150, 160, 162, 163])
    FOLLOW_type_spec_in_type_declaration368 = frozenset([45, 118])
    FOLLOW_118_in_type_declaration372 = frozenset([120])
    FOLLOW_120_in_type_declaration374 = frozenset([45])
    FOLLOW_LPAREN_in_type_declaration381 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_plsql_expressions_in_type_declaration383 = frozenset([44])
    FOLLOW_RPAREN_in_type_declaration385 = frozenset([45])
    FOLLOW_SEMI_in_type_declaration389 = frozenset([1])
    FOLLOW_keySUBTYPE_in_subtype_declaration402 = frozenset([15, 22, 58, 59, 60, 61, 62, 63, 66, 67, 68, 74, 75, 76, 82, 91, 102, 103, 109, 112, 114, 115, 116, 117, 121, 122, 123, 124, 131, 132, 137, 138, 144, 150, 160, 162, 163])
    FOLLOW_type_spec_in_subtype_declaration404 = frozenset([106])
    FOLLOW_106_in_subtype_declaration406 = frozenset([15, 22, 58, 59, 60, 61, 62, 63, 66, 67, 68, 74, 75, 76, 82, 91, 102, 103, 109, 112, 114, 115, 116, 117, 121, 122, 123, 124, 131, 132, 137, 138, 144, 150, 160, 162, 163])
    FOLLOW_type_spec_in_subtype_declaration408 = frozenset([22, 45, 118])
    FOLLOW_118_in_subtype_declaration412 = frozenset([120])
    FOLLOW_120_in_subtype_declaration414 = frozenset([45])
    FOLLOW_keyRANGE_in_subtype_declaration418 = frozenset([29, 34, 36, 39])
    FOLLOW_literal_in_subtype_declaration420 = frozenset([14])
    FOLLOW_DOUBLEDOT_in_subtype_declaration422 = frozenset([29, 34, 36, 39])
    FOLLOW_literal_in_subtype_declaration424 = frozenset([45])
    FOLLOW_SEMI_in_subtype_declaration429 = frozenset([1])
    FOLLOW_keyCURSOR_in_cursor_declaration442 = frozenset([15, 22])
    FOLLOW_cursor_name_in_cursor_declaration444 = frozenset([27, 106])
    FOLLOW_LPAREN_in_cursor_declaration450 = frozenset([15, 22])
    FOLLOW_parameter_specs_in_cursor_declaration452 = frozenset([44])
    FOLLOW_RPAREN_in_cursor_declaration454 = frozenset([106])
    FOLLOW_106_in_cursor_declaration461 = frozenset([147])
    FOLLOW_select_command_in_cursor_declaration463 = frozenset([45])
    FOLLOW_SEMI_in_cursor_declaration465 = frozenset([1])
    FOLLOW_variable_declaration_in_package_obj_body475 = frozenset([1])
    FOLLOW_subtype_declaration_in_package_obj_body481 = frozenset([1])
    FOLLOW_cursor_declaration_in_package_obj_body487 = frozenset([1])
    FOLLOW_exception_declaration_in_package_obj_body493 = frozenset([1])
    FOLLOW_record_declaration_in_package_obj_body499 = frozenset([1])
    FOLLOW_plsql_table_declaration_in_package_obj_body505 = frozenset([1])
    FOLLOW_varray_declaration_in_package_obj_body511 = frozenset([1])
    FOLLOW_procedure_body_in_package_obj_body516 = frozenset([1])
    FOLLOW_function_body_in_package_obj_body522 = frozenset([1])
    FOLLOW_pragma_declaration_in_package_obj_body528 = frozenset([1])
    FOLLOW_statement_in_seq_of_statements539 = frozenset([45])
    FOLLOW_SEMI_in_seq_of_statements541 = frozenset([1, 10, 15, 22, 26, 56, 65, 70, 73, 77, 79, 90, 92, 94, 95, 98, 101, 108, 110, 120, 133, 135, 136, 140, 142, 144, 146, 147, 148, 159, 166])
    FOLLOW_statement_in_seq_of_statements545 = frozenset([45])
    FOLLOW_SEMI_in_seq_of_statements547 = frozenset([1, 10, 15, 22, 26, 56, 65, 70, 73, 77, 79, 90, 92, 94, 95, 98, 101, 108, 110, 120, 133, 135, 136, 140, 142, 144, 146, 147, 148, 159, 166])
    FOLLOW_assignment_statement_in_statement562 = frozenset([1])
    FOLLOW_exit_statement_in_statement567 = frozenset([1])
    FOLLOW_goto_statement_in_statement572 = frozenset([1])
    FOLLOW_case_statement_in_statement577 = frozenset([1])
    FOLLOW_if_statement_in_statement582 = frozenset([1])
    FOLLOW_loop_statement_in_statement588 = frozenset([1])
    FOLLOW_null_statement_in_statement594 = frozenset([1])
    FOLLOW_raise_statement_in_statement599 = frozenset([1])
    FOLLOW_return_statement_in_statement604 = frozenset([1])
    FOLLOW_sql_statement_in_statement609 = frozenset([1])
    FOLLOW_plsql_block_in_statement614 = frozenset([1])
    FOLLOW_function_call_in_statement620 = frozenset([1])
    FOLLOW_LLABEL_in_plsql_block635 = frozenset([15, 22])
    FOLLOW_label_name_in_plsql_block637 = frozenset([41])
    FOLLOW_RLABEL_in_plsql_block639 = frozenset([15, 22, 56, 73, 77, 94, 133, 135])
    FOLLOW_77_in_plsql_block650 = frozenset([15, 22, 73, 94, 133, 135])
    FOLLOW_declare_spec_in_plsql_block656 = frozenset([15, 22, 56, 73, 94, 133, 135])
    FOLLOW_56_in_plsql_block668 = frozenset([10, 15, 22, 26, 56, 65, 70, 73, 77, 79, 90, 92, 94, 95, 98, 101, 108, 110, 120, 133, 135, 136, 140, 142, 144, 146, 147, 148, 159, 166])
    FOLLOW_seq_of_statements_in_plsql_block674 = frozenset([85, 86])
    FOLLOW_86_in_plsql_block680 = frozenset([164])
    FOLLOW_exception_handler_in_plsql_block684 = frozenset([85, 164])
    FOLLOW_85_in_plsql_block697 = frozenset([1, 15, 22])
    FOLLOW_label_name_in_plsql_block701 = frozenset([1])
    FOLLOW_variable_declaration_in_declare_spec717 = frozenset([1])
    FOLLOW_subtype_declaration_in_declare_spec723 = frozenset([1])
    FOLLOW_cursor_declaration_in_declare_spec729 = frozenset([1])
    FOLLOW_exception_declaration_in_declare_spec735 = frozenset([1])
    FOLLOW_record_declaration_in_declare_spec741 = frozenset([1])
    FOLLOW_plsql_table_declaration_in_declare_spec747 = frozenset([1])
    FOLLOW_varray_declaration_in_declare_spec753 = frozenset([1])
    FOLLOW_procedure_declaration_in_declare_spec758 = frozenset([1])
    FOLLOW_function_declaration_in_declare_spec764 = frozenset([1])
    FOLLOW_type_declaration_in_declare_spec769 = frozenset([1])
    FOLLOW_pragma_declaration_in_declare_spec775 = frozenset([1])
    FOLLOW_keyPRAGMA_in_pragma_declaration786 = frozenset([22])
    FOLLOW_keyRESTRICT_REFERENCES_in_pragma_declaration793 = frozenset([27])
    FOLLOW_LPAREN_in_pragma_declaration795 = frozenset([15, 22, 39, 78])
    FOLLOW_78_in_pragma_declaration799 = frozenset([11])
    FOLLOW_function_name_in_pragma_declaration803 = frozenset([11])
    FOLLOW_COMMA_in_pragma_declaration809 = frozenset([15, 22, 29, 34, 36, 39])
    FOLLOW_pragma_param_in_pragma_declaration811 = frozenset([11, 44])
    FOLLOW_RPAREN_in_pragma_declaration816 = frozenset([45])
    FOLLOW_keyEXCEPTION_INIT_in_pragma_declaration823 = frozenset([27])
    FOLLOW_LPAREN_in_pragma_declaration825 = frozenset([15, 22])
    FOLLOW_exception_name_in_pragma_declaration827 = frozenset([11])
    FOLLOW_COMMA_in_pragma_declaration829 = frozenset([29, 34, 36, 39])
    FOLLOW_literal_in_pragma_declaration831 = frozenset([44])
    FOLLOW_RPAREN_in_pragma_declaration833 = frozenset([45])
    FOLLOW_keyAUTONOMOUS_TRANSACTION_in_pragma_declaration839 = frozenset([45])
    FOLLOW_keySERIALLY_REUSABLE_in_pragma_declaration845 = frozenset([45])
    FOLLOW_keyBUILTIN_in_pragma_declaration851 = frozenset([27])
    FOLLOW_LPAREN_in_pragma_declaration853 = frozenset([15, 22, 29, 34, 36, 39])
    FOLLOW_pragma_params_in_pragma_declaration855 = frozenset([44])
    FOLLOW_RPAREN_in_pragma_declaration857 = frozenset([45])
    FOLLOW_keyFIPSFLAG_in_pragma_declaration863 = frozenset([27])
    FOLLOW_LPAREN_in_pragma_declaration865 = frozenset([15, 22, 29, 34, 36, 39])
    FOLLOW_pragma_params_in_pragma_declaration867 = frozenset([44])
    FOLLOW_RPAREN_in_pragma_declaration869 = frozenset([45])
    FOLLOW_keyINTERFACE_in_pragma_declaration875 = frozenset([27])
    FOLLOW_LPAREN_in_pragma_declaration877 = frozenset([15, 22, 29, 34, 36, 39])
    FOLLOW_pragma_params_in_pragma_declaration879 = frozenset([44])
    FOLLOW_RPAREN_in_pragma_declaration881 = frozenset([45])
    FOLLOW_keyNEW_NAMES_in_pragma_declaration887 = frozenset([27])
    FOLLOW_LPAREN_in_pragma_declaration889 = frozenset([15, 22, 29, 34, 36, 39])
    FOLLOW_pragma_params_in_pragma_declaration891 = frozenset([44])
    FOLLOW_RPAREN_in_pragma_declaration893 = frozenset([45])
    FOLLOW_keyTIMESTAMP_in_pragma_declaration899 = frozenset([27])
    FOLLOW_LPAREN_in_pragma_declaration901 = frozenset([15, 22, 29, 34, 36, 39])
    FOLLOW_pragma_params_in_pragma_declaration903 = frozenset([44])
    FOLLOW_RPAREN_in_pragma_declaration905 = frozenset([45])
    FOLLOW_SEMI_in_pragma_declaration913 = frozenset([1])
    FOLLOW_pragma_param_in_pragma_params924 = frozenset([1, 11])
    FOLLOW_COMMA_in_pragma_params928 = frozenset([15, 22, 29, 34, 36, 39])
    FOLLOW_pragma_param_in_pragma_params930 = frozenset([1, 11])
    FOLLOW_NUMBER_in_pragma_param955 = frozenset([1])
    FOLLOW_QUOTED_STRING_in_pragma_param960 = frozenset([1])
    FOLLOW_identifier_in_pragma_param965 = frozenset([1])
    FOLLOW_lvalue_in_assignment_statement981 = frozenset([5])
    FOLLOW_ASSIGN_in_assignment_statement983 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_plsql_expression_in_assignment_statement985 = frozenset([1])
    FOLLOW_lvalue_in_lvalues997 = frozenset([1, 11])
    FOLLOW_COMMA_in_lvalues1001 = frozenset([10, 15, 22])
    FOLLOW_lvalue_in_lvalues1003 = frozenset([1, 11])
    FOLLOW_variable_name_in_lvalue1016 = frozenset([1])
    FOLLOW_record_name_in_lvalue1021 = frozenset([13])
    FOLLOW_DOT_in_lvalue1023 = frozenset([15, 22])
    FOLLOW_field_name_in_lvalue1025 = frozenset([1])
    FOLLOW_plsql_table_name_in_lvalue1030 = frozenset([27])
    FOLLOW_LPAREN_in_lvalue1032 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_subscript_in_lvalue1034 = frozenset([44])
    FOLLOW_RPAREN_in_lvalue1036 = frozenset([1, 13])
    FOLLOW_DOT_in_lvalue1040 = frozenset([15, 22])
    FOLLOW_field_name_in_lvalue1042 = frozenset([1, 13])
    FOLLOW_COLON_in_lvalue1050 = frozenset([15, 22])
    FOLLOW_host_variable_in_lvalue1052 = frozenset([1, 10])
    FOLLOW_COLON_in_lvalue1056 = frozenset([15, 22])
    FOLLOW_host_variable_in_lvalue1058 = frozenset([1])
    FOLLOW_identifier_in_field_name1072 = frozenset([1])
    FOLLOW_plsql_expression_in_subscript1084 = frozenset([1])
    FOLLOW_identifier_in_host_variable1097 = frozenset([1])
    FOLLOW_95_in_goto_statement1109 = frozenset([15, 22])
    FOLLOW_label_name_in_goto_statement1111 = frozenset([1])
    FOLLOW_identifier_in_label_name1123 = frozenset([1])
    FOLLOW_keyEXIT_in_exit_statement1135 = frozenset([1, 15, 22, 164])
    FOLLOW_label_name_in_exit_statement1139 = frozenset([1, 164])
    FOLLOW_164_in_exit_statement1146 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_plsql_condition_in_exit_statement1148 = frozenset([1])
    FOLLOW_61_in_datatype1163 = frozenset([1])
    FOLLOW_60_in_datatype1169 = frozenset([1])
    FOLLOW_59_in_datatype1174 = frozenset([1])
    FOLLOW_115_in_datatype1179 = frozenset([1])
    FOLLOW_132_in_datatype1185 = frozenset([1])
    FOLLOW_set_in_datatype1191 = frozenset([1, 27])
    FOLLOW_LPAREN_in_datatype1211 = frozenset([34])
    FOLLOW_NUMBER_in_datatype1213 = frozenset([11, 44])
    FOLLOW_COMMA_in_datatype1217 = frozenset([34])
    FOLLOW_NUMBER_in_datatype1219 = frozenset([44])
    FOLLOW_RPAREN_in_datatype1224 = frozenset([1])
    FOLLOW_109_in_datatype1232 = frozenset([1, 27, 137])
    FOLLOW_137_in_datatype1236 = frozenset([1, 27])
    FOLLOW_LPAREN_in_datatype1242 = frozenset([34])
    FOLLOW_NUMBER_in_datatype1244 = frozenset([44])
    FOLLOW_RPAREN_in_datatype1246 = frozenset([1])
    FOLLOW_137_in_datatype1254 = frozenset([1, 27])
    FOLLOW_LPAREN_in_datatype1258 = frozenset([34])
    FOLLOW_NUMBER_in_datatype1260 = frozenset([44])
    FOLLOW_RPAREN_in_datatype1262 = frozenset([1])
    FOLLOW_63_in_datatype1270 = frozenset([1])
    FOLLOW_74_in_datatype1275 = frozenset([1])
    FOLLOW_keyINTERVAL_in_datatype1280 = frozenset([22])
    FOLLOW_keyDAY_in_datatype1282 = frozenset([27, 155])
    FOLLOW_LPAREN_in_datatype1286 = frozenset([34])
    FOLLOW_NUMBER_in_datatype1288 = frozenset([44])
    FOLLOW_RPAREN_in_datatype1290 = frozenset([155])
    FOLLOW_155_in_datatype1295 = frozenset([22])
    FOLLOW_keySECOND_in_datatype1297 = frozenset([1, 27])
    FOLLOW_LPAREN_in_datatype1301 = frozenset([34])
    FOLLOW_NUMBER_in_datatype1303 = frozenset([44])
    FOLLOW_RPAREN_in_datatype1305 = frozenset([1])
    FOLLOW_keyINTERVAL_in_datatype1313 = frozenset([22])
    FOLLOW_keyYEAR_in_datatype1315 = frozenset([27, 155])
    FOLLOW_LPAREN_in_datatype1319 = frozenset([34])
    FOLLOW_NUMBER_in_datatype1321 = frozenset([44])
    FOLLOW_RPAREN_in_datatype1323 = frozenset([155])
    FOLLOW_155_in_datatype1328 = frozenset([22])
    FOLLOW_keyMONTH_in_datatype1330 = frozenset([1])
    FOLLOW_keyTIME_in_datatype1337 = frozenset([1, 27, 167])
    FOLLOW_keyTIMESTAMP_in_datatype1341 = frozenset([1, 27, 167])
    FOLLOW_LPAREN_in_datatype1347 = frozenset([34])
    FOLLOW_NUMBER_in_datatype1349 = frozenset([44])
    FOLLOW_RPAREN_in_datatype1351 = frozenset([1, 167])
    FOLLOW_167_in_datatype1358 = frozenset([22])
    FOLLOW_keyLOCAL_in_datatype1362 = frozenset([22])
    FOLLOW_keyTIME_in_datatype1367 = frozenset([22])
    FOLLOW_keyZONE_in_datatype1369 = frozenset([1])
    FOLLOW_103_in_datatype1376 = frozenset([1])
    FOLLOW_102_in_datatype1381 = frozenset([1])
    FOLLOW_150_in_datatype1386 = frozenset([1])
    FOLLOW_91_in_datatype1391 = frozenset([1, 27])
    FOLLOW_LPAREN_in_datatype1395 = frozenset([34])
    FOLLOW_NUMBER_in_datatype1397 = frozenset([44])
    FOLLOW_RPAREN_in_datatype1399 = frozenset([1])
    FOLLOW_138_in_datatype1407 = frozenset([1])
    FOLLOW_82_in_datatype1412 = frozenset([22])
    FOLLOW_keyPRECISION_in_datatype1414 = frozenset([1])
    FOLLOW_66_in_datatype1419 = frozenset([1, 22, 27, 67])
    FOLLOW_keyVARYING_in_datatype1428 = frozenset([1, 27, 67])
    FOLLOW_LPAREN_in_datatype1435 = frozenset([34])
    FOLLOW_NUMBER_in_datatype1437 = frozenset([22, 44, 66])
    FOLLOW_keyBYTE_in_datatype1441 = frozenset([44])
    FOLLOW_66_in_datatype1445 = frozenset([44])
    FOLLOW_RPAREN_in_datatype1450 = frozenset([1, 67])
    FOLLOW_67_in_datatype1457 = frozenset([148])
    FOLLOW_148_in_datatype1459 = frozenset([15, 22, 144])
    FOLLOW_identifier_in_datatype1463 = frozenset([1])
    FOLLOW_column_spec_in_datatype1467 = frozenset([9])
    FOLLOW_CHARSET_ATTR_in_datatype1469 = frozenset([1])
    FOLLOW_162_in_datatype1479 = frozenset([1, 27, 67])
    FOLLOW_LPAREN_in_datatype1501 = frozenset([34])
    FOLLOW_NUMBER_in_datatype1503 = frozenset([22, 44, 66])
    FOLLOW_keyBYTE_in_datatype1507 = frozenset([44])
    FOLLOW_66_in_datatype1511 = frozenset([44])
    FOLLOW_RPAREN_in_datatype1516 = frozenset([1, 67])
    FOLLOW_67_in_datatype1523 = frozenset([148])
    FOLLOW_148_in_datatype1525 = frozenset([15, 22, 144])
    FOLLOW_identifier_in_datatype1529 = frozenset([1])
    FOLLOW_column_spec_in_datatype1533 = frozenset([9])
    FOLLOW_CHARSET_ATTR_in_datatype1535 = frozenset([1])
    FOLLOW_163_in_datatype1545 = frozenset([1, 27, 67])
    FOLLOW_LPAREN_in_datatype1566 = frozenset([34])
    FOLLOW_NUMBER_in_datatype1568 = frozenset([22, 44, 66])
    FOLLOW_keyBYTE_in_datatype1572 = frozenset([44])
    FOLLOW_66_in_datatype1576 = frozenset([44])
    FOLLOW_RPAREN_in_datatype1581 = frozenset([1, 67])
    FOLLOW_67_in_datatype1588 = frozenset([148])
    FOLLOW_148_in_datatype1590 = frozenset([15, 22, 144])
    FOLLOW_identifier_in_datatype1594 = frozenset([1])
    FOLLOW_column_spec_in_datatype1598 = frozenset([9])
    FOLLOW_CHARSET_ATTR_in_datatype1600 = frozenset([1])
    FOLLOW_67_in_datatype1610 = frozenset([1, 22, 27])
    FOLLOW_keyVARYING_in_datatype1614 = frozenset([1, 27])
    FOLLOW_LPAREN_in_datatype1621 = frozenset([34])
    FOLLOW_NUMBER_in_datatype1623 = frozenset([44])
    FOLLOW_RPAREN_in_datatype1625 = frozenset([1])
    FOLLOW_116_in_datatype1633 = frozenset([1, 22, 27])
    FOLLOW_keyVARYING_in_datatype1641 = frozenset([1, 27])
    FOLLOW_LPAREN_in_datatype1648 = frozenset([34])
    FOLLOW_NUMBER_in_datatype1650 = frozenset([44])
    FOLLOW_RPAREN_in_datatype1652 = frozenset([1])
    FOLLOW_123_in_datatype1660 = frozenset([1, 27])
    FOLLOW_LPAREN_in_datatype1665 = frozenset([34])
    FOLLOW_NUMBER_in_datatype1667 = frozenset([44])
    FOLLOW_RPAREN_in_datatype1669 = frozenset([1])
    FOLLOW_124_in_datatype1677 = frozenset([1, 27])
    FOLLOW_LPAREN_in_datatype1681 = frozenset([34])
    FOLLOW_NUMBER_in_datatype1683 = frozenset([44])
    FOLLOW_RPAREN_in_datatype1685 = frozenset([1])
    FOLLOW_114_in_datatype1693 = frozenset([66, 67])
    FOLLOW_set_in_datatype1696 = frozenset([1, 22, 27])
    FOLLOW_keyVARYING_in_datatype1708 = frozenset([1, 27])
    FOLLOW_LPAREN_in_datatype1715 = frozenset([34])
    FOLLOW_NUMBER_in_datatype1717 = frozenset([44])
    FOLLOW_RPAREN_in_datatype1719 = frozenset([1])
    FOLLOW_112_in_datatype1727 = frozenset([1])
    FOLLOW_131_in_datatype1732 = frozenset([1])
    FOLLOW_62_in_datatype1737 = frozenset([1])
    FOLLOW_68_in_datatype1742 = frozenset([1, 67])
    FOLLOW_67_in_datatype1746 = frozenset([148])
    FOLLOW_148_in_datatype1748 = frozenset([15, 22, 144])
    FOLLOW_identifier_in_datatype1752 = frozenset([1])
    FOLLOW_column_spec_in_datatype1756 = frozenset([9])
    FOLLOW_CHARSET_ATTR_in_datatype1758 = frozenset([1])
    FOLLOW_117_in_datatype1768 = frozenset([1])
    FOLLOW_58_in_datatype1773 = frozenset([1])
    FOLLOW_144_in_datatype1778 = frozenset([1])
    FOLLOW_160_in_datatype1784 = frozenset([1, 27])
    FOLLOW_LPAREN_in_datatype1788 = frozenset([34])
    FOLLOW_NUMBER_in_datatype1790 = frozenset([44])
    FOLLOW_RPAREN_in_datatype1792 = frozenset([1])
    FOLLOW_datatype_in_type_spec1806 = frozenset([1])
    FOLLOW_column_spec_in_type_spec1813 = frozenset([47])
    FOLLOW_TYPE_ATTR_in_type_spec1815 = frozenset([1])
    FOLLOW_table_spec_in_type_spec1821 = frozenset([43])
    FOLLOW_ROWTYPE_ATTR_in_type_spec1823 = frozenset([1])
    FOLLOW_type_name_in_type_spec1829 = frozenset([1, 27])
    FOLLOW_LPAREN_in_type_spec1833 = frozenset([34])
    FOLLOW_NUMBER_in_type_spec1835 = frozenset([44])
    FOLLOW_RPAREN_in_type_spec1837 = frozenset([1])
    FOLLOW_identifier_in_type_name1851 = frozenset([1, 13])
    FOLLOW_DOT_in_type_name1855 = frozenset([15, 22])
    FOLLOW_identifier_in_type_name1857 = frozenset([1, 13])
    FOLLOW_parameter_spec_in_parameter_specs1871 = frozenset([1, 11])
    FOLLOW_COMMA_in_parameter_specs1875 = frozenset([15, 22])
    FOLLOW_parameter_spec_in_parameter_specs1877 = frozenset([1, 11])
    FOLLOW_parameter_name_in_parameter_spec1891 = frozenset([1, 15, 22, 58, 59, 60, 61, 62, 63, 66, 67, 68, 74, 75, 76, 82, 91, 99, 102, 103, 109, 112, 114, 115, 116, 117, 121, 122, 123, 124, 131, 132, 137, 138, 144, 150, 160, 162, 163])
    FOLLOW_99_in_parameter_spec1895 = frozenset([1, 15, 22, 58, 59, 60, 61, 62, 63, 66, 67, 68, 74, 75, 76, 82, 91, 102, 103, 109, 112, 114, 115, 116, 117, 121, 122, 123, 124, 131, 132, 137, 138, 144, 150, 160, 162, 163])
    FOLLOW_type_spec_in_parameter_spec1902 = frozenset([1])
    FOLLOW_identifier_in_parameter_name1917 = frozenset([1])
    FOLLOW_keyCURSOR_in_cursor_spec1928 = frozenset([15, 22])
    FOLLOW_cursor_name_in_cursor_spec1930 = frozenset([27, 140])
    FOLLOW_LPAREN_in_cursor_spec1937 = frozenset([15, 22])
    FOLLOW_parameter_specs_in_cursor_spec1939 = frozenset([44])
    FOLLOW_RPAREN_in_cursor_spec1941 = frozenset([140])
    FOLLOW_keyRETURN_in_cursor_spec1948 = frozenset([15, 22, 58, 59, 60, 61, 62, 63, 66, 67, 68, 74, 75, 76, 82, 91, 102, 103, 109, 112, 114, 115, 116, 117, 121, 122, 123, 124, 131, 132, 137, 138, 144, 150, 160, 162, 163])
    FOLLOW_return_type_in_cursor_spec1950 = frozenset([45])
    FOLLOW_SEMI_in_cursor_spec1952 = frozenset([1])
    FOLLOW_135_in_procedure_spec1965 = frozenset([15, 22, 39])
    FOLLOW_procedure_name_in_procedure_spec1967 = frozenset([27, 45])
    FOLLOW_LPAREN_in_procedure_spec1973 = frozenset([15, 22])
    FOLLOW_arguments_in_procedure_spec1975 = frozenset([44])
    FOLLOW_RPAREN_in_procedure_spec1977 = frozenset([45])
    FOLLOW_SEMI_in_procedure_spec1982 = frozenset([1])
    FOLLOW_94_in_function_spec1993 = frozenset([15, 22, 39])
    FOLLOW_function_name_in_function_spec1995 = frozenset([27, 140])
    FOLLOW_LPAREN_in_function_spec2002 = frozenset([15, 22])
    FOLLOW_arguments_in_function_spec2004 = frozenset([44])
    FOLLOW_RPAREN_in_function_spec2006 = frozenset([140])
    FOLLOW_keyRETURN_in_function_spec2013 = frozenset([15, 22, 58, 59, 60, 61, 62, 63, 66, 67, 68, 74, 75, 76, 82, 91, 102, 103, 109, 112, 114, 115, 116, 117, 121, 122, 123, 124, 131, 132, 137, 138, 144, 150, 160, 162, 163])
    FOLLOW_return_type_in_function_spec2015 = frozenset([45])
    FOLLOW_SEMI_in_function_spec2017 = frozenset([1])
    FOLLOW_exception_name_in_exception_declaration2028 = frozenset([86])
    FOLLOW_86_in_exception_declaration2030 = frozenset([45])
    FOLLOW_SEMI_in_exception_declaration2032 = frozenset([1])
    FOLLOW_exception_name_in_exception_names2043 = frozenset([1, 127])
    FOLLOW_127_in_exception_names2047 = frozenset([15, 22])
    FOLLOW_exception_name_in_exception_names2049 = frozenset([1, 127])
    FOLLOW_exception_package_name_in_exception_name2065 = frozenset([13])
    FOLLOW_DOT_in_exception_name2067 = frozenset([15, 22])
    FOLLOW_identifier_in_exception_name2072 = frozenset([1])
    FOLLOW_identifier_in_exception_package_name2083 = frozenset([1])
    FOLLOW_record_type_dec_in_record_declaration2102 = frozenset([1])
    FOLLOW_keyTYPE_in_record_type_dec2115 = frozenset([15, 22])
    FOLLOW_type_name_in_record_type_dec2117 = frozenset([106])
    FOLLOW_106_in_record_type_dec2119 = frozenset([139])
    FOLLOW_keyRECORD_in_record_type_dec2121 = frozenset([27])
    FOLLOW_LPAREN_in_record_type_dec2126 = frozenset([15, 22, 144])
    FOLLOW_field_specs_in_record_type_dec2128 = frozenset([44])
    FOLLOW_RPAREN_in_record_type_dec2130 = frozenset([45])
    FOLLOW_SEMI_in_record_type_dec2132 = frozenset([1])
    FOLLOW_field_spec_in_field_specs2147 = frozenset([1, 11])
    FOLLOW_COMMA_in_field_specs2151 = frozenset([15, 22, 144])
    FOLLOW_field_spec_in_field_specs2153 = frozenset([1, 11])
    FOLLOW_column_name_in_field_spec2166 = frozenset([15, 22, 58, 59, 60, 61, 62, 63, 66, 67, 68, 74, 75, 76, 82, 91, 102, 103, 109, 112, 114, 115, 116, 117, 121, 122, 123, 124, 131, 132, 137, 138, 144, 150, 160, 162, 163])
    FOLLOW_type_spec_in_field_spec2168 = frozenset([1, 5, 78, 118])
    FOLLOW_118_in_field_spec2173 = frozenset([120])
    FOLLOW_120_in_field_spec2175 = frozenset([1, 5, 78])
    FOLLOW_set_in_field_spec2184 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_plsql_expression_in_field_spec2194 = frozenset([1])
    FOLLOW_table_type_dec_in_plsql_table_declaration2207 = frozenset([1])
    FOLLOW_keyTYPE_in_table_type_dec2219 = frozenset([15, 22])
    FOLLOW_type_name_in_table_type_dec2221 = frozenset([106])
    FOLLOW_106_in_table_type_dec2223 = frozenset([153])
    FOLLOW_153_in_table_type_dec2225 = frozenset([125])
    FOLLOW_125_in_table_type_dec2230 = frozenset([15, 22, 58, 59, 60, 61, 62, 63, 66, 67, 68, 74, 75, 76, 82, 91, 102, 103, 109, 112, 114, 115, 116, 117, 121, 122, 123, 124, 131, 132, 137, 138, 144, 150, 160, 162, 163])
    FOLLOW_type_spec_in_table_type_dec2232 = frozenset([45, 100, 118])
    FOLLOW_118_in_table_type_dec2236 = frozenset([120])
    FOLLOW_120_in_table_type_dec2238 = frozenset([45, 100])
    FOLLOW_100_in_table_type_dec2247 = frozenset([64])
    FOLLOW_64_in_table_type_dec2249 = frozenset([61, 131, 163])
    FOLLOW_61_in_table_type_dec2257 = frozenset([45])
    FOLLOW_131_in_table_type_dec2264 = frozenset([45])
    FOLLOW_163_in_table_type_dec2271 = frozenset([27])
    FOLLOW_LPAREN_in_table_type_dec2273 = frozenset([34])
    FOLLOW_integer_in_table_type_dec2275 = frozenset([44])
    FOLLOW_RPAREN_in_table_type_dec2277 = frozenset([45])
    FOLLOW_SEMI_in_table_type_dec2291 = frozenset([1])
    FOLLOW_plsql_table_name_in_table_var_dec2302 = frozenset([15, 22])
    FOLLOW_type_name_in_table_var_dec2304 = frozenset([45])
    FOLLOW_SEMI_in_table_var_dec2306 = frozenset([1])
    FOLLOW_identifier_in_plsql_table_name2317 = frozenset([1, 13])
    FOLLOW_DOT_in_plsql_table_name2321 = frozenset([15, 22])
    FOLLOW_identifier_in_plsql_table_name2323 = frozenset([1, 13])
    FOLLOW_keyTYPE_in_varray_declaration2337 = frozenset([15, 22])
    FOLLOW_type_name_in_varray_declaration2339 = frozenset([106])
    FOLLOW_106_in_varray_declaration2341 = frozenset([22])
    FOLLOW_keyVARRAY_in_varray_declaration2348 = frozenset([27])
    FOLLOW_keyVARYING_in_varray_declaration2352 = frozenset([22])
    FOLLOW_keyARRAY_in_varray_declaration2354 = frozenset([27])
    FOLLOW_LPAREN_in_varray_declaration2358 = frozenset([34])
    FOLLOW_integer_in_varray_declaration2360 = frozenset([44])
    FOLLOW_RPAREN_in_varray_declaration2362 = frozenset([125])
    FOLLOW_125_in_varray_declaration2366 = frozenset([15, 22, 58, 59, 60, 61, 62, 63, 66, 67, 68, 74, 75, 76, 82, 91, 102, 103, 109, 112, 114, 115, 116, 117, 121, 122, 123, 124, 131, 132, 137, 138, 144, 150, 160, 162, 163])
    FOLLOW_type_spec_in_varray_declaration2368 = frozenset([1, 118])
    FOLLOW_118_in_varray_declaration2372 = frozenset([120])
    FOLLOW_120_in_varray_declaration2374 = frozenset([1])
    FOLLOW_procedure_body_in_procedure_declaration2388 = frozenset([1])
    FOLLOW_proc_fun_start_in_procedure_body2401 = frozenset([135])
    FOLLOW_135_in_procedure_body2406 = frozenset([15, 22, 39])
    FOLLOW_procedure_name_in_procedure_body2409 = frozenset([27, 53, 106])
    FOLLOW_LPAREN_in_procedure_body2416 = frozenset([15, 22])
    FOLLOW_argument_in_procedure_body2418 = frozenset([11, 44])
    FOLLOW_COMMA_in_procedure_body2422 = frozenset([15, 22])
    FOLLOW_argument_in_procedure_body2424 = frozenset([11, 44])
    FOLLOW_RPAREN_in_procedure_body2429 = frozenset([53, 106])
    FOLLOW_set_in_procedure_body2437 = frozenset([15, 22, 56, 73, 94, 133, 135])
    FOLLOW_declare_spec_in_procedure_body2464 = frozenset([15, 22, 56, 73, 94, 133, 135])
    FOLLOW_56_in_procedure_body2475 = frozenset([10, 15, 22, 26, 56, 65, 70, 73, 77, 79, 90, 92, 94, 95, 98, 101, 108, 110, 120, 133, 135, 136, 140, 142, 144, 146, 147, 148, 159, 166])
    FOLLOW_seq_of_statements_in_procedure_body2483 = frozenset([85, 86])
    FOLLOW_86_in_procedure_body2491 = frozenset([85, 164])
    FOLLOW_exception_handler_in_procedure_body2495 = frozenset([85, 164])
    FOLLOW_85_in_procedure_body2505 = frozenset([15, 22, 39, 45])
    FOLLOW_procedure_name_in_procedure_body2509 = frozenset([45])
    FOLLOW_SEMI_in_procedure_body2514 = frozenset([1])
    FOLLOW_56_in_begin_block2525 = frozenset([10, 15, 22, 26, 56, 65, 70, 73, 77, 79, 90, 92, 94, 95, 98, 101, 108, 110, 120, 133, 135, 136, 140, 142, 144, 146, 147, 148, 159, 166])
    FOLLOW_seq_of_statements_in_begin_block2531 = frozenset([85, 86])
    FOLLOW_86_in_begin_block2539 = frozenset([164])
    FOLLOW_exception_handler_in_begin_block2543 = frozenset([85, 164])
    FOLLOW_85_in_begin_block2553 = frozenset([1])
    FOLLOW_164_in_exception_handler2565 = frozenset([15, 22])
    FOLLOW_exception_names_in_exception_handler2567 = frozenset([154])
    FOLLOW_154_in_exception_handler2569 = frozenset([10, 15, 22, 26, 56, 65, 70, 73, 77, 79, 90, 92, 94, 95, 98, 101, 108, 110, 120, 133, 135, 136, 140, 142, 144, 146, 147, 148, 159, 166])
    FOLLOW_seq_of_statements_in_exception_handler2573 = frozenset([1])
    FOLLOW_73_in_proc_fun_start2584 = frozenset([1, 127])
    FOLLOW_127_in_proc_fun_start2588 = frozenset([22])
    FOLLOW_keyREPLACE_in_proc_fun_start2590 = frozenset([1])
    FOLLOW_proc_fun_start_in_function_body2606 = frozenset([94])
    FOLLOW_94_in_function_body2611 = frozenset([15, 22, 39])
    FOLLOW_function_name_in_function_body2614 = frozenset([27, 140])
    FOLLOW_LPAREN_in_function_body2621 = frozenset([15, 22])
    FOLLOW_arguments_in_function_body2623 = frozenset([44])
    FOLLOW_RPAREN_in_function_body2625 = frozenset([140])
    FOLLOW_keyRETURN_in_function_body2633 = frozenset([15, 22, 58, 59, 60, 61, 62, 63, 66, 67, 68, 74, 75, 76, 82, 91, 102, 103, 109, 112, 114, 115, 116, 117, 121, 122, 123, 124, 131, 132, 137, 138, 144, 150, 160, 162, 163])
    FOLLOW_return_type_in_function_body2635 = frozenset([53, 106])
    FOLLOW_set_in_function_body2637 = frozenset([15, 22, 56, 73, 94, 133, 135])
    FOLLOW_declare_spec_in_function_body2664 = frozenset([15, 22, 56, 73, 94, 133, 135])
    FOLLOW_56_in_function_body2675 = frozenset([10, 15, 22, 26, 56, 65, 70, 73, 77, 79, 90, 92, 94, 95, 98, 101, 108, 110, 120, 133, 135, 136, 140, 142, 144, 146, 147, 148, 159, 166])
    FOLLOW_seq_of_statements_in_function_body2683 = frozenset([85, 86])
    FOLLOW_86_in_function_body2691 = frozenset([164])
    FOLLOW_exception_handler_in_function_body2695 = frozenset([85, 164])
    FOLLOW_85_in_function_body2705 = frozenset([15, 22, 39, 45])
    FOLLOW_function_name_in_function_body2709 = frozenset([45])
    FOLLOW_SEMI_in_function_body2714 = frozenset([1])
    FOLLOW_identifier_in_function_name2725 = frozenset([1])
    FOLLOW_QUOTED_STRING_in_function_name2729 = frozenset([1])
    FOLLOW_identifier_in_procedure_name2741 = frozenset([1])
    FOLLOW_QUOTED_STRING_in_procedure_name2745 = frozenset([1])
    FOLLOW_argument_in_arguments2757 = frozenset([1, 11])
    FOLLOW_COMMA_in_arguments2761 = frozenset([15, 22])
    FOLLOW_argument_in_arguments2763 = frozenset([1, 11])
    FOLLOW_argument_name_in_argument2777 = frozenset([1, 5, 15, 22, 58, 59, 60, 61, 62, 63, 66, 67, 68, 74, 75, 76, 78, 82, 91, 99, 102, 103, 109, 112, 114, 115, 116, 117, 121, 122, 123, 124, 129, 131, 132, 137, 138, 144, 150, 160, 162, 163])
    FOLLOW_keyOUT_in_argument2781 = frozenset([1, 5, 15, 22, 58, 59, 60, 61, 62, 63, 66, 67, 68, 74, 75, 76, 78, 82, 91, 102, 103, 109, 112, 114, 115, 116, 117, 121, 122, 123, 124, 131, 132, 137, 138, 144, 150, 160, 162, 163])
    FOLLOW_99_in_argument2785 = frozenset([129])
    FOLLOW_keyOUT_in_argument2787 = frozenset([1, 5, 15, 22, 58, 59, 60, 61, 62, 63, 66, 67, 68, 74, 75, 76, 78, 82, 91, 102, 103, 109, 112, 114, 115, 116, 117, 121, 122, 123, 124, 131, 132, 137, 138, 144, 150, 160, 162, 163])
    FOLLOW_99_in_argument2791 = frozenset([1, 5, 15, 22, 58, 59, 60, 61, 62, 63, 66, 67, 68, 74, 75, 76, 78, 82, 91, 102, 103, 109, 112, 114, 115, 116, 117, 121, 122, 123, 124, 131, 132, 137, 138, 144, 150, 160, 162, 163])
    FOLLOW_argument_type_in_argument2797 = frozenset([1, 5, 78])
    FOLLOW_set_in_argument2806 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_plsql_expression_in_argument2816 = frozenset([1])
    FOLLOW_identifier_in_argument_name2830 = frozenset([1])
    FOLLOW_type_spec_in_argument_type2841 = frozenset([1])
    FOLLOW_NUMBER_in_value2863 = frozenset([1])
    FOLLOW_quoted_string_in_value2868 = frozenset([1])
    FOLLOW_156_in_value2873 = frozenset([1])
    FOLLOW_89_in_value2877 = frozenset([1])
    FOLLOW_120_in_value2882 = frozenset([1])
    FOLLOW_type_spec_in_return_type2893 = frozenset([1])
    FOLLOW_function_body_in_function_declaration2904 = frozenset([1])
    FOLLOW_user_defined_function_in_function_call2915 = frozenset([1, 27])
    FOLLOW_LPAREN_in_function_call2921 = frozenset([15, 22, 27, 29, 34, 36, 39, 44, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_call_parameters_in_function_call2925 = frozenset([44])
    FOLLOW_RPAREN_in_function_call2930 = frozenset([1])
    FOLLOW_plsql_table_name_in_collection_function_call2949 = frozenset([1])
    FOLLOW_variable_name_in_variable_names2960 = frozenset([1, 11])
    FOLLOW_COMMA_in_variable_names2964 = frozenset([15, 22])
    FOLLOW_variable_name_in_variable_names2966 = frozenset([1, 11])
    FOLLOW_identifier_in_variable_name2979 = frozenset([1])
    FOLLOW_120_in_null_statement2990 = frozenset([1])
    FOLLOW_keyRAISE_in_raise_statement3002 = frozenset([1, 15, 22])
    FOLLOW_exception_name_in_raise_statement3006 = frozenset([1])
    FOLLOW_keyRETURN_in_return_statement3021 = frozenset([1, 15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_plsql_expression_in_return_statement3025 = frozenset([1])
    FOLLOW_LLABEL_in_loop_statement3041 = frozenset([15, 22])
    FOLLOW_label_name_in_loop_statement3043 = frozenset([41])
    FOLLOW_RLABEL_in_loop_statement3045 = frozenset([92, 110, 166])
    FOLLOW_keyWHILE_in_loop_statement3054 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_plsql_condition_in_loop_statement3057 = frozenset([110])
    FOLLOW_92_in_loop_statement3066 = frozenset([15, 22])
    FOLLOW_numeric_loop_param_in_loop_statement3083 = frozenset([110])
    FOLLOW_cursor_loop_param_in_loop_statement3099 = frozenset([110])
    FOLLOW_keyLOOP_in_loop_statement3120 = frozenset([10, 15, 22, 26, 56, 65, 70, 73, 77, 79, 90, 92, 94, 95, 98, 101, 108, 110, 120, 133, 135, 136, 140, 142, 144, 146, 147, 148, 159, 166])
    FOLLOW_seq_of_statements_in_loop_statement3124 = frozenset([85])
    FOLLOW_85_in_loop_statement3128 = frozenset([110])
    FOLLOW_keyLOOP_in_loop_statement3130 = frozenset([1, 15, 22])
    FOLLOW_label_name_in_loop_statement3137 = frozenset([1])
    FOLLOW_index_name_in_numeric_loop_param3151 = frozenset([99])
    FOLLOW_99_in_numeric_loop_param3153 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_keyREVERSE_in_numeric_loop_param3157 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_integer_expr_in_numeric_loop_param3162 = frozenset([14])
    FOLLOW_DOUBLEDOT_in_numeric_loop_param3164 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_integer_expr_in_numeric_loop_param3166 = frozenset([1])
    FOLLOW_identifier_in_index_name3177 = frozenset([1])
    FOLLOW_sql_expression_in_integer_expr3189 = frozenset([1])
    FOLLOW_identifier_in_cursor_name3200 = frozenset([1])
    FOLLOW_record_name_in_cursor_loop_param3211 = frozenset([99])
    FOLLOW_99_in_cursor_loop_param3213 = frozenset([15, 22, 27])
    FOLLOW_cursor_name_in_cursor_loop_param3219 = frozenset([1, 27])
    FOLLOW_LPAREN_in_cursor_loop_param3223 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_plsql_expressions_in_cursor_loop_param3225 = frozenset([44])
    FOLLOW_RPAREN_in_cursor_loop_param3227 = frozenset([1])
    FOLLOW_LPAREN_in_cursor_loop_param3236 = frozenset([147])
    FOLLOW_select_statement_in_cursor_loop_param3238 = frozenset([44])
    FOLLOW_RPAREN_in_cursor_loop_param3240 = frozenset([1])
    FOLLOW_identifier_in_record_name3255 = frozenset([1])
    FOLLOW_70_in_commit_statement3266 = frozenset([1])
    FOLLOW_98_in_if_statement3277 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_plsql_condition_in_if_statement3280 = frozenset([154])
    FOLLOW_154_in_if_statement3282 = frozenset([10, 15, 22, 26, 56, 65, 70, 73, 77, 79, 90, 92, 94, 95, 98, 101, 108, 110, 120, 133, 135, 136, 140, 142, 144, 146, 147, 148, 159, 166])
    FOLLOW_seq_of_statements_in_if_statement3284 = frozenset([83, 84, 85])
    FOLLOW_keyELSIF_in_if_statement3294 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_plsql_condition_in_if_statement3296 = frozenset([154])
    FOLLOW_154_in_if_statement3298 = frozenset([10, 15, 22, 26, 56, 65, 70, 73, 77, 79, 90, 92, 94, 95, 98, 101, 108, 110, 120, 133, 135, 136, 140, 142, 144, 146, 147, 148, 159, 166])
    FOLLOW_seq_of_statements_in_if_statement3300 = frozenset([83, 84, 85])
    FOLLOW_83_in_if_statement3311 = frozenset([10, 15, 22, 26, 56, 65, 70, 73, 77, 79, 90, 92, 94, 95, 98, 101, 108, 110, 120, 133, 135, 136, 140, 142, 144, 146, 147, 148, 159, 166])
    FOLLOW_seq_of_statements_in_if_statement3313 = frozenset([85])
    FOLLOW_85_in_if_statement3320 = frozenset([98])
    FOLLOW_98_in_if_statement3322 = frozenset([1])
    FOLLOW_sql_command_in_sql_statement3333 = frozenset([1])
    FOLLOW_to_modify_data_in_sql_command3344 = frozenset([1])
    FOLLOW_to_control_data_in_sql_command3349 = frozenset([1])
    FOLLOW_select_command_in_to_modify_data3360 = frozenset([1])
    FOLLOW_insert_command_in_to_modify_data3365 = frozenset([1])
    FOLLOW_update_command_in_to_modify_data3370 = frozenset([1])
    FOLLOW_delete_command_in_to_modify_data3375 = frozenset([1])
    FOLLOW_set_transaction_command_in_to_modify_data3380 = frozenset([1])
    FOLLOW_close_statement_in_to_control_data3391 = frozenset([1])
    FOLLOW_commit_statement_in_to_control_data3396 = frozenset([1])
    FOLLOW_fetch_statement_in_to_control_data3401 = frozenset([1])
    FOLLOW_lock_table_statement_in_to_control_data3406 = frozenset([1])
    FOLLOW_open_statement_in_to_control_data3411 = frozenset([1])
    FOLLOW_rollback_statement_in_to_control_data3416 = frozenset([1])
    FOLLOW_savepoint_statement_in_to_control_data3421 = frozenset([1])
    FOLLOW_select_statement_in_select_command3432 = frozenset([1])
    FOLLOW_select_expression_in_select_statement3446 = frozenset([1])
    FOLLOW_147_in_select_expression3461 = frozenset([6, 15, 22, 27, 29, 34, 36, 39, 50, 65, 81, 89, 120, 144, 147, 151, 156, 158])
    FOLLOW_select_list_in_select_expression3480 = frozenset([22, 93, 105])
    FOLLOW_keyBULK_in_select_expression3486 = frozenset([22])
    FOLLOW_keyCOLLECT_in_select_expression3488 = frozenset([93, 105])
    FOLLOW_105_in_select_expression3497 = frozenset([10, 15, 22])
    FOLLOW_lvalues_in_select_expression3499 = frozenset([93])
    FOLLOW_93_in_select_expression3506 = frozenset([15, 22, 27, 144, 153])
    FOLLOW_join_clause_in_select_expression3510 = frozenset([1, 22, 71, 96, 97, 104, 111, 128, 152, 157, 165])
    FOLLOW_LPAREN_in_select_expression3514 = frozenset([15, 22, 27, 144, 153])
    FOLLOW_join_clause_in_select_expression3516 = frozenset([44])
    FOLLOW_RPAREN_in_select_expression3518 = frozenset([1, 22, 71, 96, 97, 104, 111, 128, 152, 157, 165])
    FOLLOW_table_reference_list_in_select_expression3522 = frozenset([1, 22, 71, 96, 97, 104, 111, 128, 152, 157, 165])
    FOLLOW_where_clause_in_select_expression3530 = frozenset([1, 22, 71, 96, 97, 104, 111, 128, 152, 157])
    FOLLOW_hierarchical_query_clause_in_select_expression3537 = frozenset([1, 22, 96, 97, 104, 111, 128, 157])
    FOLLOW_group_by_clause_in_select_expression3544 = frozenset([1, 22, 97, 104, 111, 128, 157])
    FOLLOW_97_in_select_expression3553 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_sql_condition_in_select_expression3555 = frozenset([1, 22, 104, 111, 128, 157])
    FOLLOW_model_clause_in_select_expression3562 = frozenset([1, 104, 111, 128, 157])
    FOLLOW_157_in_select_expression3573 = frozenset([27, 50, 147])
    FOLLOW_50_in_select_expression3577 = frozenset([27, 147])
    FOLLOW_104_in_select_expression3587 = frozenset([27, 147])
    FOLLOW_111_in_select_expression3594 = frozenset([27, 147])
    FOLLOW_select_expression_in_select_expression3606 = frozenset([1, 128])
    FOLLOW_subquery_in_select_expression3614 = frozenset([1, 128])
    FOLLOW_order_by_clause_in_select_expression3630 = frozenset([1])
    FOLLOW_ASTERISK_in_select_list3644 = frozenset([1])
    FOLLOW_displayed_column_in_select_list3649 = frozenset([1, 11])
    FOLLOW_COMMA_in_select_list3653 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_displayed_column_in_select_list3655 = frozenset([1, 11])
    FOLLOW_93_in_table_reference_list_from3669 = frozenset([15, 22, 27, 144, 153])
    FOLLOW_table_reference_list_in_table_reference_list_from3671 = frozenset([1])
    FOLLOW_selected_table_in_table_reference_list3682 = frozenset([1, 11])
    FOLLOW_COMMA_in_table_reference_list3686 = frozenset([15, 22, 27, 144, 153])
    FOLLOW_selected_table_in_table_reference_list3688 = frozenset([1, 11])
    FOLLOW_selected_table_in_join_clause3702 = frozenset([22])
    FOLLOW_inner_cross_join_clause_in_join_clause3706 = frozenset([1, 22])
    FOLLOW_outer_join_clause_in_join_clause3710 = frozenset([1, 22])
    FOLLOW_keyINNER_in_inner_cross_join_clause3725 = frozenset([22])
    FOLLOW_keyJOIN_in_inner_cross_join_clause3730 = frozenset([15, 22, 144])
    FOLLOW_table_name_in_inner_cross_join_clause3732 = frozenset([22, 126])
    FOLLOW_126_in_inner_cross_join_clause3736 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_sql_condition_in_inner_cross_join_clause3738 = frozenset([1])
    FOLLOW_keyUSING_in_inner_cross_join_clause3742 = frozenset([27])
    FOLLOW_LPAREN_in_inner_cross_join_clause3744 = frozenset([15, 22, 144])
    FOLLOW_column_specs_in_inner_cross_join_clause3746 = frozenset([44])
    FOLLOW_RPAREN_in_inner_cross_join_clause3748 = frozenset([1])
    FOLLOW_keyCROSS_in_inner_cross_join_clause3757 = frozenset([22])
    FOLLOW_keyNATURAL_in_inner_cross_join_clause3761 = frozenset([22])
    FOLLOW_keyINNER_in_inner_cross_join_clause3765 = frozenset([22])
    FOLLOW_keyJOIN_in_inner_cross_join_clause3771 = frozenset([15, 22, 144])
    FOLLOW_table_name_in_inner_cross_join_clause3773 = frozenset([1])
    FOLLOW_query_partition_clause_in_outer_join_clause3785 = frozenset([22])
    FOLLOW_outer_join_type_in_outer_join_clause3794 = frozenset([22])
    FOLLOW_keyJOIN_in_outer_join_clause3796 = frozenset([15, 22, 27, 144, 153])
    FOLLOW_keyNATURAL_in_outer_join_clause3802 = frozenset([22])
    FOLLOW_outer_join_type_in_outer_join_clause3806 = frozenset([22])
    FOLLOW_keyJOIN_in_outer_join_clause3811 = frozenset([15, 22, 27, 144, 153])
    FOLLOW_selected_table_in_outer_join_clause3819 = frozenset([1, 22, 126])
    FOLLOW_query_partition_clause_in_outer_join_clause3823 = frozenset([1, 22, 126])
    FOLLOW_126_in_outer_join_clause3832 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_sql_condition_in_outer_join_clause3834 = frozenset([1])
    FOLLOW_keyUSING_in_outer_join_clause3838 = frozenset([27])
    FOLLOW_LPAREN_in_outer_join_clause3840 = frozenset([15, 22, 144])
    FOLLOW_column_specs_in_outer_join_clause3842 = frozenset([44])
    FOLLOW_RPAREN_in_outer_join_clause3844 = frozenset([1])
    FOLLOW_keyPARTITION_in_query_partition_clause3857 = frozenset([64])
    FOLLOW_64_in_query_partition_clause3859 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_expression_list_in_query_partition_clause3861 = frozenset([1])
    FOLLOW_keyFULL_in_outer_join_type3873 = frozenset([1, 22])
    FOLLOW_keyLEFT_in_outer_join_type3877 = frozenset([1, 22])
    FOLLOW_keyRIGHT_in_outer_join_type3881 = frozenset([1, 22])
    FOLLOW_keyOUTER_in_outer_join_type3887 = frozenset([1])
    FOLLOW_LPAREN_in_outer_join_sign3900 = frozenset([36])
    FOLLOW_PLUS_in_outer_join_sign3902 = frozenset([44])
    FOLLOW_RPAREN_in_outer_join_sign3904 = frozenset([1])
    FOLLOW_165_in_where_clause3914 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_sql_condition_in_where_clause3916 = frozenset([1])
    FOLLOW_152_in_hierarchical_query_clause3928 = frozenset([167])
    FOLLOW_167_in_hierarchical_query_clause3930 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_sql_condition_in_hierarchical_query_clause3932 = frozenset([71])
    FOLLOW_71_in_hierarchical_query_clause3937 = frozenset([64])
    FOLLOW_64_in_hierarchical_query_clause3939 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_keyNOCYCLE_in_hierarchical_query_clause3943 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_sql_condition_in_hierarchical_query_clause3948 = frozenset([1])
    FOLLOW_96_in_group_by_clause3958 = frozenset([64])
    FOLLOW_64_in_group_by_clause3960 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_group_by_exprs_in_group_by_clause3962 = frozenset([1])
    FOLLOW_group_by_expr_in_group_by_exprs3972 = frozenset([1, 11])
    FOLLOW_COMMA_in_group_by_exprs3976 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_group_by_expr_in_group_by_exprs3978 = frozenset([1, 11])
    FOLLOW_rollup_cube_clause_in_group_by_expr3991 = frozenset([1])
    FOLLOW_grouping_sets_clause_in_group_by_expr3996 = frozenset([1])
    FOLLOW_grouping_expression_list_in_group_by_expr4001 = frozenset([1])
    FOLLOW_keyROLLUP_in_rollup_cube_clause4013 = frozenset([27])
    FOLLOW_keyCUBE_in_rollup_cube_clause4017 = frozenset([27])
    FOLLOW_LPAREN_in_rollup_cube_clause4021 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_grouping_expression_list_in_rollup_cube_clause4023 = frozenset([44])
    FOLLOW_RPAREN_in_rollup_cube_clause4025 = frozenset([1])
    FOLLOW_keyGROUPING_in_grouping_sets_clause4035 = frozenset([22])
    FOLLOW_keySETS_in_grouping_sets_clause4037 = frozenset([27])
    FOLLOW_LPAREN_in_grouping_sets_clause4039 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_grouping_expression_list_in_grouping_sets_clause4041 = frozenset([44])
    FOLLOW_RPAREN_in_grouping_sets_clause4043 = frozenset([1])
    FOLLOW_grouping_sets_expr_in_grouping_sets_exprs4053 = frozenset([1, 11])
    FOLLOW_COMMA_in_grouping_sets_exprs4057 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_grouping_sets_expr_in_grouping_sets_exprs4059 = frozenset([1, 11])
    FOLLOW_rollup_cube_clause_in_grouping_sets_expr4072 = frozenset([1])
    FOLLOW_grouping_expression_list_in_grouping_sets_expr4076 = frozenset([1])
    FOLLOW_keyMODEL_in_model_clause4086 = frozenset([22, 140, 158])
    FOLLOW_cell_reference_options_in_model_clause4090 = frozenset([22, 140])
    FOLLOW_return_rows_clause_in_model_clause4098 = frozenset([22])
    FOLLOW_reference_model_in_model_clause4107 = frozenset([22])
    FOLLOW_main_model_in_model_clause4112 = frozenset([1])
    FOLLOW_keyIGNORE_in_cell_reference_options4126 = frozenset([22])
    FOLLOW_keyKEEP_in_cell_reference_options4130 = frozenset([22])
    FOLLOW_keyNAV_in_cell_reference_options4134 = frozenset([1, 158])
    FOLLOW_158_in_cell_reference_options4143 = frozenset([22])
    FOLLOW_keyDIMENSION_in_cell_reference_options4147 = frozenset([1])
    FOLLOW_keySINGLE_in_cell_reference_options4151 = frozenset([22])
    FOLLOW_keyREFERENCE_in_cell_reference_options4153 = frozenset([1])
    FOLLOW_keyRETURN_in_return_rows_clause4168 = frozenset([22, 50])
    FOLLOW_keyUPDATED_in_return_rows_clause4172 = frozenset([145])
    FOLLOW_50_in_return_rows_clause4176 = frozenset([145])
    FOLLOW_145_in_return_rows_clause4180 = frozenset([1])
    FOLLOW_keyREFERENCE_in_reference_model4190 = frozenset([15, 22])
    FOLLOW_reference_model_name_in_reference_model4192 = frozenset([126])
    FOLLOW_126_in_reference_model4194 = frozenset([27])
    FOLLOW_LPAREN_in_reference_model4196 = frozenset([27])
    FOLLOW_subquery_in_reference_model4198 = frozenset([44])
    FOLLOW_RPAREN_in_reference_model4200 = frozenset([22])
    FOLLOW_model_column_clauses_in_reference_model4204 = frozenset([22, 158])
    FOLLOW_cell_reference_options_in_reference_model4208 = frozenset([1])
    FOLLOW_identifier_in_reference_model_name4220 = frozenset([1])
    FOLLOW_keyMAIN_in_main_model4232 = frozenset([15, 22])
    FOLLOW_main_model_name_in_main_model4234 = frozenset([22])
    FOLLOW_model_column_clauses_in_main_model4239 = frozenset([22, 27, 158])
    FOLLOW_cell_reference_options_in_main_model4245 = frozenset([22, 27])
    FOLLOW_model_rules_clause_in_main_model4249 = frozenset([1])
    FOLLOW_identifier_in_main_model_name4259 = frozenset([1])
    FOLLOW_query_partition_clause_in_model_column_clauses4271 = frozenset([15, 22, 144])
    FOLLOW_column_spec_in_model_column_clauses4275 = frozenset([22])
    FOLLOW_keyDIMENSION_in_model_column_clauses4285 = frozenset([64])
    FOLLOW_64_in_model_column_clauses4287 = frozenset([27])
    FOLLOW_LPAREN_in_model_column_clauses4289 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_model_columns_in_model_column_clauses4291 = frozenset([44])
    FOLLOW_RPAREN_in_model_column_clauses4293 = frozenset([22])
    FOLLOW_keyMEASURES_in_model_column_clauses4297 = frozenset([27])
    FOLLOW_LPAREN_in_model_column_clauses4299 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_model_columns_in_model_column_clauses4301 = frozenset([44])
    FOLLOW_RPAREN_in_model_column_clauses4303 = frozenset([1])
    FOLLOW_model_column_in_model_columns4313 = frozenset([1, 11])
    FOLLOW_COMMA_in_model_columns4317 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_model_column_in_model_columns4319 = frozenset([1, 11])
    FOLLOW_sql_expression_in_model_column4332 = frozenset([1, 15, 22, 53, 144])
    FOLLOW_53_in_model_column4338 = frozenset([15, 22, 144])
    FOLLOW_column_spec_in_model_column4343 = frozenset([1])
    FOLLOW_keyRULES_in_model_rules_clause4358 = frozenset([22, 27, 159])
    FOLLOW_159_in_model_rules_clause4362 = frozenset([22, 27])
    FOLLOW_keyUPSERT_in_model_rules_clause4366 = frozenset([22, 27, 50])
    FOLLOW_50_in_model_rules_clause4370 = frozenset([22, 27])
    FOLLOW_keyAUTOMATIC_in_model_rules_clause4382 = frozenset([128])
    FOLLOW_keySEQUENTIAL_in_model_rules_clause4386 = frozenset([128])
    FOLLOW_128_in_model_rules_clause4390 = frozenset([22, 27])
    FOLLOW_keyITERATE_in_model_rules_clause4402 = frozenset([27])
    FOLLOW_LPAREN_in_model_rules_clause4404 = frozenset([34])
    FOLLOW_NUMBER_in_model_rules_clause4406 = frozenset([44])
    FOLLOW_RPAREN_in_model_rules_clause4408 = frozenset([22, 27])
    FOLLOW_keyUNTIL_in_model_rules_clause4412 = frozenset([27])
    FOLLOW_LPAREN_in_model_rules_clause4414 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_sql_condition_in_model_rules_clause4416 = frozenset([44])
    FOLLOW_RPAREN_in_model_rules_clause4418 = frozenset([27])
    FOLLOW_LPAREN_in_model_rules_clause4428 = frozenset([15, 22, 144, 159])
    FOLLOW_model_rules_exprs_in_model_rules_clause4430 = frozenset([44])
    FOLLOW_RPAREN_in_model_rules_clause4432 = frozenset([1])
    FOLLOW_model_rules_expr_in_model_rules_exprs4442 = frozenset([1, 11])
    FOLLOW_COMMA_in_model_rules_exprs4446 = frozenset([15, 22, 144, 159])
    FOLLOW_model_rules_expr_in_model_rules_exprs4448 = frozenset([1, 11])
    FOLLOW_159_in_model_rules_expr4463 = frozenset([15, 22, 144])
    FOLLOW_keyUPSERT_in_model_rules_expr4467 = frozenset([15, 22, 50, 144])
    FOLLOW_50_in_model_rules_expr4471 = frozenset([15, 22, 144])
    FOLLOW_cell_assignment_in_model_rules_expr4479 = frozenset([17, 128])
    FOLLOW_order_by_clause_in_model_rules_expr4483 = frozenset([17])
    FOLLOW_EQ_in_model_rules_expr4488 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expression_in_model_rules_expr4490 = frozenset([1])
    FOLLOW_measure_column_in_cell_assignment4500 = frozenset([24])
    FOLLOW_LBRACK_in_cell_assignment4502 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 92, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_multi_column_for_loop_in_cell_assignment4506 = frozenset([40])
    FOLLOW_cell_assignment_exprs_in_cell_assignment4510 = frozenset([40])
    FOLLOW_RBRACK_in_cell_assignment4514 = frozenset([1])
    FOLLOW_cell_assignment_expr_in_cell_assignment_exprs4524 = frozenset([1, 11])
    FOLLOW_COMMA_in_cell_assignment_exprs4528 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 92, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_cell_assignment_expr_in_cell_assignment_exprs4530 = frozenset([1, 11])
    FOLLOW_sql_condition_in_cell_assignment_expr4543 = frozenset([1])
    FOLLOW_sql_expression_in_cell_assignment_expr4547 = frozenset([1])
    FOLLOW_single_column_for_loop_in_cell_assignment_expr4551 = frozenset([1])
    FOLLOW_column_name_in_measure_column4561 = frozenset([1])
    FOLLOW_92_in_single_column_for_loop4571 = frozenset([15, 22, 144])
    FOLLOW_column_name_in_single_column_for_loop4573 = frozenset([93, 99, 107])
    FOLLOW_99_in_single_column_for_loop4579 = frozenset([27])
    FOLLOW_LPAREN_in_single_column_for_loop4581 = frozenset([27, 29, 34, 36, 39])
    FOLLOW_literals_in_single_column_for_loop4585 = frozenset([44])
    FOLLOW_subquery_in_single_column_for_loop4589 = frozenset([44])
    FOLLOW_RPAREN_in_single_column_for_loop4593 = frozenset([1])
    FOLLOW_107_in_single_column_for_loop4601 = frozenset([39])
    FOLLOW_pattern_in_single_column_for_loop4603 = frozenset([93])
    FOLLOW_93_in_single_column_for_loop4608 = frozenset([29, 34, 36, 39])
    FOLLOW_literal_in_single_column_for_loop4610 = frozenset([155])
    FOLLOW_155_in_single_column_for_loop4612 = frozenset([29, 34, 36, 39])
    FOLLOW_literal_in_single_column_for_loop4614 = frozenset([22])
    FOLLOW_keyINCREMENT_in_single_column_for_loop4618 = frozenset([29, 34, 36, 39])
    FOLLOW_keyDECREMENT_in_single_column_for_loop4622 = frozenset([29, 34, 36, 39])
    FOLLOW_literal_in_single_column_for_loop4626 = frozenset([1])
    FOLLOW_NUMBER_in_literal4651 = frozenset([1])
    FOLLOW_QUOTED_STRING_in_literal4656 = frozenset([1])
    FOLLOW_literal_in_literals4666 = frozenset([1, 11])
    FOLLOW_COMMA_in_literals4670 = frozenset([29, 34, 36, 39])
    FOLLOW_literal_in_literals4672 = frozenset([1, 11])
    FOLLOW_LPAREN_in_bracket_literals4685 = frozenset([29, 34, 36, 39])
    FOLLOW_literals_in_bracket_literals4687 = frozenset([44])
    FOLLOW_RPAREN_in_bracket_literals4689 = frozenset([1])
    FOLLOW_bracket_literals_in_bracket_literals_list4699 = frozenset([1, 11])
    FOLLOW_COMMA_in_bracket_literals_list4703 = frozenset([27])
    FOLLOW_bracket_literals_in_bracket_literals_list4705 = frozenset([1, 11])
    FOLLOW_QUOTED_STRING_in_pattern4718 = frozenset([1])
    FOLLOW_92_in_multi_column_for_loop4728 = frozenset([27])
    FOLLOW_LPAREN_in_multi_column_for_loop4730 = frozenset([15, 22, 144])
    FOLLOW_column_specs_in_multi_column_for_loop4732 = frozenset([44])
    FOLLOW_RPAREN_in_multi_column_for_loop4734 = frozenset([99])
    FOLLOW_99_in_multi_column_for_loop4736 = frozenset([27])
    FOLLOW_LPAREN_in_multi_column_for_loop4738 = frozenset([27])
    FOLLOW_bracket_literals_list_in_multi_column_for_loop4742 = frozenset([44])
    FOLLOW_subquery_in_multi_column_for_loop4746 = frozenset([44])
    FOLLOW_RPAREN_in_multi_column_for_loop4750 = frozenset([1])
    FOLLOW_128_in_order_by_clause4760 = frozenset([22, 64])
    FOLLOW_keySIBLINGS_in_order_by_clause4764 = frozenset([64])
    FOLLOW_64_in_order_by_clause4769 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_order_by_exprs_in_order_by_clause4771 = frozenset([1])
    FOLLOW_order_by_expr_in_order_by_exprs4781 = frozenset([1, 11])
    FOLLOW_COMMA_in_order_by_exprs4785 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_order_by_expr_in_order_by_exprs4787 = frozenset([1, 11])
    FOLLOW_sql_expression_in_order_by_expr4802 = frozenset([1, 22, 54, 80])
    FOLLOW_54_in_order_by_expr4825 = frozenset([1, 22])
    FOLLOW_80_in_order_by_expr4829 = frozenset([1, 22])
    FOLLOW_keyNULLS_in_order_by_expr4836 = frozenset([22])
    FOLLOW_keyFIRST_in_order_by_expr4838 = frozenset([1])
    FOLLOW_keyNULLS_in_order_by_expr4842 = frozenset([22])
    FOLLOW_keyLAST_in_order_by_expr4844 = frozenset([1])
    FOLLOW_92_in_for_update_clause4857 = frozenset([159])
    FOLLOW_159_in_for_update_clause4859 = frozenset([1, 22, 119, 125])
    FOLLOW_125_in_for_update_clause4863 = frozenset([15, 22, 144])
    FOLLOW_column_specs_in_for_update_clause4865 = frozenset([1, 22, 119])
    FOLLOW_keyWAIT_in_for_update_clause4872 = frozenset([34])
    FOLLOW_integer_in_for_update_clause4874 = frozenset([1])
    FOLLOW_119_in_for_update_clause4878 = frozenset([1])
    FOLLOW_165_in_where_condition_whole4892 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_sql_condition_in_where_condition_whole4894 = frozenset([1])
    FOLLOW_sql_condition_in_where_condition4905 = frozenset([1])
    FOLLOW_column_spec_in_displayed_column4918 = frozenset([13])
    FOLLOW_DOT_in_displayed_column4920 = frozenset([6])
    FOLLOW_ASTERISK_in_displayed_column4922 = frozenset([1, 15, 22, 53, 144])
    FOLLOW_sql_expression_in_displayed_column4930 = frozenset([1, 15, 22, 53, 144])
    FOLLOW_alias_in_displayed_column4940 = frozenset([1])
    FOLLOW_sql_identifier_in_schema_name4954 = frozenset([1])
    FOLLOW_sql_identifier_in_table_name4965 = frozenset([1])
    FOLLOW_nested_expression_in_nested_expressions4976 = frozenset([1, 11])
    FOLLOW_COMMA_in_nested_expressions4980 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_nested_expression_in_nested_expressions4982 = frozenset([1, 11])
    FOLLOW_sql_expression_in_nested_expression4998 = frozenset([1])
    FOLLOW_plsql_expression_in_nested_expression5005 = frozenset([1])
    FOLLOW_expr_bool_in_plsql_condition5022 = frozenset([1])
    FOLLOW_plsql_expression_in_plsql_expressions5033 = frozenset([1, 11])
    FOLLOW_COMMA_in_plsql_expressions5037 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_plsql_expression_in_plsql_expressions5039 = frozenset([1, 11])
    FOLLOW_expr_bool_in_plsql_expression5060 = frozenset([1])
    FOLLOW_expr_or_in_expr_bool5072 = frozenset([1, 127])
    FOLLOW_127_in_expr_bool5076 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_expr_or_in_expr_bool5078 = frozenset([1, 127])
    FOLLOW_expr_and_in_expr_or5091 = frozenset([1, 51])
    FOLLOW_51_in_expr_or5095 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_expr_and_in_expr_or5097 = frozenset([1, 51])
    FOLLOW_118_in_expr_and5112 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_expr_not_in_expr_and5117 = frozenset([1])
    FOLLOW_expr_add_in_expr_not5127 = frozenset([1, 8, 17, 19, 20, 21, 23, 25, 28, 32, 33, 42, 57, 99, 106, 107, 118])
    FOLLOW_relational_op_in_expr_not5134 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_expr_add_in_expr_not5136 = frozenset([1, 8, 17, 19, 20, 21, 23, 25, 28, 32, 33, 42, 57, 99, 106, 107, 118])
    FOLLOW_FOUND_ATTR_in_expr_not5142 = frozenset([1, 8, 17, 19, 20, 21, 23, 25, 28, 32, 33, 42, 57, 99, 106, 107, 118])
    FOLLOW_NOTFOUND_ATTR_in_expr_not5146 = frozenset([1, 8, 17, 19, 20, 21, 23, 25, 28, 32, 33, 42, 57, 99, 106, 107, 118])
    FOLLOW_ISOPEN_ATTR_in_expr_not5150 = frozenset([1, 8, 17, 19, 20, 21, 23, 25, 28, 32, 33, 42, 57, 99, 106, 107, 118])
    FOLLOW_ROWCOUNT_ATTR_in_expr_not5154 = frozenset([1, 8, 17, 19, 20, 21, 23, 25, 28, 32, 33, 42, 57, 99, 106, 107, 118])
    FOLLOW_BULK_ROWCOUNT_ATTR_in_expr_not5158 = frozenset([1, 8, 17, 19, 20, 21, 23, 25, 28, 32, 33, 42, 57, 99, 106, 107, 118])
    FOLLOW_106_in_expr_not5164 = frozenset([118, 120])
    FOLLOW_118_in_expr_not5168 = frozenset([120])
    FOLLOW_120_in_expr_not5173 = frozenset([1, 8, 17, 19, 20, 21, 23, 25, 28, 32, 33, 42, 57, 99, 106, 107, 118])
    FOLLOW_118_in_expr_not5181 = frozenset([107])
    FOLLOW_107_in_expr_not5186 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_expr_add_in_expr_not5188 = frozenset([1, 8, 17, 19, 20, 21, 23, 25, 28, 32, 33, 42, 57, 99, 106, 107, 118])
    FOLLOW_118_in_expr_not5196 = frozenset([57])
    FOLLOW_57_in_expr_not5201 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_expr_add_in_expr_not5203 = frozenset([51])
    FOLLOW_51_in_expr_not5205 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_expr_add_in_expr_not5207 = frozenset([1, 8, 17, 19, 20, 21, 23, 25, 28, 32, 33, 42, 57, 99, 106, 107, 118])
    FOLLOW_118_in_expr_not5215 = frozenset([99])
    FOLLOW_99_in_expr_not5220 = frozenset([27])
    FOLLOW_LPAREN_in_expr_not5222 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_nested_expressions_in_expr_not5224 = frozenset([44])
    FOLLOW_RPAREN_in_expr_not5226 = frozenset([1, 8, 17, 19, 20, 21, 23, 25, 28, 32, 33, 42, 57, 99, 106, 107, 118])
    FOLLOW_sql_expression_in_sql_expressions5257 = frozenset([1, 11])
    FOLLOW_COMMA_in_sql_expressions5261 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expression_in_sql_expressions5263 = frozenset([1, 11])
    FOLLOW_expr_add_in_sql_expression5283 = frozenset([1])
    FOLLOW_expr_mul_in_expr_add5293 = frozenset([1, 16, 29, 36])
    FOLLOW_set_in_expr_add5297 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_expr_mul_in_expr_add5311 = frozenset([1, 16, 29, 36])
    FOLLOW_expr_sign_in_expr_mul5324 = frozenset([1, 6, 12])
    FOLLOW_set_in_expr_mul5328 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_expr_sign_in_expr_mul5338 = frozenset([1, 6, 12])
    FOLLOW_expr_pow_in_expr_sign5362 = frozenset([1])
    FOLLOW_expr_expr_in_expr_pow5372 = frozenset([1, 18])
    FOLLOW_EXPONENT_in_expr_pow5376 = frozenset([15, 22, 27, 34, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_expr_expr_in_expr_pow5378 = frozenset([1, 18])
    FOLLOW_expr_paren_in_expr_expr5399 = frozenset([1])
    FOLLOW_function_expression_in_expr_expr5412 = frozenset([1])
    FOLLOW_case_expression_in_expr_expr5426 = frozenset([1])
    FOLLOW_cursor_expression_in_expr_expr5439 = frozenset([1])
    FOLLOW_simple_expression_in_expr_expr5452 = frozenset([1])
    FOLLOW_select_expression_in_expr_expr5465 = frozenset([1])
    FOLLOW_boolean_literal_in_simple_expression5484 = frozenset([1])
    FOLLOW_151_in_simple_expression5489 = frozenset([8, 19, 23, 32, 42])
    FOLLOW_set_in_simple_expression5491 = frozenset([1])
    FOLLOW_column_spec_in_simple_expression5524 = frozenset([1])
    FOLLOW_QUOTED_STRING_in_simple_expression5529 = frozenset([1])
    FOLLOW_NUMBER_in_simple_expression5534 = frozenset([1])
    FOLLOW_120_in_simple_expression5542 = frozenset([1])
    FOLLOW_expr_prior_in_compound_expression5554 = frozenset([1])
    FOLLOW_LPAREN_in_expr_paren5566 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_nested_expression_in_expr_paren5568 = frozenset([44])
    FOLLOW_RPAREN_in_expr_paren5570 = frozenset([1])
    FOLLOW_134_in_expr_prior5580 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_expr_add_in_expr_prior5582 = frozenset([1])
    FOLLOW_65_in_case_expression5592 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156, 164])
    FOLLOW_simple_case_expression_in_case_expression5596 = frozenset([83, 85])
    FOLLOW_searched_case_expression_in_case_expression5600 = frozenset([83, 85])
    FOLLOW_else_case_expression_in_case_expression5606 = frozenset([85])
    FOLLOW_85_in_case_expression5611 = frozenset([1])
    FOLLOW_nested_expression_in_simple_case_expression5621 = frozenset([164])
    FOLLOW_164_in_simple_case_expression5625 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_nested_expression_in_simple_case_expression5627 = frozenset([154])
    FOLLOW_154_in_simple_case_expression5629 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_nested_expression_in_simple_case_expression5631 = frozenset([1, 164])
    FOLLOW_164_in_searched_case_expression5646 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_nested_condition_in_searched_case_expression5648 = frozenset([154])
    FOLLOW_154_in_searched_case_expression5650 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_nested_expression_in_searched_case_expression5652 = frozenset([1, 164])
    FOLLOW_83_in_else_case_expression5665 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_nested_expression_in_else_case_expression5667 = frozenset([1])
    FOLLOW_label_name_in_case_statement5679 = frozenset([65])
    FOLLOW_65_in_case_statement5684 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156, 164])
    FOLLOW_simple_case_statement_in_case_statement5689 = frozenset([83, 85])
    FOLLOW_searched_case_statement_in_case_statement5693 = frozenset([83, 85])
    FOLLOW_else_case_statement_in_case_statement5699 = frozenset([85])
    FOLLOW_85_in_case_statement5704 = frozenset([65])
    FOLLOW_65_in_case_statement5706 = frozenset([1, 15, 22])
    FOLLOW_label_name_in_case_statement5710 = frozenset([1])
    FOLLOW_plsql_expression_in_simple_case_statement5723 = frozenset([164])
    FOLLOW_164_in_simple_case_statement5727 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_plsql_expression_in_simple_case_statement5729 = frozenset([154])
    FOLLOW_154_in_simple_case_statement5731 = frozenset([10, 15, 22, 26, 56, 65, 70, 73, 77, 79, 90, 92, 94, 95, 98, 101, 108, 110, 120, 133, 135, 136, 140, 142, 144, 146, 147, 148, 159, 166])
    FOLLOW_seq_of_statements_in_simple_case_statement5733 = frozenset([1, 164])
    FOLLOW_164_in_searched_case_statement5748 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_plsql_expression_in_searched_case_statement5750 = frozenset([154])
    FOLLOW_154_in_searched_case_statement5752 = frozenset([10, 15, 22, 26, 56, 65, 70, 73, 77, 79, 90, 92, 94, 95, 98, 101, 108, 110, 120, 133, 135, 136, 140, 142, 144, 146, 147, 148, 159, 166])
    FOLLOW_seq_of_statements_in_searched_case_statement5754 = frozenset([1, 164])
    FOLLOW_83_in_else_case_statement5767 = frozenset([10, 15, 22, 26, 56, 65, 70, 73, 77, 79, 90, 92, 94, 95, 98, 101, 108, 110, 120, 133, 135, 136, 140, 142, 144, 146, 147, 148, 159, 166])
    FOLLOW_seq_of_statements_in_else_case_statement5769 = frozenset([1])
    FOLLOW_keyCURSOR_in_cursor_expression5779 = frozenset([27])
    FOLLOW_LPAREN_in_cursor_expression5781 = frozenset([27])
    FOLLOW_subquery_in_cursor_expression5783 = frozenset([44])
    FOLLOW_RPAREN_in_cursor_expression5785 = frozenset([1])
    FOLLOW_sql_expression_in_datetime_expression5795 = frozenset([55])
    FOLLOW_55_in_datetime_expression5797 = frozenset([22])
    FOLLOW_keyLOCAL_in_datetime_expression5803 = frozenset([1])
    FOLLOW_keyTIME_in_datetime_expression5809 = frozenset([22])
    FOLLOW_keyZONE_in_datetime_expression5811 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_keyDBTIMEZONE_in_datetime_expression5815 = frozenset([1])
    FOLLOW_keySESSIONTIMEZONE_in_datetime_expression5819 = frozenset([1])
    FOLLOW_sql_expression_in_datetime_expression5823 = frozenset([1])
    FOLLOW_function_call_in_function_expression5839 = frozenset([1, 13])
    FOLLOW_DOT_in_function_expression5843 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_nested_expression_in_function_expression5845 = frozenset([1])
    FOLLOW_keyCOUNT_in_function_expression5859 = frozenset([27])
    FOLLOW_LPAREN_in_function_expression5861 = frozenset([6, 15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_ASTERISK_in_function_expression5865 = frozenset([44])
    FOLLOW_nested_expression_in_function_expression5869 = frozenset([44])
    FOLLOW_RPAREN_in_function_expression5873 = frozenset([1])
    FOLLOW_81_in_function_expression5879 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_LPAREN_in_function_expression5883 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_nested_expression_in_function_expression5885 = frozenset([44])
    FOLLOW_RPAREN_in_function_expression5887 = frozenset([1])
    FOLLOW_nested_expression_in_function_expression5891 = frozenset([1])
    FOLLOW_keyCOUNT_in_special_expression5913 = frozenset([27])
    FOLLOW_LPAREN_in_special_expression5915 = frozenset([6, 15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_ASTERISK_in_special_expression5919 = frozenset([44])
    FOLLOW_nested_expression_in_special_expression5923 = frozenset([44])
    FOLLOW_RPAREN_in_special_expression5927 = frozenset([1])
    FOLLOW_81_in_special_expression5933 = frozenset([27])
    FOLLOW_LPAREN_in_special_expression5935 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_nested_expression_in_special_expression5937 = frozenset([44])
    FOLLOW_RPAREN_in_special_expression5939 = frozenset([1])
    FOLLOW_sql_expression_in_interval_expression5953 = frozenset([22])
    FOLLOW_keyDAY_in_interval_expression5959 = frozenset([27, 155])
    FOLLOW_LPAREN_in_interval_expression5963 = frozenset([34])
    FOLLOW_leading_field_precision_in_interval_expression5965 = frozenset([44])
    FOLLOW_RPAREN_in_interval_expression5967 = frozenset([155])
    FOLLOW_155_in_interval_expression5972 = frozenset([22])
    FOLLOW_keySECOND_in_interval_expression5974 = frozenset([1, 27])
    FOLLOW_LPAREN_in_interval_expression5978 = frozenset([34])
    FOLLOW_fractional_second_precision_in_interval_expression5980 = frozenset([44])
    FOLLOW_RPAREN_in_interval_expression5982 = frozenset([1])
    FOLLOW_keyYEAR_in_interval_expression5991 = frozenset([27, 155])
    FOLLOW_LPAREN_in_interval_expression5995 = frozenset([34])
    FOLLOW_leading_field_precision_in_interval_expression5997 = frozenset([44])
    FOLLOW_RPAREN_in_interval_expression5999 = frozenset([155])
    FOLLOW_155_in_interval_expression6004 = frozenset([22])
    FOLLOW_keyMONTH_in_interval_expression6006 = frozenset([1])
    FOLLOW_integer_in_leading_field_precision6020 = frozenset([1])
    FOLLOW_integer_in_fractional_second_precision6031 = frozenset([1])
    FOLLOW_identifier_in_sequence_name6082 = frozenset([1])
    FOLLOW_NUMBER_in_integer6092 = frozenset([1])
    FOLLOW_53_in_alias6106 = frozenset([15, 22, 144])
    FOLLOW_sql_identifier_in_alias6111 = frozenset([1])
    FOLLOW_column_spec_in_column_specs6122 = frozenset([1, 11])
    FOLLOW_COMMA_in_column_specs6126 = frozenset([15, 22, 144])
    FOLLOW_column_spec_in_column_specs6128 = frozenset([1, 11])
    FOLLOW_sql_identifier_in_column_spec6142 = frozenset([1, 13])
    FOLLOW_DOT_in_column_spec6146 = frozenset([15, 22, 144])
    FOLLOW_sql_identifier_in_column_spec6148 = frozenset([1, 13])
    FOLLOW_DOT_in_column_spec6152 = frozenset([15, 22, 144])
    FOLLOW_sql_identifier_in_column_spec6154 = frozenset([1])
    FOLLOW_sql_identifier_in_column_name6176 = frozenset([1])
    FOLLOW_sql_identifier_in_nested_table6186 = frozenset([1])
    FOLLOW_schema_name_in_nested_table_column_name6198 = frozenset([13])
    FOLLOW_DOT_in_nested_table_column_name6200 = frozenset([15, 22, 144])
    FOLLOW_table_name_in_nested_table_column_name6205 = frozenset([13])
    FOLLOW_DOT_in_nested_table_column_name6207 = frozenset([15, 22, 144])
    FOLLOW_nested_table_in_nested_table_column_name6209 = frozenset([13])
    FOLLOW_DOT_in_nested_table_column_name6211 = frozenset([15, 22, 144])
    FOLLOW_column_name_in_nested_table_column_name6213 = frozenset([1])
    FOLLOW_sql_identifier_in_user_defined_function6224 = frozenset([1, 13])
    FOLLOW_DOT_in_user_defined_function6228 = frozenset([15, 22, 144])
    FOLLOW_sql_identifier_in_user_defined_function6230 = frozenset([1, 13])
    FOLLOW_DOT_in_user_defined_function6237 = frozenset([79, 88, 134])
    FOLLOW_set_in_user_defined_function6239 = frozenset([1])
    FOLLOW_table_spec_in_selected_table6277 = frozenset([1, 15, 22, 53, 144])
    FOLLOW_153_in_selected_table6283 = frozenset([27])
    FOLLOW_keyTHE_in_selected_table6287 = frozenset([27])
    FOLLOW_subquery_in_selected_table6292 = frozenset([1, 15, 22, 53, 144])
    FOLLOW_alias_in_selected_table6298 = frozenset([1])
    FOLLOW_schema_name_in_table_spec6314 = frozenset([13])
    FOLLOW_DOT_in_table_spec6316 = frozenset([15, 22, 144])
    FOLLOW_table_name_in_table_spec6321 = frozenset([1, 7])
    FOLLOW_AT_SIGN_in_table_spec6325 = frozenset([15, 22, 144])
    FOLLOW_link_name_in_table_spec6327 = frozenset([1])
    FOLLOW_schema_name_in_table_alias6343 = frozenset([13])
    FOLLOW_DOT_in_table_alias6345 = frozenset([15, 22, 144])
    FOLLOW_table_name_in_table_alias6350 = frozenset([1, 7, 15, 22, 53, 144])
    FOLLOW_AT_SIGN_in_table_alias6354 = frozenset([15, 22, 144])
    FOLLOW_link_name_in_table_alias6356 = frozenset([1, 15, 22, 53, 144])
    FOLLOW_alias_in_table_alias6363 = frozenset([1])
    FOLLOW_sql_identifier_in_link_name6377 = frozenset([1])
    FOLLOW_condition_or_in_nested_condition6389 = frozenset([1])
    FOLLOW_expr_bool_in_nested_condition6396 = frozenset([1])
    FOLLOW_condition_or_in_sql_condition6413 = frozenset([1])
    FOLLOW_LPAREN_in_condition_paren6424 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_sql_condition_in_condition_paren6426 = frozenset([44])
    FOLLOW_RPAREN_in_condition_paren6428 = frozenset([1])
    FOLLOW_condition_and_in_condition_or6438 = frozenset([1, 127])
    FOLLOW_127_in_condition_or6442 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_condition_and_in_condition_or6444 = frozenset([1, 127])
    FOLLOW_condition_not_in_condition_and6457 = frozenset([1, 51])
    FOLLOW_51_in_condition_and6461 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_condition_not_in_condition_and6463 = frozenset([1, 51])
    FOLLOW_118_in_condition_not6476 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 120, 134, 144, 147, 151, 156])
    FOLLOW_condition_expr_in_condition_not6478 = frozenset([1])
    FOLLOW_condition_expr_in_condition_not6483 = frozenset([1])
    FOLLOW_condition_exists_in_condition_expr6493 = frozenset([1])
    FOLLOW_condition_is_in_condition_expr6498 = frozenset([1])
    FOLLOW_condition_comparison_in_condition_expr6503 = frozenset([1])
    FOLLOW_condition_group_comparison_in_condition_expr6508 = frozenset([1])
    FOLLOW_condition_in_in_condition_expr6513 = frozenset([1])
    FOLLOW_condition_is_a_set_in_condition_expr6518 = frozenset([1])
    FOLLOW_condition_is_any_in_condition_expr6523 = frozenset([1])
    FOLLOW_condition_is_empty_in_condition_expr6528 = frozenset([1])
    FOLLOW_condition_is_of_type_in_condition_expr6533 = frozenset([1])
    FOLLOW_condition_is_present_in_condition_expr6538 = frozenset([1])
    FOLLOW_condition_like_in_condition_expr6543 = frozenset([1])
    FOLLOW_condition_memeber_in_condition_expr6548 = frozenset([1])
    FOLLOW_condition_between_in_condition_expr6553 = frozenset([1])
    FOLLOW_condition_regexp_like_in_condition_expr6558 = frozenset([1])
    FOLLOW_condition_submultiset_in_condition_expr6563 = frozenset([1])
    FOLLOW_condition_equals_path_in_condition_expr6568 = frozenset([1])
    FOLLOW_condition_under_path_in_condition_expr6573 = frozenset([1])
    FOLLOW_condition_paren_in_condition_expr6578 = frozenset([1])
    FOLLOW_88_in_condition_exists6588 = frozenset([27])
    FOLLOW_LPAREN_in_condition_exists6590 = frozenset([147])
    FOLLOW_select_command_in_condition_exists6592 = frozenset([44])
    FOLLOW_RPAREN_in_condition_exists6594 = frozenset([1])
    FOLLOW_sql_expression_in_condition_is6604 = frozenset([106])
    FOLLOW_106_in_condition_is6606 = frozenset([22, 118, 120])
    FOLLOW_118_in_condition_is6610 = frozenset([22, 120])
    FOLLOW_keyNAN_in_condition_is6617 = frozenset([1])
    FOLLOW_keyINFINITE_in_condition_is6621 = frozenset([1])
    FOLLOW_120_in_condition_is6625 = frozenset([1])
    FOLLOW_LPAREN_in_condition_comparison6637 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expressions_in_condition_comparison6639 = frozenset([44])
    FOLLOW_RPAREN_in_condition_comparison6641 = frozenset([17, 27, 33])
    FOLLOW_outer_join_sign_in_condition_comparison6645 = frozenset([17, 33])
    FOLLOW_set_in_condition_comparison6650 = frozenset([27])
    FOLLOW_LPAREN_in_condition_comparison6660 = frozenset([147])
    FOLLOW_select_command_in_condition_comparison6662 = frozenset([44])
    FOLLOW_RPAREN_in_condition_comparison6664 = frozenset([1, 27])
    FOLLOW_outer_join_sign_in_condition_comparison6668 = frozenset([1])
    FOLLOW_134_in_condition_comparison6678 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expression_in_condition_comparison6683 = frozenset([17, 20, 21, 25, 27, 28, 33])
    FOLLOW_outer_join_sign_in_condition_comparison6687 = frozenset([17, 20, 21, 25, 28, 33])
    FOLLOW_set_in_condition_comparison6692 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 134, 144, 147, 151, 156])
    FOLLOW_134_in_condition_comparison6720 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expression_in_condition_comparison6727 = frozenset([1, 27])
    FOLLOW_LPAREN_in_condition_comparison6731 = frozenset([147])
    FOLLOW_select_command_in_condition_comparison6733 = frozenset([44])
    FOLLOW_RPAREN_in_condition_comparison6735 = frozenset([1, 27])
    FOLLOW_outer_join_sign_in_condition_comparison6741 = frozenset([1])
    FOLLOW_LPAREN_in_condition_group_comparison6754 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expressions_in_condition_group_comparison6756 = frozenset([44])
    FOLLOW_RPAREN_in_condition_group_comparison6758 = frozenset([17, 33])
    FOLLOW_set_in_condition_group_comparison6760 = frozenset([22, 50, 52])
    FOLLOW_52_in_condition_group_comparison6772 = frozenset([27])
    FOLLOW_keySOME_in_condition_group_comparison6776 = frozenset([27])
    FOLLOW_50_in_condition_group_comparison6780 = frozenset([27])
    FOLLOW_LPAREN_in_condition_group_comparison6784 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_grouping_expression_list_in_condition_group_comparison6788 = frozenset([44])
    FOLLOW_select_command_in_condition_group_comparison6792 = frozenset([44])
    FOLLOW_RPAREN_in_condition_group_comparison6796 = frozenset([1])
    FOLLOW_sql_expression_in_condition_group_comparison6801 = frozenset([17, 20, 21, 25, 28, 33])
    FOLLOW_set_in_condition_group_comparison6803 = frozenset([22, 50, 52])
    FOLLOW_52_in_condition_group_comparison6831 = frozenset([27])
    FOLLOW_keySOME_in_condition_group_comparison6835 = frozenset([27])
    FOLLOW_50_in_condition_group_comparison6839 = frozenset([27])
    FOLLOW_LPAREN_in_condition_group_comparison6843 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expressions_in_condition_group_comparison6847 = frozenset([44])
    FOLLOW_select_command_in_condition_group_comparison6851 = frozenset([44])
    FOLLOW_RPAREN_in_condition_group_comparison6855 = frozenset([1])
    FOLLOW_LPAREN_in_condition_in6865 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expressions_in_condition_in6867 = frozenset([44])
    FOLLOW_RPAREN_in_condition_in6869 = frozenset([99, 118])
    FOLLOW_118_in_condition_in6873 = frozenset([99])
    FOLLOW_99_in_condition_in6878 = frozenset([27])
    FOLLOW_LPAREN_in_condition_in6880 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_grouping_expression_list_in_condition_in6884 = frozenset([44])
    FOLLOW_select_command_in_condition_in6888 = frozenset([44])
    FOLLOW_RPAREN_in_condition_in6892 = frozenset([1])
    FOLLOW_sql_expression_in_condition_in6897 = frozenset([99, 118])
    FOLLOW_118_in_condition_in6901 = frozenset([99])
    FOLLOW_99_in_condition_in6906 = frozenset([27])
    FOLLOW_LPAREN_in_condition_in6908 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_expression_list_in_condition_in6912 = frozenset([44])
    FOLLOW_select_command_in_condition_in6916 = frozenset([44])
    FOLLOW_RPAREN_in_condition_in6920 = frozenset([1])
    FOLLOW_nested_table_column_name_in_condition_is_a_set6930 = frozenset([106])
    FOLLOW_106_in_condition_is_a_set6932 = frozenset([22, 118])
    FOLLOW_118_in_condition_is_a_set6936 = frozenset([22])
    FOLLOW_keyA_in_condition_is_a_set6941 = frozenset([148])
    FOLLOW_148_in_condition_is_a_set6943 = frozenset([1])
    FOLLOW_column_name_in_condition_is_any6955 = frozenset([106])
    FOLLOW_106_in_condition_is_any6957 = frozenset([52])
    FOLLOW_52_in_condition_is_any6962 = frozenset([1])
    FOLLOW_nested_table_column_name_in_condition_is_empty6972 = frozenset([106])
    FOLLOW_106_in_condition_is_empty6974 = frozenset([22, 118])
    FOLLOW_118_in_condition_is_empty6978 = frozenset([22])
    FOLLOW_keyEMPTY_in_condition_is_empty6983 = frozenset([1])
    FOLLOW_sql_expression_in_condition_is_of_type6993 = frozenset([106])
    FOLLOW_106_in_condition_is_of_type6995 = frozenset([118, 125])
    FOLLOW_118_in_condition_is_of_type6999 = frozenset([125])
    FOLLOW_125_in_condition_is_of_type7004 = frozenset([22, 27])
    FOLLOW_keyTYPE_in_condition_is_of_type7008 = frozenset([27])
    FOLLOW_LPAREN_in_condition_is_of_type7013 = frozenset([15, 22])
    FOLLOW_type_name_in_condition_is_of_type7015 = frozenset([44])
    FOLLOW_RPAREN_in_condition_is_of_type7017 = frozenset([1])
    FOLLOW_condition_is_of_type_name_in_condition_is_of_type_names7027 = frozenset([1, 11])
    FOLLOW_COMMA_in_condition_is_of_type_names7031 = frozenset([15, 22])
    FOLLOW_condition_is_of_type_name_in_condition_is_of_type_names7033 = frozenset([1, 11])
    FOLLOW_keyONLY_in_condition_is_of_type_name7048 = frozenset([15, 22])
    FOLLOW_type_name_in_condition_is_of_type_name7053 = frozenset([1])
    FOLLOW_cell_reference_in_condition_is_present7063 = frozenset([106])
    FOLLOW_106_in_condition_is_present7065 = frozenset([22])
    FOLLOW_keyPRESENT_in_condition_is_present7067 = frozenset([1])
    FOLLOW_sql_expression_in_condition_like7077 = frozenset([22, 107, 118])
    FOLLOW_118_in_condition_like7081 = frozenset([22, 107])
    FOLLOW_107_in_condition_like7088 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_keyLIKEC_in_condition_like7092 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_keyLIKE2_in_condition_like7096 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_keyLIKE4_in_condition_like7100 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expression_in_condition_like7104 = frozenset([1, 22])
    FOLLOW_keyESCAPE_in_condition_like7108 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expression_in_condition_like7110 = frozenset([1])
    FOLLOW_sql_expression_in_condition_memeber7123 = frozenset([22, 118])
    FOLLOW_118_in_condition_memeber7127 = frozenset([22])
    FOLLOW_keyMEMBER_in_condition_memeber7132 = frozenset([15, 22, 125, 144])
    FOLLOW_125_in_condition_memeber7136 = frozenset([15, 22, 144])
    FOLLOW_nested_table_column_name_in_condition_memeber7141 = frozenset([1])
    FOLLOW_sql_expression_in_condition_between7151 = frozenset([57, 118])
    FOLLOW_118_in_condition_between7155 = frozenset([57])
    FOLLOW_57_in_condition_between7160 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expression_in_condition_between7162 = frozenset([51])
    FOLLOW_51_in_condition_between7164 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expression_in_condition_between7166 = frozenset([1])
    FOLLOW_keyREGEXP_LIKE_in_condition_regexp_like7176 = frozenset([27])
    FOLLOW_LPAREN_in_condition_regexp_like7178 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_call_parameters_in_condition_regexp_like7180 = frozenset([44])
    FOLLOW_RPAREN_in_condition_regexp_like7182 = frozenset([1])
    FOLLOW_nested_table_column_name_in_condition_submultiset7192 = frozenset([22, 118])
    FOLLOW_118_in_condition_submultiset7196 = frozenset([22])
    FOLLOW_keySUBMULTISET_in_condition_submultiset7201 = frozenset([15, 22, 125, 144])
    FOLLOW_125_in_condition_submultiset7205 = frozenset([15, 22, 144])
    FOLLOW_nested_table_column_name_in_condition_submultiset7210 = frozenset([1])
    FOLLOW_keyEQUALS_PATH_in_condition_equals_path7220 = frozenset([27])
    FOLLOW_LPAREN_in_condition_equals_path7222 = frozenset([15, 22, 144])
    FOLLOW_column_name_in_condition_equals_path7224 = frozenset([11])
    FOLLOW_COMMA_in_condition_equals_path7226 = frozenset([39])
    FOLLOW_path_string_in_condition_equals_path7228 = frozenset([11, 44])
    FOLLOW_COMMA_in_condition_equals_path7232 = frozenset([34])
    FOLLOW_correlation_integer_in_condition_equals_path7234 = frozenset([44])
    FOLLOW_RPAREN_in_condition_equals_path7239 = frozenset([1])
    FOLLOW_keyUNDER_PATH_in_condition_under_path7249 = frozenset([27])
    FOLLOW_LPAREN_in_condition_under_path7251 = frozenset([15, 22, 144])
    FOLLOW_column_name_in_condition_under_path7253 = frozenset([11])
    FOLLOW_COMMA_in_condition_under_path7257 = frozenset([34])
    FOLLOW_levels_in_condition_under_path7259 = frozenset([11])
    FOLLOW_COMMA_in_condition_under_path7264 = frozenset([39])
    FOLLOW_path_string_in_condition_under_path7266 = frozenset([11, 44])
    FOLLOW_COMMA_in_condition_under_path7270 = frozenset([34])
    FOLLOW_correlation_integer_in_condition_under_path7272 = frozenset([44])
    FOLLOW_RPAREN_in_condition_under_path7277 = frozenset([1])
    FOLLOW_integer_in_levels7287 = frozenset([1])
    FOLLOW_integer_in_correlation_integer7297 = frozenset([1])
    FOLLOW_QUOTED_STRING_in_path_string7307 = frozenset([1])
    FOLLOW_expression_list_in_grouping_expression_list7317 = frozenset([1, 11])
    FOLLOW_COMMA_in_grouping_expression_list7321 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_expression_list_in_grouping_expression_list7323 = frozenset([1, 11])
    FOLLOW_LPAREN_in_expression_list7336 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expressions_in_expression_list7338 = frozenset([44])
    FOLLOW_RPAREN_in_expression_list7340 = frozenset([1])
    FOLLOW_sql_expressions_in_expression_list7345 = frozenset([1])
    FOLLOW_sql_identifier_in_cell_reference7355 = frozenset([1])
    FOLLOW_call_parameter_in_call_parameters7365 = frozenset([1, 11])
    FOLLOW_COMMA_in_call_parameters7369 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_call_parameter_in_call_parameters7371 = frozenset([1, 11])
    FOLLOW_parameter_name_in_call_parameter7386 = frozenset([4])
    FOLLOW_ARROW_in_call_parameter7388 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_nested_expression_in_call_parameter7393 = frozenset([1])
    FOLLOW_sql_expression_in_exp_set7443 = frozenset([1])
    FOLLOW_subquery_in_exp_set7448 = frozenset([1])
    FOLLOW_LPAREN_in_subquery7459 = frozenset([147])
    FOLLOW_select_command_in_subquery7461 = frozenset([44])
    FOLLOW_RPAREN_in_subquery7463 = frozenset([1])
    FOLLOW_152_in_connect_clause7476 = frozenset([167])
    FOLLOW_167_in_connect_clause7478 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_sql_condition_in_connect_clause7480 = frozenset([71])
    FOLLOW_71_in_connect_clause7487 = frozenset([64])
    FOLLOW_64_in_connect_clause7489 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 134, 144, 147, 151, 156])
    FOLLOW_134_in_connect_clause7496 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expression_in_connect_clause7498 = frozenset([17, 20, 21, 25, 28, 33])
    FOLLOW_relational_op_in_connect_clause7500 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expression_in_connect_clause7502 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_sql_expression_in_connect_clause7508 = frozenset([17, 20, 21, 25, 28, 33])
    FOLLOW_relational_op_in_connect_clause7510 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expression_in_connect_clause7512 = frozenset([134])
    FOLLOW_134_in_connect_clause7514 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_134_in_connect_clause7540 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_sql_condition_in_connect_clause7544 = frozenset([1, 152])
    FOLLOW_sql_expression_in_connect_clause7550 = frozenset([17, 20, 21, 25, 28, 33])
    FOLLOW_relational_op_in_connect_clause7552 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 134, 144, 147, 151, 156])
    FOLLOW_134_in_connect_clause7556 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expression_in_connect_clause7561 = frozenset([1, 51, 152])
    FOLLOW_51_in_connect_clause7565 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_sql_condition_in_connect_clause7567 = frozenset([1, 152])
    FOLLOW_152_in_connect_clause7580 = frozenset([167])
    FOLLOW_167_in_connect_clause7582 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_sql_condition_in_connect_clause7584 = frozenset([1])
    FOLLOW_96_in_group_clause7598 = frozenset([64])
    FOLLOW_64_in_group_clause7600 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expression_in_group_clause7602 = frozenset([1, 11, 97])
    FOLLOW_COMMA_in_group_clause7606 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expression_in_group_clause7608 = frozenset([1, 11, 97])
    FOLLOW_97_in_group_clause7615 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_sql_condition_in_group_clause7617 = frozenset([1])
    FOLLOW_157_in_set_clause7635 = frozenset([50])
    FOLLOW_50_in_set_clause7637 = frozenset([147])
    FOLLOW_104_in_set_clause7643 = frozenset([147])
    FOLLOW_111_in_set_clause7647 = frozenset([147])
    FOLLOW_select_command_in_set_clause7651 = frozenset([1])
    FOLLOW_128_in_order_clause7663 = frozenset([64])
    FOLLOW_64_in_order_clause7665 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sorted_def_in_order_clause7667 = frozenset([1, 11])
    FOLLOW_COMMA_in_order_clause7671 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sorted_def_in_order_clause7673 = frozenset([1, 11])
    FOLLOW_sql_expression_in_sorted_def7697 = frozenset([1, 54, 80])
    FOLLOW_NUMBER_in_sorted_def7709 = frozenset([1, 54, 80])
    FOLLOW_92_in_update_clause7733 = frozenset([159])
    FOLLOW_159_in_update_clause7735 = frozenset([1, 119, 125])
    FOLLOW_125_in_update_clause7739 = frozenset([15, 22, 144])
    FOLLOW_column_name_in_update_clause7741 = frozenset([1, 11, 119])
    FOLLOW_COMMA_in_update_clause7745 = frozenset([15, 22, 144])
    FOLLOW_column_name_in_update_clause7747 = frozenset([1, 11, 119])
    FOLLOW_119_in_update_clause7757 = frozenset([1])
    FOLLOW_101_in_insert_command7771 = frozenset([105])
    FOLLOW_105_in_insert_command7773 = frozenset([15, 22, 27, 144, 153])
    FOLLOW_table_reference_list_in_insert_command7775 = frozenset([27, 147, 161])
    FOLLOW_LPAREN_in_insert_command7781 = frozenset([15, 22, 144])
    FOLLOW_column_specs_in_insert_command7783 = frozenset([44])
    FOLLOW_RPAREN_in_insert_command7785 = frozenset([147, 161])
    FOLLOW_161_in_insert_command7794 = frozenset([27])
    FOLLOW_LPAREN_in_insert_command7796 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_plsql_expressions_in_insert_command7798 = frozenset([44])
    FOLLOW_RPAREN_in_insert_command7800 = frozenset([1, 140, 141])
    FOLLOW_select_statement_in_insert_command7806 = frozenset([1, 140, 141])
    FOLLOW_returning_clause_in_insert_command7816 = frozenset([1])
    FOLLOW_159_in_update_command7830 = frozenset([15, 22, 27, 144, 153])
    FOLLOW_selected_table_in_update_command7832 = frozenset([148])
    FOLLOW_148_in_update_command7836 = frozenset([15, 22, 27, 144])
    FOLLOW_update_nested_column_specs_in_update_command7843 = frozenset([1, 140, 141, 165])
    FOLLOW_update_column_specs_in_update_command7849 = frozenset([1, 140, 141, 165])
    FOLLOW_165_in_update_command7859 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_keyCURRENT_OF_in_update_command7866 = frozenset([15, 22])
    FOLLOW_cursor_name_in_update_command7868 = frozenset([1, 140, 141])
    FOLLOW_sql_condition_in_update_command7875 = frozenset([1, 140, 141])
    FOLLOW_returning_clause_in_update_command7891 = frozenset([1])
    FOLLOW_update_column_spec_in_update_column_specs7905 = frozenset([1, 11])
    FOLLOW_COMMA_in_update_column_specs7909 = frozenset([15, 22, 144])
    FOLLOW_update_column_spec_in_update_column_specs7911 = frozenset([1, 11])
    FOLLOW_column_spec_in_update_column_spec7925 = frozenset([17])
    FOLLOW_EQ_in_update_column_spec7927 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expression_in_update_column_spec7929 = frozenset([1])
    FOLLOW_update_nested_column_spec_in_update_nested_column_specs7940 = frozenset([1, 11])
    FOLLOW_COMMA_in_update_nested_column_specs7944 = frozenset([27])
    FOLLOW_update_nested_column_spec_in_update_nested_column_specs7946 = frozenset([1, 11])
    FOLLOW_LPAREN_in_update_nested_column_spec7960 = frozenset([15, 22, 144])
    FOLLOW_column_specs_in_update_nested_column_spec7962 = frozenset([44])
    FOLLOW_RPAREN_in_update_nested_column_spec7964 = frozenset([17])
    FOLLOW_EQ_in_update_nested_column_spec7966 = frozenset([27])
    FOLLOW_subquery_in_update_nested_column_spec7968 = frozenset([1])
    FOLLOW_79_in_delete_command7979 = frozenset([15, 22, 27, 93, 144, 153])
    FOLLOW_93_in_delete_command7983 = frozenset([15, 22, 27, 144, 153])
    FOLLOW_selected_table_in_delete_command7988 = frozenset([1, 140, 141, 165])
    FOLLOW_165_in_delete_command7994 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_keyCURRENT_OF_in_delete_command8001 = frozenset([15, 22])
    FOLLOW_cursor_name_in_delete_command8003 = frozenset([1, 140, 141])
    FOLLOW_sql_condition_in_delete_command8010 = frozenset([1, 140, 141])
    FOLLOW_returning_clause_in_delete_command8026 = frozenset([1])
    FOLLOW_keyRETURN_in_returning_clause8042 = frozenset([6, 15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_keyRETURNING_in_returning_clause8046 = frozenset([6, 15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_select_list_in_returning_clause8050 = frozenset([22, 105])
    FOLLOW_keyBULK_in_returning_clause8054 = frozenset([22])
    FOLLOW_keyCOLLECT_in_returning_clause8056 = frozenset([105])
    FOLLOW_105_in_returning_clause8061 = frozenset([10, 15, 22])
    FOLLOW_lvalues_in_returning_clause8063 = frozenset([1])
    FOLLOW_148_in_set_transaction_command8074 = frozenset([22])
    FOLLOW_keyTRANSACTION_in_set_transaction_command8076 = frozenset([22])
    FOLLOW_keyREAD_in_set_transaction_command8078 = frozenset([22])
    FOLLOW_keyONLY_in_set_transaction_command8080 = frozenset([1])
    FOLLOW_keyCLOSE_in_close_statement8091 = frozenset([15, 22])
    FOLLOW_cursor_name_in_close_statement8093 = frozenset([1])
    FOLLOW_90_in_fetch_statement8104 = frozenset([15, 22])
    FOLLOW_cursor_name_in_fetch_statement8106 = frozenset([105])
    FOLLOW_105_in_fetch_statement8108 = frozenset([15, 22])
    FOLLOW_variable_names_in_fetch_statement8115 = frozenset([1])
    FOLLOW_record_name_in_fetch_statement8121 = frozenset([1])
    FOLLOW_108_in_lock_table_statement8136 = frozenset([153])
    FOLLOW_153_in_lock_table_statement8138 = frozenset([15, 22, 27, 144, 153])
    FOLLOW_table_reference_list_in_lock_table_statement8140 = frozenset([99])
    FOLLOW_99_in_lock_table_statement8144 = frozenset([87, 143, 149])
    FOLLOW_lock_mode_in_lock_table_statement8146 = frozenset([113])
    FOLLOW_113_in_lock_table_statement8148 = frozenset([1, 119])
    FOLLOW_119_in_lock_table_statement8152 = frozenset([1])
    FOLLOW_143_in_lock_mode8166 = frozenset([149])
    FOLLOW_149_in_lock_mode8168 = frozenset([1])
    FOLLOW_143_in_lock_mode8173 = frozenset([87])
    FOLLOW_87_in_lock_mode8175 = frozenset([1])
    FOLLOW_149_in_lock_mode8180 = frozenset([159])
    FOLLOW_159_in_lock_mode8182 = frozenset([1])
    FOLLOW_149_in_lock_mode8187 = frozenset([1])
    FOLLOW_149_in_lock_mode8192 = frozenset([143])
    FOLLOW_143_in_lock_mode8194 = frozenset([87])
    FOLLOW_87_in_lock_mode8196 = frozenset([1])
    FOLLOW_87_in_lock_mode8201 = frozenset([1])
    FOLLOW_keyOPEN_in_open_statement8212 = frozenset([15, 22])
    FOLLOW_cursor_name_in_open_statement8214 = frozenset([1, 27])
    FOLLOW_LPAREN_in_open_statement8218 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_plsql_expressions_in_open_statement8220 = frozenset([44])
    FOLLOW_RPAREN_in_open_statement8222 = frozenset([1])
    FOLLOW_keyROLLBACK_in_rollback_statement8236 = frozenset([1, 22, 69, 155])
    FOLLOW_keyWORK_in_rollback_statement8240 = frozenset([1, 69, 155])
    FOLLOW_155_in_rollback_statement8249 = frozenset([15, 22, 146])
    FOLLOW_146_in_rollback_statement8253 = frozenset([15, 22])
    FOLLOW_savepoint_name_in_rollback_statement8258 = frozenset([1, 69])
    FOLLOW_69_in_rollback_statement8267 = frozenset([39])
    FOLLOW_quoted_string_in_rollback_statement8269 = frozenset([1])
    FOLLOW_146_in_savepoint_statement8283 = frozenset([15, 22])
    FOLLOW_savepoint_name_in_savepoint_statement8285 = frozenset([1])
    FOLLOW_identifier_in_savepoint_name8296 = frozenset([1])
    FOLLOW_QUOTED_STRING_in_quoted_string8328 = frozenset([1])
    FOLLOW_QUOTED_STRING_in_match_string8339 = frozenset([1])
    FOLLOW_ID_in_keyA8378 = frozenset([1])
    FOLLOW_ID_in_keyAUTOMATIC8407 = frozenset([1])
    FOLLOW_ID_in_keyCOUNT8440 = frozenset([1])
    FOLLOW_ID_in_keyCROSS8473 = frozenset([1])
    FOLLOW_ID_in_keyCUBE8507 = frozenset([1])
    FOLLOW_ID_in_keyCURRENT_OF8535 = frozenset([1])
    FOLLOW_ID_in_keyDAY8570 = frozenset([1])
    FOLLOW_ID_in_keyDBTIMEZONE8598 = frozenset([1])
    FOLLOW_ID_in_keyDECREMENT8627 = frozenset([1])
    FOLLOW_ID_in_keyDIMENSION8656 = frozenset([1])
    FOLLOW_ID_in_keyEMPTY8689 = frozenset([1])
    FOLLOW_ID_in_keyEQUALS_PATH8716 = frozenset([1])
    FOLLOW_ID_in_keyESCAPE8748 = frozenset([1])
    FOLLOW_ID_in_keyFIRST8781 = frozenset([1])
    FOLLOW_ID_in_keyFULL8815 = frozenset([1])
    FOLLOW_ID_in_keyGROUPING8845 = frozenset([1])
    FOLLOW_ID_in_keyIGNORE8877 = frozenset([1])
    FOLLOW_ID_in_keyINCREMENT8906 = frozenset([1])
    FOLLOW_ID_in_keyINFINITE8936 = frozenset([1])
    FOLLOW_ID_in_keyINNER8969 = frozenset([1])
    FOLLOW_ID_in_keyINTERVAL8999 = frozenset([1])
    FOLLOW_ID_in_keyITERATE9030 = frozenset([1])
    FOLLOW_ID_in_keyJOIN9064 = frozenset([1])
    FOLLOW_ID_in_keyKEEP9098 = frozenset([1])
    FOLLOW_ID_in_keyLAST9132 = frozenset([1])
    FOLLOW_ID_in_keyLEFT9166 = frozenset([1])
    FOLLOW_ID_in_keyLIKE29199 = frozenset([1])
    FOLLOW_ID_in_keyLIKE49232 = frozenset([1])
    FOLLOW_ID_in_keyLIKEC9265 = frozenset([1])
    FOLLOW_ID_in_keyLOCAL9298 = frozenset([1])
    FOLLOW_ID_in_keyMAIN9332 = frozenset([1])
    FOLLOW_ID_in_keyMEASURES9362 = frozenset([1])
    FOLLOW_ID_in_keyMEMBER9394 = frozenset([1])
    FOLLOW_ID_in_keyMODEL9427 = frozenset([1])
    FOLLOW_ID_in_keyMONTH9460 = frozenset([1])
    FOLLOW_ID_in_keyNAN9495 = frozenset([1])
    FOLLOW_ID_in_keyNATURAL9526 = frozenset([1])
    FOLLOW_ID_in_keyNAV9561 = frozenset([1])
    FOLLOW_ID_in_keyNOCYCLE9592 = frozenset([1])
    FOLLOW_ID_in_keyNULLS9625 = frozenset([1])
    FOLLOW_ID_in_keyONLY9659 = frozenset([1])
    FOLLOW_ID_in_keyOUTER9692 = frozenset([1])
    FOLLOW_ID_in_keyPARTITION9721 = frozenset([1])
    FOLLOW_ID_in_keyPRECISION9750 = frozenset([1])
    FOLLOW_ID_in_keyPRESENT9781 = frozenset([1])
    FOLLOW_ID_in_keyREFERENCE9810 = frozenset([1])
    FOLLOW_ID_in_keyREGEXP_LIKE9837 = frozenset([1])
    FOLLOW_ID_in_keyRIGHT9871 = frozenset([1])
    FOLLOW_ID_in_keyROLLUP9903 = frozenset([1])
    FOLLOW_ID_in_keyRULES9936 = frozenset([1])
    FOLLOW_ID_in_keySECOND9968 = frozenset([1])
    FOLLOW_ID_in_keySECONDS9999 = frozenset([1])
    FOLLOW_ID_in_keySEQUENTIAL10027 = frozenset([1])
    FOLLOW_ID_in_keySESSIONTIMEZONE10050 = frozenset([1])
    FOLLOW_ID_in_keySETS10084 = frozenset([1])
    FOLLOW_ID_in_keySIBLINGS10114 = frozenset([1])
    FOLLOW_ID_in_keySINGLE10146 = frozenset([1])
    FOLLOW_ID_in_keySOME10180 = frozenset([1])
    FOLLOW_ID_in_keySUBMULTISET10207 = frozenset([1])
    FOLLOW_ID_in_keyTIME10241 = frozenset([1])
    FOLLOW_ID_in_keyTIMESTAMP10270 = frozenset([1])
    FOLLOW_ID_in_keyTHE10305 = frozenset([1])
    FOLLOW_ID_in_keyUNDER_PATH10333 = frozenset([1])
    FOLLOW_ID_in_keyUNTIL10366 = frozenset([1])
    FOLLOW_ID_in_keyUPDATED10397 = frozenset([1])
    FOLLOW_ID_in_keyUPSERT10429 = frozenset([1])
    FOLLOW_ID_in_keyWAIT10463 = frozenset([1])
    FOLLOW_ID_in_keyYEAR10497 = frozenset([1])
    FOLLOW_ID_in_keyZONE10531 = frozenset([1])
    FOLLOW_ID_in_keyARRAY10565 = frozenset([1])
    FOLLOW_ID_in_keyAUTONOMOUS_TRANSACTION10581 = frozenset([1])
    FOLLOW_ID_in_keyBODY10615 = frozenset([1])
    FOLLOW_ID_in_keyBUILTIN10646 = frozenset([1])
    FOLLOW_ID_in_keyBULK10680 = frozenset([1])
    FOLLOW_ID_in_keyBYTE10714 = frozenset([1])
    FOLLOW_ID_in_keyCLOSE10747 = frozenset([1])
    FOLLOW_ID_in_keyCOLLECT10778 = frozenset([1])
    FOLLOW_ID_in_keyCURSOR10810 = frozenset([1])
    FOLLOW_84_in_keyELSIF10841 = frozenset([1])
    FOLLOW_ID_in_keyEXCEPTION_INIT10866 = frozenset([1])
    FOLLOW_ID_in_keyEXIT10900 = frozenset([1])
    FOLLOW_ID_in_keyFIPSFLAG10930 = frozenset([1])
    FOLLOW_94_in_keyFUNCTION10958 = frozenset([1])
    FOLLOW_ID_in_keyINTERFACE10988 = frozenset([1])
    FOLLOW_110_in_keyLOOP11020 = frozenset([1])
    FOLLOW_ID_in_keyNEW11056 = frozenset([1])
    FOLLOW_ID_in_keyNEW_NAMES11085 = frozenset([1])
    FOLLOW_ID_in_keyOPEN11119 = frozenset([1])
    FOLLOW_129_in_keyOUT11152 = frozenset([1])
    FOLLOW_130_in_keyPACKAGE11182 = frozenset([1])
    FOLLOW_133_in_keyPRAGMA11213 = frozenset([1])
    FOLLOW_136_in_keyRAISE11245 = frozenset([1])
    FOLLOW_ID_in_keyRANGE11279 = frozenset([1])
    FOLLOW_ID_in_keyREAD11313 = frozenset([1])
    FOLLOW_139_in_keyRECORD11343 = frozenset([1])
    FOLLOW_ID_in_keyREF11379 = frozenset([1])
    FOLLOW_ID_in_keyREPLACE11410 = frozenset([1])
    FOLLOW_ID_in_keyRESTRICT_REFERENCES11429 = frozenset([1])
    FOLLOW_140_in_keyRETURN11459 = frozenset([1])
    FOLLOW_141_in_keyRETURNING11487 = frozenset([1])
    FOLLOW_ID_in_keyREVERSE11519 = frozenset([1])
    FOLLOW_142_in_keyROLLBACK11547 = frozenset([1])
    FOLLOW_ID_in_keySERIALLY_REUSABLE11569 = frozenset([1])
    FOLLOW_ID_in_keySUBTYPE11600 = frozenset([1])
    FOLLOW_ID_in_keyTRANSACTION11627 = frozenset([1])
    FOLLOW_ID_in_keyTYPE11661 = frozenset([1])
    FOLLOW_ID_in_keyUSING11694 = frozenset([1])
    FOLLOW_ID_in_keyVARRAY11726 = frozenset([1])
    FOLLOW_ID_in_keyVARYING11756 = frozenset([1])
    FOLLOW_166_in_keyWHILE11787 = frozenset([1])
    FOLLOW_ID_in_keyWORK11822 = frozenset([1])
    FOLLOW_identifier_in_sql_identifier11831 = frozenset([1])
    FOLLOW_144_in_sql_identifier11836 = frozenset([1])
    FOLLOW_type_declaration_in_synpred13_PLSQL3234 = frozenset([1])
    FOLLOW_subtype_declaration_in_synpred14_PLSQL3239 = frozenset([1])
    FOLLOW_keyNEW_in_synpred27_PLSQL3361 = frozenset([1])
    FOLLOW_assignment_statement_in_synpred43_PLSQL3562 = frozenset([1])
    FOLLOW_exit_statement_in_synpred44_PLSQL3567 = frozenset([1])
    FOLLOW_case_statement_in_synpred46_PLSQL3577 = frozenset([1])
    FOLLOW_loop_statement_in_synpred48_PLSQL3588 = frozenset([1])
    FOLLOW_sql_statement_in_synpred52_PLSQL3609 = frozenset([1])
    FOLLOW_plsql_block_in_synpred53_PLSQL3614 = frozenset([1])
    FOLLOW_subtype_declaration_in_synpred62_PLSQL3723 = frozenset([1])
    FOLLOW_type_declaration_in_synpred70_PLSQL3769 = frozenset([1])
    FOLLOW_keyRESTRICT_REFERENCES_in_synpred73_PLSQL3793 = frozenset([27])
    FOLLOW_LPAREN_in_synpred73_PLSQL3795 = frozenset([15, 22, 39, 78])
    FOLLOW_78_in_synpred73_PLSQL3799 = frozenset([11])
    FOLLOW_function_name_in_synpred73_PLSQL3803 = frozenset([11])
    FOLLOW_COMMA_in_synpred73_PLSQL3809 = frozenset([15, 22, 29, 34, 36, 39])
    FOLLOW_pragma_param_in_synpred73_PLSQL3811 = frozenset([11, 44])
    FOLLOW_RPAREN_in_synpred73_PLSQL3816 = frozenset([1])
    FOLLOW_keyEXCEPTION_INIT_in_synpred74_PLSQL3823 = frozenset([27])
    FOLLOW_LPAREN_in_synpred74_PLSQL3825 = frozenset([15, 22])
    FOLLOW_exception_name_in_synpred74_PLSQL3827 = frozenset([11])
    FOLLOW_COMMA_in_synpred74_PLSQL3829 = frozenset([29, 34, 36, 39])
    FOLLOW_literal_in_synpred74_PLSQL3831 = frozenset([44])
    FOLLOW_RPAREN_in_synpred74_PLSQL3833 = frozenset([1])
    FOLLOW_keyAUTONOMOUS_TRANSACTION_in_synpred75_PLSQL3839 = frozenset([1])
    FOLLOW_keySERIALLY_REUSABLE_in_synpred76_PLSQL3845 = frozenset([1])
    FOLLOW_keyBUILTIN_in_synpred77_PLSQL3851 = frozenset([27])
    FOLLOW_LPAREN_in_synpred77_PLSQL3853 = frozenset([15, 22, 29, 34, 36, 39])
    FOLLOW_pragma_params_in_synpred77_PLSQL3855 = frozenset([44])
    FOLLOW_RPAREN_in_synpred77_PLSQL3857 = frozenset([1])
    FOLLOW_keyFIPSFLAG_in_synpred78_PLSQL3863 = frozenset([27])
    FOLLOW_LPAREN_in_synpred78_PLSQL3865 = frozenset([15, 22, 29, 34, 36, 39])
    FOLLOW_pragma_params_in_synpred78_PLSQL3867 = frozenset([44])
    FOLLOW_RPAREN_in_synpred78_PLSQL3869 = frozenset([1])
    FOLLOW_keyINTERFACE_in_synpred79_PLSQL3875 = frozenset([27])
    FOLLOW_LPAREN_in_synpred79_PLSQL3877 = frozenset([15, 22, 29, 34, 36, 39])
    FOLLOW_pragma_params_in_synpred79_PLSQL3879 = frozenset([44])
    FOLLOW_RPAREN_in_synpred79_PLSQL3881 = frozenset([1])
    FOLLOW_keyNEW_NAMES_in_synpred80_PLSQL3887 = frozenset([27])
    FOLLOW_LPAREN_in_synpred80_PLSQL3889 = frozenset([15, 22, 29, 34, 36, 39])
    FOLLOW_pragma_params_in_synpred80_PLSQL3891 = frozenset([44])
    FOLLOW_RPAREN_in_synpred80_PLSQL3893 = frozenset([1])
    FOLLOW_keyINTERVAL_in_synpred114_PLSQL31280 = frozenset([22])
    FOLLOW_keyDAY_in_synpred114_PLSQL31282 = frozenset([27, 155])
    FOLLOW_LPAREN_in_synpred114_PLSQL31286 = frozenset([34])
    FOLLOW_NUMBER_in_synpred114_PLSQL31288 = frozenset([44])
    FOLLOW_RPAREN_in_synpred114_PLSQL31290 = frozenset([155])
    FOLLOW_155_in_synpred114_PLSQL31295 = frozenset([22])
    FOLLOW_keySECOND_in_synpred114_PLSQL31297 = frozenset([1, 27])
    FOLLOW_LPAREN_in_synpred114_PLSQL31301 = frozenset([34])
    FOLLOW_NUMBER_in_synpred114_PLSQL31303 = frozenset([44])
    FOLLOW_RPAREN_in_synpred114_PLSQL31305 = frozenset([1])
    FOLLOW_keyINTERVAL_in_synpred116_PLSQL31313 = frozenset([22])
    FOLLOW_keyYEAR_in_synpred116_PLSQL31315 = frozenset([27, 155])
    FOLLOW_LPAREN_in_synpred116_PLSQL31319 = frozenset([34])
    FOLLOW_NUMBER_in_synpred116_PLSQL31321 = frozenset([44])
    FOLLOW_RPAREN_in_synpred116_PLSQL31323 = frozenset([155])
    FOLLOW_155_in_synpred116_PLSQL31328 = frozenset([22])
    FOLLOW_keyMONTH_in_synpred116_PLSQL31330 = frozenset([1])
    FOLLOW_keyTIME_in_synpred117_PLSQL31337 = frozenset([1])
    FOLLOW_datatype_in_synpred172_PLSQL31806 = frozenset([1])
    FOLLOW_LPAREN_in_synpred232_PLSQL32921 = frozenset([15, 22, 27, 29, 34, 36, 39, 44, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_call_parameters_in_synpred232_PLSQL32925 = frozenset([44])
    FOLLOW_RPAREN_in_synpred232_PLSQL32930 = frozenset([1])
    FOLLOW_numeric_loop_param_in_synpred238_PLSQL33077 = frozenset([1])
    FOLLOW_cursor_loop_param_in_synpred239_PLSQL33093 = frozenset([1])
    FOLLOW_keyREVERSE_in_synpred242_PLSQL33157 = frozenset([1])
    FOLLOW_close_statement_in_synpred252_PLSQL33391 = frozenset([1])
    FOLLOW_open_statement_in_synpred256_PLSQL33411 = frozenset([1])
    FOLLOW_join_clause_in_synpred263_PLSQL33510 = frozenset([1])
    FOLLOW_LPAREN_in_synpred264_PLSQL33514 = frozenset([15, 22, 27, 144, 153])
    FOLLOW_join_clause_in_synpred264_PLSQL33516 = frozenset([44])
    FOLLOW_RPAREN_in_synpred264_PLSQL33518 = frozenset([1])
    FOLLOW_where_clause_in_synpred265_PLSQL33530 = frozenset([1])
    FOLLOW_hierarchical_query_clause_in_synpred266_PLSQL33537 = frozenset([1])
    FOLLOW_group_by_clause_in_synpred267_PLSQL33544 = frozenset([1])
    FOLLOW_97_in_synpred268_PLSQL33553 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_sql_condition_in_synpred268_PLSQL33555 = frozenset([1])
    FOLLOW_model_clause_in_synpred269_PLSQL33562 = frozenset([1])
    FOLLOW_157_in_synpred274_PLSQL33573 = frozenset([27, 50, 147])
    FOLLOW_50_in_synpred274_PLSQL33577 = frozenset([27, 147])
    FOLLOW_104_in_synpred274_PLSQL33587 = frozenset([27, 147])
    FOLLOW_111_in_synpred274_PLSQL33594 = frozenset([27, 147])
    FOLLOW_select_expression_in_synpred274_PLSQL33606 = frozenset([1])
    FOLLOW_subquery_in_synpred274_PLSQL33614 = frozenset([1])
    FOLLOW_order_by_clause_in_synpred275_PLSQL33630 = frozenset([1])
    FOLLOW_COMMA_in_synpred278_PLSQL33686 = frozenset([15, 22, 27, 144, 153])
    FOLLOW_selected_table_in_synpred278_PLSQL33688 = frozenset([1])
    FOLLOW_inner_cross_join_clause_in_synpred279_PLSQL33706 = frozenset([1])
    FOLLOW_outer_join_clause_in_synpred280_PLSQL33710 = frozenset([1])
    FOLLOW_keyINNER_in_synpred283_PLSQL33725 = frozenset([22])
    FOLLOW_keyJOIN_in_synpred283_PLSQL33730 = frozenset([15, 22, 144])
    FOLLOW_table_name_in_synpred283_PLSQL33732 = frozenset([22, 126])
    FOLLOW_126_in_synpred283_PLSQL33736 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_sql_condition_in_synpred283_PLSQL33738 = frozenset([1])
    FOLLOW_keyUSING_in_synpred283_PLSQL33742 = frozenset([27])
    FOLLOW_LPAREN_in_synpred283_PLSQL33744 = frozenset([15, 22, 144])
    FOLLOW_column_specs_in_synpred283_PLSQL33746 = frozenset([44])
    FOLLOW_RPAREN_in_synpred283_PLSQL33748 = frozenset([1])
    FOLLOW_keyCROSS_in_synpred284_PLSQL33757 = frozenset([1])
    FOLLOW_outer_join_type_in_synpred286_PLSQL33794 = frozenset([22])
    FOLLOW_keyJOIN_in_synpred286_PLSQL33796 = frozenset([1])
    FOLLOW_outer_join_type_in_synpred287_PLSQL33806 = frozenset([1])
    FOLLOW_query_partition_clause_in_synpred288_PLSQL33823 = frozenset([1])
    FOLLOW_126_in_synpred289_PLSQL33832 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_sql_condition_in_synpred289_PLSQL33834 = frozenset([1])
    FOLLOW_keyUSING_in_synpred290_PLSQL33838 = frozenset([27])
    FOLLOW_LPAREN_in_synpred290_PLSQL33840 = frozenset([15, 22, 144])
    FOLLOW_column_specs_in_synpred290_PLSQL33842 = frozenset([44])
    FOLLOW_RPAREN_in_synpred290_PLSQL33844 = frozenset([1])
    FOLLOW_keyFULL_in_synpred291_PLSQL33873 = frozenset([1])
    FOLLOW_keyLEFT_in_synpred292_PLSQL33877 = frozenset([1])
    FOLLOW_keyOUTER_in_synpred293_PLSQL33887 = frozenset([1])
    FOLLOW_keyNOCYCLE_in_synpred295_PLSQL33943 = frozenset([1])
    FOLLOW_COMMA_in_synpred296_PLSQL33976 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_group_by_expr_in_synpred296_PLSQL33978 = frozenset([1])
    FOLLOW_rollup_cube_clause_in_synpred297_PLSQL33991 = frozenset([1])
    FOLLOW_grouping_sets_clause_in_synpred298_PLSQL33996 = frozenset([1])
    FOLLOW_keyROLLUP_in_synpred299_PLSQL34013 = frozenset([1])
    FOLLOW_rollup_cube_clause_in_synpred301_PLSQL34072 = frozenset([1])
    FOLLOW_keyIGNORE_in_synpred304_PLSQL34126 = frozenset([1])
    FOLLOW_keyIGNORE_in_synpred305_PLSQL34126 = frozenset([22])
    FOLLOW_keyKEEP_in_synpred305_PLSQL34130 = frozenset([22])
    FOLLOW_keyNAV_in_synpred305_PLSQL34134 = frozenset([1])
    FOLLOW_keyDIMENSION_in_synpred306_PLSQL34147 = frozenset([1])
    FOLLOW_query_partition_clause_in_synpred311_PLSQL34271 = frozenset([1, 15, 22, 144])
    FOLLOW_column_spec_in_synpred311_PLSQL34275 = frozenset([1])
    FOLLOW_keyAUTOMATIC_in_synpred318_PLSQL34382 = frozenset([1])
    FOLLOW_sql_condition_in_synpred330_PLSQL34543 = frozenset([1])
    FOLLOW_sql_expression_in_synpred331_PLSQL34547 = frozenset([1])
    FOLLOW_keyINCREMENT_in_synpred335_PLSQL34618 = frozenset([1])
    FOLLOW_COMMA_in_synpred343_PLSQL34785 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_order_by_expr_in_synpred343_PLSQL34787 = frozenset([1])
    FOLLOW_80_in_synpred346_PLSQL34829 = frozenset([1])
    FOLLOW_keyNULLS_in_synpred347_PLSQL34836 = frozenset([22])
    FOLLOW_keyFIRST_in_synpred347_PLSQL34838 = frozenset([1])
    FOLLOW_keyNULLS_in_synpred348_PLSQL34842 = frozenset([22])
    FOLLOW_keyLAST_in_synpred348_PLSQL34844 = frozenset([1])
    FOLLOW_sql_expression_in_synpred355_PLSQL34998 = frozenset([1])
    FOLLOW_127_in_synpred357_PLSQL35076 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_expr_or_in_synpred357_PLSQL35078 = frozenset([1])
    FOLLOW_51_in_synpred358_PLSQL35095 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_expr_and_in_synpred358_PLSQL35097 = frozenset([1])
    FOLLOW_relational_op_in_synpred360_PLSQL35134 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_expr_add_in_synpred360_PLSQL35136 = frozenset([1])
    FOLLOW_FOUND_ATTR_in_synpred361_PLSQL35142 = frozenset([1])
    FOLLOW_NOTFOUND_ATTR_in_synpred362_PLSQL35146 = frozenset([1])
    FOLLOW_ISOPEN_ATTR_in_synpred363_PLSQL35150 = frozenset([1])
    FOLLOW_ROWCOUNT_ATTR_in_synpred364_PLSQL35154 = frozenset([1])
    FOLLOW_BULK_ROWCOUNT_ATTR_in_synpred365_PLSQL35158 = frozenset([1])
    FOLLOW_106_in_synpred367_PLSQL35164 = frozenset([118, 120])
    FOLLOW_118_in_synpred367_PLSQL35168 = frozenset([120])
    FOLLOW_120_in_synpred367_PLSQL35173 = frozenset([1])
    FOLLOW_118_in_synpred369_PLSQL35181 = frozenset([107])
    FOLLOW_107_in_synpred369_PLSQL35186 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_expr_add_in_synpred369_PLSQL35188 = frozenset([1])
    FOLLOW_118_in_synpred371_PLSQL35196 = frozenset([57])
    FOLLOW_57_in_synpred371_PLSQL35201 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_expr_add_in_synpred371_PLSQL35203 = frozenset([51])
    FOLLOW_51_in_synpred371_PLSQL35205 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_expr_add_in_synpred371_PLSQL35207 = frozenset([1])
    FOLLOW_118_in_synpred373_PLSQL35215 = frozenset([99])
    FOLLOW_99_in_synpred373_PLSQL35220 = frozenset([27])
    FOLLOW_LPAREN_in_synpred373_PLSQL35222 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_nested_expressions_in_synpred373_PLSQL35224 = frozenset([44])
    FOLLOW_RPAREN_in_synpred373_PLSQL35226 = frozenset([1])
    FOLLOW_COMMA_in_synpred375_PLSQL35261 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expression_in_synpred375_PLSQL35263 = frozenset([1])
    FOLLOW_set_in_synpred378_PLSQL35297 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_expr_mul_in_synpred378_PLSQL35311 = frozenset([1])
    FOLLOW_set_in_synpred380_PLSQL35328 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_expr_sign_in_synpred380_PLSQL35338 = frozenset([1])
    FOLLOW_EXPONENT_in_synpred383_PLSQL35376 = frozenset([15, 22, 27, 34, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_expr_expr_in_synpred383_PLSQL35378 = frozenset([1])
    FOLLOW_expr_paren_in_synpred384_PLSQL35393 = frozenset([1])
    FOLLOW_function_expression_in_synpred385_PLSQL35406 = frozenset([1])
    FOLLOW_case_expression_in_synpred386_PLSQL35420 = frozenset([1])
    FOLLOW_cursor_expression_in_synpred387_PLSQL35433 = frozenset([1])
    FOLLOW_simple_expression_in_synpred388_PLSQL35446 = frozenset([1])
    FOLLOW_select_expression_in_synpred389_PLSQL35459 = frozenset([1])
    FOLLOW_column_spec_in_synpred396_PLSQL35518 = frozenset([1])
    FOLLOW_keyDBTIMEZONE_in_synpred410_PLSQL35815 = frozenset([1])
    FOLLOW_keySESSIONTIMEZONE_in_synpred411_PLSQL35819 = frozenset([1])
    FOLLOW_function_call_in_synpred413_PLSQL35839 = frozenset([1, 13])
    FOLLOW_DOT_in_synpred413_PLSQL35843 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_nested_expression_in_synpred413_PLSQL35845 = frozenset([1])
    FOLLOW_LPAREN_in_synpred416_PLSQL35883 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 118, 120, 144, 147, 151, 156])
    FOLLOW_nested_expression_in_synpred416_PLSQL35885 = frozenset([44])
    FOLLOW_RPAREN_in_synpred416_PLSQL35887 = frozenset([1])
    FOLLOW_keyDAY_in_synpred421_PLSQL35959 = frozenset([27, 155])
    FOLLOW_LPAREN_in_synpred421_PLSQL35963 = frozenset([34])
    FOLLOW_leading_field_precision_in_synpred421_PLSQL35965 = frozenset([44])
    FOLLOW_RPAREN_in_synpred421_PLSQL35967 = frozenset([155])
    FOLLOW_155_in_synpred421_PLSQL35972 = frozenset([22])
    FOLLOW_keySECOND_in_synpred421_PLSQL35974 = frozenset([1, 27])
    FOLLOW_LPAREN_in_synpred421_PLSQL35978 = frozenset([34])
    FOLLOW_fractional_second_precision_in_synpred421_PLSQL35980 = frozenset([44])
    FOLLOW_RPAREN_in_synpred421_PLSQL35982 = frozenset([1])
    FOLLOW_DOT_in_synpred428_PLSQL36228 = frozenset([15, 22, 144])
    FOLLOW_sql_identifier_in_synpred428_PLSQL36230 = frozenset([1])
    FOLLOW_table_spec_in_synpred432_PLSQL36277 = frozenset([1])
    FOLLOW_alias_in_synpred435_PLSQL36298 = frozenset([1])
    FOLLOW_condition_or_in_synpred441_PLSQL36389 = frozenset([1])
    FOLLOW_127_in_synpred442_PLSQL36442 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_condition_and_in_synpred442_PLSQL36444 = frozenset([1])
    FOLLOW_51_in_synpred443_PLSQL36461 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_condition_not_in_synpred443_PLSQL36463 = frozenset([1])
    FOLLOW_condition_is_in_synpred446_PLSQL36498 = frozenset([1])
    FOLLOW_condition_comparison_in_synpred447_PLSQL36503 = frozenset([1])
    FOLLOW_condition_group_comparison_in_synpred448_PLSQL36508 = frozenset([1])
    FOLLOW_condition_in_in_synpred449_PLSQL36513 = frozenset([1])
    FOLLOW_condition_is_a_set_in_synpred450_PLSQL36518 = frozenset([1])
    FOLLOW_condition_is_any_in_synpred451_PLSQL36523 = frozenset([1])
    FOLLOW_condition_is_empty_in_synpred452_PLSQL36528 = frozenset([1])
    FOLLOW_condition_is_of_type_in_synpred453_PLSQL36533 = frozenset([1])
    FOLLOW_condition_is_present_in_synpred454_PLSQL36538 = frozenset([1])
    FOLLOW_condition_like_in_synpred455_PLSQL36543 = frozenset([1])
    FOLLOW_condition_memeber_in_synpred456_PLSQL36548 = frozenset([1])
    FOLLOW_condition_between_in_synpred457_PLSQL36553 = frozenset([1])
    FOLLOW_condition_regexp_like_in_synpred458_PLSQL36558 = frozenset([1])
    FOLLOW_condition_submultiset_in_synpred459_PLSQL36563 = frozenset([1])
    FOLLOW_condition_equals_path_in_synpred460_PLSQL36568 = frozenset([1])
    FOLLOW_condition_under_path_in_synpred461_PLSQL36573 = frozenset([1])
    FOLLOW_keyNAN_in_synpred463_PLSQL36617 = frozenset([1])
    FOLLOW_keyINFINITE_in_synpred464_PLSQL36621 = frozenset([1])
    FOLLOW_outer_join_sign_in_synpred467_PLSQL36668 = frozenset([1])
    FOLLOW_LPAREN_in_synpred468_PLSQL36637 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expressions_in_synpred468_PLSQL36639 = frozenset([44])
    FOLLOW_RPAREN_in_synpred468_PLSQL36641 = frozenset([17, 27, 33])
    FOLLOW_outer_join_sign_in_synpred468_PLSQL36645 = frozenset([17, 33])
    FOLLOW_set_in_synpred468_PLSQL36650 = frozenset([27])
    FOLLOW_LPAREN_in_synpred468_PLSQL36660 = frozenset([147])
    FOLLOW_select_command_in_synpred468_PLSQL36662 = frozenset([44])
    FOLLOW_RPAREN_in_synpred468_PLSQL36664 = frozenset([1, 27])
    FOLLOW_outer_join_sign_in_synpred468_PLSQL36668 = frozenset([1])
    FOLLOW_sql_expression_in_synpred477_PLSQL36727 = frozenset([1])
    FOLLOW_outer_join_sign_in_synpred478_PLSQL36741 = frozenset([1])
    FOLLOW_grouping_expression_list_in_synpred482_PLSQL36788 = frozenset([1])
    FOLLOW_LPAREN_in_synpred483_PLSQL36754 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expressions_in_synpred483_PLSQL36756 = frozenset([44])
    FOLLOW_RPAREN_in_synpred483_PLSQL36758 = frozenset([17, 33])
    FOLLOW_set_in_synpred483_PLSQL36760 = frozenset([22, 50, 52])
    FOLLOW_52_in_synpred483_PLSQL36772 = frozenset([27])
    FOLLOW_keySOME_in_synpred483_PLSQL36776 = frozenset([27])
    FOLLOW_50_in_synpred483_PLSQL36780 = frozenset([27])
    FOLLOW_LPAREN_in_synpred483_PLSQL36784 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_grouping_expression_list_in_synpred483_PLSQL36788 = frozenset([44])
    FOLLOW_select_command_in_synpred483_PLSQL36792 = frozenset([44])
    FOLLOW_RPAREN_in_synpred483_PLSQL36796 = frozenset([1])
    FOLLOW_sql_expressions_in_synpred491_PLSQL36847 = frozenset([1])
    FOLLOW_grouping_expression_list_in_synpred493_PLSQL36884 = frozenset([1])
    FOLLOW_LPAREN_in_synpred494_PLSQL36865 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expressions_in_synpred494_PLSQL36867 = frozenset([44])
    FOLLOW_RPAREN_in_synpred494_PLSQL36869 = frozenset([99, 118])
    FOLLOW_118_in_synpred494_PLSQL36873 = frozenset([99])
    FOLLOW_99_in_synpred494_PLSQL36878 = frozenset([27])
    FOLLOW_LPAREN_in_synpred494_PLSQL36880 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_grouping_expression_list_in_synpred494_PLSQL36884 = frozenset([44])
    FOLLOW_select_command_in_synpred494_PLSQL36888 = frozenset([44])
    FOLLOW_RPAREN_in_synpred494_PLSQL36892 = frozenset([1])
    FOLLOW_expression_list_in_synpred496_PLSQL36912 = frozenset([1])
    FOLLOW_keyLIKEC_in_synpred506_PLSQL37092 = frozenset([1])
    FOLLOW_keyLIKE2_in_synpred507_PLSQL37096 = frozenset([1])
    FOLLOW_keyESCAPE_in_synpred508_PLSQL37108 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expression_in_synpred508_PLSQL37110 = frozenset([1])
    FOLLOW_COMMA_in_synpred517_PLSQL37321 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_expression_list_in_synpred517_PLSQL37323 = frozenset([1])
    FOLLOW_LPAREN_in_synpred518_PLSQL37336 = frozenset([15, 22, 27, 29, 34, 36, 39, 65, 81, 89, 120, 144, 147, 151, 156])
    FOLLOW_sql_expressions_in_synpred518_PLSQL37338 = frozenset([44])
    FOLLOW_RPAREN_in_synpred518_PLSQL37340 = frozenset([1])
    FOLLOW_sql_expression_in_synpred526_PLSQL37437 = frozenset([1])
    FOLLOW_134_in_synpred529_PLSQL37528 = frozenset([1])
    FOLLOW_134_in_synpred530_PLSQL37528 = frozenset([15, 22, 27, 29, 34, 36, 39, 52, 65, 81, 88, 89, 118, 120, 134, 144, 147, 151, 156])
    FOLLOW_sql_condition_in_synpred530_PLSQL37533 = frozenset([1])
    FOLLOW_134_in_synpred531_PLSQL37540 = frozenset([1])
    FOLLOW_sql_expression_in_synpred540_PLSQL37691 = frozenset([1])
    FOLLOW_NUMBER_in_synpred541_PLSQL37703 = frozenset([1])
    FOLLOW_variable_names_in_synpred562_PLSQL38115 = frozenset([1])



def main(argv, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr):
    from antlr3.main import ParserMain
    main = ParserMain("PLSQL3Lexer", PLSQL3Parser)

    main.stdin = stdin
    main.stdout = stdout
    main.stderr = stderr
    main.execute(argv)



if __name__ == '__main__':
    main(sys.argv)
